# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/game.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/build_aimessage_vc10/temp_defines_release.h" 1
# 1 "<command-line>" 2
# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/game.cpp"
# 13 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/game.cpp"
# 1 "c:/marmalade/6.2/s3e/h/s3e.h" 1
# 19 "c:/marmalade/6.2/s3e/h/s3e.h"
# 1 "c:/marmalade/6.2/s3e/h/s3eAccelerometer.h" 1
# 15 "c:/marmalade/6.2/s3e/h/s3eAccelerometer.h"
# 1 "c:/marmalade/6.2/s3e/h/s3eTypes.h" 1
# 35 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
typedef unsigned char s3e_uint8_t;
typedef signed char s3e_int8_t;
typedef unsigned short int s3e_uint16_t;
typedef signed short int s3e_int16_t;
typedef unsigned int s3e_uint32_t;
typedef signed int s3e_int32_t;
# 49 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
  typedef signed long long s3e_int64_t;
  typedef unsigned long long s3e_uint64_t;
# 72 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
typedef s3e_uint64_t uint64_t;
typedef s3e_int64_t int64_t;
typedef s3e_uint32_t uint32_t;
typedef s3e_int32_t int32_t;
typedef s3e_uint16_t uint16_t;
typedef s3e_int16_t int16_t;
typedef s3e_uint8_t uint8_t;
typedef s3e_int8_t int8_t;
# 94 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
    typedef int intptr_t;
    typedef unsigned int uintptr_t;
# 106 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
typedef unsigned int uint;
typedef unsigned short int ushort;
typedef unsigned long int ulong;
typedef unsigned char uint8;
typedef signed char int8;







typedef int64_t int64;
typedef uint64_t uint64;





typedef unsigned int uint32;






typedef signed int int32;






typedef uint16_t uint16;




typedef int16_t int16;
# 224 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
typedef enum s3eResult
{
    S3E_RESULT_SUCCESS = 0,
    S3E_RESULT_ERROR = 1
} s3eResult;




typedef uint8 s3eBool;
# 242 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
typedef wchar_t s3eWChar;
# 254 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
typedef int32 (*s3eCallback) (void* systemData, void* userData);
# 16 "c:/marmalade/6.2/s3e/h/s3eAccelerometer.h" 2
# 64 "c:/marmalade/6.2/s3e/h/s3eAccelerometer.h"
typedef enum s3eAccelerometerError
{
    S3E_ACCELEROMETER_ERR_NONE = 0,
    S3E_ACCELEROMETER_ERR_PARAM = 1,
    S3E_ACCELEROMETER_ERR_UNAVAIL = 5
} s3eAccelerometerError;







extern "C" s3eAccelerometerError s3eAccelerometerGetError();
# 86 "c:/marmalade/6.2/s3e/h/s3eAccelerometer.h"
extern "C" const char* s3eAccelerometerGetErrorString();






typedef enum s3eAccelerometerProperty
{
    S3E_ACCELEROMETER_AVAILABLE = 0
} s3eAccelerometerProperty;

extern "C" int32 s3eAccelerometerGetInt(s3eAccelerometerProperty property);
# 108 "c:/marmalade/6.2/s3e/h/s3eAccelerometer.h"
extern "C" s3eResult s3eAccelerometerStart();







extern "C" void s3eAccelerometerStop();






extern "C" int32 s3eAccelerometerGetX();






extern "C" int32 s3eAccelerometerGetY();






extern "C" int32 s3eAccelerometerGetZ();
# 20 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eAudio.h" 1
# 62 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
typedef enum s3eAudioCodec
{
    S3E_AUDIO_CODEC_MIDI = 1,
    S3E_AUDIO_CODEC_MP3 = 2,
    S3E_AUDIO_CODEC_AAC = 3,
    S3E_AUDIO_CODEC_AACPLUS = 4,
    S3E_AUDIO_CODEC_QCP = 5,
    S3E_AUDIO_CODEC_PCM = 6,
    S3E_AUDIO_CODEC_SPF = 7,
    S3E_AUDIO_CODEC_AMR = 8,
    S3E_AUDIO_CODEC_MP4 = 9
} s3eAudioCodec;






typedef enum s3eAudioStatus
{





    S3E_AUDIO_STOPPED = 0,




    S3E_AUDIO_PLAYING = 1,




    S3E_AUDIO_PAUSED = 2,
# 106 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
    S3E_AUDIO_FAILED = 3
} s3eAudioStatus;
# 116 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
typedef enum s3eAudioProperty
{





    S3E_AUDIO_VOLUME = 0,





    S3E_AUDIO_STATUS = 1,





    S3E_AUDIO_POSITION = 2,
# 148 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
    S3E_AUDIO_VOLUME_DEFAULT = 3,





    S3E_AUDIO_CHANNEL = 4,





    S3E_AUDIO_NUM_CHANNELS = 5,

    S3E_AUDIO_AVAILABLE = 6,







    S3E_AUDIO_MUTES_S3ESOUND = 7,






    S3E_AUDIO_DURATION = 8,






    S3E_AUDIO_PLAYBACK_FROM_HTTP_AVAILABLE = 9
} s3eAudioProperty;
# 202 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
extern "C" int32 s3eAudioGetInt(s3eAudioProperty property);
# 222 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioSetInt(s3eAudioProperty property, int32 value);
# 232 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
typedef enum s3eAudioCallback
{
# 249 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
    S3E_AUDIO_STOP = 2,

    S3E_AUDIO_CALLBACK_MAX
} s3eAudioCallback;






typedef struct s3eAudioCallbackData
{

    uint32 m_ChannelID;
} s3eAudioCallbackData;
# 284 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioRegister(s3eAudioCallback cbid, s3eCallback fn, void* userData);
# 300 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioUnRegister(s3eAudioCallback cbid, s3eCallback fn);
# 309 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
typedef enum s3eAudioError
{
    S3E_AUDIO_ERR_NONE = 0,
    S3E_AUDIO_ERR_PARAM = 1,
    S3E_AUDIO_ERR_TOO_MANY = 2,
    S3E_AUDIO_ERR_ALREADY_REG = 3,
    S3E_AUDIO_ERR_NOT_FOUND = 4,
    S3E_AUDIO_ERR_UNAVAIL = 5,
    S3E_AUDIO_ERR_DEVICE = 6,
    S3E_AUDIO_ERR_UNSUPPORTED = 7,
    S3E_AUDIO_ERR_MEM = 8,
    S3E_AUDIO_ERR_INVALID_DRIVE = 10,
    S3E_AUDIO_ERR_INVALID_PATH = 11,
    S3E_AUDIO_ERR_FILEFORMAT = 1000,
    S3E_AUDIO_ERR_WRONG_STATE = 1001
} s3eAudioError;
# 338 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
extern "C" s3eAudioError s3eAudioGetError();
# 352 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
extern "C" const char* s3eAudioGetErrorString();
# 426 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioPlay(const char* filename, uint32 repeatCount =1);
# 497 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioPlayFromBuffer(void* buffer, uint32 bufferLen, uint32 repeatCount =0);
# 522 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioPause();
# 541 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioResume();
# 555 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
extern "C" void s3eAudioStop();
# 566 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
extern "C" s3eBool s3eAudioIsPlaying();
# 580 "c:/marmalade/6.2/s3e/h/s3eAudio.h"
extern "C" s3eBool s3eAudioIsCodecSupported(s3eAudioCodec codec);





# 1 "c:/marmalade/6.2/s3e/h/legacy/s3eAudio_legacy.h" 1
# 587 "c:/marmalade/6.2/s3e/h/s3eAudio.h" 2
# 21 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eCompression.h" 1
# 33 "c:/marmalade/6.2/s3e/h/s3eCompression.h"
typedef enum s3eCompressionAlgorithms
{
    S3E_COMPRESSION_ALG_AUTO = 0,
    S3E_COMPRESSION_ALG_NONE = 1,







    S3E_COMPRESSION_ALG_ZLIB = 2,







    S3E_COMPRESSION_ALG_GZIP = 3,





    S3E_COMPRESSION_ALG_LZMA = 4,

    S3E_COMPRESSION_ALG_MAX
} s3eCompressionAlgorithms;






typedef enum s3eCompressionError
{
    S3E_COMPRESSION_ERR_NONE = 0,
    S3E_COMPRESSION_ERR_PARAM = 1,
    S3E_COMPRESSION_ERR_TOO_MANY = 2,
    S3E_COMPRESSION_ERR_DEVICE = 6,
    S3E_COMPRESSION_ERR_MEM = 8,

    S3E_COMPRESSION_ERR_BAD_DATA = 1000,
    S3E_COMPRESSION_ERR_INSUFF = 1002
} s3eCompressionError;





typedef struct s3eDecompressionHandle s3eDecompressionHandle;
# 95 "c:/marmalade/6.2/s3e/h/s3eCompression.h"
typedef struct s3eDecompressionInput
{

    void* m_Data;

    int32 m_Size;
} s3eDecompressionInput;
# 137 "c:/marmalade/6.2/s3e/h/s3eCompression.h"
extern "C" s3eDecompressionHandle* s3eCompressionDecompInit(s3eCompressionAlgorithms alg, s3eCallback inputFn, void* userData);
# 190 "c:/marmalade/6.2/s3e/h/s3eCompression.h"
extern "C" s3eResult s3eCompressionDecompRead(s3eDecompressionHandle* handle, void* bufferOut, uint32* lenOut);
# 210 "c:/marmalade/6.2/s3e/h/s3eCompression.h"
extern "C" s3eResult s3eCompressionDecompFinal(s3eDecompressionHandle* handle);
# 260 "c:/marmalade/6.2/s3e/h/s3eCompression.h"
extern "C" s3eResult s3eCompressionDecomp(void* bufferIn, uint32 lenIn, void** bufferOut, uint32 *lenOut, s3eCompressionAlgorithms algorithm);
# 273 "c:/marmalade/6.2/s3e/h/s3eCompression.h"
extern "C" s3eCompressionError s3eCompressionGetError();
# 286 "c:/marmalade/6.2/s3e/h/s3eCompression.h"
extern "C" const char* s3eCompressionGetErrorString();
# 22 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eConfig.h" 1
# 16 "c:/marmalade/6.2/s3e/h/s3eConfig.h"
# 1 "c:/marmalade/6.2/s3e/h/s3eFile.h" 1
# 33 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef struct s3eFile s3eFile;
# 58 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef enum s3eFileSeekOrigin
{
    S3E_FILESEEK_SET = 0,
    S3E_FILESEEK_CUR = 1,
    S3E_FILESEEK_END = 2
} s3eFileSeekOrigin;




typedef struct s3eFileList s3eFileList;
# 89 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef enum s3eFileProperty
{






    S3E_FILE_ROM_EXISTS = 1,





    S3E_FILE_BYTES_TOTAL = 2,




    S3E_FILE_BYTES_FREE = 3
} s3eFileProperty;
# 119 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef enum s3eFileStats
{







    S3E_FILE_ISFILE = 0,







    S3E_FILE_ISDIR = 1,






    S3E_FILE_ISUSER = 2,
# 156 "c:/marmalade/6.2/s3e/h/s3eFile.h"
    S3E_FILE_ISWRITABLE = 3,





    S3E_FILE_SIZE = 4,
# 172 "c:/marmalade/6.2/s3e/h/s3eFile.h"
    S3E_FILE_MODIFIED_DATE = 5,
# 184 "c:/marmalade/6.2/s3e/h/s3eFile.h"
    S3E_FILE_DRIVE_BYTES_FREE = 6,
# 193 "c:/marmalade/6.2/s3e/h/s3eFile.h"
    S3E_FILE_DRIVE = 7,
# 202 "c:/marmalade/6.2/s3e/h/s3eFile.h"
    S3E_FILE_DRIVE_BYTES_TOTAL = 8,






    S3E_FILE_REAL_PATH = 9,
} s3eFileStats;
# 228 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" int32 s3eFileGetInt(s3eFileProperty property);
# 253 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" int64 s3eFileGetFileInt(const char* filename, s3eFileStats stat);
# 278 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" char* s3eFileGetFileString(const char* filename, s3eFileStats stat, char* str, int len);
# 287 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef enum s3eFileError
{
    S3E_FILE_ERR_NONE = 0,
    S3E_FILE_ERR_PARAM = 1,
    S3E_FILE_ERR_TOO_MANY = 2,
    S3E_FILE_ERR_ALREADY_REG = 3,
    S3E_FILE_ERR_NOT_FOUND = 4,
    S3E_FILE_ERR_UNAVAIL = 5,
    S3E_FILE_ERR_DEVICE = 6,
    S3E_FILE_ERR_UNSUPPORTED = 7,
    S3E_FILE_ERR_MEM = 8,
    S3E_FILE_ERR_GENERIC = 9,
    S3E_FILE_ERR_INVALID_DRIVE = 10,
    S3E_FILE_ERR_INVALID_PATH = 11,
    S3E_FILE_ERR_DATA = 12,

    S3E_FILE_ERR_INVALID_MODE = 1000,
    S3E_FILE_ERR_EXISTS = 1001,
    S3E_FILE_ERR_NOT_EMPTY = 1002,
    S3E_FILE_ERR_ACCESS = 1003,
    S3E_FILE_ERR_NO_MORE = 1004,
    S3E_FILE_ERR_EOF = 1005
} s3eFileError;
# 322 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eFileError s3eFileGetError();
# 336 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" const char* s3eFileGetErrorString();
# 387 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eFile* s3eFileOpen(const char* filename, const char* mode);
# 406 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eFile* s3eFileOpenFromMemory(void* buffer, uint32 bufferLen);
# 423 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileClose(s3eFile* file);
# 444 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileFlush(s3eFile* file);
# 475 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" uint32 s3eFileRead(void* buffer, uint32 elemSize, uint32 noElems, s3eFile* file);
# 502 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" uint32 s3eFileWrite(const void* buffer, uint32 elemSize, uint32 noElems, s3eFile* file);
# 516 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" int s3eFilePrintf(s3eFile* f, const char *fmt, ...);
# 536 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" int32 s3eFileGetChar(s3eFile* file);
# 559 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" int32 s3eFilePutChar(char c, s3eFile* file);
# 597 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" char* s3eFileReadString(char* string, uint32 maxLen, s3eFile* file);
# 620 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eBool s3eFileEOF(s3eFile* file);
# 655 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileSeek(s3eFile* file, int32 offset, s3eFileSeekOrigin origin);
# 671 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" int32 s3eFileTell(s3eFile* file);
# 688 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" int32 s3eFileGetSize(s3eFile* file);
# 714 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileMakeDirectory(const char* dirName);
# 739 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileDeleteDirectory(const char* dirName);
# 755 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eBool s3eFileCheckExists(const char* filename);
# 789 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileRename(const char* src, const char* dest);
# 814 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileDelete(const char* filename);
# 842 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileTruncate(const char* filename, uint32 length);
# 852 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" uint64 s3eFileGetLastWriteTime(const char* filename);
# 881 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eFileList* s3eFileListDirectory(const char* dirName);
# 903 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileListNext(s3eFileList* handle, char* filename, int filenameLen);
# 918 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileListClose(s3eFileList* handle);







typedef struct s3eUsrFile s3eUsrFile;
# 936 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef s3eUsrFile*(*s3eUserOpenFn)(const char* filename, const char *mode);
# 948 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef uint32 (*s3eUserReadFn)(void* buffer, uint32 elemLen, uint32 noElems, s3eUsrFile *file);
# 960 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef uint32 (*s3eUserWriteFn)(const void* buffer, uint32 elemLen, uint32 noElems, s3eUsrFile *file);
# 969 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef s3eBool (*s3eUserEOFFn)(s3eUsrFile* file);
# 980 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserSeekFn)(s3eUsrFile* file, int32 offset, s3eFileSeekOrigin origin);
# 989 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef int32 (*s3eUserTellFn)(s3eUsrFile* file);
# 998 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserCloseFn)(s3eUsrFile* file);




typedef struct s3eUsrFileList s3eUsrFileList;
# 1013 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef s3eUsrFileList* (*s3eUserListDirFn)(const char* path);
# 1027 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserListNextFn)(s3eUsrFileList* handle, char* filename, int filenameLen);
# 1037 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserListCloseFn)(s3eUsrFileList* handle);
# 1047 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserDeleteFn)(const char* filename);
# 1084 "c:/marmalade/6.2/s3e/h/s3eFile.h"
typedef struct
{
    s3eUserOpenFn m_Open;
    s3eUserReadFn m_Read;
    s3eUserEOFFn m_EOF;
    s3eUserSeekFn m_Seek;
    s3eUserTellFn m_Tell;
    s3eUserCloseFn m_Close;

    s3eUserListDirFn m_ListDir;
    s3eUserListNextFn m_ListNext;
    s3eUserListCloseFn m_ListClose;

    s3eUserWriteFn m_Write;
    s3eUserDeleteFn m_Delete;

    void* m_Reserved[5];
} s3eFileUserCallbacks;
# 1114 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileAddUserFileSys(s3eFileUserCallbacks* callbacks);
# 1124 "c:/marmalade/6.2/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileRemoveUserFileSys(s3eFileUserCallbacks* callbacks);





# 1 "c:/marmalade/6.2/s3e/h/legacy/s3eFile_legacy.h" 1
# 16 "c:/marmalade/6.2/s3e/h/legacy/s3eFile_legacy.h"
typedef enum s3eFilePath
{
    S3E_FILEPATH_ROM,
    S3E_FILEPATH_RAM,
    S3E_FILEPATH_MMC,
    S3E_FILEPATH_MAX
} s3eFilePath;
# 34 "c:/marmalade/6.2/s3e/h/legacy/s3eFile_legacy.h"
extern "C" uint64 s3eFileGetFree(s3eFilePath path);
# 1131 "c:/marmalade/6.2/s3e/h/s3eFile.h" 2
# 17 "c:/marmalade/6.2/s3e/h/s3eConfig.h" 2
# 39 "c:/marmalade/6.2/s3e/h/s3eConfig.h"
typedef enum s3eConfigError
{
    S3E_CONFIG_ERR_NONE = 0,
    S3E_CONFIG_ERR_PARAM = 1,

    S3E_CONFIG_ERR_NOT_FOUND = 4,

    S3E_CONFIG_ERR_PARSE = 6
} s3eConfigError;
# 67 "c:/marmalade/6.2/s3e/h/s3eConfig.h"
extern "C" s3eConfigError s3eConfigGetError();
# 81 "c:/marmalade/6.2/s3e/h/s3eConfig.h"
extern "C" const char* s3eConfigGetErrorString();
# 104 "c:/marmalade/6.2/s3e/h/s3eConfig.h"
extern "C" s3eResult s3eConfigGetString(const char* group, const char* name, char* value);

extern "C" s3eResult s3eConfigGetStringHash(uint32 hash, char* value);
# 133 "c:/marmalade/6.2/s3e/h/s3eConfig.h"
extern "C" s3eResult s3eConfigGetInt(const char* group, const char* name, int* value);

extern "C" s3eResult s3eConfigGetIntHash(uint32 hash, int* value);
# 23 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eCrypto.h" 1
# 33 "c:/marmalade/6.2/s3e/h/s3eCrypto.h"
typedef struct s3eSHA1 s3eSHA1;
# 42 "c:/marmalade/6.2/s3e/h/s3eCrypto.h"
typedef enum s3eCryptoError
{
    S3E_CRYPTO_ERR_NONE = 0,
    S3E_CRYPTO_ERR_PARAM = 1,
    S3E_CRYPTO_ERR_TOO_MANY = 2,
    S3E_CRYPTO_ERR_DEVICE = 6,


    S3E_CRYPTO_ERR_INVALID_SIG = 1000,
    S3E_CRYPTO_ERR_SIG_CHECK = 1001
} s3eCryptoError;
# 68 "c:/marmalade/6.2/s3e/h/s3eCrypto.h"
extern "C" uint32 s3eCryptoRand();
# 84 "c:/marmalade/6.2/s3e/h/s3eCrypto.h"
extern "C" s3eResult s3eCryptoSha1(const uint8* data, uint32 dataLen, uint8* hash);
# 100 "c:/marmalade/6.2/s3e/h/s3eCrypto.h"
extern "C" s3eSHA1* s3eCryptoSha1Init();
# 117 "c:/marmalade/6.2/s3e/h/s3eCrypto.h"
extern "C" s3eResult s3eCryptoSha1Update(s3eSHA1* ctx, const uint8* data, uint32 dataLen);
# 133 "c:/marmalade/6.2/s3e/h/s3eCrypto.h"
extern "C" s3eResult s3eCryptoSha1Final(s3eSHA1* ctx, uint8* hash);
# 150 "c:/marmalade/6.2/s3e/h/s3eCrypto.h"
extern "C" s3eResult s3eCryptoVerifyRsa(uint8* sig, int sigLen,
                                     uint8* hash, int hashLen,
                                     uint8* mod, int modLen,
                                     uint8* exp, int expLen);
# 166 "c:/marmalade/6.2/s3e/h/s3eCrypto.h"
extern "C" s3eCryptoError s3eCryptoGetError();
# 180 "c:/marmalade/6.2/s3e/h/s3eCrypto.h"
extern "C" const char* s3eCryptoGetErrorString();
# 24 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eDebug.h" 1
# 38 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
typedef enum s3eDebugProperty
{



    S3E_DEBUG_TRACE_ENABLED = 0,





    S3E_DEBUG_TRACE_TO_FILE = 1,




    S3E_DEBUG_ASSERT_ENABLED = 2,





    S3E_DEBUG_AVAILABLE = 3,




    S3E_DEBUG_FONT_SCALE = 4,




    S3E_DEBUG_FONT_WIDTH = 5,




    S3E_DEBUG_FONT_HEIGHT = 6

} s3eDebugProperty;
# 95 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
extern "C" int32 s3eDebugGetInt(s3eDebugProperty property);
# 113 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
extern "C" s3eResult s3eDebugSetInt(s3eDebugProperty property, int32 value);







typedef enum s3eDebugCallback
{
# 137 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
    S3E_DEBUG_ASSERT = 0,
# 152 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
    S3E_DEBUG_ERROR = 1,

    S3E_DEBUG_CALLBACK_MAX
} s3eDebugCallback;
# 180 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
extern "C" s3eResult s3eDebugRegister(s3eDebugCallback cbid, s3eCallback fn, void* userData);
# 197 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
extern "C" s3eResult s3eDebugUnRegister(s3eDebugCallback cbid, s3eCallback fn);
# 206 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
typedef enum s3eDebugError
{
    S3E_DEBUG_ERR_NONE = 0,
    S3E_DEBUG_ERR_PARAM = 1,
    S3E_DEBUG_ERR_TOO_MANY = 2,
    S3E_DEBUG_ERR_ALREADY_REG = 3,
    S3E_DEBUG_ERR_NOT_FOUND = 4
} s3eDebugError;
# 226 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
extern "C" s3eDebugError s3eDebugGetError();
# 239 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
extern "C" const char* s3eDebugGetErrorString();

typedef enum s3eErrorShowResult
{

    S3E_ERROR_SHOW_CONTINUE = 0,

    S3E_ERROR_SHOW_STOP = 1,

    S3E_ERROR_SHOW_IGNORE = 2,





    S3E_ERROR_SHOW_AGAIN = 3
} s3eErrorShowResult;




typedef enum s3eMessageType
{





    S3E_MESSAGE_CONTINUE = 0,





    S3E_MESSAGE_CONTINUE_STOP = 1,






    S3E_MESSAGE_CONTINUE_STOP_IGNORE = 2
} s3eMessageType;







extern "C" s3eBool s3eDebugIsDebuggerPresent();
# 305 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
extern "C" void s3eDebugOutputString(const char* pStr);
# 317 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
extern "C" s3eErrorShowResult s3eDebugErrorShow(s3eMessageType type, const char* string);






extern "C" s3eErrorShowResult s3eDebugErrorPrintf(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;
# 342 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
extern "C" s3eErrorShowResult s3eDebugAssertShow(s3eMessageType type, const char* string);
# 355 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
extern "C" void s3eDebugTraceLine(const char* string);






extern "C" int s3eDebugTracePrintf(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;






extern "C" void s3eDebugTraceClearFile();
# 382 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
extern "C" void s3eDebugTraceFlush();
# 407 "c:/marmalade/6.2/s3e/h/s3eDebug.h"
extern "C" void s3eDebugPrint(int x, int y, const char* string, s3eBool wrap);






extern "C" void s3eDebugPrintf(int x, int y, s3eBool wrap, const char* fmt, ...)

__attribute__((format(printf, 4, 5)))

;







extern "C" s3eBool s3eDebugTraceChannelSwitch(const char* channel, s3eBool new_state);
# 25 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eDevice.h" 1
# 39 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
typedef enum s3eDeviceError
{
    S3E_DEVICE_ERR_NONE = 0,
    S3E_DEVICE_ERR_PARAM = 1,
    S3E_DEVICE_ERR_TOO_MANY = 2,
    S3E_DEVICE_ERR_ALREADY_REG = 3,
    S3E_DEVICE_ERR_NOT_FOUND = 4,
    S3E_DEVICE_ERR_UNAVAIL = 5,
    S3E_DEVICE_ERR_DEVICE = 6,
    S3E_DEVICE_ERR_UNSUPPORTED = 7,
    S3E_DEVICE_ERR_MEM = 8,
    S3E_DEVICE_ERR_GENERIC = 9,
    S3E_DEVICE_ERR_INVALID_DRIVE = 10,
    S3E_DEVICE_ERR_INVALID_PATH = 11
} s3eDeviceError;
# 66 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" s3eDeviceError s3eDeviceGetError();
# 80 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" const char* s3eDeviceGetErrorString();
# 89 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
typedef enum s3eDeviceFPUType
{
    S3E_DEVICE_FPU_NONE = 0,
    S3E_DEVICE_FPU_VFP = 1,
    S3E_DEVICE_FPU_VFPV3 = 2,
    S3E_DEVICE_FPU_NEON = 3
} s3eDeviceFPUType;






typedef enum s3eDeviceProperty
{







    S3E_DEVICE_OS = 0,





    S3E_DEVICE_CLASS = 1,
# 128 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_ID = 2,





    S3E_DEVICE_PHONE_NUMBER = 3,





    S3E_DEVICE_LANGUAGE = 4,






    S3E_DEVICE_STATE = 5,




    S3E_DEVICE_FREE_RAM = 6,




    S3E_DEVICE_TOTAL_RAM = 7,







    S3E_DEVICE_ARCHITECTURE = 8,
# 175 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_S3E_VERSION = 9,





    S3E_DEVICE_BATTERY_LEVEL = 10,






    S3E_DEVICE_LEFT_SOFTKEY_IS_BACK = 11,






    S3E_DEVICE_MAINS_POWER = 12,
# 204 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_OS_VERSION = 13,





    S3E_DEVICE_CHIPSET = 14,
# 219 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_EXIT_CODE = 15,





    S3E_DEVICE_FPU = 16,





    S3E_DEVICE_BACK_SOFTKEY_POSITION = 17,





    S3E_DEVICE_ADVANCE_SOFTKEY_POSITION = 18,
# 248 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_SDK_VERSION = 19,
# 257 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_LOCALE = 20,





    S3E_DEVICE_NAME = 21,







    S3E_DEVICE_SUPPORTS_SIGNAL_HANDLING = 22,







    S3E_DEVICE_EXIT_SIGNAL = 23,







    S3E_DEVICE_PROXIMITY = 24,
# 303 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_UNIQUE_ID = 25,
# 314 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_IMSI = 26,





    S3E_DEVICE_SILENT_MODE = 27,




    S3E_DEVICE_NUM_CPU_CORES = 28,




    S3E_DEVICE_MEM_TOTAL = 29,






    S3E_DEVICE_MEM_FREE = 30,





    S3E_DEVICE_TIMEZONE = 31,





    S3E_DEVICE_3D_MODE = 32,






    S3E_DEVICE_PROCESS_ID = 33

} s3eDeviceProperty;






typedef enum s3eDeviceOSID
{

    S3E_OS_ID_WINDOWS = 3,

    S3E_OS_ID_LINUX = 5,

    S3E_OS_ID_ARM_SEMIH = 8,

    S3E_OS_ID_OSX = 13,

    S3E_OS_ID_IPHONE = 14,

    S3E_OS_ID_BADA = 18,

    S3E_OS_ID_ANDROID = 19,

    S3E_OS_ID_QNX = 24,

    S3E_OS_ID_ROKU = 25,


    S3E_OS_ID_SYMBIAN = 1,

    S3E_OS_ID_BREW = 2,

    S3E_OS_ID_WINMOBILE = 4,

    S3E_OS_ID_WIPI = 6,

    S3E_OS_ID_NDS = 7,

    S3E_OS_ID_NUCLEUS = 9,

    S3E_OS_ID_NGI = 10,

    S3E_OS_ID_WINCE = 11,

    S3E_OS_ID_SHARPEMP = 12,

    S3E_OS_ID_UIQ = 15,

    S3E_OS_ID_PS3 = 16,

    S3E_OS_ID_X360 = 17,

    S3E_OS_ID_WEBOS = 20,

    S3E_OS_ID_PSP = 21,

    S3E_OS_ID_WII = 22,
    S3E_OS_ID_MEEGO = 23

} s3eDeviceOSID;






typedef enum s3eDeviceClassID
{
    S3E_DEVICE_CLASS_UNKNOWN = 0,

    S3E_DEVICE_CLASS_WINDOWS_GENERIC = 3000,
    S3E_DEVICE_CLASS_LINUX_GENERIC = 5000,
    S3E_DEVICE_CLASS_LINUX_DESKTOP = 5001,
    S3E_DEVICE_CLASS_LINUX_EMBED = 5002,
    S3E_DEVICE_CLASS_ARM_SEMIH_GENERIC = 8000,
    S3E_DEVICE_CLASS_OSX_DESKTOP = 11000,
    S3E_DEVICE_CLASS_IPHONE = 12000,
    S3E_DEVICE_CLASS_BADA_GENERIC = 15000,
    S3E_DEVICE_CLASS_ANDROID_GENERIC = 16000,
    S3E_DEVICE_CLASS_QNX = 19000,

    S3E_DEVICE_CLASS_SYMBIAN_GENERIC = 1000,
    S3E_DEVICE_CLASS_SYMBIAN_SERIES60 = 1001,
    S3E_DEVICE_CLASS_SYMBIAN_SERIES60_EMULATOR = 1002,
    S3E_DEVICE_CLASS_SYMBIAN_UIQ = 1003,
    S3E_DEVICE_CLASS_SYMBIAN_UIQ_EMULATOR = 1004,
    S3E_DEVICE_CLASS_BREW_GENERIC = 2000,
    S3E_DEVICE_CLASS_BREW_QCIF_3G = 2001,
    S3E_DEVICE_CLASS_BREW_QCIF_25G = 2002,
    S3E_DEVICE_CLASS_BREW_SQCIF_25G = 2003,
    S3E_DEVICE_CLASS_BREW_QVGA_3G = 2004,
    S3E_DEVICE_CLASS_WINCE_GENERIC = 4000,
    S3E_DEVICE_CLASS_WINMOBILE_SP = 4001,
    S3E_DEVICE_CLASS_WINMOBILE_PPC = 4002,
    S3E_DEVICE_CLASS_WIPI_GENERIC = 6000,
    S3E_DEVICE_CLASS_NDS_GENERIC = 7000,
    S3E_DEVICE_CLASS_NDS_NDSI = 7001,
    S3E_DEVICE_CLASS_NUCLEUS_GENERIC = 9000,
    S3E_DEVICE_CLASS_NGI_GENERIC = 10000,
    S3E_DEVICE_CLASS_PS3 = 13000,
    S3E_DEVICE_CLASS_X360 = 14000,
    S3E_DEVICE_CLASS_PSP = 17000,
    S3E_DEVICE_CLASS_WII = 18000

} s3eDeviceClassID;




typedef enum s3eDeviceLanguage
{
    S3E_DEVICE_LANGUAGE_UNKNOWN = 0,
    S3E_DEVICE_LANGUAGE_ENGLISH = 1,
    S3E_DEVICE_LANGUAGE_FRENCH = 2,
    S3E_DEVICE_LANGUAGE_GERMAN = 3,
    S3E_DEVICE_LANGUAGE_SPANISH = 4,
    S3E_DEVICE_LANGUAGE_ITALIAN = 5,
    S3E_DEVICE_LANGUAGE_PORTUGUESE = 6,
    S3E_DEVICE_LANGUAGE_DUTCH = 7,
    S3E_DEVICE_LANGUAGE_TURKISH = 8,
    S3E_DEVICE_LANGUAGE_CROATIAN = 9,
    S3E_DEVICE_LANGUAGE_CZECH = 10,
    S3E_DEVICE_LANGUAGE_DANISH = 11,
    S3E_DEVICE_LANGUAGE_FINNISH = 12,
    S3E_DEVICE_LANGUAGE_HUNGARIAN = 13,
    S3E_DEVICE_LANGUAGE_NORWEGIAN = 14,
    S3E_DEVICE_LANGUAGE_POLISH = 15,
    S3E_DEVICE_LANGUAGE_RUSSIAN = 16,
    S3E_DEVICE_LANGUAGE_SERBIAN = 17,
    S3E_DEVICE_LANGUAGE_SLOVAK = 18,
    S3E_DEVICE_LANGUAGE_SLOVENIAN = 19,
    S3E_DEVICE_LANGUAGE_SWEDISH = 20,
    S3E_DEVICE_LANGUAGE_UKRAINIAN = 21,
    S3E_DEVICE_LANGUAGE_GREEK = 22,
    S3E_DEVICE_LANGUAGE_JAPANESE = 23,
    S3E_DEVICE_LANGUAGE_SIMPL_CHINESE = 24,
    S3E_DEVICE_LANGUAGE_TRAD_CHINESE = 25,
    S3E_DEVICE_LANGUAGE_KOREAN = 26,
    S3E_DEVICE_LANGUAGE_ICELANDIC = 27,
    S3E_DEVICE_LANGUAGE_FLEMISH = 28,
    S3E_DEVICE_LANGUAGE_THAI = 29,
    S3E_DEVICE_LANGUAGE_AFRIKAANS = 30,
    S3E_DEVICE_LANGUAGE_ALBANIAN = 31,
    S3E_DEVICE_LANGUAGE_AMHARIC = 32,
    S3E_DEVICE_LANGUAGE_ARABIC = 33,
    S3E_DEVICE_LANGUAGE_ARMENIAN = 34,
    S3E_DEVICE_LANGUAGE_AZERBAIJANI = 35,
    S3E_DEVICE_LANGUAGE_TAGALOG = 36,
    S3E_DEVICE_LANGUAGE_BELARUSSIAN = 37,
    S3E_DEVICE_LANGUAGE_BENGALI = 38,
    S3E_DEVICE_LANGUAGE_BULGARIAN = 39,
    S3E_DEVICE_LANGUAGE_BURMESE = 40,
    S3E_DEVICE_LANGUAGE_CATALAN = 41,
    S3E_DEVICE_LANGUAGE_ESTONIAN = 42,
    S3E_DEVICE_LANGUAGE_FARSI = 43,
    S3E_DEVICE_LANGUAGE_GAELIC = 44,
    S3E_DEVICE_LANGUAGE_GEORGIAN = 45,
    S3E_DEVICE_LANGUAGE_GUJARATI = 46,
    S3E_DEVICE_LANGUAGE_HEBREW = 47,
    S3E_DEVICE_LANGUAGE_HINDI = 48,
    S3E_DEVICE_LANGUAGE_INDONESIAN = 49,
    S3E_DEVICE_LANGUAGE_IRISH = 50,
    S3E_DEVICE_LANGUAGE_KANNADA = 51,
    S3E_DEVICE_LANGUAGE_KAZAKH = 52,
    S3E_DEVICE_LANGUAGE_KHMER = 53,
    S3E_DEVICE_LANGUAGE_LAO = 54,
    S3E_DEVICE_LANGUAGE_LATVIAN = 55,
    S3E_DEVICE_LANGUAGE_LITHUANIAN = 56,
    S3E_DEVICE_LANGUAGE_MACEDONIAN = 57,
    S3E_DEVICE_LANGUAGE_MALAY = 58,
    S3E_DEVICE_LANGUAGE_MALAYALAM = 59,
    S3E_DEVICE_LANGUAGE_MARATHI = 60,
    S3E_DEVICE_LANGUAGE_MOLDOVIAN = 61,
    S3E_DEVICE_LANGUAGE_MONGOLIAN = 62,
    S3E_DEVICE_LANGUAGE_PUNJABI = 63,
    S3E_DEVICE_LANGUAGE_ROMANIAN = 64,
    S3E_DEVICE_LANGUAGE_SINHALESE = 65,
    S3E_DEVICE_LANGUAGE_SOMALI = 66,
    S3E_DEVICE_LANGUAGE_SWAHILI = 67,
    S3E_DEVICE_LANGUAGE_TAJIK = 68,
    S3E_DEVICE_LANGUAGE_TAMIL = 69,
    S3E_DEVICE_LANGUAGE_TELUGU = 70,
    S3E_DEVICE_LANGUAGE_TIBETAN = 71,
    S3E_DEVICE_LANGUAGE_TIGRINYA = 72,
    S3E_DEVICE_LANGUAGE_TURKMEN = 73,
    S3E_DEVICE_LANGUAGE_URDU = 74,
    S3E_DEVICE_LANGUAGE_UZBEK = 75,
    S3E_DEVICE_LANGUAGE_VIETNAMESE = 76,
    S3E_DEVICE_LANGUAGE_WELSH = 77,
    S3E_DEVICE_LANGUAGE_ZULU = 78
} s3eDeviceLanguage;






typedef enum s3eDeviceArchitecture
{
    S3E_DEVICE_ARCHITECTURE_ARM4T = 0,
    S3E_DEVICE_ARCHITECTURE_ARM4 = 1,
    S3E_DEVICE_ARCHITECTURE_ARM5T = 2,
    S3E_DEVICE_ARCHITECTURE_ARM5TE = 3,
    S3E_DEVICE_ARCHITECTURE_ARM5TEJ = 4,
    S3E_DEVICE_ARCHITECTURE_ARM6 = 5,
    S3E_DEVICE_ARCHITECTURE_ARM6K = 6,
    S3E_DEVICE_ARCHITECTURE_ARM6T2 = 7,
    S3E_DEVICE_ARCHITECTURE_ARM6Z = 8,
    S3E_DEVICE_ARCHITECTURE_ARM7 = 12,
    S3E_DEVICE_ARCHITECTURE_X86 = 9,
    S3E_DEVICE_ARCHITECTURE_PPC = 10,
    S3E_DEVICE_ARCHITECTURE_AMD64 = 11,
    S3E_DEVICE_ARCHITECTURE_MIPS = 13,
    S3E_DEVICE_ARCHITECTURE_MAX = 14
} s3eDeviceArchitecture;
# 582 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
typedef enum s3eDeviceSoftKeyPosition
{
    S3E_DEVICE_SOFTKEY_BOTTOM_LEFT = 0,
    S3E_DEVICE_SOFTKEY_BOTTOM_RIGHT = 1,
    S3E_DEVICE_SOFTKEY_TOP_RIGHT = 2,
    S3E_DEVICE_SOFTKEY_TOP_LEFT = 3
} s3eDeviceSoftKeyPosition;
# 623 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" const char* s3eDeviceGetString(s3eDeviceProperty property);
# 658 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" int32 s3eDeviceGetInt(s3eDeviceProperty property);
# 678 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceSetInt(s3eDeviceProperty property, int32 value);
# 706 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" int64 s3eDeviceYield(int32 ms =0);
# 728 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceUnYield();
# 756 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceYieldUntilEvent(int32 ms =0x7fffffffL);
# 791 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceExecPushNext(const char* filename, const char* config_prepend =__null, const char* config_append =__null);
# 807 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceExit(int code =0) __attribute__ ((noreturn));






typedef enum s3eDeviceState
{




    S3E_DEVICE_STATE_PAUSED = 3,





    S3E_DEVICE_STATE_EXITING = 4,




    S3E_DEVICE_STATE_RUNNING = 5
} s3eDeviceState;
# 844 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
typedef enum s3eDeviceCallback
{
# 857 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_PAUSE = 0,
# 869 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_UNPAUSE = 1,
# 881 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_EXIT = 2,
# 897 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_VOL_UP = 17,
# 913 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_VOL_DOWN = 18,
# 931 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_MAINS_POWER_CHANGED = 20,
# 943 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_BACKGROUND = 22,
# 955 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_FOREGROUND = 23,
# 969 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_NETWORK_ONLINE = 24,
# 983 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_NETWORK_OFFLINE = 25,
# 997 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_SIMULATOR_RESTART = 26,
# 1013 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_ACTIVE = 27,
# 1029 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_INACTIVE = 28,
# 1045 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_FULLSCREEN = 29,
# 1061 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_THUMBNAIL = 30,
# 1077 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    S3E_DEVICE_APPLICATION_INVISIBLE = 31,

    S3E_DEVICE_CALLBACK_MAX
} s3eDeviceCallback;
# 1098 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
typedef struct s3eDeviceVolChangeInfo
{





    s3eBool m_VolUp;
# 1123 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
    s3eBool m_OverrideDefaultBehaviour;
} s3eDeviceVolChangeInfo;





typedef struct s3eDeviceStateChangeInfo
{



    int32 m_State;
} s3eDeviceStateChangeInfo;
# 1158 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceRegister(s3eDeviceCallback cbid, s3eCallback fn, void* userdata);
# 1178 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceUnRegister(s3eDeviceCallback cbid, s3eCallback fn);







extern "C" void s3eDeviceRequestQuit();
# 1197 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" s3eBool s3eDeviceCheckQuitRequest();
# 1207 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" s3eBool s3eDeviceCheckPauseRequest();
# 1221 "c:/marmalade/6.2/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceBacklightOn();


extern "C" s3eBool s3eDeviceNetworkCheckStart();


extern "C" s3eBool s3eDeviceNetworkCheckStop();


extern "C" void s3eDeviceLoaderCallStart(s3eBool lock, void* function);


extern "C" void s3eDeviceLoaderCallDone(s3eBool lock, void* function);
# 26 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eExt.h" 1
# 31 "c:/marmalade/6.2/s3e/h/s3eExt.h"
typedef enum s3eExtError
{
    S3E_EXT_ERR_NONE = 0,
    S3E_EXT_ERR_PARAM = 1,
    S3E_EXT_ERR_NOT_FOUND = 4
} s3eExtError;
# 49 "c:/marmalade/6.2/s3e/h/s3eExt.h"
extern "C" s3eExtError s3eExtGetError();
# 63 "c:/marmalade/6.2/s3e/h/s3eExt.h"
extern "C" const char* s3eExtGetErrorString();
# 96 "c:/marmalade/6.2/s3e/h/s3eExt.h"
extern "C" s3eResult s3eExtGet(const char* extension, void* functions, uint32 functionsLen);
# 106 "c:/marmalade/6.2/s3e/h/s3eExt.h"
extern "C" s3eResult s3eExtGetHash(uint32 hash, void* functions, uint32 functionsLen);

static inline s3eBool s3eExtAvailable(const char* extension, int32 len =0)
{
    if (s3eExtGet(extension, __null, len) == S3E_RESULT_SUCCESS)
        return (1);
    else
        return (0);
}
# 27 "c:/marmalade/6.2/s3e/h/s3e.h" 2

# 1 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h" 1
# 38 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
typedef enum s3eKey
{
    s3eKeyFirst = 0,

    s3eKeyEsc = 1,
    s3eKeyTab = 2,
    s3eKeyBackspace = 3,
    s3eKeyEnter = 4,
    s3eKeyLeftShift = 5,
    s3eKeyLeftControl = 6,
    s3eKeyReserved = 7,
    s3eKeySpace = 8,
    s3eKeyLeft = 9,
    s3eKeyUp = 10,
    s3eKeyRight = 11,
    s3eKeyDown = 12,
    s3eKey0 = 13,
    s3eKey1 = 14,
    s3eKey2 = 15,
    s3eKey3 = 16,
    s3eKey4 = 17,
    s3eKey5 = 18,
    s3eKey6 = 19,
    s3eKey7 = 20,
    s3eKey8 = 21,
    s3eKey9 = 22,
    s3eKeyA = 23,
    s3eKeyB = 24,
    s3eKeyC = 25,
    s3eKeyD = 26,
    s3eKeyE = 27,
    s3eKeyF = 28,
    s3eKeyG = 29,
    s3eKeyH = 30,
    s3eKeyI = 31,
    s3eKeyJ = 32,
    s3eKeyK = 33,
    s3eKeyL = 34,
    s3eKeyM = 35,
    s3eKeyN = 36,
    s3eKeyO = 37,
    s3eKeyP = 38,
    s3eKeyQ = 39,
    s3eKeyR = 40,
    s3eKeyS = 41,
    s3eKeyT = 42,
    s3eKeyU = 43,
    s3eKeyV = 44,
    s3eKeyW = 45,
    s3eKeyX = 46,
    s3eKeyY = 47,
    s3eKeyZ = 48,
    s3eKeyF1 = 49,
    s3eKeyF2 = 50,
    s3eKeyF3 = 51,
    s3eKeyF4 = 52,
    s3eKeyF5 = 53,
    s3eKeyF6 = 54,
    s3eKeyF7 = 55,
    s3eKeyF8 = 56,
    s3eKeyF9 = 57,
    s3eKeyF10 = 58,
    s3eKeyNumPad0 = 59,
    s3eKeyNumPad1 = 60,
    s3eKeyNumPad2 = 61,
    s3eKeyNumPad3 = 62,
    s3eKeyNumPad4 = 63,
    s3eKeyNumPad5 = 64,
    s3eKeyNumPad6 = 65,
    s3eKeyNumPad7 = 66,
    s3eKeyNumPad8 = 67,
    s3eKeyNumPad9 = 68,
    s3eKeyNumPadPlus = 69,
    s3eKeyNumPadMinus = 70,
    s3eKeyNumPadEnter = 71,
    s3eKeyRSK = 72,
    s3eKeyLSK = 73,
    s3eKeyLS = 74,
    s3eKeyRS = 75,
    s3eKeyHash = 76,
    s3eKeyStar = 77,


    s3eKeyOk = 78,
    s3eKeyCLR = 79,


    s3eKeyVolUp = 80,
    s3eKeyVolDown = 81,


    s3eKeyCamera = 82,
    s3eKeyMic = 83,
    s3eKeyFn = 84,
    s3eKeySym = 85,


    s3eKeyAccept = 86,
    s3eKeyEnd = 87,
    s3eKeyHomePage = 88,

    s3eKeyButton1 = 89,
    s3eKeyButton2 = 90,
    s3eKeyButton3 = 91,
    s3eKeyButton4 = 92,
    s3eKeyButton5 = 93,
    s3eKeyButton6 = 94,
    s3eKeyButton7 = 95,
    s3eKeyButton8 = 96,

    s3eKeyF11 = 97,
    s3eKeyF12 = 98,
    s3eKeyLeftAlt = 99,

    s3eKeyRightControl = 100,
    s3eKeyRightAlt = 101,
    s3eKeyRightShift = 102,
    s3eKeyBacktick = 103,
    s3eKeyComma = 104,
    s3eKeyPeriod = 105,
    s3eKeySlash = 106,
    s3eKeyBackSlash = 107,
    s3eKeySemicolon = 108,
    s3eKeyApostrophe = 109,
    s3eKeyLeftBracket = 110,
    s3eKeyRightBracket = 111,
    s3eKeyEquals = 112,
    s3eKeyMinus = 113,
    s3eKeyCapsLock = 114,

    s3eKeyNumPadPeriod = 115,
    s3eKeyNumPadSlash = 116,
    s3eKeyNumLock = 117,
    s3eKeyInsert = 118,
    s3eKeyHome = 119,
    s3eKeyPageUp = 120,
    s3eKeyPageDown = 121,
    s3eKeyKbEnd = 122,
    s3eKeyDelete = 123,
    s3eKeyPause = 124,
    s3eKeyAt = 125,
    s3eKeyBack = 126,
    s3eKeyMenu = 127,
    s3eKeySearch = 128,
    s3eKey3DMode = 129,
    s3eKeyMyApps = 130,

    s3eKeyAbsGameA = 200,
    s3eKeyAbsGameB = 201,
    s3eKeyAbsGameC = 202,
    s3eKeyAbsGameD = 203,
    s3eKeyAbsUp = 204,
    s3eKeyAbsDown = 205,
    s3eKeyAbsLeft = 206,
    s3eKeyAbsRight = 207,
    s3eKeyAbsOk = 208,
    s3eKeyAbsASK = 209,
    s3eKeyAbsBSK = 210,

    s3eKeyCount = 211
} s3eKey;
# 236 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
typedef enum s3eKeyboardNumpadOrientation
{
    S3E_NUMPAD_ORIENT_NORMAL = 0,
    S3E_NUMPAD_ORIENT_ROT90 = 1,
    S3E_NUMPAD_ORIENT_ROT180 = 2,
    S3E_NUMPAD_ORIENT_ROT270 = 3
} s3eKeyboardNumpadOrientation;






typedef enum s3eKeyboardProperty
{





    S3E_KEYBOARD_HAS_NUMPAD = 0,






    S3E_KEYBOARD_HAS_ALPHA = 1,






    S3E_KEYBOARD_HAS_DIRECTION = 2,






    S3E_KEYBOARD_NUMPAD_ORIENTATION = 3,
# 303 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
    S3E_KEYBOARD_GET_CHAR = 4
} s3eKeyboardProperty;







typedef enum s3eKeyboardError
{
    S3E_KEYBOARD_ERR_NONE = 0,
    S3E_KEYBOARD_ERR_PARAM = 1,
    S3E_KEYBOARD_ERR_TOO_MANY = 2,
    S3E_KEYBOARD_ERR_ALREADY_REG = 3,
    S3E_KEYBOARD_ERR_NOT_FOUND = 4,
    S3E_KEYBOARD_ERR_UNAVAIL = 5,

    S3E_KEYBOARD_ERR_DEVICE = 6
} s3eKeyboardError;






typedef enum s3eKeyboardCallback
{
# 343 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
    S3E_KEYBOARD_KEY_EVENT = 0,
# 358 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
    S3E_KEYBOARD_CHAR_EVENT = 1,

    S3E_KEYBOARD_CALLBACK_MAX
} s3eKeyboardCallback;






typedef struct s3eKeyboardEvent
{

    s3eKey m_Key;

    uint32 m_Pressed;
} s3eKeyboardEvent;






typedef struct s3eKeyboardCharEvent
{

    s3eWChar m_Char;
} s3eKeyboardCharEvent;
# 408 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
extern "C" int32 s3eKeyboardGetInt(s3eKeyboardProperty property);
# 428 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
extern "C" s3eResult s3eKeyboardSetInt(s3eKeyboardProperty property, int32 value);
# 456 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
extern "C" s3eResult s3eKeyboardRegister(s3eKeyboardCallback cbid, s3eCallback fn, void* userdata);
# 475 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
extern "C" s3eResult s3eKeyboardUnRegister(s3eKeyboardCallback cbid, s3eCallback fn);
# 487 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
extern "C" s3eKeyboardError s3eKeyboardGetError();
# 501 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
extern "C" const char* s3eKeyboardGetErrorString();







extern "C" void s3eKeyboardClearState();







extern "C" s3eResult s3eKeyboardUpdate();
# 533 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
extern "C" int32 s3eKeyboardGetState(s3eKey key);






extern "C" s3eWChar s3eKeyboardGetChar();
# 551 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
extern "C" s3eKey s3eKeyboardAnyKey();
# 573 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h"
extern "C" s3eResult s3eKeyboardGetDisplayName(char* dst, s3eKey key, s3eBool terminateString =(1));





# 1 "c:/marmalade/6.2/s3e/h/legacy/s3eKeyboard_legacy.h" 1
# 580 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h" 2
# 29 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eLicense.h" 1
# 36 "c:/marmalade/6.2/s3e/h/s3eLicense.h"
typedef enum s3eLicenseStatus
{
    S3E_LICENSE_EXPIRED = 0,
    S3E_LICENSE_DEMO = 0x10,
    S3E_LICENSE_USECOUNT = 0x20,
    S3E_LICENSE_EXPIRYDATE = 0x21,
    S3E_LICENSE_EXPIRYMINSUSE = 0x22,
    S3E_LICENSE_PURCHASE = 0x100,
    S3E_LICENSE_SUBSCRIPTION = 0x200,
    S3E_LICENSE_UPGRADE = 0x300,
    S3E_LICENSE_NONCOMMERCIAL = 0x1000
} s3eLicenseStatus;






typedef enum s3eLicenseError
{
    S3E_LICENSE_ERR_NONE = 0,
    S3E_LICENSE_ERR_PARAM = 1
} s3eLicenseError;






typedef enum s3eLicenseProperty
{
    S3E_LICENSE_USES_LEFT,
    S3E_LICENSE_EXPIRY_DATE,
    S3E_LICENSE_MINS_LEFT,
    S3E_LICENSE_STATUS
} s3eLicenseProperty;




extern "C" int32 s3eLicenseGetInt(s3eLicenseProperty property);
# 88 "c:/marmalade/6.2/s3e/h/s3eLicense.h"
extern "C" s3eLicenseError s3eLicenseGetError();
# 102 "c:/marmalade/6.2/s3e/h/s3eLicense.h"
extern "C" const char* s3eLicenseGetErrorString();
# 111 "c:/marmalade/6.2/s3e/h/s3eLicense.h"
extern "C" s3eResult s3eLicenseBuy();
# 30 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eMemory.h" 1
# 38 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
typedef enum s3eMemoryProperty
{
# 55 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
    S3E_MEMORY_HEAP = 0,





    S3E_MEMORY_SIZE = 1,





    S3E_MEMORY_FREE = 2,





    S3E_MEMORY_USED = 3,






    S3E_MEMORY_LFB = 4,






    S3E_MEMORY_FLAGS = 5
} s3eMemoryProperty;







typedef enum s3eMemoryFlags
{



    S3E_MEMORY_NO_MSG_ON_FAIL = (1 << 0),
# 112 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
    S3E_MEMORY_USE_STACK_ALLOCATOR = (1 << 1),
# 121 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
    S3E_MEMORY_INACTIVE = (1 << 2)
} s3eMemoryFlags;
# 144 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" int32 s3eMemoryGetInt(s3eMemoryProperty property);
# 163 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" s3eResult s3eMemorySetInt(s3eMemoryProperty property, int32 value);
# 172 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
typedef enum s3eMemoryError
{
    S3E_MEMORY_ERR_NONE = 0,
    S3E_MEMORY_ERR_PARAM = 1,
    S3E_MEMORY_ERR_UNAVAIL = 5,

    S3E_MEMORY_ERR_INVALID_PTR = 1000,
    S3E_MEMORY_ERR_NO_MEM = 1001,
    S3E_MEMORY_ERR_INVALID_STATE = 1002
} s3eMemoryError;
# 194 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" s3eMemoryError s3eMemoryGetError();
# 208 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" const char* s3eMemoryGetErrorString();
# 229 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" void* s3eMalloc(int size);
# 253 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" void* s3eRealloc(void* item, int newSize);
# 267 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" void s3eFree(void* item);
# 286 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" void* s3eMallocBase(int size);
# 312 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" void* s3eReallocBase(void* item, int newSize);
# 324 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" void s3eFreeBase(void* item);
# 345 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" s3eResult s3eMemoryHeapDestroy(int32 heapID, s3eBool failIfNotEmpty);
# 360 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" s3eResult s3eMemoryHeapCreate(int32 heapID);
# 369 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" void* s3eMemoryHeapAddress(int32 heapID);



typedef void*(*s3eMallocFn)(int size);
typedef void*(*s3eReallocFn)(void* item, int size);
typedef void (*s3eFreeFn)(void* item);




typedef struct s3eMemoryUsrMgr
{
    s3eMallocFn m_Malloc;
    s3eReallocFn m_Realloc;
    s3eFreeFn m_Free;
} s3eMemoryUsrMgr;
# 407 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" s3eResult s3eMemorySetUserMemMgr(s3eMemoryUsrMgr* callbacks);
# 429 "c:/marmalade/6.2/s3e/h/s3eMemory.h"
extern "C" s3eResult s3eMemoryGetUserMemMgr(s3eMemoryUsrMgr* callbacks);
# 31 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3ePointer.h" 1
# 37 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
typedef enum s3ePointerType
{
    S3E_POINTER_TYPE_INVALID = 0,
    S3E_POINTER_TYPE_MOUSE = 1,
    S3E_POINTER_TYPE_STYLUS = 2
} s3ePointerType;







typedef enum s3eStylusType
{
    S3E_STYLUS_TYPE_INVALID = 0,
    S3E_STYLUS_TYPE_STYLUS = 1,
    S3E_STYLUS_TYPE_FINGER = 2
} s3eStylusType;
# 68 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
typedef enum s3ePointerProperty
{



    S3E_POINTER_AVAILABLE = 0,






    S3E_POINTER_HIDE_CURSOR = 1,




    S3E_POINTER_TYPE = 2,




    S3E_POINTER_STYLUS_TYPE = 3,




    S3E_POINTER_MULTI_TOUCH_AVAILABLE = 4

} s3ePointerProperty;
# 111 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
extern "C" int32 s3ePointerGetInt(s3ePointerProperty property);
# 128 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
extern "C" s3eResult s3ePointerSetInt(s3ePointerProperty property, int32 value);
# 137 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
typedef enum s3ePointerCallback
{







    S3E_POINTER_BUTTON_EVENT,
# 155 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
    S3E_POINTER_MOTION_EVENT,
# 166 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
    S3E_POINTER_TOUCH_EVENT,
# 177 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
    S3E_POINTER_TOUCH_MOTION_EVENT,
    S3E_POINTER_CALLBACK_MAX
} s3ePointerCallback;
# 201 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
extern "C" s3eResult s3ePointerRegister(s3ePointerCallback cbid, s3eCallback fn, void* userData);
# 218 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
extern "C" s3eResult s3ePointerUnRegister(s3ePointerCallback cbid, s3eCallback fn);
# 227 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
typedef enum s3ePointerError
{
    S3E_POINTER_ERR_NONE = 0,
    S3E_POINTER_ERR_PARAM = 1,
    S3E_POINTER_ERR_TOO_MANY = 2,
    S3E_POINTER_ERR_ALREADY_REG = 3,
    S3E_POINTER_ERR_NOT_FOUND = 4,
    S3E_POINTER_ERR_UNAVAIL = 5
} s3ePointerError;







extern "C" s3ePointerError s3ePointerGetError();







extern "C" const char* s3ePointerGetErrorString();






typedef enum s3ePointerState
{
    S3E_POINTER_STATE_UP = 0,
    S3E_POINTER_STATE_DOWN = 1,
    S3E_POINTER_STATE_PRESSED = 2,
    S3E_POINTER_STATE_RELEASED = 4,
    S3E_POINTER_STATE_UNKNOWN
} s3ePointerState;






typedef enum s3ePointerButton
{
    S3E_POINTER_BUTTON_SELECT = 0,
    S3E_POINTER_BUTTON_LEFTMOUSE = 0,
    S3E_POINTER_BUTTON_RIGHTMOUSE = 1,
    S3E_POINTER_BUTTON_MIDDLEMOUSE = 2,
    S3E_POINTER_BUTTON_MOUSEWHEELUP = 3,
    S3E_POINTER_BUTTON_MOUSEWHEELDOWN = 4,
    S3E_POINTER_BUTTON_MAX
} s3ePointerButton;




typedef struct s3ePointerEvent
{

    s3ePointerButton m_Button;

    uint32 m_Pressed;

    int32 m_x;

    int32 m_y;
} s3ePointerEvent;




typedef struct s3ePointerMotionEvent
{

    int32 m_x;

    int32 m_y;
} s3ePointerMotionEvent;




typedef struct s3ePointerTouchEvent
{





    uint32 m_TouchID;

    uint32 m_Pressed;

    int32 m_x;

    int32 m_y;
} s3ePointerTouchEvent;




typedef struct s3ePointerTouchMotionEvent
{





    uint32 m_TouchID;

    int32 m_x;

    int32 m_y;
} s3ePointerTouchMotionEvent;






extern "C" s3ePointerState s3ePointerGetState(s3ePointerButton button);






extern "C" int32 s3ePointerGetX();






extern "C" int32 s3ePointerGetY();
# 375 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
extern "C" s3ePointerState s3ePointerGetTouchState(uint32 touchID);
# 387 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
extern "C" int32 s3ePointerGetTouchX(uint32 touchID);
# 399 "c:/marmalade/6.2/s3e/h/s3ePointer.h"
extern "C" int32 s3ePointerGetTouchY(uint32 touchID);







extern "C" s3eResult s3ePointerUpdate();
# 32 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eSecureStorage.h" 1
# 38 "c:/marmalade/6.2/s3e/h/s3eSecureStorage.h"
typedef enum s3eSecureStorageError
{
    S3E_SECURESTORAGE_ERR_NONE = 0,
    S3E_SECURESTORAGE_ERR_PARAM = 1,
    S3E_SECURESTORAGE_ERR_NOT_FOUND = 4,
    S3E_SECURESTORAGE_ERR_DEVICE = 6,
    S3E_SECURESTORAGE_ERR_INSUFF = 1000,
    S3E_SECURESTORAGE_ERR_CORRUPT = 1001
} s3eSecureStorageError;
# 59 "c:/marmalade/6.2/s3e/h/s3eSecureStorage.h"
extern "C" s3eSecureStorageError s3eSecureStorageGetError();
# 72 "c:/marmalade/6.2/s3e/h/s3eSecureStorage.h"
extern "C" const char* s3eSecureStorageGetErrorString();
# 96 "c:/marmalade/6.2/s3e/h/s3eSecureStorage.h"
extern "C" s3eResult s3eSecureStoragePut(void* data, uint16 size);
# 119 "c:/marmalade/6.2/s3e/h/s3eSecureStorage.h"
extern "C" s3eResult s3eSecureStorageGet(void* data, uint16 size);
# 33 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eSound.h" 1
# 46 "c:/marmalade/6.2/s3e/h/s3eSound.h"
typedef enum s3eSoundProperty
{





    S3E_SOUND_VOLUME = 0,
# 66 "c:/marmalade/6.2/s3e/h/s3eSound.h"
    S3E_SOUND_OUTPUT_FREQ = 1,







    S3E_SOUND_DEFAULT_FREQ = 2,




    S3E_SOUND_NUM_CHANNELS = 3,





    S3E_SOUND_USED_CHANNELS = 4,




    S3E_SOUND_AVAILABLE = 5,
# 103 "c:/marmalade/6.2/s3e/h/s3eSound.h"
    S3E_SOUND_VOLUME_DEFAULT = 6,
# 112 "c:/marmalade/6.2/s3e/h/s3eSound.h"
    S3E_SOUND_STEREO_ENABLED = 7
} s3eSoundProperty;
# 140 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" int32 s3eSoundGetInt(s3eSoundProperty property);
# 162 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundSetInt(s3eSoundProperty property, int32 value);
# 171 "c:/marmalade/6.2/s3e/h/s3eSound.h"
typedef enum s3eSoundError
{
    S3E_SOUND_ERR_NONE = 0,
    S3E_SOUND_ERR_PARAM = 1,
    S3E_SOUND_ERR_TOO_MANY = 2,
    S3E_SOUND_ERR_ALREADY_REG = 3,
    S3E_SOUND_ERR_NOT_FOUND = 4,
    S3E_SOUND_ERR_UNAVAIL = 5
} s3eSoundError;
# 192 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" s3eSoundError s3eSoundGetError();
# 205 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" const char* s3eSoundGetErrorString();
# 219 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" int s3eSoundGetFreeChannel();
# 234 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" void s3eSoundPauseAllChannels();
# 248 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" void s3eSoundResumeAllChannels();
# 263 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" void s3eSoundStopAllChannels();






typedef enum s3eSoundChannelProperty
{
# 282 "c:/marmalade/6.2/s3e/h/s3eSound.h"
    S3E_CHANNEL_PITCH = 0,
# 291 "c:/marmalade/6.2/s3e/h/s3eSound.h"
    S3E_CHANNEL_RATE = 1,







    S3E_CHANNEL_USERVAR = 2,
# 308 "c:/marmalade/6.2/s3e/h/s3eSound.h"
    S3E_CHANNEL_VOLUME = 3,





    S3E_CHANNEL_STATUS = 4,





    S3E_CHANNEL_PAUSED = 5
} s3eSoundChannelProperty;
# 342 "c:/marmalade/6.2/s3e/h/s3eSound.h"
typedef enum s3eSoundChannelCallback
{
# 359 "c:/marmalade/6.2/s3e/h/s3eSound.h"
    S3E_CHANNEL_END_SAMPLE = 0,
# 405 "c:/marmalade/6.2/s3e/h/s3eSound.h"
    S3E_CHANNEL_GEN_AUDIO = 1,
# 419 "c:/marmalade/6.2/s3e/h/s3eSound.h"
    S3E_CHANNEL_STOP_AUDIO = 2,
# 443 "c:/marmalade/6.2/s3e/h/s3eSound.h"
    S3E_CHANNEL_GEN_AUDIO_STEREO = 3
} s3eSoundChannelCallback;
# 484 "c:/marmalade/6.2/s3e/h/s3eSound.h"
typedef struct s3eSoundEndSampleInfo
{



    int32 m_Channel;





    int32 m_RepsRemaining;






    int16* m_NewData;





    uint32 m_NumSamples;
} s3eSoundEndSampleInfo;
# 567 "c:/marmalade/6.2/s3e/h/s3eSound.h"
typedef struct s3eSoundGenAudioInfo
{
    int32 m_Channel;

    int16* m_Target;
    uint32 m_NumSamples;
    int32 m_Mix;

    int16* m_OrigStart;
    uint32 m_OrigNumSamples;
    uint32 m_OrigRepeat;

    s3eBool m_EndSample;
    s3eBool m_Stereo;
} s3eSoundGenAudioInfo;
# 609 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelSetInt(int channel, s3eSoundChannelProperty property, int32 value);
# 628 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" int32 s3eSoundChannelGetInt(int channel, s3eSoundChannelProperty property);
# 661 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelPlay(int channel, int16* start, uint32 numSamples, int32 repeat, int32 loopfrom);
# 683 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelStop(int channel);
# 704 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelPause(int channel);
# 725 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelResume(int channel);
# 754 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelRegister(int channel, s3eSoundChannelCallback cbid, s3eCallback func, void* userData);
# 779 "c:/marmalade/6.2/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelUnRegister(int channel, s3eSoundChannelCallback cbid);
# 34 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eSocket.h" 1
# 36 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
typedef enum s3eSocketType
{
    S3E_SOCKET_TCP,
    S3E_SOCKET_UDP
} s3eSocketType;

typedef enum s3eNetworkType
{
    S3E_NETWORK_TYPE_NONE = 0,
    S3E_NETWORK_TYPE_UNKNOWN = 1,
    S3E_NETWORK_TYPE_LAN = 2,
    S3E_NETWORK_TYPE_WLAN = 3,
    S3E_NETWORK_TYPE_GPRS = 4,
    S3E_NETWORK_TYPE_UMTS = 5,
    S3E_NETWORK_TYPE_EVDO = 6,
    S3E_NETWORK_TYPE_CDMA2000 = 7,
    S3E_NETWORK_TYPE_HSDPA = 8,
    S3E_NETWORK_TYPE_WIMAX = 9,
    S3E_NETWORK_TYPE_BLUETOOTH = 10,
    S3E_NETWORK_TYPE_EDGE = 11,
    S3E_NETWORK_TYPE_CDMA = 12,
    S3E_NETWORK_TYPE_IDEN = 13,
    S3E_NETWORK_TYPE_LTE = 14,
    S3E_NETWORK_TYPE_EHRPD = 15,
    S3E_NETWORK_TYPE_HSPAPLUS = 16,
} s3eNetworkType;
# 88 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
typedef struct s3eSocket s3eSocket;
# 101 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
typedef uint32 s3eInetIPAddress;
# 114 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
typedef struct s3eInetAddress
{

    char m_Local;

    char m_LocalAddress[128];

    char m_Abstract;

    s3eInetIPAddress m_IPAddress;

    uint16 m_Port;

    char m_String[128];
} s3eInetAddress;
# 137 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
typedef enum s3eSocketProperty
{



    S3E_SOCKET_MAX_SOCKETS,



    S3E_SOCKET_NETWORK_AVAILABLE,



    S3E_SOCKET_NETWORK_TYPE,



    S3E_SOCKET_DOMAINNAME,



    S3E_SOCKET_HOSTNAME,



    S3E_SOCKET_HTTP_PROXY,



    S3E_SOCKET_UDP_AVAILABLE
} s3eSocketProperty;


typedef enum s3eSocketOption
{





    S3E_SOCKET_NODELAY = 1,







    S3E_SOCKET_KEEPALIVE = 2,







    S3E_SOCKET_BROADCAST = 3,
# 204 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
    S3E_SOCKET_ADD_MEMBERSHIP = 4,
# 217 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
    S3E_SOCKET_DROP_MEMBERSHIP = 5

} s3eSocketOption;
# 234 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" int32 s3eSocketGetInt(s3eSocketProperty socketProperty);
# 249 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketSetOpt(s3eSocket* s, s3eSocketOption opt, void* value, int valueLen);
# 264 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketGetOpt(s3eSocket* s, s3eSocketOption opt, void* out, int* outLen);
# 275 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" const char* s3eSocketGetString(s3eSocketProperty socketProperty);
# 284 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
typedef int32 (*s3eSocketCallbackFn)(s3eSocket* s, void* systemData, void* userData);
# 294 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
typedef enum s3eSocketError
{
    S3E_SOCKET_ERR_NONE = 0,
    S3E_SOCKET_ERR_PARAM = 1,
    S3E_SOCKET_ERR_TOO_MANY = 2,
    S3E_SOCKET_ERR_ALREADY_REG = 3,
    S3E_SOCKET_ERR_NOT_FOUND = 4,
    S3E_SOCKET_ERR_UNAVAIL = 5,
    S3E_SOCKET_ERR_UNSUPPORTED = 7,

    S3E_SOCKET_ERR_WOULDBLOCK = 1000,
    S3E_SOCKET_ERR_INPROGRESS = 1001,
    S3E_SOCKET_ERR_ALREADY = 1002,
    S3E_SOCKET_ERR_NOTSOCK = 1003,
    S3E_SOCKET_ERR_MSGSIZE = 1004,
    S3E_SOCKET_ERR_ADDRINUSE = 1005,
    S3E_SOCKET_ERR_NETDOWN = 1006,
    S3E_SOCKET_ERR_CONNRESET = 1007,
    S3E_SOCKET_ERR_ISCONN = 1008,
    S3E_SOCKET_ERR_NOTCONN = 1009,
    S3E_SOCKET_ERR_SHUTDOWN = 1010,
    S3E_SOCKET_ERR_TIMEDOUT = 1011,
    S3E_SOCKET_ERR_CONNREFUSED = 1012,
    S3E_SOCKET_ERR_UNKNOWN_HOST = 1013
} s3eSocketErrors;
# 333 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eSocketErrors s3eSocketGetError();
# 347 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" const char* s3eSocketGetErrorString();
# 360 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eInetAton(s3eInetIPAddress* result, const char* addr);
# 370 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" uint32 s3eInetNtohl(uint32 addr);
# 380 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" uint32 s3eInetHtonl(uint32 addr);
# 390 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" uint16 s3eInetNtohs(uint16 addr);
# 400 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" uint16 s3eInetHtons(uint16 addr);
# 413 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" char* s3eInetNtoa(s3eInetIPAddress addr, char* buf, int len);
# 423 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" const char* s3eInetToString(const s3eInetAddress* s);
# 447 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eInetLookup(const char* hostname, s3eInetAddress* addr, s3eCallback func, void* userData);




extern "C" void s3eInetLookupCancel();
# 469 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eSocket* s3eSocketCreate(s3eSocketType type, uint32 flags =0);
# 483 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketClose(s3eSocket* socket);
# 514 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketBind(s3eSocket* sock, const s3eInetAddress* addr, uint8 reuseAddress);
# 529 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketGetLocalName(s3eSocket* sock, s3eInetAddress* addr);
# 542 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketGetPeerName(s3eSocket* sock, s3eInetAddress* addr);
# 574 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketConnect(s3eSocket* sock, const s3eInetAddress* addr, s3eSocketCallbackFn func, void* userdata);
# 595 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" int32 s3eSocketSend(s3eSocket* sock, const char* buf, uint32 len, int flags);
# 615 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" int32 s3eSocketRecv(s3eSocket* sock, char* buf, uint32 len, int flags);
# 636 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" int32 s3eSocketRecvFrom(s3eSocket* s, char* buf, uint32 len, int flags, s3eInetAddress* from);
# 661 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" int32 s3eSocketSendTo(s3eSocket* s, const char* buf, uint32 len, int flags, const s3eInetAddress* to);
# 681 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketListen(s3eSocket* s, uint16 backlog);
# 702 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eSocket* s3eSocketAccept(s3eSocket* s, s3eInetAddress* addr, s3eSocketCallbackFn callback, void* userdata);
# 716 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketReadable(s3eSocket* s, s3eSocketCallbackFn readable, void* userData);
# 729 "c:/marmalade/6.2/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketWritable(s3eSocket* s, s3eSocketCallbackFn writable, void* data);
# 35 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eSurface.h" 1
# 92 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
typedef enum s3eSurfacePixelType
{
    S3E_SURFACE_PIXEL_TYPE_RGB444 = 0x20 | 0x400 | 0x1,
    S3E_SURFACE_PIXEL_TYPE_RGB555 = 0x20 | 0x400 | 0x3,
    S3E_SURFACE_PIXEL_TYPE_RGB5551 = 0x20 | 0x400 | 0x6,
    S3E_SURFACE_PIXEL_TYPE_RGB565 = 0x20 | 0x400 | 0x2,
    S3E_SURFACE_PIXEL_TYPE_RGB666 = 0x40 | 0x400 | 0x4,
    S3E_SURFACE_PIXEL_TYPE_RGB888 = 0x40 | 0x400 | 0x5,
    S3E_SURFACE_PIXEL_TYPE_RGB888_3B = 0x30 | 0x400 | 0x5,
    S3E_SURFACE_PIXEL_TYPE_XRGB888 = 0x40 | 0x400 | 0x7,

    S3E_SURFACE_PIXEL_TYPE_BGR444 = 0x20 | 0x800 | 0x1,
    S3E_SURFACE_PIXEL_TYPE_BGR555 = 0x20 | 0x800 | 0x3,
    S3E_SURFACE_PIXEL_TYPE_BGR5551 = 0x20 | 0x800 | 0x6,
    S3E_SURFACE_PIXEL_TYPE_BGR565 = 0x20 | 0x800 | 0x2,
    S3E_SURFACE_PIXEL_TYPE_BGR666 = 0x40 | 0x800 | 0x4,
    S3E_SURFACE_PIXEL_TYPE_BGR888 = 0x40 | 0x800 | 0x5,
    S3E_SURFACE_PIXEL_TYPE_BGR888_3B = 0x30 | 0x800 | 0x5,
    S3E_SURFACE_PIXEL_TYPE_XBGR888 = 0x40 | 0x800 | 0x7
} s3eSurfacePixelType;






typedef enum s3eSurfaceBlitDirection
{

    S3E_SURFACE_BLIT_DIR_NORMAL = 0,


    S3E_SURFACE_BLIT_DIR_ROT90 = 1,


    S3E_SURFACE_BLIT_DIR_ROT180 = 2,


    S3E_SURFACE_BLIT_DIR_ROT270 = 3,





    S3E_SURFACE_BLIT_DIR_NATIVE = 4
} s3eSurfaceBlitDirection;






typedef struct s3eSurfaceInfo
{

    uint32 m_Width;

    uint32 m_Height;

    uint32 m_Pitch;

    s3eSurfacePixelType m_PixelType;

    void* m_Data;
} s3eSurfaceInfo;




extern "C" void s3eSurfaceClear(uint8 r, uint8 g, uint8 b);






extern "C" void s3eSurfaceBlank(uint8 bitpattern);







typedef enum s3eSurfaceProperty
{






    S3E_SURFACE_WIDTH = 0,







    S3E_SURFACE_HEIGHT = 1,






    S3E_SURFACE_PITCH = 2,





    S3E_SURFACE_PIXEL_TYPE = 3,


    S3E_SURFACE_DEVICE_WIDTH = 4,


    S3E_SURFACE_DEVICE_HEIGHT = 5,


    S3E_SURFACE_DEVICE_PIXEL_TYPE = 6,





    S3E_SURFACE_DEVICE_PITCH = 7,







    S3E_SURFACE_BLIT_DIRECTION = 8,


    S3E_SURFACE_DISPLAY = 9,





    S3E_SURFACE_NUM_DISPLAYS = 10,
# 249 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
    S3E_SURFACE_DEVICE_BLIT_DIRECTION = 11,
# 262 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
    S3E_SURFACE_DEVICE_WIDTH_QUANTISED = 12,
# 275 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
    S3E_SURFACE_DEVICE_HEIGHT_QUANTISED = 13,
# 291 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
    S3E_SURFACE_DEVICE_ORIENTATION_LOCK = 14
} s3eSurfaceProperty;
# 306 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
extern "C" int32 s3eSurfaceGetInt(s3eSurfaceProperty property);
# 321 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
 extern "C" s3eResult s3eSurfaceSetInt(s3eSurfaceProperty property, int32 val);
# 332 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
typedef struct s3eSurfaceOrientation
{
    s3eBool m_OrientationChanged;
    uint32 m_Width;
    uint32 m_Height;
    s3eSurfaceBlitDirection m_DeviceBlitDirection;
    uint32 m_Pitch;
} s3eSurfaceOrientation;
# 349 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
typedef enum s3eSurfaceCallback
{
# 362 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
    S3E_SURFACE_COPYUP = 0,
# 375 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
    S3E_SURFACE_SCREENSIZE = 1,

    S3E_SURFACE_CALLBACK_MAX = 3
} s3eSurfaceCallback;
# 403 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
typedef struct s3eSurfaceCopyupInfo
{

    s3eSurfaceInfo m_SrcSurface;

    s3eSurfaceInfo m_DestSurface;

    uint32 m_X;

    uint32 m_Y;

    uint32 m_Width;

    uint32 m_Height;

    s3eSurfaceBlitDirection m_BlitDirection;
} s3eSurfaceCopyupInfo;
# 447 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
extern "C" s3eResult s3eSurfaceRegister(s3eSurfaceCallback cbid, s3eCallback fn, void* userData);
# 466 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
extern "C" s3eResult s3eSurfaceUnRegister(s3eSurfaceCallback cbid, s3eCallback fn);
# 475 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
typedef enum s3eSurfaceError
{
    S3E_SURFACE_ERR_NONE = 0,
    S3E_SURFACE_ERR_PARAM = 1,
    S3E_SURFACE_ERR_TOO_MANY = 2,
    S3E_SURFACE_ERR_ALREADY_REG = 3,
    S3E_SURFACE_ERR_NOT_FOUND = 4,
    S3E_SURFACE_ERR_DEVICE = 6,
    S3E_SURFACE_ERR_MEM = 8
} s3eSurfaceError;
# 497 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
extern "C" s3eSurfaceError s3eSurfaceGetError();
# 511 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
extern "C" const char* s3eSurfaceGetErrorString();
# 533 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
extern "C" void* s3eSurfacePtr();
# 568 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
extern "C" s3eResult s3eSurfaceShow();
# 658 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
extern "C" s3eResult s3eSurfaceSetup(s3eSurfacePixelType pixelType, uint32 pitch =0, void* ptr =__null, s3eSurfaceBlitDirection blitDirection =S3E_SURFACE_BLIT_DIR_NORMAL);
# 686 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
extern "C" void s3eSurfaceInvalidate(int32 x, int32 y, int32 dx, int32 dy);
# 700 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
extern "C" uint32 s3eSurfaceConvertRGB(uint8 r, uint8 g, uint8 b);
# 719 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
extern "C" s3eResult s3eSurfaceSetDisplayID(uint32 id);
# 729 "c:/marmalade/6.2/s3e/h/s3eSurface.h"
typedef enum
{
    S3E_SURFACE_ORIENTATION_LOCK_MIN = 0,




    S3E_SURFACE_ORIENTATION_FREE = 0,






    S3E_SURFACE_PORTRAIT = 1,






    S3E_SURFACE_LANDSCAPE = 2,





    S3E_SURFACE_PORTRAIT_FIXED = 3,





    S3E_SURFACE_LANDSCAPE_FIXED = 4,

    S3E_SURFACE_ORIENTATION_LOCK_MAX = 4
} s3eSurfaceOrientationLock;
# 36 "c:/marmalade/6.2/s3e/h/s3e.h" 2

# 1 "c:/marmalade/6.2/s3e/h/s3eThread.h" 1
# 59 "c:/marmalade/6.2/s3e/h/s3eThread.h"
typedef enum s3eThreadError
{
    S3E_THREAD_ERR_NONE = 0,
    S3E_THREAD_ERR_PARAM = 1,
    S3E_THREAD_ERR_TOO_MANY = 2,
    S3E_THREAD_ERR_ALREADY = 3,
    S3E_THREAD_ERR_UNKNOWN = 9,
    S3E_THREAD_ERR_TIMEOUT = 1000,
    S3E_THREAD_ERR_WRONG_THREAD = 1001
} s3eThreadError;


typedef struct _s3eThread s3eThread;


typedef struct _s3eThreadLock s3eThreadLock;


typedef struct _s3eThreadSem s3eThreadSem;
# 94 "c:/marmalade/6.2/s3e/h/s3eThread.h"
typedef void* (*s3eThreadStartFunc)(void*);
typedef void (*s3eThreadCleanupHandler)();

extern "C" {





s3eBool s3eThreadAvailable();
# 117 "c:/marmalade/6.2/s3e/h/s3eThread.h"
const char* s3eThreadGetErrorString();
# 130 "c:/marmalade/6.2/s3e/h/s3eThread.h"
s3eThreadError s3eThreadGetError();






int s3eThreadCount();
# 151 "c:/marmalade/6.2/s3e/h/s3eThread.h"
s3eThread* s3eThreadCreate(s3eThreadStartFunc startRoutine, void* arg =__null, s3eThreadCleanupHandler cleanup =__null, int stackSize =0, void* stackPtr =0);




s3eThread* s3eThreadGetCurrent();




void s3eThreadExit(void* retval);
# 170 "c:/marmalade/6.2/s3e/h/s3eThread.h"
s3eResult s3eThreadDetach(s3eThread* thread);
# 183 "c:/marmalade/6.2/s3e/h/s3eThread.h"
s3eResult s3eThreadJoin(s3eThread* thread, void** result =__null);







s3eResult s3eThreadCancel(s3eThread* thread);
# 205 "c:/marmalade/6.2/s3e/h/s3eThread.h"
s3eThreadLock* s3eThreadLockCreate();






s3eResult s3eThreadLockDestroy(s3eThreadLock* lock);
# 235 "c:/marmalade/6.2/s3e/h/s3eThread.h"
s3eResult s3eThreadLockAcquire(s3eThreadLock* lock, int timeout =-1);
# 248 "c:/marmalade/6.2/s3e/h/s3eThread.h"
s3eResult s3eThreadLockRelease(s3eThreadLock* lock);







s3eThreadSem* s3eThreadSemCreate(int initialValue);
# 268 "c:/marmalade/6.2/s3e/h/s3eThread.h"
s3eResult s3eThreadSemDestroy(s3eThreadSem* sem);
# 286 "c:/marmalade/6.2/s3e/h/s3eThread.h"
s3eResult s3eThreadSemWait(s3eThreadSem* sem, int timeout =-1);
# 301 "c:/marmalade/6.2/s3e/h/s3eThread.h"
s3eResult s3eThreadSemPost(s3eThreadSem* sem);
# 314 "c:/marmalade/6.2/s3e/h/s3eThread.h"
s3eResult s3eThreadSemGetValue(s3eThreadSem* sem, int* value);
# 333 "c:/marmalade/6.2/s3e/h/s3eThread.h"
s3eResult s3eThreadEnqueueCallback(s3eThread* thread, s3eCallback callback, void* userData);

}
# 38 "c:/marmalade/6.2/s3e/h/s3e.h" 2

# 1 "c:/marmalade/6.2/s3e/h/s3eTimer.h" 1
# 36 "c:/marmalade/6.2/s3e/h/s3eTimer.h"
typedef enum s3eTimerProperty
{
    S3E_TIMER_RESOLUTION
} s3eTimerProperty;
# 48 "c:/marmalade/6.2/s3e/h/s3eTimer.h"
typedef enum s3eTimerError
{
    S3E_TIMER_ERR_NONE = 0,
    S3E_TIMER_ERR_PARAM = 1,
    S3E_TIMER_ERR_TOO_MANY = 2,
    S3E_TIMER_ERR_ALREADY_REG = 3,
    S3E_TIMER_ERR_NOT_FOUND = 4,
    S3E_TIMER_ERR_UNAVAIL = 5
} s3eTimerError;
# 69 "c:/marmalade/6.2/s3e/h/s3eTimer.h"
extern "C" s3eTimerError s3eTimerGetError();
# 82 "c:/marmalade/6.2/s3e/h/s3eTimer.h"
extern "C" const char* s3eTimerGetErrorString();
# 98 "c:/marmalade/6.2/s3e/h/s3eTimer.h"
extern "C" int32 s3eTimerGetInt(s3eTimerProperty property);
# 112 "c:/marmalade/6.2/s3e/h/s3eTimer.h"
extern "C" int64 s3eTimerGetUST();
# 123 "c:/marmalade/6.2/s3e/h/s3eTimer.h"
extern "C" int64 s3eTimerGetUSTNanoseconds();




extern "C" uint64 s3eTimerGetMs();





extern "C" int64 s3eTimerGetUTC();
# 143 "c:/marmalade/6.2/s3e/h/s3eTimer.h"
extern "C" int64 s3eTimerGetLocaltimeOffset(int64* when =__null);
# 175 "c:/marmalade/6.2/s3e/h/s3eTimer.h"
extern "C" s3eResult s3eTimerSetTimer(uint32 ms, s3eCallback fn, void* userData);
# 196 "c:/marmalade/6.2/s3e/h/s3eTimer.h"
extern "C" s3eResult s3eTimerCancelTimer(s3eCallback fn, void* userData);
# 40 "c:/marmalade/6.2/s3e/h/s3e.h" 2

# 1 "c:/marmalade/6.2/s3e/h/s3eVersion.h" 1
# 42 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eVibra.h" 1
# 38 "c:/marmalade/6.2/s3e/h/s3eVibra.h"
typedef enum s3eVibraProperty
{





    S3E_VIBRA_AVAILABLE = 0,







    S3E_VIBRA_ENABLED = 1,





    S3E_VIBRA_THRESHOLD = 2
} s3eVibraProperty;
# 69 "c:/marmalade/6.2/s3e/h/s3eVibra.h"
typedef enum s3eVibraError
{
    S3E_VIBRA_ERR_NONE = 0,
    S3E_VIBRA_ERR_PARAM = 1,
    S3E_VIBRA_ERR_UNAVAIL = 5,
    S3E_VIBRA_ERR_DEVICE = 6,
    S3E_VIBRA_ERR_DISABLED = 1000
} s3eVibraError;
# 91 "c:/marmalade/6.2/s3e/h/s3eVibra.h"
extern "C" int32 s3eVibraGetInt(s3eVibraProperty property);
# 109 "c:/marmalade/6.2/s3e/h/s3eVibra.h"
extern "C" s3eResult s3eVibraSetInt(s3eVibraProperty property, int32 value);
# 122 "c:/marmalade/6.2/s3e/h/s3eVibra.h"
extern "C" s3eVibraError s3eVibraGetError();
# 135 "c:/marmalade/6.2/s3e/h/s3eVibra.h"
extern "C" const char* s3eVibraGetErrorString();
# 151 "c:/marmalade/6.2/s3e/h/s3eVibra.h"
extern "C" s3eResult s3eVibraVibrate(uint8 level, uint32 ms);






extern "C" void s3eVibraStop();
# 43 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eVideo.h" 1
# 80 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
typedef enum s3eVideoCodec
{







    S3E_VIDEO_CODEC_MPEG4 = 1,
# 98 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
    S3E_VIDEO_CODEC_3GPP = 2,





    S3E_VIDEO_CODEC_JPEG = 3,
# 113 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
    S3E_VIDEO_CODEC_3GPP_VIDEO_H263 = 4,
# 122 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
    S3E_VIDEO_CODEC_3GPP_VIDEO_H264 = 5,
# 131 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
    S3E_VIDEO_CODEC_3GPP_AUDIO_AMR = 6,







    S3E_VIDEO_CODEC_3GPP_AUDIO_AAC = 7,
# 148 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
    S3E_VIDEO_CODEC_MPEG4_VIDEO_MPEG4 = 8,
# 157 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
    S3E_VIDEO_CODEC_MPEG4_VIDEO_H264 = 9,







    S3E_VIDEO_CODEC_MPEG4_AUDIO_AAC = 10,






    S3E_VIDEO_CODEC_SWF = 11
} s3eVideoCodec;






typedef enum s3eVideoStatus
{




    S3E_VIDEO_STOPPED = 0,




    S3E_VIDEO_PLAYING = 1,




    S3E_VIDEO_PAUSED = 2,
# 205 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
    S3E_VIDEO_FAILED = 3
} s3eVideoStatus;
# 215 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
typedef enum s3eVideoProperty
{





    S3E_VIDEO_VOLUME = 0,





    S3E_VIDEO_STATUS = 1,





    S3E_VIDEO_POSITION = 2,
# 247 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
    S3E_VIDEO_VOLUME_DEFAULT = 3,


    S3E_VIDEO_AVAILABLE = 5

} s3eVideoProperty;
# 267 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
extern "C" int32 s3eVideoGetInt(s3eVideoProperty property);
# 286 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoSetInt(s3eVideoProperty property, int32 value);
# 296 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
typedef enum s3eVideoCallback
{
# 314 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
    S3E_VIDEO_STOP = 2,

    S3E_VIDEO_CALLBACK_MAX
} s3eVideoCallback;
# 339 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoRegister(s3eVideoCallback cbid, s3eCallback fn, void* userData);
# 357 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoUnRegister(s3eVideoCallback cbid, s3eCallback fn);
# 366 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
typedef enum s3eVideoError
{
    S3E_VIDEO_ERR_NONE = 0,
    S3E_VIDEO_ERR_PARAM = 1,
    S3E_VIDEO_ERR_TOO_MANY = 2,
    S3E_VIDEO_ERR_ALREADY_REG = 3,
    S3E_VIDEO_ERR_NOT_FOUND = 4,
    S3E_VIDEO_ERR_UNAVAIL = 5,
    S3E_VIDEO_ERR_DEVICE = 6,
    S3E_VIDEO_ERR_UNSUPPORTED = 7,
    S3E_VIDEO_ERR_MEM = 8,
    S3E_VIDEO_ERR_INVALID_DRIVE = 10,
    S3E_VIDEO_ERR_INVALID_PATH = 11,
    S3E_VIDEO_ERR_FILEFORMAT = 1000,
    S3E_VIDEO_ERR_WRONG_STATE = 1001
} s3eVideoError;
# 394 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
extern "C" s3eVideoError s3eVideoGetError();
# 408 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
extern "C" const char* s3eVideoGetErrorString();
# 498 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoPlay(const char* filename, uint32 repeatCount =1, int32 x =0, int32 y =0, int32 width =0, int32 height =0);
# 572 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoPlayFromBuffer(void* data, uint32 len, uint32 repeatCount =1, int32 x =0, int32 y =0, int32 width =0, int32 height =0);
# 598 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoPause();
# 619 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoResume();
# 636 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
extern "C" void s3eVideoStop();
# 648 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
extern "C" s3eBool s3eVideoIsPlaying();
# 672 "c:/marmalade/6.2/s3e/h/s3eVideo.h"
extern "C" s3eBool s3eVideoIsCodecSupported(s3eVideoCodec codec);







# 1 "c:/marmalade/6.2/s3e/h/legacy/s3eVideo_legacy.h" 1
# 681 "c:/marmalade/6.2/s3e/h/s3eVideo.h" 2
# 44 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eGL.h" 1
# 38 "c:/marmalade/6.2/s3e/h/s3eGL.h"
typedef enum s3eGLError
{
    S3E_GL_ERR_NONE = 0,
    S3E_GL_ERR_PARAM = 1,
    S3E_GL_ERR_TOO_MANY = 2,
    S3E_GL_ERR_ALREADY_REG = 3,
    S3E_GL_ERR_NOT_FOUND = 4,
    S3E_GL_ERR_UNAVAIL = 5,
} s3eGLError;






typedef enum s3eGLProperty
{





    S3E_GL_VERSION = 0,





    S3E_EGL_VERSION = 1,






    S3E_GL_MUST_SUSPEND = 2,

} s3eGLProperty;
# 87 "c:/marmalade/6.2/s3e/h/s3eGL.h"
extern "C" int32 s3eGLGetInt(s3eGLProperty property);
# 97 "c:/marmalade/6.2/s3e/h/s3eGL.h"
typedef enum s3eGLCallback
{
# 110 "c:/marmalade/6.2/s3e/h/s3eGL.h"
    S3E_GL_SUSPEND = 0,
# 122 "c:/marmalade/6.2/s3e/h/s3eGL.h"
    S3E_GL_RESUME = 1,

    S3E_GL_CALLBACK_MAX
} s3eGLCallback;
# 148 "c:/marmalade/6.2/s3e/h/s3eGL.h"
extern "C" s3eResult s3eGLRegister(s3eGLCallback cbid, s3eCallback fn, void* userdata);
# 168 "c:/marmalade/6.2/s3e/h/s3eGL.h"
extern "C" s3eResult s3eGLUnRegister(s3eGLCallback cbid, s3eCallback fn);
# 182 "c:/marmalade/6.2/s3e/h/s3eGL.h"
extern "C" s3eGLError s3eGLGetError();
# 196 "c:/marmalade/6.2/s3e/h/s3eGL.h"
extern "C" const char* s3eGLGetErrorString();
# 208 "c:/marmalade/6.2/s3e/h/s3eGL.h"
extern "C" void* s3eGLGetNativeWindow();
# 45 "c:/marmalade/6.2/s3e/h/s3e.h" 2
# 14 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/game.cpp" 2
# 1 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h" 1
       
# 20 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
# 1 "c:/marmalade/6.2/s3e/h/s3eSurface.h" 1
# 21 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h" 2
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h" 1
       
# 21 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h" 1
       
# 16 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
# 1 "c:/marmalade/6.2/s3e/h/s3eTypes.h" 1
# 17 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h" 1
# 16 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h"
# 1 "c:/marmalade/6.2/s3e/h/s3eDebug.h" 1
# 17 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eDevice.h" 1
# 18 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwCore.h" 1
# 19 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h" 2


# 1 "c:/marmalade/6.2/s3e/h/std/stdarg.h" 1
# 15 "c:/marmalade/6.2/s3e/h/std/stdarg.h"
# 1 "c:/marmalade/6.2/s3e/h/std/sys/types.h" 1
# 16 "c:/marmalade/6.2/s3e/h/std/sys/types.h"
# 1 "c:/marmalade/6.2/s3e/h/std/stddef.h" 1
# 15 "c:/marmalade/6.2/s3e/h/std/stddef.h"
typedef signed int ptrdiff_t;


    typedef unsigned int wint_t;
    typedef unsigned long int wctype_t;







typedef unsigned int size_t;
# 17 "c:/marmalade/6.2/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/stdint.h" 1
# 19 "c:/marmalade/6.2/s3e/h/std/stdint.h"
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef long int_least32_t;
typedef int64_t int_least64_t;

typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned long uint_least32_t;
typedef uint64_t uint_least64_t;

typedef signed char int_fast8_t;
typedef short int_fast16_t;
typedef long int_fast32_t;
typedef int64_t int_fast64_t;

typedef unsigned char uint_fast8_t;
typedef unsigned short uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef uint64_t uint_fast64_t;

typedef int64_t intmax_t;
typedef uint64_t uintmax_t;
# 18 "c:/marmalade/6.2/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/sys/select.h" 1
# 24 "c:/marmalade/6.2/s3e/h/std/sys/select.h"
struct timeval;

typedef struct fd_set
{
    char fds_bits[256/8];
} fd_set;
# 39 "c:/marmalade/6.2/s3e/h/std/sys/select.h"
extern "C" {

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

}
# 19 "c:/marmalade/6.2/s3e/h/std/sys/types.h" 2



typedef long off_t;

typedef int64_t off64_t;


namespace std
{
typedef ::size_t size_t;
}


typedef uint u_int;
typedef uint8_t u_int8_t;
typedef uint16_t u_int16_t;
typedef uint32_t u_int32_t;
typedef uint64_t u_int64_t;

typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;

typedef int ssize_t;
typedef int pid_t;
typedef short uid_t;
typedef short gid_t;
typedef int idtype_t;
typedef int id_t;
typedef uint32 mode_t;
typedef short dev_t;
typedef short ino_t;
typedef int key_t;
typedef void* caddr_t;
# 16 "c:/marmalade/6.2/s3e/h/std/stdarg.h" 2
# 54 "c:/marmalade/6.2/s3e/h/std/stdarg.h"
typedef __builtin_va_list va_list;
# 22 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/stdio.h" 1
# 19 "c:/marmalade/6.2/s3e/h/std/stdio.h"
struct __XXFILE;
typedef struct __XXFILE FILE;

typedef uint32 fpos_t;
# 38 "c:/marmalade/6.2/s3e/h/std/stdio.h"
extern "C" {
# 54 "c:/marmalade/6.2/s3e/h/std/stdio.h"
extern FILE *__aeabi_stdin;
extern FILE *__aeabi_stdout;
extern FILE *__aeabi_stderr;
# 66 "c:/marmalade/6.2/s3e/h/std/stdio.h"
FILE *fopen(const char *path, const char *mode);
int fclose(FILE *fp);
int fcloseall();
int fflush(FILE *stream);

FILE *fopen(const char *path, const char *mode);
FILE *fdopen(int fildes, const char *mode);
FILE *freopen(const char *path, const char *mode, FILE *stream);

size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

int fputc(int c, FILE *stream);
int fputs(const char *s, FILE *stream);
int putc(int c, FILE *stream);
int putchar(int c);
int puts(const char *s);

int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
char *gets(char *s);
int ungetc(int c, FILE *stream);

int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, fpos_t *pos);

void flockfile(FILE *filehandle);
int ftrylockfile(FILE *filehandle);
void funlockfile(FILE *filehandle);

int getc_unlocked(FILE *stream);
int getchar_unlocked(void);
int putc_unlocked(int c, FILE *stream);
int putchar_unlocked(int c);

FILE *popen(const char *command, const char *type);
int pclose(FILE *stream);

char *tempnam(const char *dir, const char *pfx);




int printf(const char *format, ...) __attribute__((format(printf, 1, 2)));



int fprintf(FILE *stream, const char* format, ...) __attribute__((format(printf, 2, 3)));



int sprintf(char *str, const char* format, ...) __attribute__((format(printf, 2, 3)));



int snprintf(char *str, size_t size, const char *format, ...) __attribute__((format(printf, 3, 4)));




int scanf(const char *format, ...);



int fscanf(FILE *stream, const char *format, ...);



int sscanf(const char *str, const char *format, ...);

void clearerr(FILE *stream);
int feof(FILE *stream);
int ferror(FILE *stream);
int fileno(FILE *stream);

int remove(const char *pathname);
int rename(const char *oldpath, const char *newpath);

void perror(const char *s);



FILE *tmpfile(void);
char *tmpnam(char *s);

void setbuf(FILE *stream, char *buf);
void setbuffer(FILE *stream, char *buf, size_t size);
void setlinebuf(FILE *stream);
int setvbuf(FILE *stream, char *buf, int mode , size_t size);



int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);
int vprintf(const char *format, va_list ap);
int asprintf(char **strp, const char *fmt, ...);
int vasprintf(char **strp, const char *fmt, va_list ap);

int vscanf(const char *format, va_list ap);
int vsscanf(const char *str, const char *format, va_list ap);
int vfscanf(FILE *stream, const char *format, va_list ap);

}
# 23 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/stdlib.h" 1
# 16 "c:/marmalade/6.2/s3e/h/std/stdlib.h"
# 1 "c:/marmalade/6.2/s3e/h/std/malloc.h" 1
# 16 "c:/marmalade/6.2/s3e/h/std/malloc.h"
# 1 "c:/marmalade/6.2/s3e/h/std/alloca.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/alloca.h"
extern "C" {


    extern void *alloca(size_t __size);
# 35 "c:/marmalade/6.2/s3e/h/std/alloca.h"
}
# 17 "c:/marmalade/6.2/s3e/h/std/malloc.h" 2

extern "C" {

void *calloc(size_t nmemb, size_t size);
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);

}
# 17 "c:/marmalade/6.2/s3e/h/std/stdlib.h" 2
# 28 "c:/marmalade/6.2/s3e/h/std/stdlib.h"
extern "C" {

double atof(const char* string);
int atoi(const char *nptr);
long atol(const char *nptr);
int64_t atoll(const char *nptr);
int64_t atoq(const char *nptr);
int abs(int j);
long int labs(long int j);
int64_t llabs(int64_t j);
void qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *));
void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
void abort(void);
int putenv(char *string);
char *getenv(const char *name);
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);
void exit(int status) __attribute__ ((noreturn));
void _exit(int status) __attribute__ ((noreturn));
void _Exit(int status) __attribute__ ((noreturn));
unsigned long int strtoul(const char *nptr, char **endptr, int base);
uint64_t strtoull(const char *nptr, char **endptr, int base);
long int strtol(const char *nptr, char **endptr, int base);
int64_t strtoll(const char *nptr, char **endptr, int base);
double strtod(const char *nptr, char **endptr);
float strtof(const char *nptr, char **endptr);
long double strtold(const char *nptr, char **endptr);
int atexit(void (*function)(void));
int system(const char *command);
int posix_memalign(void **memptr, size_t alignment, size_t size);
char *mktemp(char *templ);
int mkstemp(char *templ);



int rand(void);
void srand(unsigned int seed);

long int random(void);
void srandom(unsigned int seed);

size_t __ctype_get_mb_cur_max();


int mblen(const char *s, size_t n);
int mbtowc(wchar_t *pwc, const char *s, size_t n);
int wctomb(char *s, wchar_t wc);
size_t mbstowcs(wchar_t *dest, const char *src, size_t n);
size_t wcstombs(char *dest, const wchar_t *src, size_t n);

typedef struct
{
    int quot;
    int rem;
} div_t;

typedef struct
{
    int quot;
    int rem;
} ldiv_t;

typedef struct
{
    int64_t quot;
    int64_t rem;
} lldiv_t;

div_t div(int numerator, int denominator);
ldiv_t ldiv(long numerator, long denominator);
lldiv_t lldiv(int64_t numerator, int64_t denominator);
# 112 "c:/marmalade/6.2/s3e/h/std/stdlib.h"
}
# 24 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h" 2
# 51 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h"
typedef void(*IwAssertTextCallback)(char* pBuffer);

extern "C" {

typedef s3eErrorShowResult(*IwAssertCallback)(const char* channel, const char* pExpr, const char* pFilename, int32 line, const char* message);
typedef s3eErrorShowResult(*IwErrorCallback)(const char* message);
# 65 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h"
 s3eBool IwDebugTraceIsChannelOn(const char* channel, s3eBool default_on);
# 91 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h"
 s3eBool IwDebugTraceChannelSwitch(const char* channel, s3eBool new_state);
# 101 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h"
 void IwDebugTraceLinePrintf(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;






 void IwDebugTraceLineVPrintf(const char* fmt, va_list args);


 void IwDebugAssertSetUID(uint32 n);







 s3eBool IwDebugAssertIsChannelOn(const char* channel);







 void IwDebugClearConfigCache();
# 141 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h"
 void IwDebugAssertSetMessage(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;
# 168 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h"
 s3eErrorShowResult IwDebugAssertShow(const char* pExpr, const char* pFilename, int32 line, uint8 ignorable);






 IwAssertTextCallback IwAssertRegisterTextCallback(IwAssertTextCallback fn);






 IwAssertCallback IwAssertRegisterCallback(IwAssertCallback fn);
# 192 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h"
 s3eErrorShowResult IwDebugErrorShow(const char* Args, ...)

__attribute__((format(printf, 1, 2)))

;






 IwErrorCallback IwDebugErrorRegisterCallback(IwErrorCallback fn);

}
# 582 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h"
template <class _To, class _From>
_To IwSafeCast(_From from)
{
# 595 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h"
    return static_cast <_To> (from);
}
# 18 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eFile.h" 1
# 19 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h" 2

class CIwManaged;
class CIwTextParserITX;
# 39 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
typedef void(*IwSerialiseUserCallback)();





struct IwSerialiseContext
{
    bool read;
    uint32 base;
    s3eFile* handle;
    char filename[160];
    uint32 bytesRead;
    uint32 callbackPeriod;
    uint8 buffer[8];
    int32 headBit;
    uint32 version;
    uint16 versionUser;
    uint16 pad;
    IwSerialiseUserCallback callback;
};
extern IwSerialiseContext g_IwSerialiseContext;
extern int g_IwSerialiseContextValid;
# 76 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
enum IwSerialiseMode
{
    IW_SERIALISE_WRITE = 0,
    IW_SERIALISE_READ = 1
};
# 89 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline bool IwSerialiseIsReading() {return g_IwSerialiseContext.read == true;}
# 98 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline bool IwSerialiseIsWriting() {return g_IwSerialiseContext.read == false;}
# 109 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseSetUserVersion(uint16 v) {g_IwSerialiseContext.versionUser = v;}
# 118 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline uint16 IwSerialiseGetUserVersion() {return g_IwSerialiseContext.versionUser;}







static inline bool IwIsSerialiseOpen(){return (g_IwSerialiseContextValid > 0);}
# 135 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseOpen(const char* filename, IwSerialiseMode mode, bool ram=false);
# 145 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseOpen(const char* filename, bool read, bool ram=false)
{
    IwSerialiseOpen(filename, read ? IW_SERIALISE_READ : IW_SERIALISE_WRITE, ram);
}






bool IwSerialiseExists(const char* filename, bool ram=false);







bool IwSerialiseEOF();
# 173 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseOpenFromMemory(void* pBuffer, int size, IwSerialiseMode mode);







static inline void IwSerialiseOpenFromMemory(void* pBuffer, int size, bool read)
{
    IwSerialiseOpenFromMemory(pBuffer, size, read ? IW_SERIALISE_READ : IW_SERIALISE_WRITE);
}






void IwSerialiseClose();






void IwSerialiseResetCallbackCount();






void IwSerialiseSetCallbackPeriod(uint32 p);






void IwSerialiseSetCallback(IwSerialiseUserCallback cb);
# 221 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline void _SerialiseScalarType(IwSerialiseContext& c, void* var, int itemSize, int numItems)
{

    if (c.read == true)
        s3eFileRead(var, itemSize, numItems, c.handle);
    else
        s3eFileWrite(var, itemSize, numItems, c.handle);
# 249 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
}
# 260 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseDouble(double& var, int n=1, int numBits=sizeof(double)*8, int stride=sizeof(double));
# 271 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseFloat(float& var, int n=1, int numBits=sizeof(float)*8, int stride=sizeof(float));
# 282 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt64(uint64& var, int n=1, int numBits=sizeof(uint64)*8, int stride=sizeof(uint64));
# 293 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt64(int64& var, int n=1, int numBits=sizeof(int64)*8-1, int stride=sizeof(int64));
# 305 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt32(uint32& var, int n=1, int numBits=sizeof(uint32)*8, int stride=sizeof(uint32));
# 316 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt32(int32& var, int n=1, int numBits=sizeof(int32)*8-1, int stride=sizeof(int32));
# 327 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt16(uint16& var, int n=1, int numBits=sizeof(uint16)*8, int stride=sizeof(uint16));
# 338 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt16(int16& var, int n=1, int numBits=sizeof(int16)*8-1, int stride=sizeof(int16));
# 349 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt8(uint8& var, int n=1, int numBits=sizeof(uint8)*8, int stride=sizeof(uint8));
# 360 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt8(int8& var, int n=1, int numBits=sizeof(int8)*8-1, int stride=sizeof(int8));
# 371 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseChar(char& var, int n=1, int numBits=sizeof(int8)*8-1, int stride=sizeof(char));
# 382 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseBool(bool& var, int n=1, int numBits=1, int stride=sizeof(bool));
# 392 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseEnum(void* pVar);





template <class T, bool SGN>
void _IwSerialiseBitDepthRequired(T& var, int n, int stride, void(*CB1)(T&, int, int, int))
{

    uint32 mb;
    if (g_IwSerialiseContext.read == false)
    {
        T* pVal = &var;
        uint32 t = n;
        mb = 1;
        while(t-- && (mb < sizeof(T)*8))
        {
            T v = *pVal;
            pVal += stride / sizeof(T);
            if (SGN)
            {
                if (v & (1ul << ((sizeof(T)*8) - 1)))
                    v = ~v;
            }
            while((v >= ((T)1 << mb)) && (mb < sizeof(T)*8))
                mb++;
        }
    }

    IwSerialiseUInt32(mb, 1, 6);
    (CB1)(var, n, mb, stride);



}
# 440 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseCharBitDepthRequired(char& var, int n=1, int stride=sizeof(char))
{
    _IwSerialiseBitDepthRequired<char, true>(var, n, stride, IwSerialiseChar);
}
# 456 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseInt8BitDepthRequired(int8& var, int n=1, int stride=sizeof(int8))
{
    _IwSerialiseBitDepthRequired<int8, true>(var, n, stride, IwSerialiseInt8);
}
# 472 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseUInt8BitDepthRequired(uint8& var, int n=1, int stride=sizeof(uint8))
{
    _IwSerialiseBitDepthRequired<uint8, false>(var, n, stride, IwSerialiseUInt8);
}
# 488 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseInt16BitDepthRequired(int16& var, int n=1, int stride=sizeof(int16))
{
    _IwSerialiseBitDepthRequired<int16, true>(var, n, stride, IwSerialiseInt16);
}
# 504 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseUInt16BitDepthRequired(uint16& var, int n=1, int stride=sizeof(uint16))
{
    _IwSerialiseBitDepthRequired<uint16, false>(var, n, stride, IwSerialiseUInt16);
}
# 520 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseInt32BitDepthRequired(int32& var, int n=1, int stride=sizeof(int32))
{
    _IwSerialiseBitDepthRequired<int32, true>(var, n, stride, IwSerialiseInt32);
}
# 536 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseUInt32BitDepthRequired(uint32& var, int n=1, int stride=sizeof(uint32))
{
    _IwSerialiseBitDepthRequired<uint32, false>(var, n, stride, IwSerialiseUInt32);
}
# 591 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseMappedData(const uint16* pMap, void* _pData, int numStructs, int stride);
# 602 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseString(char* text, int maxLen=0);
# 615 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseManagedHash(void* pptr);






void IwSerialiseManagedObject(CIwManaged*& pObj);
# 633 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
void IwSerialiseFile(CIwTextParserITX* pParser, char const* filename, void* pptr, IwSerialiseMode mode);
# 642 "c:/marmalade/6.2/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseFile(CIwTextParserITX* pParser, char const* filename, void* pptr, bool read)
{
    IwSerialiseFile(pParser, filename, pptr, read ? IW_SERIALISE_READ : IW_SERIALISE_WRITE);
}
# 22 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwMath.h" 1
# 16 "c:/marmalade/6.2/modules/iwutil/h/IwMath.h"
# 1 "c:/marmalade/6.2/s3e/h/std/float.h" 1
# 31 "c:/marmalade/6.2/s3e/h/std/float.h"
  extern "C" {
# 109 "c:/marmalade/6.2/s3e/h/std/float.h"
extern "C" {

unsigned _controlfp(unsigned, unsigned);
unsigned _clearfp(void);
unsigned _statusfp(void);

}
# 150 "c:/marmalade/6.2/s3e/h/std/float.h"
    }
# 17 "c:/marmalade/6.2/modules/iwutil/h/IwMath.h" 2
# 87 "c:/marmalade/6.2/modules/iwutil/h/IwMath.h"
static inline int32 IwRoundFraction(double aValue)
{
    double lPositive = (aValue < 0.0f) ? -aValue : aValue;
    double lDecimal = lPositive - (double) ((int32) lPositive);
    int32 lRetVal;

    if (aValue < 0.0f)
    {
        if (lDecimal >= 0.5f)
        {
            lRetVal = ((int32) aValue) - 1;
        }
        else
        {
            lRetVal = (int32) aValue;
        }
    }
    else
    {
        if (lDecimal >= 0.5f)
        {
            lRetVal = ((int32) aValue) + 1;
        }
        else
        {
            lRetVal = (int32) aValue;
        }
    }
    return lRetVal;
}







static inline uint8 iwlzc(uint32 a)
{
    uint8 r=0;
    if ((a >> 16) == 0) {r+=16; a<<=16;}
    if ((a >> 24) == 0) {r+=8; a<<=8;}
    if ((a >> 28) == 0) {r+=4; a<<=4;}
    if ((a >> 30) == 0) {r+=2; a<<=2;}
    if ((a >> 31) == 0) {r+=1;}
    return r;
}






static inline uint8 iwlog2(uint32 a)
{
    return (uint8)(31-iwlzc(a));
}
# 158 "c:/marmalade/6.2/modules/iwutil/h/IwMath.h"
static inline uint32 clz(uint32 a)
{

    int32 r=0;
    if ((a >> 16) == 0) {r+=16; a<<=16;}
    if ((a >> 24) == 0) {r+=8; a<<=8;}
    if ((a >> 28) == 0) {r+=4; a<<=4;}
    if ((a >> 30) == 0) {r+=2; a<<=2;}
    if ((a >> 31) == 0) {r+=1;}
    return r;
}
# 23 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h" 2

# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h" 1
       
# 18 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwDebug.h" 1
# 19 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwDivide.h" 1
# 78 "c:/marmalade/6.2/modules/iwutil/h/IwDivide.h"
static inline uint64 i3d_uldiv_split(uint32 toplo, uint32 tophi, uint32 bottom)
{
    unsigned accumhi = 0;
    unsigned accumlo = 0;


    int i=31;




    if(tophi & 0xffff0000)
        i -= 16;
    if(tophi==0)
        i=0;

    for (; i>=0; i--)
    {
        accumhi = accumhi << 1;

        if ((tophi>>(i)) >= (bottom))
        {
            accumhi++;


            tophi = tophi - (bottom<<i);
        }
    }
# 125 "c:/marmalade/6.2/modules/iwutil/h/IwDivide.h"
    if (tophi==0) goto fast_bit32;

    accumlo = accumlo << 1; if ((toplo>>31)+(tophi<<(32-31)) >= (bottom) || (tophi>>31)!=0) { accumlo++; if ((bottom<<31) > toplo) tophi--; toplo = toplo - (bottom<<31); tophi = tophi - (bottom>>(32-31)); if (!tophi) goto fast_bit31; }
    accumlo = accumlo << 1; if ((toplo>>30)+(tophi<<(32-30)) >= (bottom) || (tophi>>30)!=0) { accumlo++; if ((bottom<<30) > toplo) tophi--; toplo = toplo - (bottom<<30); tophi = tophi - (bottom>>(32-30)); if (!tophi) goto fast_bit30; }
    accumlo = accumlo << 1; if ((toplo>>29)+(tophi<<(32-29)) >= (bottom) || (tophi>>29)!=0) { accumlo++; if ((bottom<<29) > toplo) tophi--; toplo = toplo - (bottom<<29); tophi = tophi - (bottom>>(32-29)); if (!tophi) goto fast_bit29; }
    accumlo = accumlo << 1; if ((toplo>>28)+(tophi<<(32-28)) >= (bottom) || (tophi>>28)!=0) { accumlo++; if ((bottom<<28) > toplo) tophi--; toplo = toplo - (bottom<<28); tophi = tophi - (bottom>>(32-28)); if (!tophi) goto fast_bit28; }
    accumlo = accumlo << 1; if ((toplo>>27)+(tophi<<(32-27)) >= (bottom) || (tophi>>27)!=0) { accumlo++; if ((bottom<<27) > toplo) tophi--; toplo = toplo - (bottom<<27); tophi = tophi - (bottom>>(32-27)); if (!tophi) goto fast_bit27; }
    accumlo = accumlo << 1; if ((toplo>>26)+(tophi<<(32-26)) >= (bottom) || (tophi>>26)!=0) { accumlo++; if ((bottom<<26) > toplo) tophi--; toplo = toplo - (bottom<<26); tophi = tophi - (bottom>>(32-26)); if (!tophi) goto fast_bit26; }
    accumlo = accumlo << 1; if ((toplo>>25)+(tophi<<(32-25)) >= (bottom) || (tophi>>25)!=0) { accumlo++; if ((bottom<<25) > toplo) tophi--; toplo = toplo - (bottom<<25); tophi = tophi - (bottom>>(32-25)); if (!tophi) goto fast_bit25; }
    accumlo = accumlo << 1; if ((toplo>>24)+(tophi<<(32-24)) >= (bottom) || (tophi>>24)!=0) { accumlo++; if ((bottom<<24) > toplo) tophi--; toplo = toplo - (bottom<<24); tophi = tophi - (bottom>>(32-24)); if (!tophi) goto fast_bit24; }
    accumlo = accumlo << 1; if ((toplo>>23)+(tophi<<(32-23)) >= (bottom) || (tophi>>23)!=0) { accumlo++; if ((bottom<<23) > toplo) tophi--; toplo = toplo - (bottom<<23); tophi = tophi - (bottom>>(32-23)); if (!tophi) goto fast_bit23; }
    accumlo = accumlo << 1; if ((toplo>>22)+(tophi<<(32-22)) >= (bottom) || (tophi>>22)!=0) { accumlo++; if ((bottom<<22) > toplo) tophi--; toplo = toplo - (bottom<<22); tophi = tophi - (bottom>>(32-22)); if (!tophi) goto fast_bit22; }
    accumlo = accumlo << 1; if ((toplo>>21)+(tophi<<(32-21)) >= (bottom) || (tophi>>21)!=0) { accumlo++; if ((bottom<<21) > toplo) tophi--; toplo = toplo - (bottom<<21); tophi = tophi - (bottom>>(32-21)); if (!tophi) goto fast_bit21; }
    accumlo = accumlo << 1; if ((toplo>>20)+(tophi<<(32-20)) >= (bottom) || (tophi>>20)!=0) { accumlo++; if ((bottom<<20) > toplo) tophi--; toplo = toplo - (bottom<<20); tophi = tophi - (bottom>>(32-20)); if (!tophi) goto fast_bit20; }
    accumlo = accumlo << 1; if ((toplo>>19)+(tophi<<(32-19)) >= (bottom) || (tophi>>19)!=0) { accumlo++; if ((bottom<<19) > toplo) tophi--; toplo = toplo - (bottom<<19); tophi = tophi - (bottom>>(32-19)); if (!tophi) goto fast_bit19; }
    accumlo = accumlo << 1; if ((toplo>>18)+(tophi<<(32-18)) >= (bottom) || (tophi>>18)!=0) { accumlo++; if ((bottom<<18) > toplo) tophi--; toplo = toplo - (bottom<<18); tophi = tophi - (bottom>>(32-18)); if (!tophi) goto fast_bit18; }
    accumlo = accumlo << 1; if ((toplo>>17)+(tophi<<(32-17)) >= (bottom) || (tophi>>17)!=0) { accumlo++; if ((bottom<<17) > toplo) tophi--; toplo = toplo - (bottom<<17); tophi = tophi - (bottom>>(32-17)); if (!tophi) goto fast_bit17; }
    accumlo = accumlo << 1; if ((toplo>>16)+(tophi<<(32-16)) >= (bottom) || (tophi>>16)!=0) { accumlo++; if ((bottom<<16) > toplo) tophi--; toplo = toplo - (bottom<<16); tophi = tophi - (bottom>>(32-16)); if (!tophi) goto fast_bit16; }
    accumlo = accumlo << 1; if ((toplo>>15)+(tophi<<(32-15)) >= (bottom) || (tophi>>15)!=0) { accumlo++; if ((bottom<<15) > toplo) tophi--; toplo = toplo - (bottom<<15); tophi = tophi - (bottom>>(32-15)); if (!tophi) goto fast_bit15; }
    accumlo = accumlo << 1; if ((toplo>>14)+(tophi<<(32-14)) >= (bottom) || (tophi>>14)!=0) { accumlo++; if ((bottom<<14) > toplo) tophi--; toplo = toplo - (bottom<<14); tophi = tophi - (bottom>>(32-14)); if (!tophi) goto fast_bit14; }
    accumlo = accumlo << 1; if ((toplo>>13)+(tophi<<(32-13)) >= (bottom) || (tophi>>13)!=0) { accumlo++; if ((bottom<<13) > toplo) tophi--; toplo = toplo - (bottom<<13); tophi = tophi - (bottom>>(32-13)); if (!tophi) goto fast_bit13; }
    accumlo = accumlo << 1; if ((toplo>>12)+(tophi<<(32-12)) >= (bottom) || (tophi>>12)!=0) { accumlo++; if ((bottom<<12) > toplo) tophi--; toplo = toplo - (bottom<<12); tophi = tophi - (bottom>>(32-12)); if (!tophi) goto fast_bit12; }
    accumlo = accumlo << 1; if ((toplo>>11)+(tophi<<(32-11)) >= (bottom) || (tophi>>11)!=0) { accumlo++; if ((bottom<<11) > toplo) tophi--; toplo = toplo - (bottom<<11); tophi = tophi - (bottom>>(32-11)); if (!tophi) goto fast_bit11; }
    accumlo = accumlo << 1; if ((toplo>>10)+(tophi<<(32-10)) >= (bottom) || (tophi>>10)!=0) { accumlo++; if ((bottom<<10) > toplo) tophi--; toplo = toplo - (bottom<<10); tophi = tophi - (bottom>>(32-10)); if (!tophi) goto fast_bit10; }
    accumlo = accumlo << 1; if ((toplo>>9)+(tophi<<(32-9)) >= (bottom) || (tophi>>9)!=0) { accumlo++; if ((bottom<<9) > toplo) tophi--; toplo = toplo - (bottom<<9); tophi = tophi - (bottom>>(32-9)); if (!tophi) goto fast_bit9; }
    accumlo = accumlo << 1; if ((toplo>>8)+(tophi<<(32-8)) >= (bottom) || (tophi>>8)!=0) { accumlo++; if ((bottom<<8) > toplo) tophi--; toplo = toplo - (bottom<<8); tophi = tophi - (bottom>>(32-8)); if (!tophi) goto fast_bit8; }
    accumlo = accumlo << 1; if ((toplo>>7)+(tophi<<(32-7)) >= (bottom) || (tophi>>7)!=0) { accumlo++; if ((bottom<<7) > toplo) tophi--; toplo = toplo - (bottom<<7); tophi = tophi - (bottom>>(32-7)); if (!tophi) goto fast_bit7; }
    accumlo = accumlo << 1; if ((toplo>>6)+(tophi<<(32-6)) >= (bottom) || (tophi>>6)!=0) { accumlo++; if ((bottom<<6) > toplo) tophi--; toplo = toplo - (bottom<<6); tophi = tophi - (bottom>>(32-6)); if (!tophi) goto fast_bit6; }
    accumlo = accumlo << 1; if ((toplo>>5)+(tophi<<(32-5)) >= (bottom) || (tophi>>5)!=0) { accumlo++; if ((bottom<<5) > toplo) tophi--; toplo = toplo - (bottom<<5); tophi = tophi - (bottom>>(32-5)); if (!tophi) goto fast_bit5; }
    accumlo = accumlo << 1; if ((toplo>>4)+(tophi<<(32-4)) >= (bottom) || (tophi>>4)!=0) { accumlo++; if ((bottom<<4) > toplo) tophi--; toplo = toplo - (bottom<<4); tophi = tophi - (bottom>>(32-4)); if (!tophi) goto fast_bit4; }
    accumlo = accumlo << 1; if ((toplo>>3)+(tophi<<(32-3)) >= (bottom) || (tophi>>3)!=0) { accumlo++; if ((bottom<<3) > toplo) tophi--; toplo = toplo - (bottom<<3); tophi = tophi - (bottom>>(32-3)); if (!tophi) goto fast_bit3; }
    accumlo = accumlo << 1; if ((toplo>>2)+(tophi<<(32-2)) >= (bottom) || (tophi>>2)!=0) { accumlo++; if ((bottom<<2) > toplo) tophi--; toplo = toplo - (bottom<<2); tophi = tophi - (bottom>>(32-2)); if (!tophi) goto fast_bit2; }
    accumlo = accumlo << 1; if ((toplo>>1)+(tophi<<(32-1)) >= (bottom) || (tophi>>1)!=0) { accumlo++; if ((bottom<<1) > toplo) tophi--; toplo = toplo - (bottom<<1); tophi = tophi - (bottom>>(32-1)); if (!tophi) goto fast_bit1; }
    accumlo = accumlo << 1; if ((toplo>>0) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<0); }

    return (uint64)accumlo | ((uint64)accumhi)<<32;

fast_bit32:
    accumlo = accumlo << 1; if ((toplo>>31) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<31); } fast_bit31:
    accumlo = accumlo << 1; if ((toplo>>30) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<30); } fast_bit30:
    accumlo = accumlo << 1; if ((toplo>>29) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<29); } fast_bit29:
    accumlo = accumlo << 1; if ((toplo>>28) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<28); } fast_bit28:
    accumlo = accumlo << 1; if ((toplo>>27) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<27); } fast_bit27:
    accumlo = accumlo << 1; if ((toplo>>26) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<26); } fast_bit26:
    accumlo = accumlo << 1; if ((toplo>>25) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<25); } fast_bit25:
    accumlo = accumlo << 1; if ((toplo>>24) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<24); } fast_bit24:
    accumlo = accumlo << 1; if ((toplo>>23) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<23); } fast_bit23:
    accumlo = accumlo << 1; if ((toplo>>22) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<22); } fast_bit22:
    accumlo = accumlo << 1; if ((toplo>>21) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<21); } fast_bit21:
    accumlo = accumlo << 1; if ((toplo>>20) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<20); } fast_bit20:
    accumlo = accumlo << 1; if ((toplo>>19) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<19); } fast_bit19:
    accumlo = accumlo << 1; if ((toplo>>18) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<18); } fast_bit18:
    accumlo = accumlo << 1; if ((toplo>>17) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<17); } fast_bit17:
    accumlo = accumlo << 1; if ((toplo>>16) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<16); } fast_bit16:
    accumlo = accumlo << 1; if ((toplo>>15) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<15); } fast_bit15:
    accumlo = accumlo << 1; if ((toplo>>14) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<14); } fast_bit14:
    accumlo = accumlo << 1; if ((toplo>>13) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<13); } fast_bit13:
    accumlo = accumlo << 1; if ((toplo>>12) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<12); } fast_bit12:
    accumlo = accumlo << 1; if ((toplo>>11) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<11); } fast_bit11:
    accumlo = accumlo << 1; if ((toplo>>10) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<10); } fast_bit10:
    accumlo = accumlo << 1; if ((toplo>>9) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<9); } fast_bit9:
    accumlo = accumlo << 1; if ((toplo>>8) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<8); } fast_bit8:
    accumlo = accumlo << 1; if ((toplo>>7) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<7); } fast_bit7:
    accumlo = accumlo << 1; if ((toplo>>6) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<6); } fast_bit6:
    accumlo = accumlo << 1; if ((toplo>>5) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<5); } fast_bit5:
    accumlo = accumlo << 1; if ((toplo>>4) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<4); } fast_bit4:
    accumlo = accumlo << 1; if ((toplo>>3) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<3); } fast_bit3:
    accumlo = accumlo << 1; if ((toplo>>2) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<2); } fast_bit2:
    accumlo = accumlo << 1; if ((toplo>>1) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<1); } fast_bit1:
    accumlo = accumlo << 1; if ((toplo>>0) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<0); }
# 224 "c:/marmalade/6.2/modules/iwutil/h/IwDivide.h"
    return (uint64)accumlo | ((uint64)accumhi)<<32;
}

static inline uint64 i3d_ldiv_split(uint32 toplo, int32 tophi, int32 bottom)
{
    if(tophi<0) {
        if(bottom>0)
            return -(int64)i3d_uldiv_split(toplo, -tophi, bottom);
        else
            return i3d_uldiv_split(toplo, -tophi, -bottom);
    }
    else {
        if(bottom<0)
            return i3d_uldiv_split(toplo, tophi, -bottom);
        else
            return i3d_uldiv_split(toplo, tophi, bottom);
    }
}

static inline uint64 i3d_uldiv(uint64 udividend, uint32 udivisor)
{
    return i3d_uldiv_split((uint32)(udividend&0xffffffff), (uint32)(udividend>>32), udivisor);
}





static inline int64 i3d_ldiv(int64 dividend,
                    int32 divisor)
{
    if(dividend<0) {
        if(divisor>0)
            return -(int64)i3d_uldiv(-dividend,divisor);
        else
            return i3d_uldiv(-dividend,-divisor);
    }
    else {
        if(divisor<0)
            return -(int64)i3d_uldiv(dividend,-divisor);
        else
            return i3d_uldiv(dividend,divisor);
    }
}
# 293 "c:/marmalade/6.2/modules/iwutil/h/IwDivide.h"
static inline int32 i3d_lmod(int64 dividend, int32 divisor)
{
        return (int32)(dividend - (((int64)(((int64)(dividend))/((int32)(divisor)))) * divisor));
}
# 20 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h" 2

# 1 "c:/marmalade/6.2/modules/iwutil/h/IwRuntime.h" 1
       
# 30 "c:/marmalade/6.2/modules/iwutil/h/IwRuntime.h"
# 1 "c:/marmalade/6.2/s3e/h/s3eTimer.h" 1
# 31 "c:/marmalade/6.2/modules/iwutil/h/IwRuntime.h" 2

extern "C" {
# 41 "c:/marmalade/6.2/modules/iwutil/h/IwRuntime.h"
typedef struct _IwCallStack
{
    const char** m_Stack;
    const char** m_StackPtr;

} IwCallStack;

void IwCallStackLeave(void* pObj);
void IwCallStackSetStackSizeLimit(uint32 limit);
void IwCallStackSetStackAddress(uint32 addr);
void IwCallStackPrintStack(char* pBuffer);
IwCallStack* IwCallStackGet();







void IwCallStackInit();
void IwCallStackTerm();
# 75 "c:/marmalade/6.2/modules/iwutil/h/IwRuntime.h"
    void IwCallStackSetCallStackTracing(bool bOnOrOff);



void IwProfileStartProfile(const char* name);
void IwProfileStopProfile();
void IwProfileIncrementFrameCounter();
void IwProfileReset();

}
# 214 "c:/marmalade/6.2/modules/iwutil/h/IwRuntime.h"
class CIwProfileNode
{
public:
    CIwProfileNode(const char* name, CIwProfileNode* parent);
    ~CIwProfileNode();

    CIwProfileNode* GetSubNode(const char* name);

    CIwProfileNode* GetParent() {return m_Parent;}
    CIwProfileNode* GetSibling() {return m_Sibling;}
    CIwProfileNode* GetChild() {return m_Child;}

    void Reset();
    void Call();
    bool Return();
    void NewFrame();

    const char* GetName() {return m_Name;}
    long GetTotalCalls() {return m_TotalCalls;}
    float GetTotalTime() {return m_TotalTime;}
    float GetLastTime() {return m_LastTime;}

    long GetLastFrameCalls(){ return m_LastFrameCalls; }
    float GetLastFrameTime() { return m_LastFrameTime; }
    float GetFrameTimeAvg() { return m_FrameWeightedAvg; }

    bool IsRemainingTimeNode() { return m_IsOtherTimeNode; }

protected:
    const char* m_Name;
    long m_TotalCalls;
    float m_TotalTime;
    float m_LastTime;
    float m_WeightedAvg;

    long m_FrameCalls;
    float m_FrameTime;
    float m_FrameWeightedAvg;

    long m_LastFrameCalls;
    float m_LastFrameTime;

    int32 m_StartTime;
    long m_RecursionCounter;

    bool m_IsOtherTimeNode;

    CIwProfileNode* m_Parent;
    CIwProfileNode* m_Child;
    CIwProfileNode* m_Sibling;
};




class CIwProfileIterator
{
public:

    void First();
    void Next();
    bool IsDone();

    void EnterChild(long index);
    void EnterParent();


    const char* GetCurrentName() {return m_CurrentChild->GetName();}
    long GetCurrentTotalCalls() {return m_CurrentChild->GetTotalCalls();}
    float GetCurrentTotalTime() {return m_CurrentChild->GetTotalTime();}
    float GetCurrentLastTime() {return m_CurrentChild->GetLastTime();}
    float GetCurrentLastFrameTime() {return m_CurrentChild->GetLastFrameTime();}
    long GetCurrentLastFrameCalls() {return m_CurrentChild->GetLastFrameCalls();}
    float GetCurrentFrameTimeAvg() {return m_CurrentChild->GetFrameTimeAvg();}
    bool IsCurrentRemainingTimeNode() {return m_CurrentChild->IsRemainingTimeNode();}




    const char* GetCurrentParentName() {return m_CurrentParent->GetName();}
    long GetCurrentParentTotalCalls() {return m_CurrentParent->GetTotalCalls();}
    float GetCurrentParentTotalTime() {return m_CurrentParent->GetTotalTime();}


protected:
    CIwProfileNode* m_CurrentParent;
    CIwProfileNode* m_CurrentChild;

    CIwProfileIterator(CIwProfileNode* start);
    friend class CIwProfileManager;
};




class CIwProfileManager
{
public:
    CIwProfileManager(uint32 maxNodes=200);
    ~CIwProfileManager();

    inline void SetActive(bool active) {m_Active = active;}
    void StartProfile(const char* name);
    void StopProfile();

    void Reset();
    void IncrementFrameCounter();
    inline long GetFrameCountSinceReset() {return m_FrameCounter;}
    float GetTimeSinceReset();

    inline CIwProfileIterator* GetIterator() {return new CIwProfileIterator(&m_Root);}
    inline void ReleaseIterator(CIwProfileIterator* iterator ) {delete iterator;}


    static CIwProfileManager& Get();

    static CIwProfileManager* g_Singleton;

    CIwProfileNode* AllocNode(const char* name, CIwProfileNode* parent);

private:
    bool m_Active;
    CIwProfileNode m_Root;
    CIwProfileNode* m_CurrentNode;
    long m_FrameCounter;
    int64 m_ResetTime;
    uint32* m_Memory;
    uint32* m_MemoryCursor;
    int32 m_FreeNodes;
};




class CIwProfileSample
{
public:
    CIwProfileSample(const char* name) {IwProfileStartProfile(name);}
    ~CIwProfileSample() {IwProfileStopProfile();}
};
# 22 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h" 2
# 49 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
void IwGeomInit();






void IwGeomTerminate();
# 161 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
typedef int32 iwfixed;




typedef uint32 iwufixed;




typedef int16 iwsfixed;




typedef uint16 iwusfixed;




typedef int32 iwqfixed;
# 191 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
typedef int32 iwangle;




typedef int32 iwqangle;
# 227 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwsfixed IW_SFIXED_FROM_FIXED(iwfixed a)
{
    ((void)0);
    return (iwsfixed)a;
}
# 271 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_FROM_FLOAT(float a)
{




    return (iwfixed)(a * (float)(1 << 12));
}
# 290 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwsfixed IW_SFIXED_FROM_FLOAT_CAST(float a)
{




    return (iwsfixed)a;
}

static inline iwfixed IW_FIXED_FROM_FLOAT_CAST(float a)
{




    return (iwfixed)a;
}
# 365 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwangle IW_ANGLE_DIFFERENCE(iwangle x, iwangle y)
{
    iwangle z = ((iwangle)((x - y) & (((iwangle)(1 << 12)) - 1)));

    if (z <= ((iwangle)(1 << (12 - 1))))
        return z;
    else
        return z - ((iwangle)(1 << 12));
}
# 387 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL(iwfixed a, iwfixed b)
{




    return (a * b) >> 12;
}
# 405 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL_SAFE(iwfixed a, iwfixed b)
{
    int64 res = (((int64)a * b) >> 12);
    ((void)0);
    return (iwfixed)res;
}
# 422 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwsfixed IW_SFIXED_MUL(iwfixed a, iwfixed b)
{
    return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(a, b));
}
# 436 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwqfixed IW_QFIXED_MUL(iwqfixed a, iwqfixed b)
{




    return (a * b) >> 30;
}
# 454 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwqfixed IW_QFIXED_MUL_SAFE(iwqfixed a, iwqfixed b)
{
    int64 res = (((int64)a * b) >> 30);
    ((void)0);
    return (iwfixed)res;
}
# 470 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL3(iwfixed a, iwfixed b, iwfixed c, iwfixed d, iwfixed e, iwfixed f)
{
# 485 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
    return ((a * d) + (b * e) + (c * f)) >> 12;

}
# 499 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL3_SAFE(iwfixed a, iwfixed b, iwfixed c, iwfixed d, iwfixed e, iwfixed f)
{
    int64 res = ((((int64)a * d) + ((int64)b * e) + ((int64)c * f)) >> 12);
    ((void)0);
    return (iwfixed)res;
}
# 516 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL2(iwfixed a, iwfixed b, iwfixed d, iwfixed e)
{
# 527 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
    return ((a * d) + (b * e)) >> 12;

}
# 542 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL2_SAFE(iwfixed a, iwfixed b, iwfixed d, iwfixed e)
{
    int64 res = ((((int64)a * d) + ((int64)b * e)) >> 12);
    ((void)0);
    return (iwfixed)res;
}
# 562 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_DIV(iwfixed a, iwfixed b)
{
    if (!(b & ((1 << 12) - 1)))
    {
        return (iwfixed)(((int32)(a))/((int32)(b >> 12)));
    }
    else
    {




        return (iwfixed)(((int32)(a << 12))/((int32)(b)));
    }
}
# 593 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_DIV_SAFE(iwfixed a, iwfixed b)
{
    if ((a>>19) == (a>>31) || !(b & ((1 << 12) - 1))) return IW_FIXED_DIV(a, b);
    int64 result = ((int64)a << 12);
    result = ((int64)(((int64)(result))/((int32)(b))));
    ((void)0);
    return (iwfixed)result;
}


extern "C" {
# 613 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
iwfixed IwGeomSin(iwangle x);






iwfixed IwGeomCos(iwangle x);






iwqfixed IwGeomQSin(iwqangle x);






iwqfixed IwGeomQCos(iwqangle x);






iwfixed IwGeomTan(iwangle x);






iwfixed IwGeomACos(iwfixed v);






iwqfixed IwGeomQACos(iwqfixed v);






iwfixed IwGeomASin(iwfixed v);






iwqfixed IwGeomQASin(iwqfixed v);






iwqfixed IwGeomQATan2(iwqfixed u, iwqfixed v);
# 687 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
iwangle IwGeomAtan2(int y, int x);
# 703 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
extern double cos(double);
extern double acos(double);
extern double sin(double);
extern double asin(double);
extern double sqrt(double);
extern double tan(double);
extern double atan2(double,double);
# 720 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
}
# 731 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MULCHECK(const int32 a, const int32 b)
{






    return a*b;
}
# 752 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MUL64_SHIFT(int32 a, int32 b, int32 shift)
{







    return (int32)(((int64)a * b) >> shift);
}
# 774 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MUL64_3_SHIFT(int32 a, int32 b, int32 c, int32 d, int32 e, int32 f, int32 shift)
{







    return (int32) ((((int64)a * d) + ((int64)b * e) + ((int64)c * f)) >> shift);
}
# 795 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MUL_3_SHIFT(int32 a, int32 b, int32 c, int32 d, int32 e, int32 f, int32 shift)
{
# 810 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
    return ((a * d) + (b * e) + (c * f)) >> shift;

}
# 825 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MUL_2_SHIFT(int32 a, int32 b, int32 d, int32 e, int32 shift)
{
# 836 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h"
    return ((a * d) + (b * e)) >> shift;

}




# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomLegacy.h" 1
       
# 844 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h" 2
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSqrt.h" 1
       
# 38 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSqrt.h"
iwfixed IW_GEOM_SQRT(iwfixed a);






iwqfixed IW_GEOM_QSQRT(iwqfixed a);
# 54 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSqrt.h"
int32 IW_GEOM_SQRT2(int32 a);
# 79 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSqrt.h"
extern iwfixed g_SqrtTable [];


void IwSqrtInit();
# 93 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSqrt.h"
static inline iwfixed IW_GEOM_SQRT_FAST(iwfixed x){
    uint32 m = clz(x);

    if (m <= (32 - 12 + 1)) {
        m = ((32 - 12 + 1) - m + 1) & (~1);




        int32 totalshift = (0>>1) + 12 - (m>>1);

        if (((x<<1)>>m)&1){
            if (totalshift > 0)
                return g_SqrtTable[(x>>m)+1]>>totalshift;
            else
                return g_SqrtTable[(x>>m)+1]<<(-totalshift);
        } else {
            if (totalshift > 0)
                return g_SqrtTable[x>>m]>>totalshift;
            else
                return g_SqrtTable[x>>m]<<(-totalshift);
        }
    } else {
        m = (m - (32 - 12 + 1) - 1) & (~1);




        return g_SqrtTable[x<<m]>>((0 + m)>>1)>>12;
    }
}
# 133 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSqrt.h"
static inline iwfixed IW_GEOM_SQRT2_FAST(iwfixed x){
    uint32 m = clz(x);

    if (m <= (32 - 12 + 1)) {
        m = ((32 - 12 + 1) - m + 1) & (~1);




        int32 totalshift = (0>>1) + (12>>1) - (m>>1);

        if (((x<<1)>>m)&1){
            if (totalshift > 0)
                return g_SqrtTable[(x>>m)+1]>>totalshift;
            else
                return g_SqrtTable[(x>>m)+1]<<(-totalshift);
        } else {
            if (totalshift > 0)
                return g_SqrtTable[x>>m]>>totalshift;
            else
                return g_SqrtTable[x>>m]<<(-totalshift);
        }
    } else {
        m = (m - (32 - 12 + 1) - 1) & (~1);




        return g_SqrtTable[x<<m]>>((0 + m + 12)>>1);
    }
}
# 190 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSqrt.h"
void IwInverseSqrtInit();






extern iwfixed g_InverseSqrtTable[];
# 209 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSqrt.h"
static inline iwfixed IW_GEOM_INVERSE_SQRT(iwfixed x)
{
    uint32 m = clz(x);







    if (m <= (32 - 12 + 1)){
        m = ((32 - 12 + 1) - m + 1)>>1;





        return (g_InverseSqrtTable[x>>(m<<1)]<<(6>>1))>>m;
    } else {
        m = (m - (32 - 12 + 1))>>1;





        return g_InverseSqrtTable[x<<(m<<1)]<<((6>>1) - m);
    }
}
# 250 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSqrt.h"
static inline iwfixed IW_GEOM_INVERSE_SQRT2(iwfixed x){
    uint32 m = clz(x);







    if (m <= (32 - 12 + 1)){
        m = ((32 - 12 + 1) - m + 1)>>1;





        return (g_InverseSqrtTable[x>>(m<<1)]<<((6 + 12)>>1))>>m;
    } else {
        m = (m - (32 - 12 + 1))>>1;





        return g_InverseSqrtTable[x<<(m<<1)]<<(((6 + 12)>>1) - m);
    }
}
# 845 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomCore.h" 2
# 25 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h" 2
# 41 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h"
typedef uint16 IwPixel;
# 80 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h"
class CIwColour
{
public:




    inline void Serialise()
    {
        IwSerialiseUInt8(r);
        IwSerialiseUInt8(g);
        IwSerialiseUInt8(b);
        IwSerialiseUInt8(a);
    }
# 102 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h"
    void Set(uint32 rgba)
    {






        *(uint32*)this = rgba;

    }
# 124 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h"
    inline void Set(uint8 _r, uint8 _g, uint8 _b, uint8 _a)
    {
        r = _r;
        g = _g;
        b = _b;
        a = _a;
    }
# 141 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h"
    inline void Set(uint8 _r, uint8 _g, uint8 _b)
    {
        r = _r;
        g = _g;
        b = _b;
        a = 0xff;
    }
# 156 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h"
    inline void Set(CIwColour other) { *(uint32*)this = *(uint32*)&other; }







    inline uint32 Get() const
    {






        return *(uint32*)this;

    }
# 183 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h"
    inline void SetOpaque(uint32 rgb)
    {
        Set(rgb | (uint32)0xff << 24);
    }
# 195 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h"
    inline void SetGrey(uint8 g) { SetOpaque(g | g << 8 | g << 16); }
# 205 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h"
    CIwColour operator= (uint32 rgba)
    {
        Set(rgba);
        return *this;
    }






    bool operator == (uint32 rgba) const
    {
        return Get() == rgba;
    }






    bool operator == (const CIwColour& other) const
    {
        return *(uint32*)this == *(uint32*)&other;
    }






    bool operator != (uint32 rgba) const
    {
        return Get() != rgba;
    }






    bool operator != (const CIwColour& other) const
    {
        return *(uint32*)this != *(uint32*)&other;
    }







    CIwColour operator *= (const CIwColour& other)
    {
        (*this).r = ((*this).r * (other).r) >> (7); (*this).g = ((*this).g * (other).g) >> (7); (*this).b = ((*this).b * (other).b) >> (7); (*this).a = ((*this).a * (other).a) >> (7);
        return *this;
    }






    CIwColour operator * (iwfixed other)
    {
        CIwColour ret;
        ret.r = (uint8)((((0xff) < (IW_FIXED_MUL(other, r))) ? (0xff) : (IW_FIXED_MUL(other, r))));
        ret.g = (uint8)((((0xff) < (IW_FIXED_MUL(other, g))) ? (0xff) : (IW_FIXED_MUL(other, g))));
        ret.b = (uint8)((((0xff) < (IW_FIXED_MUL(other, b))) ? (0xff) : (IW_FIXED_MUL(other, b))));
        ret.a = (uint8)((((0xff) < (IW_FIXED_MUL(other, a))) ? (0xff) : (IW_FIXED_MUL(other, a))));
        return ret;
    }






    CIwColour operator + (CIwColour other)
    {
        CIwColour ret;
        ret.r = (((0xff) < (r + other.r)) ? (0xff) : (r + other.r));
        ret.g = (((0xff) < (g + other.g)) ? (0xff) : (g + other.g));
        ret.b = (((0xff) < (b + other.b)) ? (0xff) : (b + other.b));
        ret.a = (((0xff) < (a + other.a)) ? (0xff) : (a + other.a));
        return ret;
    }






    CIwColour operator += (const CIwColour& other)
    {
        r = (((0xff) < (r + other.r)) ? (0xff) : (r + other.r));
        g = (((0xff) < (g + other.g)) ? (0xff) : (g + other.g));
        b = (((0xff) < (b + other.b)) ? (0xff) : (b + other.b));
        a = (((0xff) < (a + other.a)) ? (0xff) : (a + other.a));
        return *this;
    }






    CIwColour operator -= (const CIwColour& other)
    {
        r = (((0x00) > (r - other.r)) ? (0x00) : (r - other.r));
        g = (((0x00) > (g - other.g)) ? (0x00) : (g - other.g));
        b = (((0x00) > (b - other.b)) ? (0x00) : (b - other.b));
        a = (((0x00) > (a - other.a)) ? (0x00) : (a - other.a));
        return *this;
    }







            uint8 r;
            uint8 g;
            uint8 b;
            uint8 a;





}

__attribute__ ((aligned (4)))

;






typedef enum IwGxColourFixed
{
    IW_GX_COLOUR_BLACK,
    IW_GX_COLOUR_WHITE,
    IW_GX_COLOUR_GREY,
    IW_GX_COLOUR_RED,
    IW_GX_COLOUR_GREEN,
    IW_GX_COLOUR_BLUE,
    IW_GX_COLOUR_MAGENTA,
    IW_GX_COLOUR_CYAN,
    IW_GX_COLOUR_YELLOW,
    IW_GX_COLOUR_MAX,
} IwGxColourFixed;





extern CIwColour g_IwGxColours[];
# 374 "c:/marmalade/6.2/modules/iwgx/h/IwColour.h"
static inline const CIwColour& IwGxGetColFixed(IwGxColourFixed colID)
{
    ((void)0);
    return g_IwGxColours[colID];
}
# 22 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h" 2
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeom.h" 1
       
# 22 "c:/marmalade/6.2/modules/iwgeom/h/IwGeom.h"
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec.h" 1
       
# 33 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec.h"
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec2.h" 1
       
# 33 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec2.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwSVec2
{
public:
    int16 x;
    int16 y;


    static CIwSVec2 g_Zero;


    static CIwSVec2 g_AxisX;


    static CIwSVec2 g_AxisY;




    CIwSVec2() {};






    CIwSVec2(int16 _x, int16 _y) : x(_x), y(_y) {};

    explicit CIwSVec2(const CIwVec2& v);
    explicit CIwSVec2(const CIwFVec2& v);
    CIwSVec2 operator = (const CIwVec2& v);
    CIwSVec2 operator = (const CIwFVec2& v);
# 90 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec2.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {





        return (x*x + y*y) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 140 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec2.h"
    void NormaliseSlow();
# 150 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec2.h"
    void Normalise();





    CIwSVec2 GetNormalised() const;







    void NormaliseSafe();





    CIwSVec2 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 190 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec2.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwSVec2 const & v) const {return *this * v;}
# 219 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec2.h"
    CIwSVec2& operator = (CIwSVec2 const & v);






    CIwSVec2 operator + (CIwSVec2 const & v) const;






    CIwSVec2 & operator += (CIwSVec2 const & v);






    CIwSVec2 operator - (CIwSVec2 const & v) const;






    CIwSVec2 & operator -= (CIwSVec2 const & v);






    int32 operator * (CIwSVec2 const & v) const;







    bool operator == (CIwSVec2 const & v) const;






    bool operator != (CIwSVec2 const & v) const;
# 282 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec2.h"
    CIwSVec2 operator - () const;






    CIwSVec2 operator * (iwfixed l) const;







    CIwSVec2 & operator *= (iwfixed l);






    CIwSVec2 operator / (const iwfixed s) const;






    CIwSVec2 operator >> (const int s) const;







    CIwSVec2 operator >>= (const int s);






    CIwSVec2 operator << (const int s) const;







    CIwSVec2 operator <<= (const int s);






    int16 & operator [] (const int n);






    int16 operator [] (const int n) const;




};




inline CIwSVec2& CIwSVec2::operator = (CIwSVec2 const & v)
{
    x = v.x;
    y = v.y;
    return *this;
}




inline CIwSVec2 CIwSVec2::operator + (CIwSVec2 const & v) const
{





    return CIwSVec2(
        (int16)(x + v.x)
        , (int16)(y + v.y)
        );
}




inline CIwSVec2 & CIwSVec2::operator += (CIwSVec2 const & v)
{





    x += v.x;
    y += v.y;
    return *this;
}




inline CIwSVec2 CIwSVec2::operator - (CIwSVec2 const & v) const
{





    return CIwSVec2(
        (int16)(x - v.x)
        , (int16)(y - v.y)
        );
}




inline CIwSVec2 & CIwSVec2::operator -= (CIwSVec2 const & v)
{





    x -= v.x;
    y -= v.y;
    return *this;
}




inline int32 CIwSVec2::operator * (CIwSVec2 const & v) const
{
# 442 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec2.h"
    return (
        (int32)x * v.x +
        (int32)y * v.y +
        0) >> 12;
}




inline bool CIwSVec2::operator == (CIwSVec2 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        true);
}




inline bool CIwSVec2::operator != (CIwSVec2 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        false);
}




inline CIwSVec2 CIwSVec2::operator * (iwfixed l) const
{
# 483 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec2.h"
    return CIwSVec2(
          (int16)IW_FIXED_MUL(x,l)
        , (int16)IW_FIXED_MUL(y,l)
        );
}




inline CIwSVec2 & CIwSVec2::operator *= (iwfixed l)
{
# 502 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec2.h"
    x = (int16)IW_FIXED_MUL(x,l);
    y = (int16)IW_FIXED_MUL(y,l);
    return *this;
}




inline CIwSVec2 CIwSVec2::operator - () const
{
    return CIwSVec2(
        (int16)-x
        , (int16)-y
        );
}




inline CIwSVec2 CIwSVec2::operator / (const iwfixed s) const
{
    return CIwSVec2(
        (int16)(IW_FIXED_DIV(x, s))
        , (int16)(IW_FIXED_DIV(y, s))
        );
}




inline CIwSVec2 CIwSVec2::operator >> (const int s) const
{
    return CIwSVec2(
        (int16)(x >> s)
        , (int16)(y >> s)
        );
}

inline CIwSVec2 CIwSVec2::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    return *this;
}




inline CIwSVec2 CIwSVec2::operator << (const int s) const
{





    return CIwSVec2(
        (int16)(x << s)
        , (int16)(y << s)
        );
}

inline CIwSVec2 CIwSVec2::operator <<= (const int s)
{





    x <<= s;
    y <<= s;
    return *this;
}


inline int16 & CIwSVec2::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline int16 CIwSVec2::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwSVec2 operator * (iwfixed l, const CIwSVec2& v)
{
    return v * l;
}





# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec2.h" 1
       
# 33 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec2.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwVec2
{
public:
    int32 x;
    int32 y;


    static CIwVec2 g_Zero;


    static CIwVec2 g_AxisX;


    static CIwVec2 g_AxisY;




    CIwVec2() {};






    CIwVec2(int32 _x, int32 _y) : x(_x), y(_y) {};

    explicit CIwVec2(const CIwSVec2& v);
    explicit CIwVec2(const CIwFVec2& v);
    CIwVec2 operator = (const CIwSVec2& v);
    CIwVec2 operator = (const CIwFVec2& v);
# 90 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec2.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {





        return (x*x + y*y) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 140 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec2.h"
    void NormaliseSlow();
# 150 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec2.h"
    void Normalise();





    CIwVec2 GetNormalised() const;







    void NormaliseSafe();





    CIwVec2 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 190 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec2.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwVec2 const & v) const {return *this * v;}
# 219 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec2.h"
    CIwVec2& operator = (CIwVec2 const & v);






    CIwVec2 operator + (CIwVec2 const & v) const;






    CIwVec2 & operator += (CIwVec2 const & v);






    CIwVec2 operator - (CIwVec2 const & v) const;






    CIwVec2 & operator -= (CIwVec2 const & v);






    int32 operator * (CIwVec2 const & v) const;







    bool operator == (CIwVec2 const & v) const;






    bool operator != (CIwVec2 const & v) const;
# 282 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec2.h"
    CIwVec2 operator - () const;






    CIwVec2 operator * (iwfixed l) const;







    CIwVec2 & operator *= (iwfixed l);






    CIwVec2 operator / (const iwfixed s) const;






    CIwVec2 operator >> (const int s) const;







    CIwVec2 operator >>= (const int s);






    CIwVec2 operator << (const int s) const;







    CIwVec2 operator <<= (const int s);






    int32 & operator [] (const int n);






    int32 operator [] (const int n) const;




};




inline CIwVec2& CIwVec2::operator = (CIwVec2 const & v)
{
    x = v.x;
    y = v.y;
    return *this;
}




inline CIwVec2 CIwVec2::operator + (CIwVec2 const & v) const
{





    return CIwVec2(
        (int32)(x + v.x)
        , (int32)(y + v.y)
        );
}




inline CIwVec2 & CIwVec2::operator += (CIwVec2 const & v)
{





    x += v.x;
    y += v.y;
    return *this;
}




inline CIwVec2 CIwVec2::operator - (CIwVec2 const & v) const
{





    return CIwVec2(
        (int32)(x - v.x)
        , (int32)(y - v.y)
        );
}




inline CIwVec2 & CIwVec2::operator -= (CIwVec2 const & v)
{





    x -= v.x;
    y -= v.y;
    return *this;
}




inline int32 CIwVec2::operator * (CIwVec2 const & v) const
{
# 442 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec2.h"
    return (
        (int32)x * v.x +
        (int32)y * v.y +
        0) >> 12;
}




inline bool CIwVec2::operator == (CIwVec2 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        true);
}




inline bool CIwVec2::operator != (CIwVec2 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        false);
}




inline CIwVec2 CIwVec2::operator * (iwfixed l) const
{
# 483 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec2.h"
    return CIwVec2(
          (int32)IW_FIXED_MUL(x,l)
        , (int32)IW_FIXED_MUL(y,l)
        );
}




inline CIwVec2 & CIwVec2::operator *= (iwfixed l)
{
# 502 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec2.h"
    x = (int32)IW_FIXED_MUL(x,l);
    y = (int32)IW_FIXED_MUL(y,l);
    return *this;
}




inline CIwVec2 CIwVec2::operator - () const
{
    return CIwVec2(
        (int32)-x
        , (int32)-y
        );
}




inline CIwVec2 CIwVec2::operator / (const iwfixed s) const
{
    return CIwVec2(
        (int32)(IW_FIXED_DIV(x, s))
        , (int32)(IW_FIXED_DIV(y, s))
        );
}




inline CIwVec2 CIwVec2::operator >> (const int s) const
{
    return CIwVec2(
        (int32)(x >> s)
        , (int32)(y >> s)
        );
}

inline CIwVec2 CIwVec2::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    return *this;
}




inline CIwVec2 CIwVec2::operator << (const int s) const
{





    return CIwVec2(
        (int32)(x << s)
        , (int32)(y << s)
        );
}

inline CIwVec2 CIwVec2::operator <<= (const int s)
{





    x <<= s;
    y <<= s;
    return *this;
}


inline int32 & CIwVec2::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline int32 CIwVec2::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwVec2 operator * (iwfixed l, const CIwVec2& v)
{
    return v * l;
}







inline CIwVec2::CIwVec2(const CIwSVec2& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
}

inline CIwVec2 CIwVec2::operator = (const CIwSVec2& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    return *this;
}


inline bool operator == (const CIwVec2& v1, const CIwSVec2& v2)
{
    return (
        v1.x == (int32)v2.x &&
        v1.y == (int32)v2.y &&
        true);
}


inline CIwVec2 operator + (const CIwVec2& v1, const CIwSVec2& v2)
{
    return CIwVec2(
        v1.x + (int32)v2.x
        , v1.y + (int32)v2.y
        );
}


inline CIwVec2 operator - (const CIwVec2& v1, const CIwSVec2& v2)
{
    return CIwVec2(
        v1.x - (int32)v2.x
        , v1.y - (int32)v2.y
        );
}




inline CIwVec2 operator += (CIwVec2& v1, const CIwSVec2& v2)
{
    v1.x += (int32)v2.x;
    v1.y += (int32)v2.y;
    return v1;
}




inline CIwVec2 operator -= (CIwVec2& v1, const CIwSVec2& v2)
{
    v1.x -= (int32)v2.x;
    v1.y -= (int32)v2.y;
    return v1;
}




inline int32 operator * (const CIwVec2& v1, const CIwSVec2& v2)
{
    return v1 * CIwVec2(v2);
}






# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec2.h" 1
       
# 33 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec2.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwFVec2
{
public:
    float x;
    float y;


    static CIwFVec2 g_Zero;


    static CIwFVec2 g_AxisX;


    static CIwFVec2 g_AxisY;




    CIwFVec2() {};






    CIwFVec2(float _x, float _y) : x(_x), y(_y) {};

    explicit CIwFVec2(const CIwSVec2& v);
    explicit CIwFVec2(const CIwVec2& v);
    CIwFVec2 operator = (const CIwSVec2& v);
    CIwFVec2 operator = (const CIwVec2& v);
# 90 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec2.h"
    float GetLength() const;





    inline float GetLengthSquared() const
    {

        return (x*x + y*y);
    }
# 117 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec2.h"
    void Normalise();






    CIwFVec2 GetNormalised() const;







    bool IsNormalised() const;
# 145 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec2.h"
    void Serialise(void);





    bool IsZero() const;






    inline float Dot(CIwFVec2 const & v) const {return *this * v;}
# 174 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec2.h"
    CIwFVec2& operator = (CIwFVec2 const & v);






    CIwFVec2 operator + (CIwFVec2 const & v) const;






    CIwFVec2 & operator += (CIwFVec2 const & v);






    CIwFVec2 operator - (CIwFVec2 const & v) const;






    CIwFVec2 & operator -= (CIwFVec2 const & v);






    float operator * (CIwFVec2 const & v) const;







    bool operator == (CIwFVec2 const & v) const;






    bool operator != (CIwFVec2 const & v) const;
# 237 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec2.h"
    CIwFVec2 operator - () const;






    CIwFVec2 operator * (float l) const;







    CIwFVec2 & operator *= (float l);






    CIwFVec2 operator / (const float s) const;







    float & operator [] (const int n);






    float operator [] (const int n) const;




};




inline CIwFVec2& CIwFVec2::operator = (CIwFVec2 const & v)
{
    x = v.x;
    y = v.y;
    return *this;
}




inline CIwFVec2 CIwFVec2::operator + (CIwFVec2 const & v) const
{
    return CIwFVec2(
        (float)(x + v.x)
        , (float)(y + v.y)
        );
}




inline CIwFVec2 & CIwFVec2::operator += (CIwFVec2 const & v)
{
    x += v.x;
    y += v.y;
    return *this;
}




inline CIwFVec2 CIwFVec2::operator - (CIwFVec2 const & v) const
{
    return CIwFVec2(
        (float)(x - v.x)
        , (float)(y - v.y)
        );
}




inline CIwFVec2 & CIwFVec2::operator -= (CIwFVec2 const & v)
{
    x -= v.x;
    y -= v.y;
    return *this;
}




inline float CIwFVec2::operator * (CIwFVec2 const & v) const
{

    return (
        (float)x * v.x +
        (float)y * v.y +
        0);
}




inline bool CIwFVec2::operator == (CIwFVec2 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        true);
}




inline bool CIwFVec2::operator != (CIwFVec2 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        false);
}




inline CIwFVec2 CIwFVec2::operator * (float l) const
{
    return CIwFVec2(
        (float)(x * l)
        , (float)(y * l)
        );
}




inline CIwFVec2 & CIwFVec2::operator *= (float l)
{
    x = (float)(x * l);
    y = (float)(y * l);
    return *this;
}




inline CIwFVec2 CIwFVec2::operator - () const
{
    return CIwFVec2(
        (float)-x
        , (float)-y
        );
}




inline CIwFVec2 CIwFVec2::operator / (const float s) const
{
    return CIwFVec2(
        (float)(x / s)
        , (float)(y / s)
        );
}


inline float & CIwFVec2::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline float CIwFVec2::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwFVec2 operator * (float l, const CIwFVec2& v)
{
    return v * l;
}







inline CIwFVec2::CIwFVec2(const CIwSVec2& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
}

inline CIwFVec2 CIwFVec2::operator = (const CIwSVec2& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    return *this;
}


inline bool operator == (const CIwFVec2& v1, const CIwSVec2& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        true);
}


inline CIwFVec2 operator + (const CIwFVec2& v1, const CIwSVec2& v2)
{
    return CIwFVec2(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        );
}


inline CIwFVec2 operator - (const CIwFVec2& v1, const CIwSVec2& v2)
{
    return CIwFVec2(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        );
}




inline CIwFVec2 operator += (CIwFVec2& v1, const CIwSVec2& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    return v1;
}




inline CIwFVec2 operator -= (CIwFVec2& v1, const CIwSVec2& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec2& v1, const CIwSVec2& v2)
{
    return v1 * CIwFVec2(v2);
}
# 514 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec2.h"
inline CIwFVec2::CIwFVec2(const CIwVec2& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
}




inline CIwFVec2 CIwFVec2::operator = (const CIwVec2& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    return *this;
}




inline bool operator == (const CIwFVec2& v1, const CIwVec2& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        true);
}




inline CIwFVec2 operator + (const CIwFVec2& v1, const CIwVec2& v2)
{
    return CIwFVec2(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        );
}




inline CIwFVec2 operator - (const CIwFVec2& v1, const CIwVec2& v2)
{
    return CIwFVec2(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        );
}




inline CIwFVec2 operator += (CIwFVec2& v1, const CIwVec2& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    return v1;
}




inline CIwFVec2 operator -= (CIwFVec2& v1, const CIwVec2& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec2& v1, const CIwVec2& v2)
{
    return v1 * CIwFVec2(v2);
}
# 678 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec2.h" 2

inline CIwVec2::CIwVec2(const CIwFVec2& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
}




inline CIwVec2 CIwVec2::operator = (const CIwFVec2& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    return *this;
}




inline bool operator == (const CIwVec2& v1, const CIwFVec2& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        true);
}




inline CIwFVec2 operator + (const CIwVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        );
}




inline CIwFVec2 operator - (const CIwVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        );
}




inline CIwVec2 operator += (CIwVec2& v1, const CIwFVec2& v2)
{
    v1.x += IW_FIXED_FROM_FLOAT(v2.x);
    v1.y += IW_FIXED_FROM_FLOAT(v2.y);
    return v1;
}




inline CIwVec2 operator -= (CIwVec2& v1, const CIwFVec2& v2)
{
    v1.x -= IW_FIXED_FROM_FLOAT(v2.x);
    v1.y -= IW_FIXED_FROM_FLOAT(v2.y);
    return v1;
}




inline float operator * (const CIwVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(v1) * v2;
}
# 603 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec2.h" 2

inline CIwSVec2::CIwSVec2(const CIwVec2& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
}

inline CIwSVec2 CIwSVec2::operator = (const CIwVec2& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    return *this;
}


inline bool operator == (const CIwSVec2& v1, const CIwVec2& v2)
{
    return (
        (int32)v1.x == v2.x &&
        (int32)v1.y == v2.y &&
        true);
}


inline CIwVec2 operator + (const CIwSVec2& v1, const CIwVec2& v2)
{
    return CIwVec2(
        (int32)v1.x + v2.x
        , (int32)v1.y + v2.y
        );
}


inline CIwVec2 operator - (const CIwSVec2& v1, const CIwVec2& v2)
{
    return CIwVec2(
        (int32)v1.x - v2.x
        , (int32)v1.y - v2.y
        );
}




inline CIwSVec2 operator += (CIwSVec2& v1, const CIwVec2& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(v2.x);
    v1.y += IW_SFIXED_FROM_FIXED(v2.y);
    return v1;
}




inline CIwSVec2 operator -= (CIwSVec2& v1, const CIwVec2& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(v2.x);
    v1.y -= IW_SFIXED_FROM_FIXED(v2.y);
    return v1;
}




inline int32 operator * (const CIwSVec2& v1, const CIwVec2& v2)
{
    return CIwVec2(v1) * v2;
}
# 679 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec2.h"
inline CIwSVec2::CIwSVec2(const CIwFVec2& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
}




inline CIwSVec2 CIwSVec2::operator = (const CIwFVec2& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    return *this;
}




inline bool operator == (const CIwSVec2& v1, const CIwFVec2& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        true);
}




inline CIwFVec2 operator + (const CIwSVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        );
}




inline CIwFVec2 operator - (const CIwSVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        );
}




inline CIwSVec2 operator += (CIwSVec2& v1, const CIwFVec2& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    return v1;
}




inline CIwSVec2 operator -= (CIwSVec2& v1, const CIwFVec2& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    return v1;
}




inline float operator * (const CIwSVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(v1) * v2;
}
# 34 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec.h" 2
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h" 1
       
# 33 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwSVec3
{
public:
    int16 x;
    int16 y;
    int16 z;


    static CIwSVec3 g_Zero;


    static CIwSVec3 g_AxisX;


    static CIwSVec3 g_AxisY;


    static CIwSVec3 g_AxisZ;




    CIwSVec3() {};
# 79 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h"
    CIwSVec3(int16 _x, int16 _y, int16 _z) : x(_x), y(_y), z(_z) {};

    explicit CIwSVec3(const CIwVec3& v);
    explicit CIwSVec3(const CIwFVec3& v);
    CIwSVec3 operator = (const CIwVec3& v);
    CIwSVec3 operator = (const CIwFVec3& v);
# 97 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {





        return (x*x + y*y+ z*z) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 147 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h"
    void NormaliseSlow();
# 157 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h"
    void Normalise();





    CIwSVec3 GetNormalised() const;







    void NormaliseSafe();





    CIwSVec3 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 197 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwSVec3 const & v) const {return *this * v;}






    inline CIwSVec3 Cross(CIwSVec3 const & v) const {return *this ^ v;}
# 234 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h"
    CIwSVec3& operator = (CIwSVec3 const & v);






    CIwSVec3 operator + (CIwSVec3 const & v) const;






    CIwSVec3 & operator += (CIwSVec3 const & v);






    CIwSVec3 operator - (CIwSVec3 const & v) const;






    CIwSVec3 & operator -= (CIwSVec3 const & v);






    int32 operator * (CIwSVec3 const & v) const;






    CIwSVec3 operator ^ (CIwSVec3 const & v) const;






    bool operator == (CIwSVec3 const & v) const;






    bool operator != (CIwSVec3 const & v) const;
# 303 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h"
    CIwSVec3 operator - () const;






    CIwSVec3 operator * (iwfixed l) const;







    CIwSVec3 & operator *= (iwfixed l);






    CIwSVec3 operator / (const iwfixed s) const;






    CIwSVec3 operator >> (const int s) const;







    CIwSVec3 operator >>= (const int s);






    CIwSVec3 operator << (const int s) const;







    CIwSVec3 operator <<= (const int s);






    int16 & operator [] (const int n);






    int16 operator [] (const int n) const;




};




inline CIwSVec3& CIwSVec3::operator = (CIwSVec3 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    return *this;
}




inline CIwSVec3 CIwSVec3::operator + (CIwSVec3 const & v) const
{






    return CIwSVec3(
        (int16)(x + v.x)
        , (int16)(y + v.y)
        , (int16)(z + v.z)
        );
}




inline CIwSVec3 & CIwSVec3::operator += (CIwSVec3 const & v)
{






    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}




inline CIwSVec3 CIwSVec3::operator - (CIwSVec3 const & v) const
{






    return CIwSVec3(
        (int16)(x - v.x)
        , (int16)(y - v.y)
        , (int16)(z - v.z)
        );
}




inline CIwSVec3 & CIwSVec3::operator -= (CIwSVec3 const & v)
{






    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}




inline int32 CIwSVec3::operator * (CIwSVec3 const & v) const
{
# 473 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h"
    return (
        (int32)x * v.x +
        (int32)y * v.y +
        (int32)z * v.z +
        0) >> 12;
}



inline CIwSVec3 CIwSVec3::operator ^ (CIwSVec3 const & v) const
{

    int chk = ((((x) > 0) ? (x) : -(x)) | (((y) > 0) ? (y) : -(y)) | (((z) > 0) ? (z) : -(z)) | (((v.x) > 0) ? (v.x) : -(v.x)) | (((v.y) > 0) ? (v.y) : -(v.y)) | (((v.z) > 0) ? (v.z) : -(v.z)));
    if (chk > (1<<15))
    {
# 497 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h"
        return CIwSVec3( (int16)(((int64)y*v.z + (int64)z*-v.y)>>12),
                        (int16)(((int64)z*v.x + (int64)x*-v.z)>>12),
                        (int16)(((int64)x*v.y + (int64)y*-v.x)>>12) );
    }
    else
    {
# 520 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h"
        return CIwSVec3( (int16)(((int32)y*v.z + (int32)z*-v.y)>>12),
                        (int16)(((int32)z*v.x + (int32)x*-v.z)>>12),
                        (int16)(((int32)x*v.y + (int32)y*-v.x)>>12) );
    }
}




inline bool CIwSVec3::operator == (CIwSVec3 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        true);
}




inline bool CIwSVec3::operator != (CIwSVec3 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        false);
}




inline CIwSVec3 CIwSVec3::operator * (iwfixed l) const
{
# 564 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h"
    return CIwSVec3(
          (int16)IW_FIXED_MUL(x,l)
        , (int16)IW_FIXED_MUL(y,l)
        , (int16)IW_FIXED_MUL(z,l)
        );
}




inline CIwSVec3 & CIwSVec3::operator *= (iwfixed l)
{
# 585 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h"
    x = (int16)IW_FIXED_MUL(x,l);
    y = (int16)IW_FIXED_MUL(y,l);
    z = (int16)IW_FIXED_MUL(z,l);
    return *this;
}




inline CIwSVec3 CIwSVec3::operator - () const
{
    return CIwSVec3(
        (int16)-x
        , (int16)-y
        , (int16)-z
        );
}




inline CIwSVec3 CIwSVec3::operator / (const iwfixed s) const
{
    return CIwSVec3(
        (int16)(IW_FIXED_DIV(x, s))
        , (int16)(IW_FIXED_DIV(y, s))
        , (int16)(IW_FIXED_DIV(z, s))
        );
}




inline CIwSVec3 CIwSVec3::operator >> (const int s) const
{
    return CIwSVec3(
        (int16)(x >> s)
        , (int16)(y >> s)
        , (int16)(z >> s)
        );
}

inline CIwSVec3 CIwSVec3::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    z >>= s;
    return *this;
}




inline CIwSVec3 CIwSVec3::operator << (const int s) const
{






    return CIwSVec3(
        (int16)(x << s)
        , (int16)(y << s)
        , (int16)(z << s)
        );
}

inline CIwSVec3 CIwSVec3::operator <<= (const int s)
{





    x <<= s;
    y <<= s;



    z <<= s;
    return *this;
}


inline int16 & CIwSVec3::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline int16 CIwSVec3::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwSVec3 operator * (iwfixed l, const CIwSVec3& v)
{
    return v * l;
}





# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h" 1
       
# 33 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwVec3
{
public:
    int32 x;
    int32 y;
    int32 z;


    static CIwVec3 g_Zero;


    static CIwVec3 g_AxisX;


    static CIwVec3 g_AxisY;


    static CIwVec3 g_AxisZ;




    CIwVec3() {};
# 79 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h"
    CIwVec3(int32 _x, int32 _y, int32 _z) : x(_x), y(_y), z(_z) {};

    explicit CIwVec3(const CIwSVec3& v);
    explicit CIwVec3(const CIwFVec3& v);
    CIwVec3 operator = (const CIwSVec3& v);
    CIwVec3 operator = (const CIwFVec3& v);
# 97 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {





        return (x*x + y*y+ z*z) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 147 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h"
    void NormaliseSlow();
# 157 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h"
    void Normalise();





    CIwVec3 GetNormalised() const;







    void NormaliseSafe();





    CIwVec3 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 197 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwVec3 const & v) const {return *this * v;}






    inline CIwVec3 Cross(CIwVec3 const & v) const {return *this ^ v;}
# 234 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h"
    CIwVec3& operator = (CIwVec3 const & v);






    CIwVec3 operator + (CIwVec3 const & v) const;






    CIwVec3 & operator += (CIwVec3 const & v);






    CIwVec3 operator - (CIwVec3 const & v) const;






    CIwVec3 & operator -= (CIwVec3 const & v);






    int32 operator * (CIwVec3 const & v) const;






    CIwVec3 operator ^ (CIwVec3 const & v) const;






    bool operator == (CIwVec3 const & v) const;






    bool operator != (CIwVec3 const & v) const;
# 303 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h"
    CIwVec3 operator - () const;






    CIwVec3 operator * (iwfixed l) const;







    CIwVec3 & operator *= (iwfixed l);






    CIwVec3 operator / (const iwfixed s) const;






    CIwVec3 operator >> (const int s) const;







    CIwVec3 operator >>= (const int s);






    CIwVec3 operator << (const int s) const;







    CIwVec3 operator <<= (const int s);






    int32 & operator [] (const int n);






    int32 operator [] (const int n) const;




};




inline CIwVec3& CIwVec3::operator = (CIwVec3 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    return *this;
}




inline CIwVec3 CIwVec3::operator + (CIwVec3 const & v) const
{






    return CIwVec3(
        (int32)(x + v.x)
        , (int32)(y + v.y)
        , (int32)(z + v.z)
        );
}




inline CIwVec3 & CIwVec3::operator += (CIwVec3 const & v)
{






    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}




inline CIwVec3 CIwVec3::operator - (CIwVec3 const & v) const
{






    return CIwVec3(
        (int32)(x - v.x)
        , (int32)(y - v.y)
        , (int32)(z - v.z)
        );
}




inline CIwVec3 & CIwVec3::operator -= (CIwVec3 const & v)
{






    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}




inline int32 CIwVec3::operator * (CIwVec3 const & v) const
{
# 473 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h"
    return (
        (int32)x * v.x +
        (int32)y * v.y +
        (int32)z * v.z +
        0) >> 12;
}



inline CIwVec3 CIwVec3::operator ^ (CIwVec3 const & v) const
{

    int chk = ((((x) > 0) ? (x) : -(x)) | (((y) > 0) ? (y) : -(y)) | (((z) > 0) ? (z) : -(z)) | (((v.x) > 0) ? (v.x) : -(v.x)) | (((v.y) > 0) ? (v.y) : -(v.y)) | (((v.z) > 0) ? (v.z) : -(v.z)));
    if (chk > (1<<15))
    {
# 497 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h"
        return CIwVec3( (int32)(((int64)y*v.z + (int64)z*-v.y)>>12),
                        (int32)(((int64)z*v.x + (int64)x*-v.z)>>12),
                        (int32)(((int64)x*v.y + (int64)y*-v.x)>>12) );
    }
    else
    {
# 520 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h"
        return CIwVec3( (int32)(((int32)y*v.z + (int32)z*-v.y)>>12),
                        (int32)(((int32)z*v.x + (int32)x*-v.z)>>12),
                        (int32)(((int32)x*v.y + (int32)y*-v.x)>>12) );
    }
}




inline bool CIwVec3::operator == (CIwVec3 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        true);
}




inline bool CIwVec3::operator != (CIwVec3 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        false);
}




inline CIwVec3 CIwVec3::operator * (iwfixed l) const
{
# 564 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h"
    return CIwVec3(
          (int32)IW_FIXED_MUL(x,l)
        , (int32)IW_FIXED_MUL(y,l)
        , (int32)IW_FIXED_MUL(z,l)
        );
}




inline CIwVec3 & CIwVec3::operator *= (iwfixed l)
{
# 585 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h"
    x = (int32)IW_FIXED_MUL(x,l);
    y = (int32)IW_FIXED_MUL(y,l);
    z = (int32)IW_FIXED_MUL(z,l);
    return *this;
}




inline CIwVec3 CIwVec3::operator - () const
{
    return CIwVec3(
        (int32)-x
        , (int32)-y
        , (int32)-z
        );
}




inline CIwVec3 CIwVec3::operator / (const iwfixed s) const
{
    return CIwVec3(
        (int32)(IW_FIXED_DIV(x, s))
        , (int32)(IW_FIXED_DIV(y, s))
        , (int32)(IW_FIXED_DIV(z, s))
        );
}




inline CIwVec3 CIwVec3::operator >> (const int s) const
{
    return CIwVec3(
        (int32)(x >> s)
        , (int32)(y >> s)
        , (int32)(z >> s)
        );
}

inline CIwVec3 CIwVec3::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    z >>= s;
    return *this;
}




inline CIwVec3 CIwVec3::operator << (const int s) const
{






    return CIwVec3(
        (int32)(x << s)
        , (int32)(y << s)
        , (int32)(z << s)
        );
}

inline CIwVec3 CIwVec3::operator <<= (const int s)
{





    x <<= s;
    y <<= s;



    z <<= s;
    return *this;
}


inline int32 & CIwVec3::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline int32 CIwVec3::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwVec3 operator * (iwfixed l, const CIwVec3& v)
{
    return v * l;
}







inline CIwVec3::CIwVec3(const CIwSVec3& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    z = (int32)v.z;
}

inline CIwVec3 CIwVec3::operator = (const CIwSVec3& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    z = (int32)v.z;
    return *this;
}


inline bool operator == (const CIwVec3& v1, const CIwSVec3& v2)
{
    return (
        v1.x == (int32)v2.x &&
        v1.y == (int32)v2.y &&
        v1.z == (int32)v2.z &&
        true);
}


inline CIwVec3 operator + (const CIwVec3& v1, const CIwSVec3& v2)
{
    return CIwVec3(
        v1.x + (int32)v2.x
        , v1.y + (int32)v2.y
        , v1.z + (int32)v2.z
        );
}


inline CIwVec3 operator - (const CIwVec3& v1, const CIwSVec3& v2)
{
    return CIwVec3(
        v1.x - (int32)v2.x
        , v1.y - (int32)v2.y
        , v1.z - (int32)v2.z
        );
}




inline CIwVec3 operator += (CIwVec3& v1, const CIwSVec3& v2)
{
    v1.x += (int32)v2.x;
    v1.y += (int32)v2.y;
    v1.z += (int32)v2.z;
    return v1;
}




inline CIwVec3 operator -= (CIwVec3& v1, const CIwSVec3& v2)
{
    v1.x -= (int32)v2.x;
    v1.y -= (int32)v2.y;
    v1.z -= (int32)v2.z;
    return v1;
}




inline int32 operator * (const CIwVec3& v1, const CIwSVec3& v2)
{
    return v1 * CIwVec3(v2);
}




inline CIwVec3 operator ^ (const CIwVec3& v1, const CIwSVec3& v2)
{
    return v1 ^ CIwVec3(v2);
}





# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec3.h" 1
       
# 33 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec3.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwFVec3
{
public:
    float x;
    float y;
    float z;


    static CIwFVec3 g_Zero;


    static CIwFVec3 g_AxisX;


    static CIwFVec3 g_AxisY;


    static CIwFVec3 g_AxisZ;




    CIwFVec3() {};
# 79 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec3.h"
    CIwFVec3(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {};

    explicit CIwFVec3(const CIwSVec3& v);
    explicit CIwFVec3(const CIwVec3& v);
    CIwFVec3 operator = (const CIwSVec3& v);
    CIwFVec3 operator = (const CIwVec3& v);
# 97 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec3.h"
    float GetLength() const;





    inline float GetLengthSquared() const
    {

        return (x*x + y*y+ z*z);
    }
# 124 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec3.h"
    void Normalise();






    CIwFVec3 GetNormalised() const;







    bool IsNormalised() const;
# 152 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec3.h"
    void Serialise(void);





    bool IsZero() const;






    inline float Dot(CIwFVec3 const & v) const {return *this * v;}






    inline CIwFVec3 Cross(CIwFVec3 const & v) const {return *this ^ v;}
# 189 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec3.h"
    CIwFVec3& operator = (CIwFVec3 const & v);






    CIwFVec3 operator + (CIwFVec3 const & v) const;






    CIwFVec3 & operator += (CIwFVec3 const & v);






    CIwFVec3 operator - (CIwFVec3 const & v) const;






    CIwFVec3 & operator -= (CIwFVec3 const & v);






    float operator * (CIwFVec3 const & v) const;






    CIwFVec3 operator ^ (CIwFVec3 const & v) const;






    bool operator == (CIwFVec3 const & v) const;






    bool operator != (CIwFVec3 const & v) const;
# 258 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec3.h"
    CIwFVec3 operator - () const;






    CIwFVec3 operator * (float l) const;







    CIwFVec3 & operator *= (float l);






    CIwFVec3 operator / (const float s) const;







    float & operator [] (const int n);






    float operator [] (const int n) const;




};




inline CIwFVec3& CIwFVec3::operator = (CIwFVec3 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    return *this;
}




inline CIwFVec3 CIwFVec3::operator + (CIwFVec3 const & v) const
{
    return CIwFVec3(
        (float)(x + v.x)
        , (float)(y + v.y)
        , (float)(z + v.z)
        );
}




inline CIwFVec3 & CIwFVec3::operator += (CIwFVec3 const & v)
{
    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}




inline CIwFVec3 CIwFVec3::operator - (CIwFVec3 const & v) const
{
    return CIwFVec3(
        (float)(x - v.x)
        , (float)(y - v.y)
        , (float)(z - v.z)
        );
}




inline CIwFVec3 & CIwFVec3::operator -= (CIwFVec3 const & v)
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}




inline float CIwFVec3::operator * (CIwFVec3 const & v) const
{

    return (
        (float)x * v.x +
        (float)y * v.y +
        (float)z * v.z +
        0);
}



inline CIwFVec3 CIwFVec3::operator ^ (CIwFVec3 const & v) const
{
    return CIwFVec3((y * v.z - z * v.y),
                (z * v.x - x * v.z),
                (x * v.y - y * v.x));
}




inline bool CIwFVec3::operator == (CIwFVec3 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        true);
}




inline bool CIwFVec3::operator != (CIwFVec3 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        false);
}




inline CIwFVec3 CIwFVec3::operator * (float l) const
{
    return CIwFVec3(
        (float)(x * l)
        , (float)(y * l)
        , (float)(z * l)
        );
}




inline CIwFVec3 & CIwFVec3::operator *= (float l)
{
    x = (float)(x * l);
    y = (float)(y * l);
    z = (float)(z * l);
    return *this;
}




inline CIwFVec3 CIwFVec3::operator - () const
{
    return CIwFVec3(
        (float)-x
        , (float)-y
        , (float)-z
        );
}




inline CIwFVec3 CIwFVec3::operator / (const float s) const
{
    return CIwFVec3(
        (float)(x / s)
        , (float)(y / s)
        , (float)(z / s)
        );
}


inline float & CIwFVec3::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline float CIwFVec3::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwFVec3 operator * (float l, const CIwFVec3& v)
{
    return v * l;
}







inline CIwFVec3::CIwFVec3(const CIwSVec3& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
}

inline CIwFVec3 CIwFVec3::operator = (const CIwSVec3& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    return *this;
}


inline bool operator == (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        v1.z == ((float)(v2.z) / (float)(1 << 12)) &&
        true);
}


inline CIwFVec3 operator + (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return CIwFVec3(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        , v1.z + ((float)(v2.z) / (float)(1 << 12))
        );
}


inline CIwFVec3 operator - (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return CIwFVec3(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        , v1.z - ((float)(v2.z) / (float)(1 << 12))
        );
}




inline CIwFVec3 operator += (CIwFVec3& v1, const CIwSVec3& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    v1.z += ((float)(v2.z) / (float)(1 << 12));
    return v1;
}




inline CIwFVec3 operator -= (CIwFVec3& v1, const CIwSVec3& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    v1.z -= ((float)(v2.z) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return v1 * CIwFVec3(v2);
}




inline CIwFVec3 operator ^ (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return v1 ^ CIwFVec3(v2);
}







inline CIwFVec3::CIwFVec3(const CIwVec3& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
}




inline CIwFVec3 CIwFVec3::operator = (const CIwVec3& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    return *this;
}




inline bool operator == (const CIwFVec3& v1, const CIwVec3& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        v1.z == ((float)(v2.z) / (float)(1 << 12)) &&
        true);
}




inline CIwFVec3 operator + (const CIwFVec3& v1, const CIwVec3& v2)
{
    return CIwFVec3(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        , v1.z + ((float)(v2.z) / (float)(1 << 12))
        );
}




inline CIwFVec3 operator - (const CIwFVec3& v1, const CIwVec3& v2)
{
    return CIwFVec3(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        , v1.z - ((float)(v2.z) / (float)(1 << 12))
        );
}




inline CIwFVec3 operator += (CIwFVec3& v1, const CIwVec3& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    v1.z += ((float)(v2.z) / (float)(1 << 12));
    return v1;
}




inline CIwFVec3 operator -= (CIwFVec3& v1, const CIwVec3& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    v1.z -= ((float)(v2.z) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec3& v1, const CIwVec3& v2)
{
    return v1 * CIwFVec3(v2);
}




inline CIwFVec3 operator ^ (const CIwFVec3& v1, const CIwVec3& v2)
{
    return v1 ^ CIwFVec3(v2);
}
# 786 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec3.h" 2

inline CIwVec3::CIwVec3(const CIwFVec3& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    z = IW_FIXED_FROM_FLOAT(v.z);
}




inline CIwVec3 CIwVec3::operator = (const CIwFVec3& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    z = IW_FIXED_FROM_FLOAT(v.z);
    return *this;
}




inline bool operator == (const CIwVec3& v1, const CIwFVec3& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        ((float)(v1.z) / (float)(1 << 12)) == v2.z &&
        true);
}




inline CIwFVec3 operator + (const CIwVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        , ((float)(v1.z) / (float)(1 << 12)) + v2.z
        );
}




inline CIwFVec3 operator - (const CIwVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        , ((float)(v1.z) / (float)(1 << 12)) - v2.z
        );
}




inline CIwVec3 operator += (CIwVec3& v1, const CIwFVec3& v2)
{
    v1.x += IW_FIXED_FROM_FLOAT(v2.x);
    v1.y += IW_FIXED_FROM_FLOAT(v2.y);
    v1.z += IW_FIXED_FROM_FLOAT(v2.z);
    return v1;
}




inline CIwVec3 operator -= (CIwVec3& v1, const CIwFVec3& v2)
{
    v1.x -= IW_FIXED_FROM_FLOAT(v2.x);
    v1.y -= IW_FIXED_FROM_FLOAT(v2.y);
    v1.z -= IW_FIXED_FROM_FLOAT(v2.z);
    return v1;
}




inline float operator * (const CIwVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(v1) * v2;
}




inline CIwFVec3 operator ^ (const CIwVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(v1) ^ v2;
}
# 697 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec3.h" 2

inline CIwSVec3::CIwSVec3(const CIwVec3& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    z = IW_SFIXED_FROM_FIXED(v.z);
}

inline CIwSVec3 CIwSVec3::operator = (const CIwVec3& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    z = IW_SFIXED_FROM_FIXED(v.z);
    return *this;
}


inline bool operator == (const CIwSVec3& v1, const CIwVec3& v2)
{
    return (
        (int32)v1.x == v2.x &&
        (int32)v1.y == v2.y &&
        (int32)v1.z == v2.z &&
        true);
}


inline CIwVec3 operator + (const CIwSVec3& v1, const CIwVec3& v2)
{
    return CIwVec3(
        (int32)v1.x + v2.x
        , (int32)v1.y + v2.y
        , (int32)v1.z + v2.z
        );
}


inline CIwVec3 operator - (const CIwSVec3& v1, const CIwVec3& v2)
{
    return CIwVec3(
        (int32)v1.x - v2.x
        , (int32)v1.y - v2.y
        , (int32)v1.z - v2.z
        );
}




inline CIwSVec3 operator += (CIwSVec3& v1, const CIwVec3& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(v2.x);
    v1.y += IW_SFIXED_FROM_FIXED(v2.y);
    v1.z += IW_SFIXED_FROM_FIXED(v2.z);
    return v1;
}




inline CIwSVec3 operator -= (CIwSVec3& v1, const CIwVec3& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(v2.x);
    v1.y -= IW_SFIXED_FROM_FIXED(v2.y);
    v1.z -= IW_SFIXED_FROM_FIXED(v2.z);
    return v1;
}




inline int32 operator * (const CIwSVec3& v1, const CIwVec3& v2)
{
    return CIwVec3(v1) * v2;
}




inline CIwVec3 operator ^ (const CIwSVec3& v1, const CIwVec3& v2)
{
    return CIwVec3(v1) ^ v2;
}







inline CIwSVec3::CIwSVec3(const CIwFVec3& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    z = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.z));
}




inline CIwSVec3 CIwSVec3::operator = (const CIwFVec3& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    z = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.z));
    return *this;
}




inline bool operator == (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        ((float)(v1.z) / (float)(1 << 12)) == v2.z &&
        true);
}




inline CIwFVec3 operator + (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        , ((float)(v1.z) / (float)(1 << 12)) + v2.z
        );
}




inline CIwFVec3 operator - (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        , ((float)(v1.z) / (float)(1 << 12)) - v2.z
        );
}




inline CIwSVec3 operator += (CIwSVec3& v1, const CIwFVec3& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    v1.z += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.z));
    return v1;
}




inline CIwSVec3 operator -= (CIwSVec3& v1, const CIwFVec3& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    v1.z -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.z));
    return v1;
}




inline float operator * (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(v1) * v2;
}




inline CIwFVec3 operator ^ (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(v1) ^ v2;
}
# 35 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec.h" 2
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h" 1
       
# 33 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwSVec4
{
public:
    int16 x;
    int16 y;
    int16 z;
    int16 w;


    static CIwSVec4 g_Zero;


    static CIwSVec4 g_AxisX;


    static CIwSVec4 g_AxisY;


    static CIwSVec4 g_AxisZ;


    static CIwSVec4 g_AxisW;




    CIwSVec4() {};
# 86 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h"
    CIwSVec4(int16 _x, int16 _y, int16 _z, int16 _w) : x(_x), y(_y), z(_z), w(_w) {};

    explicit CIwSVec4(const CIwVec4& v);
    explicit CIwSVec4(const CIwFVec4& v);
    CIwSVec4 operator = (const CIwVec4& v);
    CIwSVec4 operator = (const CIwFVec4& v);
# 104 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {





        return (x*x + y*y+ z*z+ w*w) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 154 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h"
    void NormaliseSlow();
# 164 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h"
    void Normalise();





    CIwSVec4 GetNormalised() const;







    void NormaliseSafe();





    CIwSVec4 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 204 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwSVec4 const & v) const {return *this * v;}
# 233 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h"
    CIwSVec4& operator = (CIwSVec4 const & v);






    CIwSVec4 operator + (CIwSVec4 const & v) const;






    CIwSVec4 & operator += (CIwSVec4 const & v);






    CIwSVec4 operator - (CIwSVec4 const & v) const;






    CIwSVec4 & operator -= (CIwSVec4 const & v);






    int32 operator * (CIwSVec4 const & v) const;







    bool operator == (CIwSVec4 const & v) const;






    bool operator != (CIwSVec4 const & v) const;
# 296 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h"
    CIwSVec4 operator - () const;






    CIwSVec4 operator * (iwfixed l) const;







    CIwSVec4 & operator *= (iwfixed l);






    CIwSVec4 operator / (const iwfixed s) const;






    CIwSVec4 operator >> (const int s) const;







    CIwSVec4 operator >>= (const int s);






    CIwSVec4 operator << (const int s) const;







    CIwSVec4 operator <<= (const int s);






    int16 & operator [] (const int n);






    int16 operator [] (const int n) const;




};




inline CIwSVec4& CIwSVec4::operator = (CIwSVec4 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    w = v.w;
    return *this;
}




inline CIwSVec4 CIwSVec4::operator + (CIwSVec4 const & v) const
{







    return CIwSVec4(
        (int16)(x + v.x)
        , (int16)(y + v.y)
        , (int16)(z + v.z)
        , (int16)(w + v.w)
        );
}




inline CIwSVec4 & CIwSVec4::operator += (CIwSVec4 const & v)
{







    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}




inline CIwSVec4 CIwSVec4::operator - (CIwSVec4 const & v) const
{







    return CIwSVec4(
        (int16)(x - v.x)
        , (int16)(y - v.y)
        , (int16)(z - v.z)
        , (int16)(w - v.w)
        );
}




inline CIwSVec4 & CIwSVec4::operator -= (CIwSVec4 const & v)
{







    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}




inline int32 CIwSVec4::operator * (CIwSVec4 const & v) const
{
# 476 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h"
    return (
        (int32)x * v.x +
        (int32)y * v.y +
        (int32)z * v.z +
        (int32)w * v.w +
        0) >> 12;
}




inline bool CIwSVec4::operator == (CIwSVec4 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        v.w == w &&
        true);
}




inline bool CIwSVec4::operator != (CIwSVec4 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        v.w != w ||
        false);
}




inline CIwSVec4 CIwSVec4::operator * (iwfixed l) const
{
# 525 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h"
    return CIwSVec4(
          (int16)IW_FIXED_MUL(x,l)
        , (int16)IW_FIXED_MUL(y,l)
        , (int16)IW_FIXED_MUL(z,l)
        , (int16)IW_FIXED_MUL(w,l)
        );
}




inline CIwSVec4 & CIwSVec4::operator *= (iwfixed l)
{
# 548 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h"
    x = (int16)IW_FIXED_MUL(x,l);
    y = (int16)IW_FIXED_MUL(y,l);
    z = (int16)IW_FIXED_MUL(z,l);
    w = (int16)IW_FIXED_MUL(w,l);
    return *this;
}




inline CIwSVec4 CIwSVec4::operator - () const
{
    return CIwSVec4(
        (int16)-x
        , (int16)-y
        , (int16)-z
        , (int16)-w
        );
}




inline CIwSVec4 CIwSVec4::operator / (const iwfixed s) const
{
    return CIwSVec4(
        (int16)(IW_FIXED_DIV(x, s))
        , (int16)(IW_FIXED_DIV(y, s))
        , (int16)(IW_FIXED_DIV(z, s))
        , (int16)(IW_FIXED_DIV(w, s))
        );
}




inline CIwSVec4 CIwSVec4::operator >> (const int s) const
{
    return CIwSVec4(
        (int16)(x >> s)
        , (int16)(y >> s)
        , (int16)(z >> s)
        , (int16)(w >> s)
        );
}

inline CIwSVec4 CIwSVec4::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    z >>= s;
    w >>= s;
    return *this;
}




inline CIwSVec4 CIwSVec4::operator << (const int s) const
{







    return CIwSVec4(
        (int16)(x << s)
        , (int16)(y << s)
        , (int16)(z << s)
        , (int16)(w << s)
        );
}

inline CIwSVec4 CIwSVec4::operator <<= (const int s)
{





    x <<= s;
    y <<= s;



    z <<= s;



    w <<= s;
    return *this;
}


inline int16 & CIwSVec4::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline int16 CIwSVec4::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwSVec4 operator * (iwfixed l, const CIwSVec4& v)
{
    return v * l;
}





# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec4.h" 1
       
# 33 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec4.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwVec4
{
public:
    int32 x;
    int32 y;
    int32 z;
    int32 w;


    static CIwVec4 g_Zero;


    static CIwVec4 g_AxisX;


    static CIwVec4 g_AxisY;


    static CIwVec4 g_AxisZ;


    static CIwVec4 g_AxisW;




    CIwVec4() {};
# 86 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec4.h"
    CIwVec4(int32 _x, int32 _y, int32 _z, int32 _w) : x(_x), y(_y), z(_z), w(_w) {};

    explicit CIwVec4(const CIwSVec4& v);
    explicit CIwVec4(const CIwFVec4& v);
    CIwVec4 operator = (const CIwSVec4& v);
    CIwVec4 operator = (const CIwFVec4& v);
# 104 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec4.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {





        return (x*x + y*y+ z*z+ w*w) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 154 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec4.h"
    void NormaliseSlow();
# 164 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec4.h"
    void Normalise();





    CIwVec4 GetNormalised() const;







    void NormaliseSafe();





    CIwVec4 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 204 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec4.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwVec4 const & v) const {return *this * v;}
# 233 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec4.h"
    CIwVec4& operator = (CIwVec4 const & v);






    CIwVec4 operator + (CIwVec4 const & v) const;






    CIwVec4 & operator += (CIwVec4 const & v);






    CIwVec4 operator - (CIwVec4 const & v) const;






    CIwVec4 & operator -= (CIwVec4 const & v);






    int32 operator * (CIwVec4 const & v) const;







    bool operator == (CIwVec4 const & v) const;






    bool operator != (CIwVec4 const & v) const;
# 296 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec4.h"
    CIwVec4 operator - () const;






    CIwVec4 operator * (iwfixed l) const;







    CIwVec4 & operator *= (iwfixed l);






    CIwVec4 operator / (const iwfixed s) const;






    CIwVec4 operator >> (const int s) const;







    CIwVec4 operator >>= (const int s);






    CIwVec4 operator << (const int s) const;







    CIwVec4 operator <<= (const int s);






    int32 & operator [] (const int n);






    int32 operator [] (const int n) const;




};




inline CIwVec4& CIwVec4::operator = (CIwVec4 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    w = v.w;
    return *this;
}




inline CIwVec4 CIwVec4::operator + (CIwVec4 const & v) const
{







    return CIwVec4(
        (int32)(x + v.x)
        , (int32)(y + v.y)
        , (int32)(z + v.z)
        , (int32)(w + v.w)
        );
}




inline CIwVec4 & CIwVec4::operator += (CIwVec4 const & v)
{







    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}




inline CIwVec4 CIwVec4::operator - (CIwVec4 const & v) const
{







    return CIwVec4(
        (int32)(x - v.x)
        , (int32)(y - v.y)
        , (int32)(z - v.z)
        , (int32)(w - v.w)
        );
}




inline CIwVec4 & CIwVec4::operator -= (CIwVec4 const & v)
{







    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}




inline int32 CIwVec4::operator * (CIwVec4 const & v) const
{
# 476 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec4.h"
    return (
        (int32)x * v.x +
        (int32)y * v.y +
        (int32)z * v.z +
        (int32)w * v.w +
        0) >> 12;
}




inline bool CIwVec4::operator == (CIwVec4 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        v.w == w &&
        true);
}




inline bool CIwVec4::operator != (CIwVec4 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        v.w != w ||
        false);
}




inline CIwVec4 CIwVec4::operator * (iwfixed l) const
{
# 525 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec4.h"
    return CIwVec4(
          (int32)IW_FIXED_MUL(x,l)
        , (int32)IW_FIXED_MUL(y,l)
        , (int32)IW_FIXED_MUL(z,l)
        , (int32)IW_FIXED_MUL(w,l)
        );
}




inline CIwVec4 & CIwVec4::operator *= (iwfixed l)
{
# 548 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec4.h"
    x = (int32)IW_FIXED_MUL(x,l);
    y = (int32)IW_FIXED_MUL(y,l);
    z = (int32)IW_FIXED_MUL(z,l);
    w = (int32)IW_FIXED_MUL(w,l);
    return *this;
}




inline CIwVec4 CIwVec4::operator - () const
{
    return CIwVec4(
        (int32)-x
        , (int32)-y
        , (int32)-z
        , (int32)-w
        );
}




inline CIwVec4 CIwVec4::operator / (const iwfixed s) const
{
    return CIwVec4(
        (int32)(IW_FIXED_DIV(x, s))
        , (int32)(IW_FIXED_DIV(y, s))
        , (int32)(IW_FIXED_DIV(z, s))
        , (int32)(IW_FIXED_DIV(w, s))
        );
}




inline CIwVec4 CIwVec4::operator >> (const int s) const
{
    return CIwVec4(
        (int32)(x >> s)
        , (int32)(y >> s)
        , (int32)(z >> s)
        , (int32)(w >> s)
        );
}

inline CIwVec4 CIwVec4::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    z >>= s;
    w >>= s;
    return *this;
}




inline CIwVec4 CIwVec4::operator << (const int s) const
{







    return CIwVec4(
        (int32)(x << s)
        , (int32)(y << s)
        , (int32)(z << s)
        , (int32)(w << s)
        );
}

inline CIwVec4 CIwVec4::operator <<= (const int s)
{





    x <<= s;
    y <<= s;



    z <<= s;



    w <<= s;
    return *this;
}


inline int32 & CIwVec4::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline int32 CIwVec4::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwVec4 operator * (iwfixed l, const CIwVec4& v)
{
    return v * l;
}







inline CIwVec4::CIwVec4(const CIwSVec4& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    z = (int32)v.z;
    w = (int32)v.w;
}

inline CIwVec4 CIwVec4::operator = (const CIwSVec4& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    z = (int32)v.z;
    w = (int32)v.w;
    return *this;
}


inline bool operator == (const CIwVec4& v1, const CIwSVec4& v2)
{
    return (
        v1.x == (int32)v2.x &&
        v1.y == (int32)v2.y &&
        v1.z == (int32)v2.z &&
        v1.w == (int32)v2.w &&
        true);
}


inline CIwVec4 operator + (const CIwVec4& v1, const CIwSVec4& v2)
{
    return CIwVec4(
        v1.x + (int32)v2.x
        , v1.y + (int32)v2.y
        , v1.z + (int32)v2.z
        , v1.w + (int32)v2.w
        );
}


inline CIwVec4 operator - (const CIwVec4& v1, const CIwSVec4& v2)
{
    return CIwVec4(
        v1.x - (int32)v2.x
        , v1.y - (int32)v2.y
        , v1.z - (int32)v2.z
        , v1.w - (int32)v2.w
        );
}




inline CIwVec4 operator += (CIwVec4& v1, const CIwSVec4& v2)
{
    v1.x += (int32)v2.x;
    v1.y += (int32)v2.y;
    v1.z += (int32)v2.z;
    v1.w += (int32)v2.w;
    return v1;
}




inline CIwVec4 operator -= (CIwVec4& v1, const CIwSVec4& v2)
{
    v1.x -= (int32)v2.x;
    v1.y -= (int32)v2.y;
    v1.z -= (int32)v2.z;
    v1.w -= (int32)v2.w;
    return v1;
}




inline int32 operator * (const CIwVec4& v1, const CIwSVec4& v2)
{
    return v1 * CIwVec4(v2);
}






# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec4.h" 1
       
# 33 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec4.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwFVec4
{
public:
    float x;
    float y;
    float z;
    float w;


    static CIwFVec4 g_Zero;


    static CIwFVec4 g_AxisX;


    static CIwFVec4 g_AxisY;


    static CIwFVec4 g_AxisZ;


    static CIwFVec4 g_AxisW;




    CIwFVec4() {};
# 86 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec4.h"
    CIwFVec4(float _x, float _y, float _z, float _w) : x(_x), y(_y), z(_z), w(_w) {};

    explicit CIwFVec4(const CIwSVec4& v);
    explicit CIwFVec4(const CIwVec4& v);
    CIwFVec4 operator = (const CIwSVec4& v);
    CIwFVec4 operator = (const CIwVec4& v);
# 104 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec4.h"
    float GetLength() const;





    inline float GetLengthSquared() const
    {

        return (x*x + y*y+ z*z+ w*w);
    }
# 131 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec4.h"
    void Normalise();






    CIwFVec4 GetNormalised() const;







    bool IsNormalised() const;
# 159 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec4.h"
    void Serialise(void);





    bool IsZero() const;






    inline float Dot(CIwFVec4 const & v) const {return *this * v;}
# 188 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec4.h"
    CIwFVec4& operator = (CIwFVec4 const & v);






    CIwFVec4 operator + (CIwFVec4 const & v) const;






    CIwFVec4 & operator += (CIwFVec4 const & v);






    CIwFVec4 operator - (CIwFVec4 const & v) const;






    CIwFVec4 & operator -= (CIwFVec4 const & v);






    float operator * (CIwFVec4 const & v) const;







    bool operator == (CIwFVec4 const & v) const;






    bool operator != (CIwFVec4 const & v) const;
# 251 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec4.h"
    CIwFVec4 operator - () const;






    CIwFVec4 operator * (float l) const;







    CIwFVec4 & operator *= (float l);






    CIwFVec4 operator / (const float s) const;







    float & operator [] (const int n);






    float operator [] (const int n) const;




};




inline CIwFVec4& CIwFVec4::operator = (CIwFVec4 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    w = v.w;
    return *this;
}




inline CIwFVec4 CIwFVec4::operator + (CIwFVec4 const & v) const
{
    return CIwFVec4(
        (float)(x + v.x)
        , (float)(y + v.y)
        , (float)(z + v.z)
        , (float)(w + v.w)
        );
}




inline CIwFVec4 & CIwFVec4::operator += (CIwFVec4 const & v)
{
    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}




inline CIwFVec4 CIwFVec4::operator - (CIwFVec4 const & v) const
{
    return CIwFVec4(
        (float)(x - v.x)
        , (float)(y - v.y)
        , (float)(z - v.z)
        , (float)(w - v.w)
        );
}




inline CIwFVec4 & CIwFVec4::operator -= (CIwFVec4 const & v)
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}




inline float CIwFVec4::operator * (CIwFVec4 const & v) const
{

    return (
        (float)x * v.x +
        (float)y * v.y +
        (float)z * v.z +
        (float)w * v.w +
        0);
}




inline bool CIwFVec4::operator == (CIwFVec4 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        v.w == w &&
        true);
}




inline bool CIwFVec4::operator != (CIwFVec4 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        v.w != w ||
        false);
}




inline CIwFVec4 CIwFVec4::operator * (float l) const
{
    return CIwFVec4(
        (float)(x * l)
        , (float)(y * l)
        , (float)(z * l)
        , (float)(w * l)
        );
}




inline CIwFVec4 & CIwFVec4::operator *= (float l)
{
    x = (float)(x * l);
    y = (float)(y * l);
    z = (float)(z * l);
    w = (float)(w * l);
    return *this;
}




inline CIwFVec4 CIwFVec4::operator - () const
{
    return CIwFVec4(
        (float)-x
        , (float)-y
        , (float)-z
        , (float)-w
        );
}




inline CIwFVec4 CIwFVec4::operator / (const float s) const
{
    return CIwFVec4(
        (float)(x / s)
        , (float)(y / s)
        , (float)(z / s)
        , (float)(w / s)
        );
}


inline float & CIwFVec4::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline float CIwFVec4::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwFVec4 operator * (float l, const CIwFVec4& v)
{
    return v * l;
}







inline CIwFVec4::CIwFVec4(const CIwSVec4& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    w = ((float)(v.w) / (float)(1 << 12));
}

inline CIwFVec4 CIwFVec4::operator = (const CIwSVec4& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    w = ((float)(v.w) / (float)(1 << 12));
    return *this;
}


inline bool operator == (const CIwFVec4& v1, const CIwSVec4& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        v1.z == ((float)(v2.z) / (float)(1 << 12)) &&
        v1.w == ((float)(v2.w) / (float)(1 << 12)) &&
        true);
}


inline CIwFVec4 operator + (const CIwFVec4& v1, const CIwSVec4& v2)
{
    return CIwFVec4(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        , v1.z + ((float)(v2.z) / (float)(1 << 12))
        , v1.w + ((float)(v2.w) / (float)(1 << 12))
        );
}


inline CIwFVec4 operator - (const CIwFVec4& v1, const CIwSVec4& v2)
{
    return CIwFVec4(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        , v1.z - ((float)(v2.z) / (float)(1 << 12))
        , v1.w - ((float)(v2.w) / (float)(1 << 12))
        );
}




inline CIwFVec4 operator += (CIwFVec4& v1, const CIwSVec4& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    v1.z += ((float)(v2.z) / (float)(1 << 12));
    v1.w += ((float)(v2.w) / (float)(1 << 12));
    return v1;
}




inline CIwFVec4 operator -= (CIwFVec4& v1, const CIwSVec4& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    v1.z -= ((float)(v2.z) / (float)(1 << 12));
    v1.w -= ((float)(v2.w) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec4& v1, const CIwSVec4& v2)
{
    return v1 * CIwFVec4(v2);
}
# 566 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFVec4.h"
inline CIwFVec4::CIwFVec4(const CIwVec4& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    w = ((float)(v.w) / (float)(1 << 12));
}




inline CIwFVec4 CIwFVec4::operator = (const CIwVec4& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    w = ((float)(v.w) / (float)(1 << 12));
    return *this;
}




inline bool operator == (const CIwFVec4& v1, const CIwVec4& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        v1.z == ((float)(v2.z) / (float)(1 << 12)) &&
        v1.w == ((float)(v2.w) / (float)(1 << 12)) &&
        true);
}




inline CIwFVec4 operator + (const CIwFVec4& v1, const CIwVec4& v2)
{
    return CIwFVec4(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        , v1.z + ((float)(v2.z) / (float)(1 << 12))
        , v1.w + ((float)(v2.w) / (float)(1 << 12))
        );
}




inline CIwFVec4 operator - (const CIwFVec4& v1, const CIwVec4& v2)
{
    return CIwFVec4(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        , v1.z - ((float)(v2.z) / (float)(1 << 12))
        , v1.w - ((float)(v2.w) / (float)(1 << 12))
        );
}




inline CIwFVec4 operator += (CIwFVec4& v1, const CIwVec4& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    v1.z += ((float)(v2.z) / (float)(1 << 12));
    v1.w += ((float)(v2.w) / (float)(1 << 12));
    return v1;
}




inline CIwFVec4 operator -= (CIwFVec4& v1, const CIwVec4& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    v1.z -= ((float)(v2.z) / (float)(1 << 12));
    v1.w -= ((float)(v2.w) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec4& v1, const CIwVec4& v2)
{
    return v1 * CIwFVec4(v2);
}
# 760 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec4.h" 2

inline CIwVec4::CIwVec4(const CIwFVec4& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    z = IW_FIXED_FROM_FLOAT(v.z);
    w = IW_FIXED_FROM_FLOAT(v.w);
}




inline CIwVec4 CIwVec4::operator = (const CIwFVec4& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    z = IW_FIXED_FROM_FLOAT(v.z);
    w = IW_FIXED_FROM_FLOAT(v.w);
    return *this;
}




inline bool operator == (const CIwVec4& v1, const CIwFVec4& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        ((float)(v1.z) / (float)(1 << 12)) == v2.z &&
        ((float)(v1.w) / (float)(1 << 12)) == v2.w &&
        true);
}




inline CIwFVec4 operator + (const CIwVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        , ((float)(v1.z) / (float)(1 << 12)) + v2.z
        , ((float)(v1.w) / (float)(1 << 12)) + v2.w
        );
}




inline CIwFVec4 operator - (const CIwVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        , ((float)(v1.z) / (float)(1 << 12)) - v2.z
        , ((float)(v1.w) / (float)(1 << 12)) - v2.w
        );
}




inline CIwVec4 operator += (CIwVec4& v1, const CIwFVec4& v2)
{
    v1.x += IW_FIXED_FROM_FLOAT(v2.x);
    v1.y += IW_FIXED_FROM_FLOAT(v2.y);
    v1.z += IW_FIXED_FROM_FLOAT(v2.z);
    v1.w += IW_FIXED_FROM_FLOAT(v2.w);
    return v1;
}




inline CIwVec4 operator -= (CIwVec4& v1, const CIwFVec4& v2)
{
    v1.x -= IW_FIXED_FROM_FLOAT(v2.x);
    v1.y -= IW_FIXED_FROM_FLOAT(v2.y);
    v1.z -= IW_FIXED_FROM_FLOAT(v2.z);
    v1.w -= IW_FIXED_FROM_FLOAT(v2.w);
    return v1;
}




inline float operator * (const CIwVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(v1) * v2;
}
# 671 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h" 2

inline CIwSVec4::CIwSVec4(const CIwVec4& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    z = IW_SFIXED_FROM_FIXED(v.z);
    w = IW_SFIXED_FROM_FIXED(v.w);
}

inline CIwSVec4 CIwSVec4::operator = (const CIwVec4& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    z = IW_SFIXED_FROM_FIXED(v.z);
    w = IW_SFIXED_FROM_FIXED(v.w);
    return *this;
}


inline bool operator == (const CIwSVec4& v1, const CIwVec4& v2)
{
    return (
        (int32)v1.x == v2.x &&
        (int32)v1.y == v2.y &&
        (int32)v1.z == v2.z &&
        (int32)v1.w == v2.w &&
        true);
}


inline CIwVec4 operator + (const CIwSVec4& v1, const CIwVec4& v2)
{
    return CIwVec4(
        (int32)v1.x + v2.x
        , (int32)v1.y + v2.y
        , (int32)v1.z + v2.z
        , (int32)v1.w + v2.w
        );
}


inline CIwVec4 operator - (const CIwSVec4& v1, const CIwVec4& v2)
{
    return CIwVec4(
        (int32)v1.x - v2.x
        , (int32)v1.y - v2.y
        , (int32)v1.z - v2.z
        , (int32)v1.w - v2.w
        );
}




inline CIwSVec4 operator += (CIwSVec4& v1, const CIwVec4& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(v2.x);
    v1.y += IW_SFIXED_FROM_FIXED(v2.y);
    v1.z += IW_SFIXED_FROM_FIXED(v2.z);
    v1.w += IW_SFIXED_FROM_FIXED(v2.w);
    return v1;
}




inline CIwSVec4 operator -= (CIwSVec4& v1, const CIwVec4& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(v2.x);
    v1.y -= IW_SFIXED_FROM_FIXED(v2.y);
    v1.z -= IW_SFIXED_FROM_FIXED(v2.z);
    v1.w -= IW_SFIXED_FROM_FIXED(v2.w);
    return v1;
}




inline int32 operator * (const CIwSVec4& v1, const CIwVec4& v2)
{
    return CIwVec4(v1) * v2;
}
# 761 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSVec4.h"
inline CIwSVec4::CIwSVec4(const CIwFVec4& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    z = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.z));
    w = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.w));
}




inline CIwSVec4 CIwSVec4::operator = (const CIwFVec4& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    z = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.z));
    w = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.w));
    return *this;
}




inline bool operator == (const CIwSVec4& v1, const CIwFVec4& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        ((float)(v1.z) / (float)(1 << 12)) == v2.z &&
        ((float)(v1.w) / (float)(1 << 12)) == v2.w &&
        true);
}




inline CIwFVec4 operator + (const CIwSVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        , ((float)(v1.z) / (float)(1 << 12)) + v2.z
        , ((float)(v1.w) / (float)(1 << 12)) + v2.w
        );
}




inline CIwFVec4 operator - (const CIwSVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        , ((float)(v1.z) / (float)(1 << 12)) - v2.z
        , ((float)(v1.w) / (float)(1 << 12)) - v2.w
        );
}




inline CIwSVec4 operator += (CIwSVec4& v1, const CIwFVec4& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    v1.z += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.z));
    v1.w += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.w));
    return v1;
}




inline CIwSVec4 operator -= (CIwSVec4& v1, const CIwFVec4& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    v1.z -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.z));
    v1.w -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.w));
    return v1;
}




inline float operator * (const CIwSVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(v1) * v2;
}
# 36 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomVec.h" 2
# 23 "c:/marmalade/6.2/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h" 1
       
# 35 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
class CIwFMat;
# 63 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
class CIwMat
{
public:



    iwfixed m[3][3];



    CIwVec3 t;




    static CIwMat g_Identity;




    CIwMat() {};





    explicit CIwMat(iwfixed f)
    {
        m[0][0] = m[1][1] = m[2][2] = f;
        m[0][1] = m[0][2] = m[1][0] = m[1][2] = m[2][0] = m[2][1] = 0;
        t.x = t.y = t.z = 0;
    }






    explicit CIwMat(const CIwFMat & M);





    inline CIwFMat ConvertToCIwFMat();
# 116 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
    CIwMat(CIwMat const & R, CIwVec3 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[2][0] = R.m[2][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        m[2][1] = R.m[2][1];
        m[0][2] = R.m[0][2];
        m[1][2] = R.m[1][2];
        m[2][2] = R.m[2][2];
        t = T;
    }







    CIwMat(CIwMat const & R, CIwSVec3 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[2][0] = R.m[2][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        m[2][1] = R.m[2][1];
        m[0][2] = R.m[0][2];
        m[1][2] = R.m[1][2];
        m[2][2] = R.m[2][2];
        t = T;
    }






    void Serialise();





    void Normalise()
    {
        CIwVec3* pVecX = (CIwVec3*)&m[0][0];
        CIwVec3* pVecY = (CIwVec3*)&m[1][0];
        CIwVec3* pVecZ = (CIwVec3*)&m[2][0];

        pVecZ->Normalise();




        pVecX->Normalise();

        *pVecY = *pVecZ ^ *pVecX;
# 183 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
        ((void)0);



        pVecY->Normalise();

        *pVecX = *pVecY ^ *pVecZ;
    }




    void Transpose();





    CIwVec3 const & GetTrans() const
    {
        return t;
    }






    CIwMat & SetTrans(CIwVec3 const & v)
    {
        t = v;
        return *this;
    }






    CIwMat & SetTrans(CIwSVec3 const & v)
    {
        t = v;
        return *this;
    }






    CIwMat & operator += (CIwVec3 const & V)
    {
        t += V;
        return *this;
    }






    CIwMat & operator += (CIwSVec3 const & V)
    {
        t += V;
        return *this;
    }






    CIwMat operator + (CIwVec3 const & V) const
    {
        return CIwMat(*this, t+V);
    }






    CIwMat operator + (CIwSVec3 const & V) const
    {
        return CIwMat(*this, t+V);
    }







    CIwMat& operator <<= (int32 s)
    {
        m[0][0] <<= s; m[0][1] <<= s; m[0][2] <<= s;
        m[1][0] <<= s; m[1][1] <<= s; m[1][2] <<= s;
        m[2][0] <<= s; m[2][1] <<= s; m[2][2] <<= s;
        t.x <<= s, t.y <<= s, t.z <<= s;
        return *this;
    }






    CIwMat& operator >>= (int32 s)
    {
        m[0][0] >>= s; m[0][1] >>= s; m[0][2] >>= s;
        m[1][0] >>= s; m[1][1] >>= s; m[1][2] >>= s;
        m[2][0] >>= s; m[2][1] >>= s; m[2][2] >>= s;
        t.x >>= s, t.y >>= s, t.z >>= s;
        return *this;
    }





    CIwVec3 ColumnX() const
    {
        return CIwVec3(m[0][0], m[1][0], m[2][0]);
    }




    CIwVec3 ColumnY() const
    {
        return CIwVec3(m[0][1], m[1][1], m[2][1]);
    }




    CIwVec3 ColumnZ() const
    {
        return CIwVec3(m[0][2], m[1][2], m[2][2]);
    }







    CIwVec3 RowX() const
    {
        return CIwVec3(m[0][0], m[0][1], m[0][2]);
    }







    CIwVec3 RowY() const
    {
        return CIwVec3(m[1][0], m[1][1], m[1][2]);
    }







    CIwVec3 RowZ() const
    {
        return CIwVec3(m[2][0], m[2][1], m[2][2]);
    }







    CIwVec3 RotateVec(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z),
        IW_FIXED_MUL3(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z),
        IW_FIXED_MUL3(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z)
        );
    }







    CIwSVec3 RotateVec(CIwSVec3 const &V) const
    {
        return CIwSVec3(
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z))
        );
    }







    CIwVec3 RotateVecSafe(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3_SAFE(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z),
        IW_FIXED_MUL3_SAFE(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z),
        IW_FIXED_MUL3_SAFE(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z)
        );
    }







    CIwVec3 TransformVec(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z) + t.x,
        IW_FIXED_MUL3(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z) + t.y,
        IW_FIXED_MUL3(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z) + t.z
        );
    }
# 424 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
    CIwVec3 TransformVec(CIwSVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z) + t.x,
        IW_FIXED_MUL3(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z) + t.y,
        IW_FIXED_MUL3(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z) + t.z
        );
    }
# 441 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
    CIwVec3 TransformVecShift(CIwSVec3 const &V, int32 shift) const
    {
        int32 lDotShift = 12 - shift;
        return CIwVec3(
        IW_MUL_3_SHIFT(m[0][0] >> shift, m[1][0] >> shift, m[2][0] >> shift, V.x, V.y, V.z, lDotShift) + t.x,
        IW_MUL_3_SHIFT(m[0][1] >> shift, m[1][1] >> shift, m[2][1] >> shift, V.x, V.y, V.z, lDotShift) + t.y,
        IW_MUL_3_SHIFT(m[0][2] >> shift, m[1][2] >> shift, m[2][2] >> shift, V.x, V.y, V.z, lDotShift) + t.z
        );
    }
# 459 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
    CIwVec3 TransformVecSafe(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3_SAFE(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z) + t.x,
        IW_FIXED_MUL3_SAFE(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z) + t.y,
        IW_FIXED_MUL3_SAFE(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z) + t.z
        );
    }






    CIwVec3 TransformVecSafe(CIwSVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3_SAFE(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z) + t.x,
        IW_FIXED_MUL3_SAFE(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z) + t.y,
        IW_FIXED_MUL3_SAFE(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z) + t.z
        );
    }







    CIwVec3 TransposeRotateVec(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3(m[0][0], m[0][1], m[0][2], V.x, V.y, V.z),
        IW_FIXED_MUL3(m[1][0], m[1][1], m[1][2], V.x, V.y, V.z),
        IW_FIXED_MUL3(m[2][0], m[2][1], m[2][2], V.x, V.y, V.z)
        );
    }







    CIwSVec3 TransposeRotateVec(CIwSVec3 const &V) const
    {
        return CIwSVec3(
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[0][0], m[0][1], m[0][2], V.x, V.y, V.z)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[1][0], m[1][1], m[1][2], V.x, V.y, V.z)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[2][0], m[2][1], m[2][2], V.x, V.y, V.z))
        );
    }







    CIwVec3 TransposeRotateVecSafe(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3_SAFE(m[0][0], m[0][1], m[0][2], V.x, V.y, V.z),
        IW_FIXED_MUL3_SAFE(m[1][0], m[1][1], m[1][2], V.x, V.y, V.z),
        IW_FIXED_MUL3_SAFE(m[2][0], m[2][1], m[2][2], V.x, V.y, V.z)
        );
    }
# 534 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
    CIwVec3 TransposeTransformVec(CIwVec3 const &V) const
    {
        return CIwVec3(
            IW_FIXED_MUL3(m[0][0], m[0][1], m[0][2], V.x-t.x, V.y-t.y, V.z-t.z),
            IW_FIXED_MUL3(m[1][0], m[1][1], m[1][2], V.x-t.x, V.y-t.y, V.z-t.z),
            IW_FIXED_MUL3(m[2][0], m[2][1], m[2][2], V.x-t.x, V.y-t.y, V.z-t.z)
            );
    }
# 551 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
    iwfixed TransformVecX(CIwVec3 const &V) const { return ((IW_FIXED_MUL3(m[0][0],m[1][0],m[2][0],V.x,V.y,V.z)) + (t.x)); }
    iwfixed TransformVecY(CIwVec3 const &V) const { return ((IW_FIXED_MUL3(m[0][1],m[1][1],m[2][1],V.x,V.y,V.z)) + (t.y)); }
    iwfixed TransformVecZ(CIwVec3 const &V) const { return ((IW_FIXED_MUL3(m[0][2],m[1][2],m[2][2],V.x,V.y,V.z)) + (t.z)); }
    iwfixed TransformVecZ(CIwSVec3 const &V) const { return ((IW_FIXED_MUL3(m[0][2],m[1][2],m[2][2],V.x,V.y,V.z)) + (t.z)); }
    iwfixed TransformVecX(iwsfixed x, iwsfixed y, iwsfixed z) const { return ((IW_FIXED_MUL3(m[0][0],m[1][0],m[2][0],x,y,z)) + (t.x)); }
    iwfixed TransformVecY(iwsfixed x, iwsfixed y, iwsfixed z) const { return ((IW_FIXED_MUL3(m[0][1],m[1][1],m[2][1],x,y,z)) + (t.y)); }
    iwfixed TransformVecZ(iwsfixed x, iwsfixed y, iwsfixed z) const { return ((IW_FIXED_MUL3(m[0][2],m[1][2],m[2][2],x,y,z)) + (t.z)); }
    iwfixed TransformVecX(iwfixed x, iwfixed y, iwfixed z) const { return ((IW_FIXED_MUL3(m[0][0],m[1][0],m[2][0],x,y,z)) + (t.x)); }
    iwfixed TransformVecY(iwfixed x, iwfixed y, iwfixed z) const { return ((IW_FIXED_MUL3(m[0][1],m[1][1],m[2][1],x,y,z)) + (t.y)); }
    iwfixed TransformVecZ(iwfixed x, iwfixed y, iwfixed z) const { return ((IW_FIXED_MUL3(m[0][2],m[1][2],m[2][2],x,y,z)) + (t.z)); }







    inline iwfixed RotateVecX(const CIwVec3& V) const
    {
            return IW_FIXED_MUL(m[0][0], V.x) + IW_FIXED_MUL(m[1][0], V.y) + IW_FIXED_MUL(m[2][0], V.z);
    }





    inline iwfixed RotateVecY(const CIwVec3& V) const
    {
            return IW_FIXED_MUL(m[0][1], V.x) + IW_FIXED_MUL(m[1][1], V.y) + IW_FIXED_MUL(m[2][1], V.z);
    }





    inline iwfixed RotateVecZ(const CIwVec3& V) const
    {
            return IW_FIXED_MUL(m[0][2], V.x) + IW_FIXED_MUL(m[1][2], V.y) + IW_FIXED_MUL(m[2][2], V.z);
    }







    inline iwsfixed RotateVecX(const CIwSVec3& V) const
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][0], V.x) + IW_FIXED_MUL(m[1][0], V.y) + IW_FIXED_MUL(m[2][0], V.z));
    }





    inline iwsfixed RotateVecY(const CIwSVec3& V) const
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][1], V.x) + IW_FIXED_MUL(m[1][1], V.y) + IW_FIXED_MUL(m[2][1], V.z));
    }





    inline iwsfixed RotateVecZ(const CIwSVec3& V) const
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][2], V.x) + IW_FIXED_MUL(m[1][2], V.y) + IW_FIXED_MUL(m[2][2], V.z));
    }





    CIwMat GetTranspose() const
    {
        CIwMat N;
        N.m[0][0] = m[0][0];
        N.m[1][0] = m[0][1];
        N.m[2][0] = m[0][2];
        N.m[0][1] = m[1][0];
        N.m[1][1] = m[1][1];
        N.m[2][1] = m[1][2];
        N.m[0][2] = m[2][0];
        N.m[1][2] = m[2][1];
        N.m[2][2] = m[2][2];


        N.t = CIwVec3(0, 0, 0);
        return N;
    }
# 650 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
    inline void SetRotX(iwangle r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][1] = m[0][2] = m[1][0] = m[2][0] = 0;
        m[0][0] = (1 << 12);
        m[1][1] = m[2][2] = IwGeomCos(r);
        m[1][2] = -(m[2][1] = IwGeomSin(r));
    }







    inline void SetRotY(iwangle r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][1] = m[1][2] = m[1][0] = m[2][1] = 0;
        m[1][1] = (1 << 12);
        m[0][0] = m[2][2] = IwGeomCos(r);
        m[2][0] = -(m[0][2] = IwGeomSin(r));
    }







    inline void SetRotZ(iwangle r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][2] = m[1][2] = m[2][0] = m[2][1] = 0;
        m[2][2] = (1 << 12);
        m[0][0] = m[1][1] = IwGeomCos(r);
        m[0][1] = -(m[1][0] = IwGeomSin(r));
    }


    inline void PreRotateX(iwangle r)
    {
        CIwMat rx;
        rx.SetRotX(r, true, true);
        PreRotate(rx);
    }
    inline void PreRotateY(iwangle r)
    {
        CIwMat ry;
        ry.SetRotY(r, true, true);
        PreRotate(ry);
    }
    inline void PreRotateZ(iwangle r)
    {
        CIwMat rz;
        rz.SetRotZ(r, true, true);
        PreRotate(rz);
    }
    inline void PostRotateX(iwangle r)
    {
        CIwMat rx;
        rx.SetRotX(r, true, true);
        PostRotate(rx);
    }
    inline void PostRotateY(iwangle r)
    {
        CIwMat ry;
        ry.SetRotY(r, true, true);
        PostRotate(ry);
    }
    inline void PostRotateZ(iwangle r)
    {
        CIwMat rz;
        rz.SetRotZ(r, true, true);
        PostRotate(rz);
    }







    void SetAxisAngle(CIwVec3 axis, iwangle angle);






    void LookAt(const CIwVec3& from, const CIwVec3& to, const CIwVec3& up)
    {

        CIwVec3 vx, vy, vz;

        vz = (to - from).GetNormalised();
        vx = (up ^ vz);
        if (vx.IsZero())
            vx.x = (1 << 12);
        else
            vx.Normalise();
        vy = (vz ^ vx);
        m[0][0] = vx.x; m[0][1] = vx.y; m[0][2] = vx.z;
        m[1][0] = vy.x; m[1][1] = vy.y; m[1][2] = vy.z;
        m[2][0] = vz.x; m[2][1] = vz.y; m[2][2] = vz.z;
    }







    CIwMat operator * (CIwMat const & M) const
    {
        CIwMat N;
        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);
        N.m[0][2] = FindComponentFromBA(M,*this,0,2);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);
        N.m[1][2] = FindComponentFromBA(M,*this,1,2);

        N.m[2][0] = FindComponentFromBA(M,*this,2,0);
        N.m[2][1] = FindComponentFromBA(M,*this,2,1);
        N.m[2][2] = FindComponentFromBA(M,*this,2,2);

        N.t = M.TransformVec(t);

        ((void)0);


        return N;
    }







    CIwMat & PreMult(CIwMat const & M)
    {
        return (*this = M * (*this));
    }




    CIwMat & PreMultiply(CIwMat const & M)
    {
        ((void)0);
        return PreMult(M);
    }







    CIwMat & PostMult(CIwMat const & M)
    {
        return (*this = (*this) * M);
    }




    CIwMat & PostMultiply(CIwMat const & M)
    {
        ((void)0);
        return PostMult(M);
    }







    CIwMat& operator *= (CIwMat const & M)
    {
        return PostMult(M);
    }







    CIwMat& PostRotate(CIwMat const& M)
    {
        CIwMat N;

        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);
        N.m[0][2] = FindComponentFromBA(M,*this,0,2);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);
        N.m[1][2] = FindComponentFromBA(M,*this,1,2);

        N.m[2][0] = FindComponentFromBA(M,*this,2,0);
        N.m[2][1] = FindComponentFromBA(M,*this,2,1);
        N.m[2][2] = FindComponentFromBA(M,*this,2,2);

        CopyRot(N);

        return *this;
    }






    CIwMat PreRotate(CIwMat const& M)
    {
        CIwMat t = M;
        t.t = this->t;
        return (*this = t.PostRotate(*this));
    }







    CIwMat& ScaleRot(iwfixed v)
    {
        for (int i=0; i<3; i++)
            for (int j=0; j<3; j++)
                m[i][j] = IW_FIXED_MUL(m[i][j],v);
        return *this;
    }






    CIwMat& ScaleTrans(iwfixed v)
    {
        t *= v;
        return *this;
    }





    CIwMat& Scale(iwfixed v)
    {
        ScaleRot(v);
        ScaleTrans(v);
        return *this;
    }






    CIwMat& operator *= (const iwfixed v)
    {
        Scale(v);
        return *this;
    }
# 933 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
    void InterpRot(CIwMat const & m0, CIwMat const & m1, iwfixed fraction);


    void InterpolateRot(CIwMat const & m0, CIwMat const & m1, iwfixed fraction)
    {
        ((void)0);
        InterpRot(m0, m1, fraction);
    }
# 952 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
    void InterpTrans(CIwMat const & m0, CIwMat const & m1, iwfixed fraction);


    void InterpolatePos(CIwMat const & m0, CIwMat const & m1, iwfixed fraction)
    {

        ((void)0);
        InterpTrans(m0, m1, fraction);
    }






    void CopyRot(const CIwMat& m0)
    {
        m[0][0] = m0.m[0][0];
        m[0][1] = m0.m[0][1];
        m[0][2] = m0.m[0][2];
        m[1][0] = m0.m[1][0];
        m[1][1] = m0.m[1][1];
        m[1][2] = m0.m[1][2];
        m[2][0] = m0.m[2][0];
        m[2][1] = m0.m[2][1];
        m[2][2] = m0.m[2][2];
    }





    void CopyTrans(const CIwMat& m0)
    {
        t = m0.t;
    }







    bool IsRotSame(CIwMat const& m0) const
    {
        return m[0][0] == m0.m[0][0] &&
        m[0][1] == m0.m[0][1] &&
        m[0][2] == m0.m[0][2] &&
        m[1][0] == m0.m[1][0] &&
        m[1][1] == m0.m[1][1] &&
        m[1][2] == m0.m[1][2] &&
        m[2][0] == m0.m[2][0] &&
        m[2][1] == m0.m[2][1] &&
        m[2][2] == m0.m[2][2];
    }






    bool IsTransSame(CIwMat const& m0) const
    {
        return (t == m0.t);
    }






    bool operator == (CIwMat const & m0) const
    {
        return IsRotSame(m0) && IsTransSame(m0);
    }







    bool operator != (CIwMat const & m0) const
    {
        return !IsRotSame(m0) || !IsTransSame(m0);
    }



    bool IsRotIdentity() const
    {
        return IsRotSame(g_Identity);
    }


    bool IsTransIdentity() const
    {
        return IsTransSame(g_Identity);
    }


    bool IsIdentity() const
    {
        return (*this)==g_Identity;
    }


    void SetIdentity()
    {
        *this = g_Identity;
    }


    bool IsRotZero() const
    {
        return m[0][0] == 0 &&
        m[0][1] == 0 &&
        m[0][2] == 0 &&
        m[1][0] == 0 &&
        m[1][1] == 0 &&
        m[1][2] == 0 &&
        m[2][0] == 0 &&
        m[2][1] == 0 &&
        m[2][2] == 0;
    }


    bool IsTransZero() const
    {
        return t.x == 0 &&
        t.y == 0 &&
        t.z == 0;
    }


    bool IsZero() const
    {
        return IsRotZero() && IsTransZero();
    }


    void SetZero();


    void Zero()
    {
        ((void)0);
        SetZero();
    }
# 1121 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
private:


    static inline iwfixed FindComponentFromBA(const CIwMat& A, const CIwMat& B, const int i, const int j)
    {
# 1143 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
        return (B.m[i][0]*A.m[0][j] + B.m[i][1]*A.m[1][j] + B.m[i][2]*A.m[2][j]) >> 12;
    }



};
# 1157 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h"
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat.h" 1
       
# 35 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat.h"
class CIwMat;
# 63 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat.h"
class CIwFMat
{
public:



    float m[3][3];



    CIwFVec3 t;




    static CIwFMat g_Identity;




    CIwFMat() {};





    explicit CIwFMat(float f)
    {
        m[0][0] = m[1][1] = m[2][2] = f;
        m[0][1] = m[0][2] = m[1][0] = m[1][2] = m[2][0] = m[2][1] = 0;
        t.x = t.y = t.z = 0;
    }






    explicit CIwFMat(const CIwMat & M);





    inline CIwMat ConvertToCIwMat();
# 116 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat.h"
    CIwFMat(CIwFMat const & R, CIwFVec3 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[2][0] = R.m[2][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        m[2][1] = R.m[2][1];
        m[0][2] = R.m[0][2];
        m[1][2] = R.m[1][2];
        m[2][2] = R.m[2][2];
        t = T;
    }







    void Serialise();





    void Normalise()
    {
        CIwFVec3* pVecX = (CIwFVec3*)&m[0][0];
        CIwFVec3* pVecY = (CIwFVec3*)&m[1][0];
        CIwFVec3* pVecZ = (CIwFVec3*)&m[2][0];

        pVecZ->Normalise();


        *pVecY = *pVecZ ^ *pVecX;
# 160 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat.h"
        ((void)0);



        pVecY->Normalise();

        *pVecX = *pVecY ^ *pVecZ;
    }




    void Transpose();





    CIwFVec3 const & GetTrans() const
    {
        return t;
    }






    CIwFMat & SetTrans(CIwFVec3 const & v)
    {
        t = v;
        return *this;
    }







    CIwFMat & operator += (CIwFVec3 const & V)
    {
        t += V;
        return *this;
    }







    CIwFMat operator + (CIwFVec3 const & V) const
    {
        return CIwFMat(*this, t+V);
    }
# 225 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat.h"
    CIwFVec3 ColumnX() const
    {
        return CIwFVec3(m[0][0], m[1][0], m[2][0]);
    }




    CIwFVec3 ColumnY() const
    {
        return CIwFVec3(m[0][1], m[1][1], m[2][1]);
    }




    CIwFVec3 ColumnZ() const
    {
        return CIwFVec3(m[0][2], m[1][2], m[2][2]);
    }







    CIwFVec3 RowX() const
    {
        return CIwFVec3(m[0][0], m[0][1], m[0][2]);
    }







    CIwFVec3 RowY() const
    {
        return CIwFVec3(m[1][0], m[1][1], m[1][2]);
    }







    CIwFVec3 RowZ() const
    {
        return CIwFVec3(m[2][0], m[2][1], m[2][2]);
    }






    CIwFVec3 RotateVec(CIwFVec3 const &V) const
    {
        return CIwFVec3(
        ((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z)),
        ((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z)),
        ((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z))
        );
    }

    CIwSVec3 RotateVec(CIwSVec3 const &V) const
    {
        return CIwSVec3(
        IW_SFIXED_FROM_FLOAT_CAST((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z)),
        IW_SFIXED_FROM_FLOAT_CAST((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z)),
        IW_SFIXED_FROM_FLOAT_CAST((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z))
        );
    }







    CIwFVec3 TransformVec(CIwFVec3 const &V) const
    {
        return CIwFVec3(
        ((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z)) + t.x,
        ((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z)) + t.y,
        ((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z)) + t.z
        );
    }

    CIwVec3 TransformVec(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_FROM_FLOAT_CAST((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z) + t.x),
        IW_FIXED_FROM_FLOAT_CAST((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z) + t.y),
        IW_FIXED_FROM_FLOAT_CAST((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z) + t.z)
        );
    }

    CIwVec3 TransformVec(CIwSVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_FROM_FLOAT_CAST((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z) + t.x),
        IW_FIXED_FROM_FLOAT_CAST((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z) + t.y),
        IW_FIXED_FROM_FLOAT_CAST((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z) + t.z)
        );
    }






    CIwFVec3 TransposeRotateVec(CIwFVec3 const &V) const
    {
        return CIwFVec3(
        ((m[0][0] * V.x) + (m[0][1] * V.y) + (m[0][2] * V.z)),
        ((m[1][0] * V.x) + (m[1][1] * V.y) + (m[1][2] * V.z)),
        ((m[2][0] * V.x) + (m[2][1] * V.y) + (m[2][2] * V.z))
        );
    }

    CIwSVec3 TransposeRotateVec(CIwSVec3 const &V) const
    {
        return CIwSVec3(
        IW_SFIXED_FROM_FLOAT_CAST((m[0][0] * V.x) + (m[0][1] * V.y) + (m[0][2] * V.z)),
        IW_SFIXED_FROM_FLOAT_CAST((m[1][0] * V.x) + (m[1][1] * V.y) + (m[1][2] * V.z)),
        IW_SFIXED_FROM_FLOAT_CAST((m[2][0] * V.x) + (m[2][1] * V.y) + (m[2][2] * V.z))
        );
    }
# 366 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat.h"
    CIwFVec3 TransposeTransformVec(CIwFVec3 const &V) const
    {
        return CIwFVec3(
            ((m[0][0] * (V.x-t.x)) + (m[0][1] * (V.y-t.y)) + (m[0][2] * (V.z-t.z))),
            ((m[1][0] * (V.x-t.x)) + (m[1][1] * (V.y-t.y)) + (m[1][2] * (V.z-t.z))),
            ((m[2][0] * (V.x-t.x)) + (m[2][1] * (V.y-t.y)) + (m[2][2] * (V.z-t.z)))
            );
    }


    float TransformVecX(CIwFVec3 const &V) const { return (((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z))) + t.x; }
    float TransformVecY(CIwFVec3 const &V) const { return (((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z))) + t.y; }
    float TransformVecZ(CIwFVec3 const &V) const { return (((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z))) + t.z; }
    float TransformVecX(float x, float y, float z) const { return (((m[0][0] * x) + (m[1][0] * y) + (m[2][0] * z))) + t.x; }
    float TransformVecY(float x, float y, float z) const { return (((m[0][1] * x) + (m[1][1] * y) + (m[2][1] * z))) + t.y; }
    float TransformVecZ(float x, float y, float z) const { return (((m[0][2] * x) + (m[1][2] * y) + (m[2][2] * z))) + t.z; }







    inline float RotateVecX(const CIwFVec3& V) const
    {
            return m[0][0] * V.x + m[1][0] * V.y + m[2][0] * V.z;
    }





    inline float RotateVecY(const CIwFVec3& V) const
    {
            return m[0][1] * V.x + m[1][1] * V.y + m[2][1] * V.z;
    }





    inline float RotateVecZ(const CIwFVec3& V) const
    {
            return m[0][2] * V.x + m[1][2] * V.y + m[2][2] * V.z;
    }







    CIwFMat GetTranspose() const
    {
        CIwFMat N;
        N.m[0][0] = m[0][0];
        N.m[1][0] = m[0][1];
        N.m[2][0] = m[0][2];
        N.m[0][1] = m[1][0];
        N.m[1][1] = m[1][1];
        N.m[2][1] = m[1][2];
        N.m[0][2] = m[2][0];
        N.m[1][2] = m[2][1];
        N.m[2][2] = m[2][2];


        N.t = CIwFVec3(0, 0, 0);
        return N;
    }
# 444 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat.h"
    inline void SetRotX(float r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][1] = m[0][2] = m[1][0] = m[2][0] = 0;
        m[0][0] = 1.0f;
        m[1][1] = m[2][2] = (float)cos(r);
        m[1][2] = -(m[2][1] = (float)sin(r));
    }







    inline void SetRotY(float r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][1] = m[1][2] = m[1][0] = m[2][1] = 0;
        m[1][1] = 1.0f;
        m[0][0] = m[2][2] = (float)cos(r);
        m[2][0] = -(m[0][2] = (float)sin(r));
    }







    inline void SetRotZ(float r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][2] = m[1][2] = m[2][0] = m[2][1] = 0;
        m[2][2] = 1.0f;
        m[0][0] = m[1][1] = (float)cos(r);
        m[0][1] = -(m[1][0] = (float)sin(r));
    }


    inline void PreRotateX(float r)
    {
        CIwFMat rx;
        rx.SetRotX(r, true, true);
        PreRotate(rx);
    }
    inline void PreRotateY(float r)
    {
        CIwFMat ry;
        ry.SetRotY(r, true, true);
        PreRotate(ry);
    }
    inline void PreRotateZ(float r)
    {
        CIwFMat rz;
        rz.SetRotZ(r, true, true);
        PreRotate(rz);
    }
    inline void PostRotateX(float r)
    {
        CIwFMat rx;
        rx.SetRotX(r, true, true);
        PostRotate(rx);
    }
    inline void PostRotateY(float r)
    {
        CIwFMat ry;
        ry.SetRotY(r, true, true);
        PostRotate(ry);
    }
    inline void PostRotateZ(float r)
    {
        CIwFMat rz;
        rz.SetRotZ(r, true, true);
        PostRotate(rz);
    }







    void SetAxisAngle(CIwFVec3 axis, float angle);






    void LookAt(const CIwFVec3& from, const CIwFVec3& to, const CIwFVec3& up)
    {

        CIwFVec3 vx, vy, vz;

        vz = (to - from).GetNormalised();
        vx = (up ^ vz);
        if (vx.IsZero())
            vx.x = 1.0f;
        else
            vx.Normalise();
        vy = (vz ^ vx);
        m[0][0] = vx.x; m[0][1] = vx.y; m[0][2] = vx.z;
        m[1][0] = vy.x; m[1][1] = vy.y; m[1][2] = vy.z;
        m[2][0] = vz.x; m[2][1] = vz.y; m[2][2] = vz.z;
    }







    CIwFMat operator * (CIwFMat const & M) const
    {
        CIwFMat N;
        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);
        N.m[0][2] = FindComponentFromBA(M,*this,0,2);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);
        N.m[1][2] = FindComponentFromBA(M,*this,1,2);

        N.m[2][0] = FindComponentFromBA(M,*this,2,0);
        N.m[2][1] = FindComponentFromBA(M,*this,2,1);
        N.m[2][2] = FindComponentFromBA(M,*this,2,2);

        N.t = M.TransformVec(t);

        ((void)0);


        return N;
    }







    CIwFMat & PreMult(CIwFMat const & M)
    {
        return (*this = M * (*this));
    }




    CIwFMat & PreMultiply(CIwFMat const & M)
    {
        ((void)0);
        return PreMult(M);
    }







    CIwFMat & PostMult(CIwFMat const & M)
    {
        return (*this = (*this) * M);
    }




    CIwFMat & PostMultiply(CIwFMat const & M)
    {
        ((void)0);
        return PostMult(M);
    }







    CIwFMat& operator *= (CIwFMat const & M)
    {
        return PostMult(M);
    }







    CIwFMat& PostRotate(CIwFMat const& M)
    {
        CIwFMat N;

        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);
        N.m[0][2] = FindComponentFromBA(M,*this,0,2);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);
        N.m[1][2] = FindComponentFromBA(M,*this,1,2);

        N.m[2][0] = FindComponentFromBA(M,*this,2,0);
        N.m[2][1] = FindComponentFromBA(M,*this,2,1);
        N.m[2][2] = FindComponentFromBA(M,*this,2,2);

        CopyRot(N);

        return *this;
    }






    CIwFMat PreRotate(CIwFMat const& M)
    {
        CIwFMat t = M;
        t.t = this->t;
        return (*this = t.PostRotate(*this));
    }







    CIwFMat& ScaleRot(float v)
    {
        for (int i=0; i<3; i++)
            for (int j=0; j<3; j++)
                m[i][j] = (m[i][j]*v);
        return *this;
    }






    CIwFMat& ScaleTrans(float v)
    {
        t *= v;
        return *this;
    }





    CIwFMat& Scale(float v)
    {
        ScaleRot(v);
        ScaleTrans(v);
        return *this;
    }






    CIwFMat& operator *= (const float v)
    {
        Scale(v);
        return *this;
    }
# 727 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat.h"
    void InterpRot(CIwFMat const & m0, CIwFMat const & m1, float fraction);


    void InterpolateRot(CIwFMat const & m0, CIwFMat const & m1, float fraction)
    {
        ((void)0);
        InterpRot(m0, m1, fraction);
    }
# 746 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat.h"
    void InterpTrans(CIwFMat const & m0, CIwFMat const & m1, float fraction);


    void InterpolatePos(CIwFMat const & m0, CIwFMat const & m1, float fraction)
    {

        ((void)0);
        InterpTrans(m0, m1, fraction);
    }






    void CopyRot(const CIwFMat& m0)
    {
        m[0][0] = m0.m[0][0];
        m[0][1] = m0.m[0][1];
        m[0][2] = m0.m[0][2];
        m[1][0] = m0.m[1][0];
        m[1][1] = m0.m[1][1];
        m[1][2] = m0.m[1][2];
        m[2][0] = m0.m[2][0];
        m[2][1] = m0.m[2][1];
        m[2][2] = m0.m[2][2];
    }





    void CopyTrans(const CIwFMat& m0)
    {
        t = m0.t;
    }







    bool IsRotSame(CIwFMat const& m0) const
    {
        return m[0][0] == m0.m[0][0] &&
        m[0][1] == m0.m[0][1] &&
        m[0][2] == m0.m[0][2] &&
        m[1][0] == m0.m[1][0] &&
        m[1][1] == m0.m[1][1] &&
        m[1][2] == m0.m[1][2] &&
        m[2][0] == m0.m[2][0] &&
        m[2][1] == m0.m[2][1] &&
        m[2][2] == m0.m[2][2];
    }






    bool IsTransSame(CIwFMat const& m0) const
    {
        return (t == m0.t);
    }






    bool operator == (CIwFMat const & m0) const
    {
        return IsRotSame(m0) && IsTransSame(m0);
    }







    bool operator != (CIwFMat const & m0) const
    {
        return !IsRotSame(m0) || !IsTransSame(m0);
    }



    bool IsRotIdentity() const
    {
        return IsRotSame(g_Identity);
    }


    bool IsTransIdentity() const
    {
        return IsTransSame(g_Identity);
    }


    bool IsIdentity() const
    {
        return (*this)==g_Identity;
    }


    void SetIdentity()
    {
        *this = g_Identity;
    }


    bool IsRotZero() const
    {
        return m[0][0] == 0 &&
        m[0][1] == 0 &&
        m[0][2] == 0 &&
        m[1][0] == 0 &&
        m[1][1] == 0 &&
        m[1][2] == 0 &&
        m[2][0] == 0 &&
        m[2][1] == 0 &&
        m[2][2] == 0;
    }


    bool IsTransZero() const
    {
        return t.x == 0 &&
        t.y == 0 &&
        t.z == 0;
    }


    bool IsZero() const
    {
        return IsRotZero() && IsTransZero();
    }


    void SetZero();


    void Zero()
    {
        ((void)0);
        SetZero();
    }
# 975 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat.h"
private:


    static inline float FindComponentFromBA(const CIwFMat& A, const CIwFMat& B, const int i, const int j)
    {
        return B.m[i][0]*A.m[0][j] + B.m[i][1]*A.m[1][j] + B.m[i][2]*A.m[2][j];

    }



};
# 998 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat.h"
inline CIwMat CIwFMat::ConvertToCIwMat()
    {
        return CIwMat(*this);
    }
# 1158 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat.h" 2


inline CIwFMat CIwMat::ConvertToCIwFMat()
    {
        return CIwFMat(*this);
    }
# 24 "c:/marmalade/6.2/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h" 1
       
# 35 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h"
class CIwFMat2D;
# 63 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h"
class CIwMat2D
{
public:



    iwfixed m[2][2];



    CIwVec2 t;




    static CIwMat2D g_Identity;




    CIwMat2D() {};





    explicit CIwMat2D(iwfixed f)
    {
        m[0][0] = m[1][1] = f;
        m[0][1] = m[1][0] = 0;
        t.x = t.y = 0;
    }






    explicit CIwMat2D(const CIwFMat2D & M);





    inline CIwFMat2D ConvertToCIwFMat2D();
# 116 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h"
    CIwMat2D(CIwMat2D const & R, CIwVec2 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        t = T;
    }







    CIwMat2D(CIwMat2D const & R, CIwSVec2 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        t = T;
    }






    void Serialise();





    void Normalise()
    {
        CIwVec2* pVecX = (CIwVec2*)&m[0][0];
        CIwVec2* pVecY = (CIwVec2*)&m[1][0];

        pVecX->Normalise();

        *pVecY = CIwVec2(-pVecX->y, pVecX->x);
    }




    void Transpose();





    CIwVec2 const & GetTrans() const
    {
        return t;
    }






    CIwMat2D & SetTrans(CIwVec2 const & v)
    {
        t = v;
        return *this;
    }






    CIwMat2D & SetTrans(CIwSVec2 const & v)
    {
        t = v;
        return *this;
    }






    CIwMat2D & operator += (CIwVec2 const & V)
    {
        t += V;
        return *this;
    }






    CIwMat2D & operator += (CIwSVec2 const & V)
    {
        t += V;
        return *this;
    }






    CIwMat2D operator + (CIwVec2 const & V) const
    {
        return CIwMat2D(*this, t+V);
    }






    CIwMat2D operator + (CIwSVec2 const & V) const
    {
        return CIwMat2D(*this, t+V);
    }







    CIwMat2D& operator <<= (int32 s)
    {
        m[0][0] <<= s; m[0][1] <<= s;
        m[1][0] <<= s; m[1][1] <<= s;
        t.x <<= s, t.y <<= s;
        return *this;
    }






    CIwMat2D& operator >>= (int32 s)
    {
        m[0][0] >>= s; m[0][1] >>= s;
        m[1][0] >>= s; m[1][1] >>= s;
        t.x >>= s, t.y >>= s;
        return *this;
    }





    CIwVec2 ColumnX() const
    {
        return CIwVec2(m[0][0], m[1][0]);
    }




    CIwVec2 ColumnY() const
    {
        return CIwVec2(m[0][1], m[1][1]);
    }







    CIwVec2 RowX() const
    {
        return CIwVec2(m[0][0], m[0][1]);
    }







    CIwVec2 RowY() const
    {
        return CIwVec2(m[1][0], m[1][1]);
    }







    CIwVec2 RotateVec(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2(m[0][0], m[1][0], V.x, V.y),
        IW_FIXED_MUL2(m[0][1], m[1][1], V.x, V.y)
        );
    }







    CIwSVec2 RotateVec(CIwSVec2 const &V) const
    {
        return CIwSVec2(
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL2(m[0][0], m[1][0], V.x, V.y)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL2(m[0][1], m[1][1], V.x, V.y))
        );
    }







    CIwVec2 RotateVecSafe(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2_SAFE(m[0][0], m[1][0], V.x, V.y),
        IW_FIXED_MUL2_SAFE(m[0][1], m[1][1], V.x, V.y)
        );
    }







    CIwVec2 TransformVec(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2(m[0][0], m[1][0], V.x, V.y) + t.x,
        IW_FIXED_MUL2(m[0][1], m[1][1], V.x, V.y) + t.y
        );
    }
# 368 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h"
    CIwVec2 TransformVec(CIwSVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2(m[0][0], m[1][0], V.x, V.y) + t.x,
        IW_FIXED_MUL2(m[0][1], m[1][1], V.x, V.y) + t.y
        );
    }
# 384 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h"
    CIwVec2 TransformVecShift(CIwSVec2 const &V, int32 shift) const
    {
        int32 lDotShift = 12 - shift;
        return CIwVec2(
        IW_MUL_2_SHIFT(m[0][0] >> shift, m[1][0] >> shift, V.x, V.y, lDotShift) + t.x,
        IW_MUL_2_SHIFT(m[0][1] >> shift, m[1][1] >> shift, V.x, V.y, lDotShift) + t.y
        );
    }
# 401 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h"
    CIwVec2 TransformVecSafe(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2_SAFE(m[0][0], m[1][0], V.x, V.y) + t.x,
        IW_FIXED_MUL2_SAFE(m[0][1], m[1][1], V.x, V.y) + t.y
        );
    }






    CIwVec2 TransformVecSafe(CIwSVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2_SAFE(m[0][0], m[1][0], V.x, V.y) + t.x,
        IW_FIXED_MUL2_SAFE(m[0][1], m[1][1], V.x, V.y) + t.y
        );
    }







    CIwVec2 TransposeRotateVec(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2(m[0][0], m[0][1], V.x, V.y),
        IW_FIXED_MUL2(m[1][0], m[1][1], V.x, V.y)
        );
    }







    CIwSVec2 TransposeRotateVec(CIwSVec2 const &V) const
    {
        return CIwSVec2(
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL2(m[0][0], m[0][1], V.x, V.y)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL2(m[1][0], m[1][1], V.x, V.y))
        );
    }







    CIwVec2 TransposeRotateVecSafe(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2_SAFE(m[0][0], m[0][1], V.x, V.y),
        IW_FIXED_MUL2_SAFE(m[1][0], m[1][1], V.x, V.y)
        );
    }
# 471 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h"
    CIwVec2 TransposeTransformVec(CIwVec2 const &V) const
    {
        return CIwVec2(
            IW_FIXED_MUL2(m[0][0], m[0][1], V.x-t.x, V.y-t.y),
            IW_FIXED_MUL2(m[1][0], m[1][1], V.x-t.x, V.y-t.y)
            );
    }
# 487 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h"
    iwfixed TransformVecX(CIwVec2 const &V) const { return ((IW_FIXED_MUL2(m[0][0],m[1][0],V.x,V.y)) + (t.x)); }
    iwfixed TransformVecY(CIwVec2 const &V) const { return ((IW_FIXED_MUL2(m[0][1],m[1][1],V.x,V.y)) + (t.y)); }
    iwfixed TransformVecX(iwsfixed x, iwsfixed y) const { return ((IW_FIXED_MUL2(m[0][0],m[1][0],x,y)) + (t.x)); }
    iwfixed TransformVecY(iwsfixed x, iwsfixed y) const { return ((IW_FIXED_MUL2(m[0][1],m[1][1],x,y)) + (t.y)); }
    iwfixed TransformVecX(iwfixed x, iwfixed y) const { return ((IW_FIXED_MUL2(m[0][0],m[1][0],x,y)) + (t.x)); }
    iwfixed TransformVecY(iwfixed x, iwfixed y) const { return ((IW_FIXED_MUL2(m[0][1],m[1][1],x,y)) + (t.y)); }







    inline iwfixed RotateVecX(const CIwVec2& V)
    {
            return IW_FIXED_MUL(m[0][0], V.x) + IW_FIXED_MUL(m[1][0], V.y);
    }





    inline iwfixed RotateVecY(const CIwVec2& V)
    {
            return IW_FIXED_MUL(m[0][1], V.x) + IW_FIXED_MUL(m[1][1], V.y);
    }






    inline iwsfixed RotateVecX(const CIwSVec2& V)
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][0], V.x) + IW_FIXED_MUL(m[1][0], V.y));
    }





    inline iwsfixed RotateVecY(const CIwSVec2& V)
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][1], V.x) + IW_FIXED_MUL(m[1][1], V.y));
    }





    CIwMat2D GetTranspose() const
    {
        CIwMat2D N;
        N.m[0][0] = m[0][0];
        N.m[1][0] = m[0][1];
        N.m[0][1] = m[1][0];
        N.m[1][1] = m[1][1];


        N.t = CIwVec2(0, 0);
        return N;
    }







    inline void SetRot(iwangle r = 0, bool resetTrans = true)
    {
        if (resetTrans) t.x = t.y = 0;
        m[0][0] = m[1][1] = IwGeomCos(-r);
        m[0][1] = -(m[1][0] = IwGeomSin(-r));
    }






    inline void SetRot(iwangle r, const CIwVec2& centre)
    {
        m[0][0] = m[1][1] = IwGeomCos(-r);
        m[0][1] = -(m[1][0] = IwGeomSin(-r));
        t = centre - RotateVec(centre);
    }


    inline void PreRotate(iwangle r)
    {
        CIwMat2D rz;
        rz.SetRot(r, true);
        PreRotate(rz);
    }
    inline void PostRotate(iwangle r)
    {
        CIwMat2D rz;
        rz.SetRot(r, true);
        PostRotate(rz);
    }







    CIwMat2D operator * (CIwMat2D const & M) const
    {
        CIwMat2D N;
        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);

        N.t = M.TransformVec(t);

        ((void)0);


        return N;
    }







    CIwMat2D & PreMult(CIwMat2D const & M)
    {
        return (*this = M * (*this));
    }




    CIwMat2D & PreMultiply(CIwMat2D const & M)
    {
        ((void)0);
        return PreMult(M);
    }







    CIwMat2D & PostMult(CIwMat2D const & M)
    {
        return (*this = (*this) * M);
    }




    CIwMat2D & PostMultiply(CIwMat2D const & M)
    {
        ((void)0);
        return PostMult(M);
    }







    CIwMat2D& operator *= (CIwMat2D const & M)
    {
        return PostMult(M);
    }







    CIwMat2D& PostRotate(CIwMat2D const& M)
    {
        CIwMat2D N;

        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);

        CopyRot(N);

        return *this;
    }






    CIwMat2D PreRotate(CIwMat2D const& M)
    {
        CIwMat2D t = M;
        t.t = this->t;
        return (*this = t.PostRotate(*this));
    }







    CIwMat2D& ScaleRot(iwfixed v)
    {
        for (int i=0; i<2; i++)
            for (int j=0; j<2; j++)
                m[i][j] = IW_FIXED_MUL(m[i][j],v);
        return *this;
    }






    CIwMat2D& ScaleTrans(iwfixed v)
    {
        t *= v;
        return *this;
    }





    CIwMat2D& Scale(iwfixed v)
    {
        ScaleRot(v);
        ScaleTrans(v);
        return *this;
    }






    CIwMat2D& operator *= (const iwfixed v)
    {
        Scale(v);
        return *this;
    }
# 753 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h"
    void InterpRot(CIwMat2D const & m0, CIwMat2D const & m1, iwfixed fraction);


    void InterpolateRot(CIwMat2D const & m0, CIwMat2D const & m1, iwfixed fraction)
    {
        ((void)0);
        InterpRot(m0, m1, fraction);
    }
# 772 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h"
    void InterpTrans(CIwMat2D const & m0, CIwMat2D const & m1, iwfixed fraction);


    void InterpolatePos(CIwMat2D const & m0, CIwMat2D const & m1, iwfixed fraction)
    {

        ((void)0);
        InterpTrans(m0, m1, fraction);
    }






    void CopyRot(const CIwMat2D& m0)
    {
        m[0][0] = m0.m[0][0];
        m[0][1] = m0.m[0][1];
        m[1][0] = m0.m[1][0];
        m[1][1] = m0.m[1][1];
    }





    void CopyTrans(const CIwMat2D& m0)
    {
        t = m0.t;
    }







    bool IsRotSame(CIwMat2D const& m0) const
    {
        return m[0][0] == m0.m[0][0] &&
        m[0][1] == m0.m[0][1] &&
        m[1][0] == m0.m[1][0] &&
        m[1][1] == m0.m[1][1];
    }






    bool IsTransSame(CIwMat2D const& m0) const
    {
        return (t == m0.t);
    }






    bool operator == (CIwMat2D const & m0) const
    {
        return IsRotSame(m0) && IsTransSame(m0);
    }







    bool operator != (CIwMat2D const & m0) const
    {
        return !IsRotSame(m0) || !IsTransSame(m0);
    }



    bool IsRotIdentity()
    {
        return IsRotSame(g_Identity);
    }


    bool IsTransIdentity()
    {
        return IsTransSame(g_Identity);
    }


    bool IsIdentity()
    {
        return (*this)==g_Identity;
    }


    void SetIdentity()
    {
        *this = g_Identity;
    }


    bool IsRotZero()
    {
        return m[0][0] == 0 &&
        m[0][1] == 0 &&
        m[1][0] == 0 &&
        m[1][1] == 0;
    }


    bool IsTransZero()
    {
        return t.x == 0 &&
        t.y == 0;
    }


    bool IsZero()
    {
        return IsRotZero() && IsTransZero();
    }


    void SetZero();


    void Zero()
    {
        ((void)0);
        SetZero();
    }

    iwfixed GetDeterminant() const
    {
        return IW_FIXED_MUL(m[0][0], m[1][1]) - IW_FIXED_MUL(m[0][1], m[1][0]);
    }




    CIwMat2D GetInverse() const;
# 930 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h"
private:


    static inline iwfixed FindComponentFromBA(const CIwMat2D& A, const CIwMat2D& B, const int i, const int j)
    {
# 947 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h"
        return (B.m[i][0]*A.m[0][j] + B.m[i][1]*A.m[1][j]) >> 12;
    }



};
# 961 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h"
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat2D.h" 1
       
# 35 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat2D.h"
class CIwMat2D;
# 63 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat2D.h"
class CIwFMat2D
{
public:



    float m[2][2];



    CIwFVec2 t;




    static CIwFMat2D g_Identity;




    CIwFMat2D() {};





    explicit CIwFMat2D(float f)
    {
        m[0][0] = m[1][1] = f;
        m[0][1] = m[1][0] = 0;
        t.x = t.y = 0;
    }






    explicit CIwFMat2D(const CIwMat2D & M);





    inline CIwMat2D ConvertToCIwMat2D();
# 116 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFMat2D(CIwFMat2D const & R, CIwFVec2 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        t = T;
    }







    void Serialise();





    void Normalise()
    {
        CIwFVec2* pVecX = (CIwFVec2*)&m[0][0];
        CIwFVec2* pVecY = (CIwFVec2*)&m[1][0];

        pVecX->Normalise();

        *pVecY = CIwFVec2(-pVecX->y, pVecX->x);
    }




    void Transpose();





    CIwFVec2 const & GetTrans() const
    {
        return t;
    }






    CIwFMat2D & SetTrans(CIwFVec2 const & v)
    {
        t = v;
        return *this;
    }







    CIwFMat2D & operator += (CIwFVec2 const & V)
    {
        t += V;
        return *this;
    }







    CIwFMat2D operator + (CIwFVec2 const & V) const
    {
        return CIwFMat2D(*this, t+V);
    }
# 203 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFVec2 ColumnX() const
    {
        return CIwFVec2(m[0][0], m[1][0]);
    }




    CIwFVec2 ColumnY() const
    {
        return CIwFVec2(m[0][1], m[1][1]);
    }







    CIwFVec2 RowX() const
    {
        return CIwFVec2(m[0][0], m[0][1]);
    }







    CIwFVec2 RowY() const
    {
        return CIwFVec2(m[1][0], m[1][1]);
    }






    CIwFVec2 RotateVec(CIwFVec2 const &V) const
    {
        return CIwFVec2(
        ((m[0][0] * V.x) + (m[1][0] * V.y)),
        ((m[0][1] * V.x) + (m[1][1] * V.y))
        );
    }
# 258 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFVec2 TransformVec(CIwFVec2 const &V) const
    {
        return CIwFVec2(
        ((m[0][0] * V.x) + (m[1][0] * V.y)) + t.x,
        ((m[0][1] * V.x) + (m[1][1] * V.y)) + t.y
        );
    }
# 273 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFVec2 TransposeRotateVec(CIwFVec2 const &V) const
    {
        return CIwFVec2(
        ((m[0][0] * V.x) + (m[0][1] * V.y)),
        ((m[1][0] * V.x) + (m[1][1] * V.y))
        );
    }
# 289 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFVec2 TransposeTransformVec(CIwFVec2 const &V) const
    {
        return CIwFVec2(
            ((m[0][0] * (V.x-t.x)) + (m[0][1] * (V.y-t.y))),
            ((m[1][0] * (V.x-t.x)) + (m[1][1] * (V.y-t.y)))
            );
    }


    float TransformVecX(CIwFVec2 const &V) const { return (((m[0][0] * V.x) + (m[1][0] * V.y))) + t.x; }
    float TransformVecY(CIwFVec2 const &V) const { return (((m[0][1] * V.x) + (m[1][1] * V.y))) + t.y; }
    float TransformVecX(float x, float y) const { return (((m[0][0] * x) + (m[1][0] * y))) + t.x; }
    float TransformVecY(float x, float y) const { return (((m[0][1] * x) + (m[1][1] * y))) + t.y; }







    inline float RotateVecX(const CIwFVec2& V)
    {
            return m[0][0] * V.x + m[1][0] * V.y;
    }





    inline float RotateVecY(const CIwFVec2& V)
    {
            return m[0][1] * V.x + m[1][1] * V.y;
    }






    CIwFMat2D GetTranspose() const
    {
        CIwFMat2D N;
        N.m[0][0] = m[0][0];
        N.m[1][0] = m[0][1];
        N.m[0][1] = m[1][0];
        N.m[1][1] = m[1][1];


        N.t = CIwFVec2(0, 0);
        return N;
    }







    inline void SetRot(float r = 0, bool resetTrans = true)
    {
        if (resetTrans) t.x = t.y = 0;
        m[0][0] = m[1][1] = (float)cos(-r);
        m[0][1] = -(m[1][0] = (float)sin(-r));
    }






    inline void SetRot(float r, const CIwFVec2& centre)
    {
        m[0][0] = m[1][1] = (float)cos(-r);
        m[0][1] = -(m[1][0] = (float)sin(-r));
        t = centre - RotateVec(centre);
    }


    inline void PreRotate(float r)
    {
        CIwFMat2D rz;
        rz.SetRot(r, true);
        PreRotate(rz);
    }
    inline void PostRotate(float r)
    {
        CIwFMat2D rz;
        rz.SetRot(r, true);
        PostRotate(rz);
    }







    CIwFMat2D operator * (CIwFMat2D const & M) const
    {
        CIwFMat2D N;
        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);

        N.t = M.TransformVec(t);

        ((void)0);


        return N;
    }







    CIwFMat2D & PreMult(CIwFMat2D const & M)
    {
        return (*this = M * (*this));
    }




    CIwFMat2D & PreMultiply(CIwFMat2D const & M)
    {
        ((void)0);
        return PreMult(M);
    }







    CIwFMat2D & PostMult(CIwFMat2D const & M)
    {
        return (*this = (*this) * M);
    }




    CIwFMat2D & PostMultiply(CIwFMat2D const & M)
    {
        ((void)0);
        return PostMult(M);
    }







    CIwFMat2D& operator *= (CIwFMat2D const & M)
    {
        return PostMult(M);
    }







    CIwFMat2D& PostRotate(CIwFMat2D const& M)
    {
        CIwFMat2D N;

        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);

        CopyRot(N);

        return *this;
    }






    CIwFMat2D PreRotate(CIwFMat2D const& M)
    {
        CIwFMat2D t = M;
        t.t = this->t;
        return (*this = t.PostRotate(*this));
    }







    CIwFMat2D& ScaleRot(float v)
    {
        for (int i=0; i<2; i++)
            for (int j=0; j<2; j++)
                m[i][j] = (m[i][j]*v);
        return *this;
    }






    CIwFMat2D& ScaleTrans(float v)
    {
        t *= v;
        return *this;
    }





    CIwFMat2D& Scale(float v)
    {
        ScaleRot(v);
        ScaleTrans(v);
        return *this;
    }






    CIwFMat2D& operator *= (const float v)
    {
        Scale(v);
        return *this;
    }
# 544 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat2D.h"
    void InterpRot(CIwFMat2D const & m0, CIwFMat2D const & m1, float fraction);


    void InterpolateRot(CIwFMat2D const & m0, CIwFMat2D const & m1, float fraction)
    {
        ((void)0);
        InterpRot(m0, m1, fraction);
    }
# 563 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat2D.h"
    void InterpTrans(CIwFMat2D const & m0, CIwFMat2D const & m1, float fraction);


    void InterpolatePos(CIwFMat2D const & m0, CIwFMat2D const & m1, float fraction)
    {

        ((void)0);
        InterpTrans(m0, m1, fraction);
    }






    void CopyRot(const CIwFMat2D& m0)
    {
        m[0][0] = m0.m[0][0];
        m[0][1] = m0.m[0][1];
        m[1][0] = m0.m[1][0];
        m[1][1] = m0.m[1][1];
    }





    void CopyTrans(const CIwFMat2D& m0)
    {
        t = m0.t;
    }







    bool IsRotSame(CIwFMat2D const& m0) const
    {
        return m[0][0] == m0.m[0][0] &&
        m[0][1] == m0.m[0][1] &&
        m[1][0] == m0.m[1][0] &&
        m[1][1] == m0.m[1][1];
    }






    bool IsTransSame(CIwFMat2D const& m0) const
    {
        return (t == m0.t);
    }






    bool operator == (CIwFMat2D const & m0) const
    {
        return IsRotSame(m0) && IsTransSame(m0);
    }







    bool operator != (CIwFMat2D const & m0) const
    {
        return !IsRotSame(m0) || !IsTransSame(m0);
    }



    bool IsRotIdentity()
    {
        return IsRotSame(g_Identity);
    }


    bool IsTransIdentity()
    {
        return IsTransSame(g_Identity);
    }


    bool IsIdentity()
    {
        return (*this)==g_Identity;
    }


    void SetIdentity()
    {
        *this = g_Identity;
    }


    bool IsRotZero()
    {
        return m[0][0] == 0 &&
        m[0][1] == 0 &&
        m[1][0] == 0 &&
        m[1][1] == 0;
    }


    bool IsTransZero()
    {
        return t.x == 0 &&
        t.y == 0;
    }


    bool IsZero()
    {
        return IsRotZero() && IsTransZero();
    }


    void SetZero();


    void Zero()
    {
        ((void)0);
        SetZero();
    }

    float GetDeterminant() const
    {
        return m[0][0] * m[1][1] - m[0][1] * m[1][0];
    }




    CIwFMat2D GetInverse() const;
# 779 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat2D.h"
private:


    static inline float FindComponentFromBA(const CIwFMat2D& A, const CIwFMat2D& B, const int i, const int j)
    {
        return B.m[i][0]*A.m[0][j] + B.m[i][1]*A.m[1][j];

    }



};
# 802 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFMat2D.h"
inline CIwMat2D CIwFMat2D::ConvertToCIwMat2D()
    {
        return CIwMat2D(*this);
    }
# 962 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomMat2D.h" 2


inline CIwFMat2D CIwMat2D::ConvertToCIwFMat2D()
    {
        return CIwFMat2D(*this);
    }
# 25 "c:/marmalade/6.2/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomPlane.h" 1
       
# 51 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomPlane.h"
class CIwPlane
{
public:




    CIwSVec3 v;
    int16 padding;





    int32 k;





    static CIwPlane g_YZ;



    static CIwPlane g_XZ;



    static CIwPlane g_XY;




    CIwPlane() {};





    CIwPlane(CIwSVec3 const & _v, int32 vk) : v(_v), k(vk) {};





    CIwPlane(CIwSVec3 const & _v, CIwVec3 const & vk)
    {
        v = _v;
        if (!v.IsZero())
            v.NormaliseSafe();
        k = v * vk;
    }





    CIwPlane(CIwSVec3 const & _v, CIwSVec3 const & vk)
    {
        v = _v;
        if (!v.IsZero())
            v.NormaliseSafe();
        k = v * vk;
    }






    CIwPlane(CIwVec3 const & _a, CIwVec3 const & _b, CIwVec3 const & _c)
    {
        v = ( (_a-_b)^(_c-_a) );
        if (!v.IsZero())
            v.Normalise();
        k = v * _a;
    }






    CIwPlane(CIwSVec3 const & _a, CIwSVec3 const & _b, CIwSVec3 const & _c)
    {
        v = ( (_a-_b)^(_c-_a) );
        if (!v.IsZero())
            v.Normalise();
        k = v * _a;
    }
# 150 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomPlane.h"
    int32 GetPerpDist(CIwVec3 const & a) const
    {
        return v * a - k;
    }





    CIwPlane operator - () const
    {
        return CIwPlane(-v,-k);
    }





    bool operator == (CIwPlane const & p) const
    {
        return k==p.k && v==p.v;
    }
};
# 26 "c:/marmalade/6.2/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomQuat.h" 1
       
# 29 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomQuat.h"
static inline iwqfixed iwqfixed_mul30to13(iwqfixed a, iwqfixed b) {






    return (((a>>16)*(b>>16))>>15);
}
# 56 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomQuat.h"
class CIwQuat
{
public:



    iwqfixed s,
                x, y, z;




    static CIwQuat g_Identity;




    CIwQuat():x(0),y(0),z(0),s((1 << 30)) {}





    CIwQuat(iwqfixed s,iwqfixed x,iwqfixed y,iwqfixed z):x(x),y(y),z(z),s(s) {}







    CIwQuat(CIwMat const &mat);






    CIwQuat(iwqfixed s):x(0),y(0),z(0),s(s) {}






    CIwQuat(CIwVec3 const& v, iwqangle theta){
        CIwVec3 vn = v.GetNormalised();
        SetAxisAngle(vn.x<<(30 - 12), vn.y<<(30 - 12), vn.z<<(30 - 12), theta);
    }





    void Serialise()
    {
        IwSerialiseInt32(s, 4);
    }






    bool operator == (CIwQuat const &q) const {
        return (x == q.x && y == q.y && z == q.z && s == q.s);
    }






    bool operator != (CIwQuat const &q) const {
        return !(*this == q);
    }
# 140 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomQuat.h"
    void SetAxisAngle(iwqfixed x, iwqfixed y, iwqfixed z, iwqangle theta);





    iwqfixed GetLengthSquared() const;





    iwqfixed GetLength() const;







    CIwQuat operator * (CIwQuat const & q) const {
        return CIwQuat (IW_QFIXED_MUL_SAFE(s, q.s) - (IW_QFIXED_MUL_SAFE(q.x, x) + IW_QFIXED_MUL_SAFE(q.y, y) + IW_QFIXED_MUL_SAFE(q.z, z)),
            IW_QFIXED_MUL_SAFE(s, q.x) + IW_QFIXED_MUL_SAFE(q.s, x) + IW_QFIXED_MUL_SAFE(y, q.z) - IW_QFIXED_MUL_SAFE(z, q.y),
            IW_QFIXED_MUL_SAFE(s, q.y) + IW_QFIXED_MUL_SAFE(q.s, y) + IW_QFIXED_MUL_SAFE(z, q.x) - IW_QFIXED_MUL_SAFE(x, q.z),
            IW_QFIXED_MUL_SAFE(s, q.z) + IW_QFIXED_MUL_SAFE(q.s, z) + IW_QFIXED_MUL_SAFE(x, q.y) - IW_QFIXED_MUL_SAFE(y, q.x)
            );
    }






    CIwQuat operator << (const int c) const {
        return CIwQuat(s<<c, x<<c, y<<c, z<<c);
    }






    CIwQuat operator >> (const int c) const {
        return CIwQuat(s>>c, x>>c, y>>c, z>>c);
    }
# 193 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomQuat.h"
    CIwVec3 RotateVector (CIwVec3 const &v) const {


        int64 qxvx = (((int64)v.y * z) - ((int64)v.z * y)) >> (12 -1),
                    qxvy = (((int64)v.z * x) - ((int64)v.x * z)) >> (12 -1),
                    qxvz = (((int64)v.x * y) - ((int64)v.y * x)) >> (12 -1);

        int64 qxqxvx = (((int64)qxvy * z) - ((int64)qxvz * y)) >> (30 + (30 - 12)),
                  qxqxvy = (((int64)qxvz * x) - ((int64)qxvx * z)) >> (30 + (30 - 12)),
                  qxqxvz = (((int64)qxvx * y) - ((int64)qxvy * x)) >> (30 + (30 - 12));

        return CIwVec3(
            (int32)(v.x + ((s*qxvx) >> ((30 - 12) + 30)) + qxqxvx),
            (int32)(v.y + ((s*qxvy) >> ((30 - 12) + 30)) + qxqxvy),
            (int32)(v.z + ((s*qxvz) >> ((30 - 12) + 30)) + qxqxvz));

      }





    CIwQuat operator - () const {
        return CIwQuat(s, -x, -y, -z);
    }





    CIwQuat &NormaliseInPlace() {
        iwqfixed l = GetLengthSquared();

        ((void)0);
        if (l == 0) return *this;





        if (l < 0x3FE00000 || l > 0x40200000) {
            int64 recip = (((int64)1 << (30 << 1)) >> 2) / IW_GEOM_QSQRT(l);
            ((void)0);
            ((void)0);

            s = IW_QFIXED_MUL_SAFE(s, (iwqfixed)recip)<<2;
            x = IW_QFIXED_MUL_SAFE(x, (iwqfixed)recip)<<2;
            y = IW_QFIXED_MUL_SAFE(y, (iwqfixed)recip)<<2;
            z = IW_QFIXED_MUL_SAFE(z, (iwqfixed)recip)<<2;

        }

        return *this;
    }





    CIwVec3 GetRotationAxis(){
        CIwVec3 v(x>>(30 - 12),y>>(30 - 12),z>>(30 - 12));
        v.Normalise();
        return v;
    }





    iwqangle GetRotationAngle(){
        return IwGeomQACos (s) * 2;
    }




    CIwQuat operator * (iwqfixed const l) const {
        return CIwQuat (
            IW_QFIXED_MUL_SAFE((l<<(30 - 12)), s),
            IW_QFIXED_MUL_SAFE((l<<(30 - 12)), x),
            IW_QFIXED_MUL_SAFE((l<<(30 - 12)), y),
            IW_QFIXED_MUL_SAFE((l<<(30 - 12)), z));
    }






    CIwQuat operator + (CIwQuat const & q) const {






        return CIwQuat(s + q.s, x + q.x, y + q.y, z + q.z);
    }






    CIwQuat operator - (CIwQuat const & q) const {






        return CIwQuat(s - q.s, x - q.x, y - q.y, z - q.z);
    }






    CIwQuat &operator = (CIwQuat const &q) {
        s = q.s;
        x = q.x;
        y = q.y;
        z = q.z;
        return *this;
    }





    operator CIwMat() const {
        CIwMat m;

        iwqfixed x2 = iwqfixed_mul30to13(x,x),
                    y2 = iwqfixed_mul30to13(y,y),
                    z2 = iwqfixed_mul30to13(z,z),
                    xy = iwqfixed_mul30to13(x,y),
                    yz = iwqfixed_mul30to13(y,z),
                    xz = iwqfixed_mul30to13(x,z),
                    wx = iwqfixed_mul30to13(s,x),
                    wy = iwqfixed_mul30to13(s,y),
                    wz = iwqfixed_mul30to13(s,z);



        m.m[0][0] = (1 << 12) - y2 - z2;
        m.m[1][1] = (1 << 12) - x2 - z2;
        m.m[2][2] = (1 << 12) - x2 - y2;
        m.m[1][0] = xy - wz;
        m.m[2][0] = xz + wy;
        m.m[0][1] = xy + wz;
        m.m[2][1] = yz - wx;
        m.m[0][2] = xz - wy;
        m.m[1][2] = yz + wx;

        m.t.x = m.t.y = m.t.z = 0;
        return m;
    }
# 361 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomQuat.h"
    void Lerp(const CIwQuat &startQ, const CIwQuat &endQ, iwfixed const t);
# 371 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomQuat.h"
    void Slerp(const CIwQuat &startQ, const CIwQuat &endQ, iwfixed const t);
};
# 27 "c:/marmalade/6.2/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSphere.h" 1
       
# 53 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSphere.h"
template <class V, class R>
class CIwSphereT
{
public:




    V t;




    R r;

    uint32 r2;




    CIwSphereT() {};





    CIwSphereT(V const & _t, R _r) : t(_t)
    {
        SetRadius(_r);
    };





    void Serialise();
# 97 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSphere.h"
    inline void SetRadius(R _r)
    {
        r = _r;
        r2 = ((r) * (r));
    };






    inline uint32 GetRadius() const
    {
        return r;
    };




    inline V const & GetTrans() const
    {
        return t;
    };
# 128 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSphere.h"
    template <class V2>
    void BoundVecs(V2* pVec, uint32 v)
    {
        ((void)0);


        t.x = t.y = t.z = 0;
        uint32 v2 = v;
        V2* pVec2 = pVec;
        while(v2--)
            t += *pVec2++;


        t = t / ((iwfixed)((v) * (1 << 12)));
        r = 0;
        while(v--)
        {


            CIwVec3 dv(*pVec);
            dv -= t;
            r = (((r) > ((int32)dv.GetLengthSafe())) ? (r) : ((int32)dv.GetLengthSafe()));
            pVec++;
        }


        r2 = ((r) * (r));
    }







    inline bool ClipToPlane(const CIwPlane& plane)
    {
        int32 dot = t * plane.v;
        int32 dotk = dot - plane.k;
        return dotk >= (int32)r;
    }
# 180 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSphere.h"
    bool ClipToFrustrum(CIwPlane* pPlanes, uint32 clipFlags)
    {
        ((void)0);
        while(clipFlags != 0)
        {
            if (
                (clipFlags & 0x1) &&
                (ClipToPlane(*pPlanes) == true)
                )

                return true;

            pPlanes++;
            clipFlags >>= 1;
        }

        return false;
    }
# 208 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSphere.h"
    iwufixed GetDistSqFromLine(const CIwVec3& point, const CIwVec3& dir) const
    {
        CIwVec3 delta = t-point;
        uint32 hyp2 = delta.GetLengthSquaredSafe();
        iwfixed adj = dir*(delta);
        iwufixed adj2 = IW_FIXED_MUL_SAFE(adj,adj);
        iwufixed perpdist2 = hyp2-adj2;
        return perpdist2;
    }
# 226 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomSphere.h"
    bool IntersectsLine(CIwVec3& point, CIwVec3& dir)
    {
        iwufixed r2_proper = IW_FIXED_MUL_SAFE(r,r);
        return GetDistSqFromLine(point,dir) <= r2_proper;
    }







    template <class V2>
    bool ContainsVec(const V2& v) const
    {
        return (v - t).GetLengthSafe() < r;
    }
};





typedef CIwSphereT<CIwVec3, iwfixed> CIwSphere;





typedef CIwSphereT<CIwSVec3, iwsfixed> CIwSSphere;
# 28 "c:/marmalade/6.2/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomBBox.h" 1
       
# 26 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomBBox.h"
class CIwMat;
# 54 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomBBox.h"
template <class V>
class CIwBBoxT
{
public:




    V m_Min;





    V m_Max;




    CIwBBoxT() {};
# 82 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomBBox.h"
    CIwBBoxT(const V& _min, const V& _max) : m_Min(_min), m_Max(_max) {};





    void Serialise();





    V GetCentre() { return m_Min + (m_Max - m_Min) / ((iwfixed)((2) * (1 << 12))); }





    template <class V2>
    void BoundVec(V2* pVec)
    {
        m_Min.x = (((m_Min.x) < (pVec->x)) ? (m_Min.x) : (pVec->x));
        m_Min.y = (((m_Min.y) < (pVec->y)) ? (m_Min.y) : (pVec->y));
        m_Min.z = (((m_Min.z) < (pVec->z)) ? (m_Min.z) : (pVec->z));
        m_Max.x = (((m_Max.x) > (pVec->x)) ? (m_Max.x) : (pVec->x));
        m_Max.y = (((m_Max.y) > (pVec->y)) ? (m_Max.y) : (pVec->y));
        m_Max.z = (((m_Max.z) > (pVec->z)) ? (m_Max.z) : (pVec->z));
    }
# 119 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomBBox.h"
    template <class V2>
    void BoundVecs(V2* pVec, uint32 v)
    {
        ((void)0);

        m_Min = V(0x7fff, 0x7fff, 0x7fff);
        m_Max = V((-0x7fff - 1), (-0x7fff - 1), (-0x7fff - 1));
        while(v--)
        {
            BoundVec(pVec);
            pVec++;
        }
    }
# 141 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomBBox.h"
    template <class V2>
    bool ContainsVec(const V2& v, CIwMat* pMat = __null) const
    {
        if (pMat)
        {
            CIwVec3 dv = v - pMat->t;
            int32 lx, ly, lz;
            lx = pMat->RotateVecX(dv);
            if ((lx >= m_Min.x) && (lx <= m_Max.x))
            {
                ly = pMat->RotateVecY(dv);
                if ((ly >= m_Min.y) && (ly <= m_Max.y))
                {
                    lz = pMat->RotateVecZ(dv);
                    if ((lz >= m_Min.z) && (lz <= m_Max.z))
                        return true;
                }
            }
        }
        else
        {
            if (
                (v.x >= m_Min.x) && (v.x <= m_Max.x) &&
                (v.y >= m_Min.y) && (v.y <= m_Max.y) &&
                (v.z >= m_Min.z) && (v.z <= m_Max.z)
                )
                return true;
        }
        return false;
    }
};





typedef CIwBBoxT<CIwSVec3> CIwSBBox;





typedef CIwBBoxT<CIwVec3> CIwBBox;
# 29 "c:/marmalade/6.2/modules/iwgeom/h/IwGeom.h" 2
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomIntersect.h" 1
       
# 40 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomIntersect.h"
extern int32 IW_GEOM_INTERSECT_EPSILON;
# 56 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLinePlane( const CIwVec3& vFrom,
                                const CIwVec3& vFromTo,
                                const CIwPlane& plane,
                                int32& f,
                                bool finite = true);
# 76 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLineSegPlaneOneSided(const CIwVec3& vOrg,
                                        const CIwVec3& vDirn,
                                        const CIwPlane& plane,
                                        int32& f,
                                        bool finite = true);
# 91 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLineSphere( const CIwVec3& vOrg,
                                const CIwVec3& vDirn,
                                const CIwSphere& sphere);
# 111 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLineTriNorm( const CIwVec3& vOrg,
                                const CIwVec3& vDirn,
                                const CIwVec3& v0,
                                const CIwVec3& v1,
                                const CIwVec3& v2,
                                const CIwSVec3& norm,
                                int32& f,
                                bool finite = true);
# 136 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLineLine2D( const CIwVec2& p1, const CIwVec2& dir1,
                                const CIwVec2& p2, const CIwVec2& dir2,
                                CIwVec2& collpt,
                                iwfixed& t1,
                                iwfixed& t2,
                                bool finite = true);
# 151 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectSphereSphere(const CIwSphere& s0, const CIwSphere& s1);
# 30 "c:/marmalade/6.2/modules/iwgeom/h/IwGeom.h" 2


# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFIntersect.h" 1
       
# 33 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFIntersect.h"
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFPlane.h" 1
       
# 45 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFPlane.h"
class CIwFPlane
{
public:




    CIwFVec3 v;
    int16 padding;





    float k;





    static CIwFPlane g_YZ;



    static CIwFPlane g_XZ;



    static CIwFPlane g_XY;




    CIwFPlane() {};





    CIwFPlane(CIwFVec3 const & _v, float vk) : v(_v), k(vk) {};





    CIwFPlane(CIwFVec3 const & _v, CIwFVec3 const & vk)
    {
        v = _v;
        if (!v.IsZero())
            v.Normalise();
        k = v * vk;
    }






    CIwFPlane(CIwFVec3 const & _a, CIwFVec3 const & _b, CIwFVec3 const & _c)
    {
        v = ( (_a - _b) ^ (_c - _a) );
        if (!v.IsZero())
            v.Normalise();
        k = v * _a;
    }
# 120 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFPlane.h"
    float GetPerpDist(CIwFVec3 const & a) const
    {
        return v * a - k;
    }





    CIwFPlane operator - () const
    {
        return CIwFPlane(-v, -k);
    }





    bool operator == (CIwFPlane const & p) const
    {
        return k == p.k && v == p.v;
    }
};
# 34 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFIntersect.h" 2
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFSphere.h" 1
# 21 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFSphere.h"
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFBBox.h" 1
       
# 22 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFBBox.h"
class CIwFMat;





class CIwFBBox
{
public:

    CIwFVec3 minV;
    CIwFVec3 maxV;


    CIwFBBox() {};
    CIwFBBox(const CIwFVec3& _min, const CIwFVec3& _max) : minV(_min), maxV(_max) {};


    CIwFVec3 GetCentre() { return minV + (maxV - minV) / 2; }


    inline void BoundVec(CIwFVec3* pVec)
    {
        minV.x = (((minV.x) < (pVec->x)) ? (minV.x) : (pVec->x));
        minV.y = (((minV.y) < (pVec->y)) ? (minV.y) : (pVec->y));
        minV.z = (((minV.z) < (pVec->z)) ? (minV.z) : (pVec->z));
        maxV.x = (((maxV.x) > (pVec->x)) ? (maxV.x) : (pVec->x));
        maxV.y = (((maxV.y) > (pVec->y)) ? (maxV.y) : (pVec->y));
        maxV.z = (((maxV.z) > (pVec->z)) ? (maxV.z) : (pVec->z));
    }


    void BoundVecs(CIwFVec3* pVec, uint32 v)
    {
        ((void)0);

        minV = CIwFVec3(3.402823466e+38F, 3.402823466e+38F, 3.402823466e+38F);
        maxV = CIwFVec3(-3.402823466e+38F, -3.402823466e+38F, -3.402823466e+38F);
        while(v--)
        {

            minV.x = (((minV.x) < (pVec->x)) ? (minV.x) : (pVec->x));
            minV.y = (((minV.y) < (pVec->y)) ? (minV.y) : (pVec->y));
            minV.z = (((minV.z) < (pVec->z)) ? (minV.z) : (pVec->z));
            maxV.x = (((maxV.x) > (pVec->x)) ? (maxV.x) : (pVec->x));
            maxV.y = (((maxV.y) > (pVec->y)) ? (maxV.y) : (pVec->y));
            maxV.z = (((maxV.z) > (pVec->z)) ? (maxV.z) : (pVec->z));
            pVec++;
        }
    }


    bool ContainsVec(CIwFVec3& v, CIwFMat* pMat = __null)
    {
        if (pMat)
        {
            CIwFVec3 dv = v - pMat->t;
            float lx, ly, lz;
            lx = pMat->m[0][0]*dv.x + pMat->m[1][0]*dv.y + pMat->m[2][0]*dv.z;
            if ((lx >= minV.x) && (lx <= maxV.x))
            {
                ly = pMat->m[0][1]*dv.x + pMat->m[1][1]*dv.y + pMat->m[2][1]*dv.z;
                if ((ly >= minV.y) && (ly <= maxV.y))
                {
                    lz = pMat->m[0][2]*dv.x + pMat->m[1][2]*dv.y + pMat->m[2][2]*dv.z;
                    if ((lz >= minV.z) && (lz <= maxV.z))
                        return true;
                }
            }
        }
        else
        {
            if (
                (v.x >= minV.x) && (v.x <= maxV.x) &&
                (v.y >= minV.y) && (v.y <= maxV.y) &&
                (v.z >= minV.z) && (v.z <= maxV.z)
                )
                return true;
        }
        return false;
    }
};
# 22 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFSphere.h" 2







class CIwFSphere
{
public:

    CIwFVec3 t;
    float r;
    float r2;


    CIwFSphere() {};
    CIwFSphere(const CIwFVec3& _t, float _r) : t(_t)
    {
        SetRadius(_r);
    };

    inline void SetRadius(float _r)
    {
        r = _r;
        r2 = r*r;
    };

    inline float GetRadius()
    {
        return r;
    };

    inline CIwFVec3 const & GetTrans() const
    {
        return t;
    };


    void BoundVecs(CIwFVec3* pVec, uint32 v)
    {
        ((void)0);

        CIwFBBox bbox;
        bbox.BoundVecs(pVec, v);

        t = bbox.GetCentre();
        r = 0;
        while(v--)
        {
            CIwFVec3 dv = *pVec;
            dv -= t;
            r = (((r) > (dv.GetLengthSquared())) ? (r) : (dv.GetLengthSquared()));
            pVec++;
        }


        r2 = r;

        r = (float)sqrt(r);
    }


    void Combine(CIwFSphere& rhs)
    {

        CIwFVec3 centre = rhs.t - t;
        float dist = centre.GetLength();

        if( dist + rhs.r <= r )
            return;

        if( dist + r <= rhs.r )
        {
            *this = rhs;
            return;
        }

        centre = centre / dist;

        t -= centre * r;

        t += rhs.t + centre * rhs.r;
        t = t / 2.0f;

        r = (dist + r + rhs.r) / 2.0f;
        r2 = r * r;

        ((void)0);
    }
# 146 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFSphere.h"
};




inline void IwSerialiseSphere(CIwFSphere& Sphere)
{
    Sphere.t.Serialise ();
    IwSerialiseFloat(Sphere.r);
    IwSerialiseFloat(Sphere.r2);
}
# 35 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFIntersect.h" 2
# 54 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLinePlane(const CIwFVec3& vFrom,
                          const CIwFVec3& vFromTo,
                          const CIwFPlane& plane,
                          float& f,
                          bool finite = true);
# 74 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLineSegPlaneOneSided(const CIwFVec3& vOrg,
                                     const CIwFVec3& vDirn,
                                     const CIwFPlane& plane,
                                     float& f,
                                     bool finite = true);
# 89 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLineSphere(const CIwFVec3& vOrg,
                           const CIwFVec3& vDirn,
                           const CIwFSphere& sphere);
# 109 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLineTriNorm(const CIwFVec3& vOrg,
                            const CIwFVec3& vDirn,
                            const CIwFVec3& v0,
                            const CIwFVec3& v1,
                            const CIwFVec3& v2,
                            const CIwFVec3& norm,
                            float& f,
                            bool finite = true);
# 134 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLineLine2D(const CIwFVec2& p1,
                           const CIwFVec2& dir1,
                           const CIwFVec2& p2,
                           const CIwFVec2& dir2,
                           CIwFVec2& collpt,
                           float& t1,
                           float& t2,
                           bool finite = true);
# 151 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectSphereSphere(const CIwFSphere& s0, const CIwFSphere& s1);
# 33 "c:/marmalade/6.2/modules/iwgeom/h/IwGeom.h" 2
# 23 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 1
       
# 16 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwClassFactory.h" 1
       
# 42 "c:/marmalade/6.2/modules/iwutil/h/IwClassFactory.h"
typedef void*(*IwClassFactoryFn)();
typedef void*(*IwClassSizeFactoryFn)();
# 146 "c:/marmalade/6.2/modules/iwutil/h/IwClassFactory.h"
void IwClassFactoryReserve(int number);
# 156 "c:/marmalade/6.2/modules/iwutil/h/IwClassFactory.h"
void* IwClassFactoryCreate(uint32 hash);
# 165 "c:/marmalade/6.2/modules/iwutil/h/IwClassFactory.h"
bool IwClassFactoryExists(uint32 hash);
# 174 "c:/marmalade/6.2/modules/iwutil/h/IwClassFactory.h"
void* IwClassFactoryCreate(const char* name);
# 184 "c:/marmalade/6.2/modules/iwutil/h/IwClassFactory.h"
void IwClassFactoryAdd(uint32 hash, IwClassFactoryFn fn, uint32 size = 0);
# 193 "c:/marmalade/6.2/modules/iwutil/h/IwClassFactory.h"
void IwClassFactoryAdd(const char* name, IwClassFactoryFn fn, uint32 size = 0);
# 202 "c:/marmalade/6.2/modules/iwutil/h/IwClassFactory.h"
void IwClassFactoryRemove(uint32 hash);
# 211 "c:/marmalade/6.2/modules/iwutil/h/IwClassFactory.h"
IwClassFactoryFn IwClassFactoryGet(uint32 hash);

uint32 IwClassFactoryGetSize(uint32 hash);
# 223 "c:/marmalade/6.2/modules/iwutil/h/IwClassFactory.h"
void IwClassFactoryModify(uint32 hash, IwClassFactoryFn fn, uint32 size);
# 17 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwCopyingPtr.h" 1
       
# 29 "c:/marmalade/6.2/modules/iwutil/h/IwCopyingPtr.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwAllocator.h" 1
# 19 "c:/marmalade/6.2/modules/iwutil/h/IwAllocator.h"
# 1 "c:/marmalade/6.2/s3e/h/s3eMemory.h" 1
# 20 "c:/marmalade/6.2/modules/iwutil/h/IwAllocator.h" 2
# 62 "c:/marmalade/6.2/modules/iwutil/h/IwAllocator.h"
class CIwDefaultMallocRouter
{
public:
    virtual ~CIwDefaultMallocRouter();
    virtual void* Alloc(uint32 size, uint32 objsize);
    virtual void Free(void* buf, uint32 objsize);
    virtual void* Realloc(void* buf, uint32 size, uint32 objsize);

    static CIwDefaultMallocRouter& Static();
    static void SetMallocRouter(CIwDefaultMallocRouter* a);

    static void* BaseAlloc(uint32 size, uint32 objsize);
    static void BaseFree(void* buf, uint32 objsize);
    static void* BaseRealloc(void* buf, uint32 size, uint32 objsize);
};
# 85 "c:/marmalade/6.2/modules/iwutil/h/IwAllocator.h"
template <class T>
class CIwMallocRouter : public CIwDefaultMallocRouter
{
public:
    static void* DoAlloc(uint32 size)
    {
        return BaseAlloc(size, sizeof(T));
    }
    static void DoFree(void* buf)
    {
        BaseFree(buf, sizeof(T));
    }
    static void* DoRealloc(void* buf, uint32 size)
    {
        return BaseRealloc(buf, size, sizeof(T));
    }
};
# 112 "c:/marmalade/6.2/modules/iwutil/h/IwAllocator.h"
template <class T, class M = CIwMallocRouter<T> > class CIwAllocator
{
public:
    typedef uint32 size_type;
    typedef int32 difference_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;
# 133 "c:/marmalade/6.2/modules/iwutil/h/IwAllocator.h"
    pointer allocate(size_type s)
    {
        return (pointer)M::DoAlloc(s);
    }





    pointer reallocate(pointer p, size_type s)
    {
        return (pointer)M::DoRealloc(p, s);
    }

    void deallocate(pointer p, size_type) { M::DoFree(p); }




};
# 30 "c:/marmalade/6.2/modules/iwutil/h/IwCopyingPtr.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h" 1
       
# 38 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
enum IwMemBucketID
{
    IW_MEM_BUCKET_ID_SYSTEM = 0,
    IW_MEM_BUCKET_ID_SYSTEM_DEBUG,
    IW_MEM_BUCKET_ID_USER,
};






enum IwMemBucketAllocFailBehaviour
{
    IW_MEM_BUCKET_ALLOC_FAIL_ERROR = 0,
    IW_MEM_BUCKET_ALLOC_FAIL_ASSERT,
    IW_MEM_BUCKET_ALLOC_FAIL_SILENT,

    IW_MEM_BUCKET_ALLOC_FAIL_DEFAULT = IW_MEM_BUCKET_ALLOC_FAIL_ERROR
};

class CIwMemBucket;

extern "C" {
# 74 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
void IwMemBucketCreate(uint32 bucketID, const char* name, uint32 size);
# 93 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
void IwMemBucketRegister(uint32 bucketID, const char* name, CIwMemBucket* bucket, void* data=__null);







void IwMemBucketFree(uint32 bucketID);







void IwMemBucketSet(uint32 bucketID);







uint32 IwMemBucketGetID();
# 127 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
int32 IwMemBucketGetFreeID(uint32 afterID = 0);







CIwMemBucket* IwMemBucketGet();







void IwMemBucketPush(uint32 bucketID);






void IwMemBucketPop();
# 172 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
void IwMemBucketSetAllocFailBehaviour(IwMemBucketAllocFailBehaviour behaviour);
# 182 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
IwMemBucketAllocFailBehaviour IwMemBucketGetAllocFailBehaviour();
# 199 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
uint32 IwMemBucketCheckpoint();







uint32 IwMemBucketDebugGetID(void* item);
# 219 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
uint32 IwMemBucketDebugCheck(uint32 bucketID, uint32 checkpoint, const char* filename);







void IwMemBucketVisualDump(const char* filename, int32 bucketID = -1);






typedef enum IwMemBucketDebugFlag
{
    IW_MEM_BUCKET_LOCK_FREE = 1 << 0,
    IW_MEM_BUCKET_LOCK_ALLOC = 1 << 1,
    IW_MEM_BUCKET_LOCK_SELECT = 1 << 2,
    IW_MEM_BUCKET_TRACE = 1 << 3,
    IW_MEM_BUCKET_LOCK_REALLOC = 1 << 4,
    IW_MEM_BUCKET_REUSE_IDS_FOR_REALLOC = 1 << 5,
} IwMemBucketDebugFlag;
# 251 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
void IwMemBucketDebugSetFlags(uint32 bucketID, uint32 flags);
# 260 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
void IwMemBucketDebugClearFlags(uint32 bucketID, uint32 flags);
# 270 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
void IwMemBucketDebugSetBreakpoint(uint32 allocationID);
# 289 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
uint32 IwMemBucketGetFree(uint32 bucketID);
# 298 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
uint32 IwMemBucketGetLargestFreeBlock(uint32 bucketID);
# 308 "c:/marmalade/6.2/modules/iwutil/h/IwMemory.h"
uint32 IwMemBucketGetUsed(uint32 bucketID);

}







class CIwAutoBucketSwitch
{
public:
    CIwAutoBucketSwitch(int bucket) : m_RestoreBucket(IwMemBucketGetID())
    {
        IwMemBucketSet(bucket);
    }
    ~CIwAutoBucketSwitch()
    {
        IwMemBucketSet(m_RestoreBucket);
    }

private:
    int m_RestoreBucket;
};
# 31 "c:/marmalade/6.2/modules/iwutil/h/IwCopyingPtr.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/c++/new" 1
# 21 "c:/marmalade/6.2/s3e/h/std/c++/new"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h" 1
# 10 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h" 1
# 62 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl_user_config.h" 1
# 63 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h" 2




# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config_compat.h" 1
# 68 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_site_config.h" 1
# 72 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/stlcomp.h" 1
# 54 "c:/marmalade/6.2/s3e/h/std/c++/config/stlcomp.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/stl_gcc_s3e.h" 1
# 67 "c:/marmalade/6.2/s3e/h/std/c++/config/stl_gcc_s3e.h"
     typedef char __stl_char;
# 55 "c:/marmalade/6.2/s3e/h/std/c++/config/stlcomp.h" 2
# 75 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h" 2
# 83 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/stl_confix.h" 1
# 84 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h" 2
# 488 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h"
namespace std { }
namespace __std_alias = std;
# 546 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h"
namespace _STL { }

namespace stlport = _STL;
# 11 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h" 2





# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h" 2
# 22 "c:/marmalade/6.2/s3e/h/std/c++/new" 2




# 1 "c:/marmalade/6.2/s3e/h/std/c++/cstddef" 1
# 37 "c:/marmalade/6.2/s3e/h/std/c++/cstddef"
# 1 "c:/marmalade/6.2/s3e/h/ext/../std/stddef.h" 1
# 38 "c:/marmalade/6.2/s3e/h/std/c++/cstddef" 2



namespace _STL {
using ::ptrdiff_t;
using ::size_t;
}
# 27 "c:/marmalade/6.2/s3e/h/std/c++/new" 2
# 38 "c:/marmalade/6.2/s3e/h/std/c++/new"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/new.h" 1
# 52 "c:/marmalade/6.2/s3e/h/std/c++/new.h"
inline void* operator new(size_t, void* p) { return p;};
inline void* operator new[](size_t, void* p) { return p;};
inline void operator delete(void*, void*) {};
inline void operator delete[](void*, void*) {};
# 39 "c:/marmalade/6.2/s3e/h/std/c++/new" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_new.h" 1
# 11 "c:/marmalade/6.2/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/exception" 1
# 58 "c:/marmalade/6.2/s3e/h/std/c++/exception"
# 1 "c:/marmalade/6.2/s3e/h/ext/../std/c++/exception.h" 1
# 18 "c:/marmalade/6.2/s3e/h/ext/../std/c++/exception.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/exception_gcc" 1
# 41 "c:/marmalade/6.2/s3e/h/std/c++/exception_gcc"
#pragma GCC visibility push(default)


extern "C++" {

namespace std
{
# 56 "c:/marmalade/6.2/s3e/h/std/c++/exception_gcc"
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 104 "c:/marmalade/6.2/s3e/h/std/c++/exception_gcc"
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 119 "c:/marmalade/6.2/s3e/h/std/c++/exception_gcc"
  void __verbose_terminate_handler ();
}

}


#pragma GCC visibility pop
# 19 "c:/marmalade/6.2/s3e/h/ext/../std/c++/exception.h" 2
# 59 "c:/marmalade/6.2/s3e/h/std/c++/exception" 2
# 75 "c:/marmalade/6.2/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/6.2/s3e/h/std/c++/exception"
}
# 12 "c:/marmalade/6.2/s3e/h/std/c++/stl/_new.h" 2

namespace _STL {

struct nothrow_t {};


extern const nothrow_t nothrow;




class bad_alloc : public exception {
public:
  bad_alloc () throw() { }
  bad_alloc(const bad_alloc&) throw() { }
  bad_alloc& operator=(const bad_alloc&) throw() {return *this;}
  ~bad_alloc () throw() { }
  const char* what() const throw() { return "bad alloc"; }
};

}
# 50 "c:/marmalade/6.2/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/new" 1
# 51 "c:/marmalade/6.2/s3e/h/std/c++/stl/_new.h" 2
# 80 "c:/marmalade/6.2/s3e/h/std/c++/stl/_new.h"
namespace _STL {





inline void* __stl_new(size_t __n) { void* __y = ::operator new(__n);if (__y == 0){;}return __y; }
inline void __stl_delete(void* __p) { ::operator delete(__p); }

}
# 43 "c:/marmalade/6.2/s3e/h/std/c++/new" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 2
# 47 "c:/marmalade/6.2/s3e/h/std/c++/new" 2
# 32 "c:/marmalade/6.2/modules/iwutil/h/IwCopyingPtr.h" 2


template<class T>
class CIwStandardAllocator
{
public:
    static T* allocate(uint32 size)
    {
        return (T*)s3eMalloc(size);
    }

    static T* reallocate(T* p, uint32 size)
    {
        return (T*)s3eRealloc(p, size);
    }

    static void deallocate(T* p, uint32) { s3eFree(p); }
};


template <class Type, class Allocator = CIwStandardAllocator<Type> >
class CIwCopyingPtr
{
public:
    CIwCopyingPtr() : m_Ptr(__null) {}
    ~CIwCopyingPtr()
    {
        if( m_Ptr )
        {
            m_Ptr->~Type();
            Allocator::deallocate(m_Ptr, 1);
        }
        m_Ptr = __null;
    }




    CIwCopyingPtr(const CIwCopyingPtr& rhs)
    {
        if (rhs.m_Ptr)
        {
            m_Ptr = new (Allocator::allocate(sizeof(Type))) Type;
            *m_Ptr = *rhs.m_Ptr;
        }
        else
        {
            m_Ptr = __null;
        }
    }

    CIwCopyingPtr& operator=(const CIwCopyingPtr& rhs)
    {
        if( m_Ptr )
        {
            m_Ptr->~Type();
            Allocator::deallocate(m_Ptr, 1);
        }

        if (rhs.m_Ptr)
        {
            m_Ptr = new (Allocator::allocate(sizeof(Type))) Type;
            *m_Ptr = *rhs.m_Ptr;
        }
        else
        {
            m_Ptr = __null;
        }
        return *this;
    }




    CIwCopyingPtr& operator= (Type* pPtr)
    {
        if( m_Ptr )
        {
            m_Ptr->~Type();
            Allocator::deallocate(m_Ptr, 1);
        }
        m_Ptr = pPtr;
        return *this;
    }

    Type* operator->() const
    {
        return m_Ptr;
    }

    Type& operator*() const
    {
        return *m_Ptr;
    }

    bool operator!= (Type* pPtr) const
    {
        return m_Ptr != pPtr;
    }


    void Release()
    {
        m_Ptr = __null;
    }

private:



    Type* m_Ptr;
};

template<class T>
class CIwDebugAllocator
{
public:
    static T* allocate(uint32 size)
    {




        T* alloc = (T*)s3eMalloc(size);




        return alloc;
    }

    static T* reallocate(T* p, uint32 size)
    {




        T* alloc = (T*)s3eRealloc(p, size);




        return alloc;
    }


    static void deallocate(T* p, uint32) { s3eFree(p); }
};
# 18 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwDivTable.h" 1
       
# 130 "c:/marmalade/6.2/modules/iwutil/h/IwDivTable.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwDivide.h" 1
# 131 "c:/marmalade/6.2/modules/iwutil/h/IwDivTable.h" 2
# 19 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwEvent.h" 1
       
# 26 "c:/marmalade/6.2/modules/iwutil/h/IwEvent.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h" 1
       
# 17 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h" 1
# 37 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwMath.h" 1
# 38 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h" 2
# 48 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h"
template <class X, class A>
class ReallocateDefault
{
public:
    static X* Reallocate(uint32 q, uint32 num_p, uint32 max_p, X* p, A& a)
    {
        return a.reallocate(p, q*sizeof(X));
    }
};

template <class X, class A>
class ReallocateStandard
{
public:
    static X* Reallocate(uint32 q, uint32 num_p, uint32 max_p, X* p, A& a)
    {
        X* new_p = a.allocate(q*sizeof(X));
        for (uint32 i = 0; i < num_p; i++)
        {
            new (&new_p[i]) X(p[i]);
            p[i].~X();
        }
        a.deallocate(p, max_p);
        return new_p;
    }
};






template <class X, class A=CIwAllocator<X>, class REALLOCATE = ReallocateDefault<X, A > >
class CIwArray
{
protected:
    X * p;
    uint32 num_p;
    uint32 max_p;
    bool block_delete : 1;
    bool no_grow : 1;
public:
    typedef X * iterator;
    typedef const X * const_iterator;





    iterator begin() const { return p; }





    iterator end() const { return p+num_p; }




    bool empty() const { return num_p==0; }




    uint32 size() const { return num_p; }





    uint32 capacity() const { return max_p; }





    X* data() { return p; }





    explicit CIwArray(uint32 sz=0) : p(0), num_p(0), max_p(0), block_delete(false), no_grow(false)
    {
        resize(sz);
        clear();
    }

    ~CIwArray()
    {
        for (uint32 i=0; i<num_p; i++)
            p[i].~X();
        if (!block_delete)
        {
            a.deallocate(p, num_p);
            p = 0;
        }
    }






    CIwArray(CIwArray const & v) : p(0), num_p(0), max_p(0), block_delete(false), no_grow(false)
    {
        (*this) = v;
    }







    void SerialiseHeader()
    {

        if (g_IwSerialiseContext.read)
        {
            uint32 s;
            IwSerialiseUInt32(s);
            resize_optimised(s);
        }
        else
        {
            uint32 s = size();
            IwSerialiseUInt32(s);
        }

    }






    void operator=(CIwArray const & v)
    {
        clear();
        if (v.size() < max_p/2 || v.size() > max_p)
            set_capacity(v.size());
        for (uint32 i=0; i<v.size(); i++)
            push_back( v.p[i] );
    }





    void clear()
    {
        truncate(0);
    }






    void clear_optimised()
    {
        truncate(0);
        set_capacity(0);
    }




    int MemoryUsage() const
    {
        return sizeof(X)*max_p + sizeof(*this);
    }







    void resize_optimised(uint32 s)
    {
        if (s > num_p)
            set_capacity(s);
        resize(s);
        set_capacity(num_p);
    }






    void optimise_capacity()
    {
        if (!block_delete)
            set_capacity(num_p);
    }






    void reserve(uint32 q)
    {
        if (q > max_p)
        {
            set_capacity( q+(max_p<16 ? 2 : max_p/8) );
        }
    }






    void reserve_optimised(int q)
    {
        ((void)0);
        if (q > (int)max_p)
        {
            set_capacity( q );
        }
    }







    void resize_quick(const uint32 q)
    {
        ((void)0);
        num_p = q;
    }






    void resize(const uint32 q)
    {
        if (q <= num_p)
            truncate(q);
        else
            push_back_qty(q-num_p);
    }
# 308 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h"
    int find(X const & value) const
    {
        for (uint32 i=0; i<num_p; i++)
            if (p[i]==value)
            {
                return i;
            }
        return -1;
    }






    bool contains(X const & value) const
    {
        for (uint32 i=0; i<num_p; i++)
            if (p[i]==value)
            {
                return true;
            }
        return false;
    }
# 344 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h"
    bool find_and_remove(X const & value)
    {
        for (uint32 i=0; i<num_p; i++)
            if (p[i]==value)
            {
                erase(i, i+1);
                return true;
            }
        return false;
    }
# 366 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h"
    bool find_and_remove_fast(X const & value)
    {
        for (uint32 i=0; i<num_p; i++)
            if (p[i]==value)
            {
                erase_fast(i, i+1);
                return true;
            }
        return false;
    }







    void pop_back()
    {
        truncate(num_p-1);
    }







    X pop_back_get()
    {
        ((void)0);

        X temp = p[num_p-1];
        pop_back();
        return temp;
    }
# 412 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h"
    int erase_fast(const int i)
    {
        return erase_fast(i,i+1);
    }
# 428 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h"
    int erase_fast(const int i, const int j)
    {
        ((void)0);

        const uint32 w = j-i;
        const uint32 w_copy = (((w) < (num_p-j)) ? (w) : (num_p-j));

        for (uint32 k=0; k<w_copy; k++)
            p[i+k] = p[num_p-w_copy+k];

        truncate(num_p-w);
        return i;
    }





    iterator erase_fast(iterator i)
    {
        return p + erase_fast(i-p,i-p+1);
    }






    iterator erase_fast(iterator i, iterator j)
    {
        return p + erase_fast(i-p,j-p);
    }
# 470 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h"
    int erase(const int i)
    {
        return erase(i, i+1);
    }
# 484 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h"
    int erase(const uint32 i, const uint32 j)
    {
        ((void)0);
        const int w = j-i;
        for (uint32 k=i; k<num_p-w; k++)
            p[k] = p[k+w];
        truncate(num_p-w);
        return i;
    }





    iterator erase(iterator i)
    {
        return p + erase(i-p,i-p+1);
    }






    iterator erase(iterator i, iterator j)
    {
        return p + erase(i-p,j-p);
    }







    void insert_slow(X const & x, uint32 pos)
    {
        ((void)0);
        if (pos==size())
            push_back(x);
        else
        {
            reserve(num_p+1);
            for (int k=num_p-pos-1; k>=0; k--)
                p[pos+k+1] = p[pos+k];
            num_p++;
            p[pos] = x;
        }
    }







    void insert_slow(CIwArray &a, uint32 pos)
    {
        ((void)0);
        if (pos==size())
            append(a);
        else
        {
            int s = a.size();
            reserve(num_p+s);
            for (int k=num_p-pos-1; k>=0; k--)
                p[pos+k+s] = p[pos+k];
            num_p+=s;
            for (int i=0;i<s;i++)
                p[pos+i] = a.p[i];
        }
    }






    X const & back() const
    {
        ((void)0);
        return p[size()-1];
    }
    X & back()
    {
        ((void)0);
        return p[size()-1];
    }






    X const & front() const
    {
        ((void)0);
        return p[0];
    }

    X & front()
    {
        ((void)0);
        return p[0];
    }





    int append(X const & x) { return push_back(x); }
# 603 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h"
    int append(CIwArray & a)
    {
        int c = num_p;
        resize(num_p+a.num_p);
        for (uint32 d=0;d<a.num_p;d++)
            p[c+d] = a.p[d];
        return num_p-1;
    }







    int push_back(X const & x)
    {
# 632 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h"
        ((void)0);

        reserve(num_p+1);
        ((void)0);
        new (p+num_p) X(x);
        return num_p++;
    }






    int push_back()
    {
        reserve(num_p+1);
        new (p+num_p) X;
        return num_p++;
    }







    void push_back_qty(X const & x, int qty)
    {
        if (!qty) return;
        ((void)0);
        ((void)0);
        reserve(num_p+qty);
        for (int i=0; i<qty; i++)
        {
            new (p+num_p+i) X(x);



        }
        num_p+=qty;
    }






    void push_back_qty(int qty)
    {
        ((void)0);
        reserve(num_p+qty);
        for (int i=0; i<qty; i++)
            new (p+num_p+i) X;
        num_p+=qty;
    }







    X & operator [] (int const i) const
    {
        uint32 index = (uint32)i;
        ((void)0);
        return p[index];
    }






    void Share(CIwArray<X,A> const & other)
    {
        if (!block_delete)
            clear_optimised();
        p=other.p;
        num_p=other.num_p;
        max_p=other.max_p;
        block_delete = true;
    }
# 723 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h"
    void Share(X* buffer, int current, int max)
    {
        if (!block_delete)
            clear_optimised();
        p=buffer;
        num_p=current;
        max_p=max;
        block_delete = true;
    }





    bool CanResize()
    {
        return !block_delete;
    }
# 749 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h"
    void LockSize(bool lock)
    {
        no_grow = lock;
    }





    void set_capacity(uint32 q);






    void truncate(const uint32 q)
    {
        ((void)0);

        for (uint32 i=q; i<num_p; i++)
            p[i].~X();
        num_p = q;
    }





    void swap(CIwArray<X,A>& v)
    {
        X* tmp_p = p;
        uint32 tmp_num_p = num_p;
        uint32 tmp_max_p = max_p;
        bool tmp_block_delete = block_delete;
        bool tmp_no_grow = no_grow;

        p = v.p;
        num_p = v.num_p;
        max_p = v.max_p;
        block_delete = v.block_delete;
        no_grow = v.no_grow;

        v.p = tmp_p;
        v.num_p = tmp_num_p;
        v.max_p = tmp_max_p;
        v.block_delete = tmp_block_delete;
        v.no_grow = tmp_no_grow;
    }

private:
    A a;
};

template <class X, class A, class REALLOCATE>
void CIwArray<X,A,REALLOCATE>::set_capacity(uint32 q)
{
    ((void)0);
    ((void)0);
    ((void)0);
    if (max_p==q) return;
    max_p = q;
    if (q==0)
    {
        a.deallocate(p, max_p);
        p = 0;
    }
    else
    {
        p = REALLOCATE::Reallocate(q, num_p, max_p, p, a);
    }
}



template<>
class CIwArray<bool, CIwAllocator<bool> >
{
    CIwArray<uint32, CIwAllocator<uint32> > b;
    int l;
    void fit()
    {
        ((void)0);
        b.resize((l+31) >> 5);
    }
public:
    CIwArray<bool, CIwAllocator<bool> >(int sz=0) : l(sz) { fit(); }
    void resize(int s)
    {
        l = s;
        fit();
    }
    void resize(int s, bool set_value)
    {
        resize(s);
        set_all(set_value);
    }
    void clear()
    {
        resize(0);
    }
    void clear_optimised()
    {
        b.clear_optimised();
    }
    uint32 size() const
    {
        return l;
    }
    void push_back(bool i)
    {
        l++;
        fit();
        set(l-1, i);
    }
    bool pop_back()
    {
        ((void)0);
        bool r = (*this)[l-1];
        l--;
        fit();
        return r;
    }
    void set_all(bool v)
    {
        for (uint32 i=0; i<b.size(); i++)
            b[i] = v ? 0xffffffff : 0;
    }
    void set(int i, bool v)
    {
        ((void)0);
        if (v)
            b[i>>5] |= (1<<(i&31));
        else
            b[i>>5] &= ~(1<<(i&31));
    }
    bool operator[] (int i) const
    {
        ((void)0);
        return (b[i>>5] & (1<<(i&31))) != 0;
    }

    void Serialise()
    {

        int32 il = l;
        IwSerialiseInt32(il);
        l = il;
        b.SerialiseHeader();
        IwSerialiseUInt32(*b.data(), b.size());

    }
};
# 18 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h" 2



# 1 "c:/marmalade/6.2/modules/iwutil/h/IwHashString.h" 1
       
# 17 "c:/marmalade/6.2/modules/iwutil/h/IwHashString.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwString.h" 1
# 24 "c:/marmalade/6.2/modules/iwutil/h/IwString.h"
# 1 "c:/marmalade/6.2/s3e/h/std/string.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/string.h"
extern "C" {

void *memcpy(void *dest, const void *src, size_t n);
void *memset(void *s, int c, size_t n);
int memcmp(const void *s1, const void *s2, size_t n);
void *memmove(void *dest, const void *src, size_t n);
void *memchr(const void *s, int c, size_t n);
void *memrchr(const void *s, int c, size_t n);







int strcmp(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t n);
char *strsep(char **stringp, const char *delim);
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);
char *strchr(const char *s, int c);
char *strstr(const char *haystack, const char *needle);
char *strrchr(const char *s, int c);
char *strdup(const char *s);
char *strtok(char *str, const char *delim);
char *strtok_r(char *str, const char *delim, char **saveptr);
char *strcat(char *dest, const char *src);
char *strncat(char *dest, const char *src, size_t n);
size_t strlen(const char *s);
size_t strnlen(const char *s, size_t n);
int strcasecmp(const char *s1, const char *s2);
int strncasecmp(const char *s1, const char *s2, size_t n);
size_t strspn(const char *s, const char *accept);
size_t strcspn(const char *s, const char *reject);
char *strpbrk(const char *s, const char *accept);
int strcoll(const char *s1, const char *s2);
char *strerror(int errnum);
size_t strxfrm(char *dest, const char *src, size_t n);

int strerror_r(int errnum, char *buf, size_t buflen);





size_t strlcpy(char* dest, const char* src, size_t len);
size_t strlcat(char* dest, const char* src, size_t len);

}
# 25 "c:/marmalade/6.2/modules/iwutil/h/IwString.h" 2
# 74 "c:/marmalade/6.2/modules/iwutil/h/IwString.h"
template <int N>
class CIwString
{


public:
    inline CIwString()
    {
        m_Buffer[0] = '\0';
    };

    CIwString(const char* pText)
    {
        m_Buffer[0] = '\0';
        ((void)0);
        strcpy(m_Buffer, pText);
    };
# 104 "c:/marmalade/6.2/modules/iwutil/h/IwString.h"
    inline const char* c_str() const {return m_Buffer;}
# 113 "c:/marmalade/6.2/modules/iwutil/h/IwString.h"
    inline int size() const {return strlen(m_Buffer);}
# 122 "c:/marmalade/6.2/modules/iwutil/h/IwString.h"
    inline int length() const {return strlen(m_Buffer);}






    inline int capacity() const {return N-1;}






    inline void setLength(int len)
    {
        ((void)0);
        ((void)0);
        m_Buffer[len] = '\0';
    }

    inline int find(const char* substr)
    {
        char*p = strstr(m_Buffer, substr);
        if (p)
            return (int)(p - m_Buffer);
        return -1;
    }

    inline CIwString substr(int pos, int len = -1) const
    {
        if (len < 0)
            len = length() - pos;

        CIwString s(m_Buffer + pos);
        s.setLength(len);
        return s;
    }

    inline char & operator [] (int i)
    {
        ((void)0);
        ((void)0);
        return m_Buffer[i];
    }

    inline const char & operator [] (int i) const
    {
        ((void)0);
        ((void)0);
        return m_Buffer[i];
    }






    const char* operator = (const char* pText)
    {
        ((void)0);
        strcpy(m_Buffer, pText);
        return m_Buffer;
    };

    const char* operator = ( CIwString const& str)
    {
        ((void)0);
        strcpy(m_Buffer, str.c_str());
        return m_Buffer;
    };

    const char* operator += (const char* pText)
    {
        ((void)0);
        strcat(m_Buffer, pText);
        return m_Buffer;
    };

    const char* operator += (CIwString const& str)
    {
        ((void)0);
        strcat(m_Buffer, str.c_str());
        return m_Buffer;
    };

    CIwString operator + (const char* pText)
    {
        ((void)0);
        CIwString ns = *this;
        strcat(ns.m_Buffer, pText);
        return ns;
    }

    CIwString operator + (const CIwString& str)
    {
        ((void)0);
        CIwString ns = *this;
        strcat(ns.m_Buffer, str.c_str());
        return ns;
    }

    const char* operator += (char c)
    {
        ((void)0);
        char str[2] = {c, '\0'};
        strcat(m_Buffer, str);
        return m_Buffer;
    };

    bool operator== (const char* str) const
    {
        return !strcmp(m_Buffer, str);
    }

    bool operator== (const CIwString& str) const
    {
        return !strcmp(m_Buffer, str.c_str());
    }







    inline void Serialise()
    {
        IwSerialiseString(m_Buffer, N);
    }



private:
    char m_Buffer[N];
};

template <int N>
static inline CIwString<N> operator + (const char *str1, const CIwString<N> &str2)
{
    return CIwString<N>(str1) + str2;
}






typedef CIwString<32> CIwStringS;




typedef CIwString<160> CIwStringL;
# 18 "c:/marmalade/6.2/modules/iwutil/h/IwHashString.h" 2
# 40 "c:/marmalade/6.2/modules/iwutil/h/IwHashString.h"
uint32 IwHashString(const char* pChar);
# 49 "c:/marmalade/6.2/modules/iwutil/h/IwHashString.h"
template<int N> uint32 IwHashString(const CIwString<N>& sz)
{
   

    return IwHashString(sz.c_str());
}
# 65 "c:/marmalade/6.2/modules/iwutil/h/IwHashString.h"
uint32 IwHashString(const char* pChar, uint32 hash);
# 22 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h" 2

# 1 "c:/marmalade/6.2/modules/iwutil/h/IwTextParseable.h" 1
       
# 21 "c:/marmalade/6.2/modules/iwutil/h/IwTextParseable.h"
class CIwTextParserITX;
# 41 "c:/marmalade/6.2/modules/iwutil/h/IwTextParseable.h"
class CIwParseable
{
public:


    typedef CIwArray<CIwParseable*> Array;

    typedef Array::iterator ArrayIt;

    virtual ~CIwParseable() {}
# 60 "c:/marmalade/6.2/modules/iwutil/h/IwTextParseable.h"
    virtual void ParseOpen(CIwTextParserITX* pParser) = 0;







    virtual void ParseClose(CIwTextParserITX* pParser) = 0;







    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName) = 0;
};
# 24 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h" 1
       
# 22 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwSingleton.h" 1
# 23 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h" 2

# 1 "c:/marmalade/6.2/modules/iwutil/h/IwTypes.h" 1
# 37 "c:/marmalade/6.2/modules/iwutil/h/IwTypes.h"
enum
{

    IW_TYPE_NONE = 0,
    IW_TYPE_CHAR,
    IW_TYPE_BOOL,
    IW_TYPE_INT8,
    IW_TYPE_UINT8,
    IW_TYPE_INT16,
    IW_TYPE_UINT16,
    IW_TYPE_INT32,
    IW_TYPE_UINT32,
    IW_TYPE_FLOAT,
    IW_TYPE_DOUBLE,
    IW_TYPE_STRING,
    IW_TYPE_COMPOUND,
    IW_TYPE_MAX,

    IW_TYPE_MAX_BIT = 4,


    IW_TYPE_PAD_F = (1 << 4),


    IW_TYPE_FREE_BIT = 6
};
# 25 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h" 2


class CIwMenuItem;
class CIwMenu;
# 44 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
typedef CIwStringS CIwMenuString;
# 53 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
class CIwMenuItem
{
public:

    enum
    {
        HILITE_F = (1 << 0),
        UNSELECTABLE_F = (1 << 1),
        NO_SCROLL_F = (1 << 2),
        PARAGRAPH_END_F = (1 << 3),
    };




    enum ColourID
    {
        TITLE,
        MENU,
        FIELD,
        BOOL,
        STRING,
        FIXED,
        HILITE,
        MAX_COLOUR_ID,
    };

    typedef CIwArray<CIwMenuItem*> Array;
    typedef Array::iterator ArrayIt;


    CIwMenuItem(const char* name, const char* text, uint32 flags = 0, ColourID colID = FIELD);
    virtual ~CIwMenuItem();





    virtual void Update(bool active);






    virtual void Render(int32 x, int32 y);





    virtual void Enter() { m_Flags |= HILITE_F;}





    virtual void Exit() { m_Flags &= ~HILITE_F;}





    virtual void Select() { };





    virtual void Back();





    virtual void Run()
    {

        Select();
    };





    virtual void Plus() { };





    virtual void Minus() { };






    inline void SetSelectable(bool s)
    {
        if (s == true)
            m_Flags &= ~UNSELECTABLE_F;
        else
            m_Flags |= UNSELECTABLE_F;
    }





    inline CIwMenu* GetMenu() const {return m_Menu;}




    const char* m_Name;
    ColourID m_ColourID;
    CIwMenuString m_Text;
    int32 m_X;
    int32 m_Y;
    int32 m_W;
    int32 m_H;
private:
    int32 m_Flags;
    CIwMenu* m_Menu;

    friend class CIwMenu;
};
# 189 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
class CIwMenu
{
public:

    enum
    {
        UPDATE_ALWAYS_F = (1 << 0),
        RENDER_ALWAYS_F = (1 << 1),
    };

    typedef CIwArray<CIwMenu*> Array;
    typedef Array::iterator ArrayIt;


    CIwMenu(int32 x = -1, int32 y = -1, uint32 flags = 0);
    virtual ~CIwMenu();


    virtual void Update(bool active);


    virtual void Render(bool active);


    virtual void Enter();


    virtual void Exit();






    virtual int32 AddItem(CIwMenuItem* item, int32 index = -1);





    virtual void RemoveItem(int32 index);







    virtual void SetNextSelectable(bool down, int start = -1, int count = 1);





    virtual void SetItemID(int32 id);






    virtual void SetXY(int32 x, int32 y) { m_X = x, m_Y = y;}




    CIwMenuItem::Array m_ItemArray;
    int32 m_Flags;
    int32 m_ItemID;
    int32 m_X;
    int32 m_Y;
    int32 m_ScrollID;
    int32 m_ScrollHeight;
    CIwMenu* m_Parent;
    bool m_Wrap;
};







class CIwMenuManager
{
public:



    typedef void(*TextCallback)(const char* line, int32 x, int32 y, CIwMenuItem::ColourID colID);



    typedef CIwMenu*(*MainFn)();


    enum
    {

        INPUT_UP_F = (1 << 0),
        INPUT_DOWN_F = (1 << 1),
        INPUT_LEFT_F = (1 << 2),
        INPUT_RIGHT_F = (1 << 3),
        INPUT_RUN_F = (1 << 4),
        INPUT_SHIFT_F = (1 << 5),
        INPUT_CTRL_F = (1 << 6),
        INPUT_PLUS_F = (1 << 7),
        INPUT_MINUS_F = (1 << 8),
        INPUT_MASK = (1 << 9) - 1,


        DESTROY_MENU_F = (1 << 10),
        SELECT_MENU_F = (1 << 11),
        REBUILD_MENU_F = (1 << 12),
        UPDATE_F = (1 << 14),
        RENDER_F = (1 << 15),
    };


    CIwMenuManager();
    virtual ~CIwMenuManager();




    void DestroyMenus();






    virtual void Update();






    virtual void Render();





    void AddMenu(CIwMenu* menu);





    void AddMenuOrDestroy(CIwMenu* pMenu);




    inline void DestroyMenu() {m_Flags |= DESTROY_MENU_F;}





    void SelectMenu(int32 forceID = -1)
    {
        m_Flags |= SELECT_MENU_F;
        m_ForceItemID = forceID;
    }





    void RebuildMenu(int32 forceID = -1)
    {
        m_Flags |= REBUILD_MENU_F;
        m_ForceItemID = forceID;
    }






    inline void SetMenuCharWH(uint32 w, uint32 h)
    {
        m_CharW = w;
        m_CharH = h;
    }






    inline void SetMenuDefaultXY(uint32 x, uint32 y)
    {
        m_MenuDefaultX = x;
        m_MenuDefaultY = y;
    }





    inline void SetMenuDefaultW(uint32 w)
    {
        m_MenuDefaultW = w;
    }





    inline void SetTextCallback(TextCallback cb) {m_TextCallback = cb;}





    inline void SetFocusKey(int32 k) {m_KeyDef[MK_FOCUS] = k;}





    inline bool HasFocus() {return m_Focus;}





    void SetFocus(bool focus);





    inline void SetMainMenuFn(MainFn cb) {m_MainFn = cb;}




    CIwMenu::Array m_MenuArray;
    CIwMenu* m_MenuActive;
    uint32 m_Flags;
    int32 m_ForceItemID;
    TextCallback m_TextCallback;
    uint32 m_CharW;
    uint32 m_CharH;
    uint32 m_MenuDefaultX;
    uint32 m_MenuDefaultY;
    uint32 m_MenuDefaultW;

private:
    enum CIwMenuKeyBind
    {
        MK_UP,
        MK_DOWN,
        MK_LEFT,
        MK_RIGHT,
        MK_ENTER,
        MK_SHIFT,
        MK_CONTROL,
        MK_PLUS,
        MK_MINUS,
        MK_INPUT,
        MK_FOCUS,
        COUNT_MENU_KEYS
    };
    uint32 m_KeyDef[COUNT_MENU_KEYS];
    bool m_Focus;
    bool m_Input;
    bool m_Destroy;
    bool m_Create;
    MainFn m_MainFn;
    uint32 m_LastInput;
    uint32 m_AutoRepeatTime;
};

extern CIwMenuManager* g_IwMenuManager;




inline CIwMenuManager* IwGetMenuManager() {return g_IwMenuManager;}
# 482 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
class CIwMenuItemString : public CIwMenuItem
{
public:






    CIwMenuItemString(const char* text, const char* string, uint32 flags = 0) : CIwMenuItem("", text, flags, CIwMenuItem::STRING), m_String(string) {};
    void Render(int32 x, int32 y);
    const char* m_String;
};




class CIwMenuItemEditValue : public CIwMenuItem
{
public:
    CIwMenuItemEditValue(const char* text, void* pValue, uint32 type, float delta = 1.0f, float min = 0.0f, float max = 1.0f, float def = 0.0f, CIwMenuItem::ColourID colID = CIwMenuItem::FIELD) : CIwMenuItem("", text, 0, colID)
    {
        m_Type = type;
        m_Value = pValue;
        m_Delta = delta;
        m_Default = def;
        m_Min = min;
        m_Max = max;
        if (m_Delta == 0.0f)
            m_ColourID = CIwMenuItem::FIXED;
    };
    ~CIwMenuItemEditValue() {};
    void Back() {IwGetMenuManager()->DestroyMenu();}
    void Plus();
    void Minus();
    virtual void EditMember(float delta);
    void Render(int32 x, int32 y);

    uint32 m_Type;
    void* m_Value;
    float m_Delta;
    float m_Default;
    float m_Min;
    float m_Max;
};







class CIwMenuItemEditInt8 : public CIwMenuItemEditValue
{
public:
# 546 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditInt8( const char* text, int8* pValue, float delta = 1.0f, float min = (float)(-0x7f - 1), float max = (float)0x7f, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_INT8, delta, min, max, def) {};
};




class CIwMenuItemEditUInt8 : public CIwMenuItemEditValue
{
public:
# 564 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditUInt8( const char* text, uint8* pValue, float delta = 1.0f, float min = (float)0x0, float max = (float)0xff, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_UINT8, delta, min, max, def) {};
};




class CIwMenuItemEditInt16 : public CIwMenuItemEditValue
{
public:
# 582 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditInt16( const char* text, int16* pValue, float delta = 1.0f, float min = (float)(-0x7fff - 1), float max = (float)0x7fff, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_INT16, delta, min, max, def) {};
};




class CIwMenuItemEditUInt16 : public CIwMenuItemEditValue
{
public:
# 600 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditUInt16( const char* text, uint16* pValue, float delta = 1.0f, float min = (float)0x0, float max = (float)0xffff, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_UINT16, delta, min, max, def) {};
};




class CIwMenuItemEditInt32 : public CIwMenuItemEditValue
{
public:
# 618 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditInt32( const char* text, int32* pValue, float delta = 1.0f, float min = (float)(-0x7fffffffL - 1), float max = (float)0x7fffffffL, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_INT32, delta, min, max, def) {};
};




class CIwMenuItemEditUInt32 : public CIwMenuItemEditValue
{
public:
# 636 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditUInt32( const char* text, uint32* pValue, float delta = 1.0f, float min = (float)0x0000, float max = (float)0xffff, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_UINT32, delta, min, max, def) {};
};




class CIwMenuItemEditFloat : public CIwMenuItemEditValue
{
public:
# 654 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditFloat( const char* text, float* pValue, float delta = 0.01f, float min = (float)(-0x7fffffffL - 1), float max = (float)0x7fffffffL, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_FLOAT, delta, min, max, def) {};
};




class CIwMenuItemEditBool : public CIwMenuItemEditValue
{
public:
# 672 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditBool( const char* text, bool* pValue, float delta = 1.0f, float min = (float)0x0, float max = (float)0x1, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_BOOL, delta, min, max, def, CIwMenuItem::BOOL) {};
};




class CIwMenuItemDisplayValue : public CIwMenuItemEditValue
{
public:
    CIwMenuItemDisplayValue(const char* text, uint32 Value, uint32 type, CIwMenuItem::ColourID colID = CIwMenuItem::FIXED) : CIwMenuItemEditValue(text, __null, type, 0, 0, 0, 0, colID)
    {
        m_Type = type;
        m_StoreValue = Value;
        m_Value = (void*)&m_StoreValue;
    };
    ~CIwMenuItemDisplayValue() {};
    virtual void EditMember(float delta) { }
    uint32 m_StoreValue;
};







class CIwMenuItemTitle: public CIwMenuItem
{
public:




    CIwMenuItemTitle(const char* text) : CIwMenuItem("", text, CIwMenuItem::UNSELECTABLE_F, CIwMenuItem::TITLE) {}
};







class CIwMenuItemEditFlags : public CIwMenuItemEditUInt32
{
public:






    CIwMenuItemEditFlags(const char* text, uint32* pValue, uint32 mask) : CIwMenuItemEditUInt32(text, pValue)
    {
        m_Type = IW_TYPE_UINT32;
        m_Default = (float)mask;
        m_ColourID = CIwMenuItem::BOOL;
    };
    void EditMember(float delta)
    {
        *(uint32*)m_Value ^= (uint32)m_Default;
    }
    void Render(int32 x, int32 y);
};







class CIwMenuItemEditEnum : public CIwMenuItemEditUInt32
{
public:
# 754 "c:/marmalade/6.2/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditEnum(const char* text, uint32* pValue, const char** ppNames = __null, bool edit = true, uint32 min = 0, uint32 max = 0);
    void Render(int32 x, int32 y);
    const char** m_Names;
};







class CIwMenuItemDisplayInt8 : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayInt8( const char* text, int8 Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_INT8) {};
};




class CIwMenuItemDisplayUInt8 : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayUInt8( const char* text, uint8 Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_UINT8) {};
};




class CIwMenuItemDisplayInt16 : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayInt16( const char* text, int16 Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_INT16) {};
};




class CIwMenuItemDisplayUInt16 : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayUInt16( const char* text, uint16 Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_UINT16) {};
};




class CIwMenuItemDisplayInt32 : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayInt32( const char* text, int32 Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_INT32) {};
};




class CIwMenuItemDisplayUInt32 : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayUInt32( const char* text, uint32 Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_UINT32) {};
};




class CIwMenuItemDisplayFloat : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayFloat( const char* text, float Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_FLOAT) {};
};




class CIwMenuItemDisplayBool : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayBool( const char* text, bool Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_BOOL) {};
};
# 25 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h" 2

class CIwEvent;
class CIwManaged;
class CIwTextParserITX;
# 108 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h"
class CIwManaged : public CIwParseable
{
public:
    typedef CIwArray<CIwManaged*> Array;
    typedef Array::iterator ArrayIt;

    CIwManaged();
    virtual ~CIwManaged();






    virtual void Serialise();
# 134 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h"
    virtual void Resolve();
# 143 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h"
    virtual void ParseOpen(CIwTextParserITX* pParser) {};
# 154 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h"
    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
# 164 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h"
    virtual void ParseClose(CIwTextParserITX* pParser);
# 176 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h"
    virtual void ParseCloseChild(CIwTextParserITX* pParser, CIwManaged* pChild);
# 187 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h"
    virtual bool HandleEvent(CIwEvent* pEvent) {return false;}
# 196 "c:/marmalade/6.2/modules/iwutil/h/IwManaged.h"
    virtual void SetName(const char* pName);


    virtual const char* GetClassName() const;


    inline const char* DebugGetName() const
    {



        ((void)0);
        return "";

    }


    virtual void DebugRender() {};


    virtual void DebugAddMenuItems(CIwMenu* pMenu);


    void _SetNameNoHash(const char* pName);
    void _CopyNameAndHash(const CIwManaged* pObj);

    uint32 m_Hash;

    static void _EnableParsing();

    virtual void _Replace(CIwManaged* pRHS);

protected:
    void DebugSerialiseName();

private:
    CIwCopyingPtr<CIwStringL, CIwDebugAllocator<CIwStringL> > m_DebugName;

    friend class CIwMaterial;
};




class CIwMenuItemManaged : public CIwMenuItemString
{
public:
    CIwMenuItemManaged(const char* pString, CIwManaged* pObj) : CIwMenuItemString("", "")
    {
        m_Obj = pObj;
        m_Text = (pString) ? pString : pObj->GetClassName();
    };
    void Select();
    CIwManaged* m_Obj;
};

typedef void (*IwManagedConstructorCallback)(CIwManaged*);
typedef void (*IwManagedDestructorCallback)(CIwManaged*);
typedef void (*IwManagedSerialiseCallback)(CIwManaged*);
void _IwManagedSetConstructorCallback(IwManagedConstructorCallback fn);
void _IwManagedSetDestructorCallback(IwManagedDestructorCallback fn);
void _IwManagedSetSerialiseCallback(IwManagedSerialiseCallback fn);
IwManagedConstructorCallback _IwManagedGetConstructorCallback();
IwManagedDestructorCallback _IwManagedGetDestructorCallback();
IwManagedSerialiseCallback _IwManagedGetSerialiseCallback();
# 27 "c:/marmalade/6.2/modules/iwutil/h/IwEvent.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h" 1
       
# 51 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
typedef void(*IwManagedListSerialiseCallback)(CIwManaged*);
void IwManagedListSetSerialiseCallbackPre(IwManagedListSerialiseCallback fn);
void IwManagedListSetSerialiseCallbackPost(IwManagedListSerialiseCallback fn);
IwManagedListSerialiseCallback IwManagedListGetSerialiseCallbackPre();
IwManagedListSerialiseCallback IwManagedListGetSerialiseCallbackPost();
# 68 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
class CIwManagedList
{
private:
    inline void _CheckAdd(CIwManaged* pObj, bool allowDups) const
    {
# 88 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    }
    inline void _CheckGet(uint32 hash, bool allowDups) const
    {
# 108 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    }

public:



    CIwManagedList() {}
    ~CIwManagedList() {}
# 128 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    void Serialise();
# 137 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    void Resolve();
# 146 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    void SerialisePtrs();





    inline void OptimizeCapacity() {m_List.optimise_capacity();}
# 161 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    void ResolvePtrs(const CIwManagedList& list);
# 172 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline void SerialiseHeader() {m_List.SerialiseHeader();}





    void Delete();







    inline void Clear() {m_List.clear();}







    inline void ClearAndFree() {m_List.clear_optimised();}
# 207 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    CIwManaged* GetObjNamed(const char* pName, bool allowDups = false) const;
# 223 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    CIwManaged* GetObjHashed(uint32 hash, bool allowDups = false) const;
# 239 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    CIwManaged::ArrayIt GetObjHashedNextIt(uint32 hash, CIwManaged::ArrayIt start = __null, bool allowDups = false) const;
# 251 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    void Add(CIwManaged* pObject, bool allowDups = false);
# 265 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline void Insert(CIwManaged* pObject, uint32 pos, bool allowDups = false)
    {
        _CheckAdd(pObject, allowDups);
        m_List.insert_slow(pObject, pos);
    }
# 279 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline bool RemoveSlow(CIwManaged* pObject) {return m_List.find_and_remove(pObject); }
# 289 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline bool RemoveFast(CIwManaged* pObject) {return m_List.find_and_remove_fast(pObject); }
# 299 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline CIwManaged** Erase(CIwManaged** it) {return m_List.erase(it);}
# 309 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline uint32 EraseFast(uint32 i) {return m_List.erase_fast(i);}
# 318 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline bool Contains(CIwManaged* pObject) const
    {
        return m_List.contains(pObject);
    }
# 331 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    int32 Find(CIwManaged* const& pObject) const
    {
        return m_List.find(pObject);
    }
# 343 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    void CopyList(const CIwManagedList& list);







    inline uint32 GetSize() const {return (uint32)m_List.size();}







    inline uint32 GetCapacity() const {return (uint32)m_List.capacity();}
# 370 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline void Push(CIwManaged* pObject, bool allowDups = false)
    {
        _CheckAdd(pObject, allowDups);
        m_List.push_back(pObject);
    }
# 383 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline CIwManaged* Pop() {return m_List.pop_back_get();}
# 392 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline CIwManaged* GetTop() {return m_List.back();}







    CIwManaged* & operator [] (int const i) const
    {
        uint32 index = (uint32)i;
        return m_List[index];
    }
# 413 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline CIwManaged** GetBegin() const {return m_List.begin();}
# 423 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline CIwManaged** GetEnd() const {return m_List.end();}
# 433 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline void Reserve(uint32 i) {m_List.reserve_optimised(i);}
# 442 "c:/marmalade/6.2/modules/iwutil/h/IwManagedList.h"
    inline void LockSize(bool lock) { m_List.LockSize(lock); }




    inline void _AddHashAsPointer(uint32 hash) {m_List.push_back((CIwManaged*)(intptr_t)hash);}
private:
    CIwManaged::Array m_List;
};


void IwResolveManagedHash(void* pptr, const CIwManagedList& list);







class CIwMenuItemManagedList : public CIwMenuItem
{
public:
    CIwMenuItemManagedList(const char* pString, CIwManagedList* pList) : CIwMenuItem("", pString, 0, CIwMenuItem::FIELD)
    {
        m_List = pList;
    }
    void Select();
    CIwManagedList* m_List;
};
# 28 "c:/marmalade/6.2/modules/iwutil/h/IwEvent.h" 2



enum IW_EVENT_TABLE_GLOBAL
{
    IW_EVENT_NULL = 0,


    IW_EVENT_GX = 0x0100,
    IW_EVENT_ENGINE = 0x0200,
    IW_EVENT_ANIM = 0x0300,
    IW_EVENT_GUI = 0x0400,




    IW_EVENT_USER = 0x8000,


    IW_EVENT_ALLOCATION_MASK = 0xFF00,
};







class CIwEvent : public CIwManaged
{
public:

    uint32 GetID() const { return m_Hash; }
    CIwManaged* GetSender() const { return m_Sender; }


    bool Send(CIwManaged *pTarget, CIwManaged *pSender);


    void Post(CIwManaged *pTarget, CIwManaged *pSender);

protected:
    CIwManaged* m_Sender;

    CIwEvent() : m_Sender(__null) { m_Hash = IW_EVENT_NULL; }
};





class CIwEventBroadcast : public CIwEvent
{
public:


    using CIwEvent::Send;


    bool Send(CIwManaged *pSender);


    void Post(CIwManaged *pSender);

protected:




    static void AddHandler(CIwManaged* pHandler, CIwManagedList **ppHList);
    static void RemoveHandler(CIwManaged* pHandler, CIwManagedList **ppHList);
    static void ReserveHandlers(CIwManagedList **ppHList, int size);
    virtual CIwManagedList *GetHandlers() = 0;
};






void IwEventInit();


void IwEventSetListStorage(uint16 eventQueueSize, uint16 handlerListSize);


void IwEventTerminate();


void IwEventDeliverPosted();


void IwEventClearAllHandlers();
# 20 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwFile.h" 1
       
# 17 "c:/marmalade/6.2/modules/iwutil/h/IwFile.h"
struct s3eFile;
# 30 "c:/marmalade/6.2/modules/iwutil/h/IwFile.h"
s3eResult IwFileCopy(const char* dest, const char* src);
# 41 "c:/marmalade/6.2/modules/iwutil/h/IwFile.h"
s3eResult IwFileMakeDirs(const char* path);
# 52 "c:/marmalade/6.2/modules/iwutil/h/IwFile.h"
s3eResult IwFileRmTree(const char* path);
# 65 "c:/marmalade/6.2/modules/iwutil/h/IwFile.h"
s3eFile* IwFileOpenPrefixed(const char* filename, const char* mode);
# 75 "c:/marmalade/6.2/modules/iwutil/h/IwFile.h"
bool IwFileGetPathPrefixed(const char* filename, const char* mode, char* out);







bool IwFileCheckExists(const char* filename);
# 93 "c:/marmalade/6.2/modules/iwutil/h/IwFile.h"
void IwFileReadSetPathGlobals(const char** pGlobals);
# 103 "c:/marmalade/6.2/modules/iwutil/h/IwFile.h"
void IwFileReadSetPathPrefixes(const char** pPrefixes);






void IwFileWriteSetPathPrefix(const char* pPrefix);
# 124 "c:/marmalade/6.2/modules/iwutil/h/IwFile.h"
int64 IwFileGetDirSize(const char* path, bool bDoRecursive);
# 133 "c:/marmalade/6.2/modules/iwutil/h/IwFile.h"
int32 IwFileSubCopy(s3eFile* pSrc, s3eFile* pDst, int32 size);
# 21 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2

# 1 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h" 1
       
# 22 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
class CIwImage;
class CIwMemBucket;
class CIwTexture;
struct PNGChunk;
struct PNGHeader;
struct CIwGxCompressedTextureBlock;


extern uint64 g_ColourReductionThreshold;
extern int g_ColourReductionDump;
extern int g_DoColourReduction;
# 85 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
class CIwImage
{
public:

    typedef enum FormatDataFlags
    {

        PALETTISED_4BIT_F = (1 << 0),
        PALETTISED_5BIT_F = (1 << 1),
        PALETTISED_6BIT_F = (1 << 2),
        PALETTISED_7BIT_F = (1 << 3),
        PALETTISED_8BIT_F = (1 << 4),
        PALETTISED_MASK = PALETTISED_4BIT_F | PALETTISED_5BIT_F | PALETTISED_6BIT_F | PALETTISED_7BIT_F | PALETTISED_8BIT_F,

        ALPHA_F = (1 << 5),
        REVERSE_F = (1 << 6),

        SIZE_8_F = (1 << 7),
        SIZE_16_F = (2 << 7),
        SIZE_24_F = (3 << 7),
        SIZE_32_F = (4 << 7),
        SIZE_MASK = (0x7 << 7),

        ALPHA_FLIP_F = (1 << 10),

        NON_PALETTE_ALPHA_F = (1 << 11),

    } FormatDataFlags;


    struct FormatData
    {
        uint16 m_Flags;
        uint8 m_NumBitsR;
        uint8 m_NumBitsG;
        uint8 m_NumBitsB;
        uint8 m_NumBitsA;

        int32 GetByteDepth() const { return (m_Flags & SIZE_MASK) >> 7; }
    };






    enum Format
    {
        FORMAT_UNDEFINED,

        RGB_332,
        BGR_332,


        RGB_565,
        BGR_565,


        RGBA_4444,
        ABGR_4444,
        RGBA_5551,
        ABGR_1555,


        RGB_888,
        BGR_888,


        RGBA_6666,
        ABGR_6666,


        RGBA_8888,
        ABGR_8888,
        RGBA_AAA2,
        ABGR_2AAA,


        PALETTE4_RGB_888,
        PALETTE4_RGBA_8888,
        PALETTE4_RGB_565,
        PALETTE4_RGBA_4444,
        PALETTE4_RGBA_5551,
        PALETTE4_ABGR_1555,

        PALETTE8_RGB_888,
        PALETTE8_RGBA_8888,
        PALETTE8_RGB_565,
        PALETTE8_RGBA_4444,
        PALETTE8_RGBA_5551,
        PALETTE8_ABGR_1555,

        PALETTE7_ABGR_1555,
        PALETTE6_ABGR_1555,
        PALETTE5_ABGR_1555,


        PVRTC_2,
        PVRTC_4,
        ATITC,
        COMPRESSED,

        PALETTE4_ABGR_4444,
        PALETTE8_ABGR_4444,

        A_8,

        ETC,
        ARGB_8888,

        PALETTE4_ARGB_8888,
        PALETTE8_ARGB_8888,

        DXT3,

        PALETTE4_BGR555,
        PALETTE8_BGR555,
        A5_PALETTE3_BGR_555,
        A3_PALETTE5_BGR_555,

        PALETTE4_BGR_565,
        PALETTE4_ABGR_8888,
        PALETTE8_BGR_565,
        PALETTE8_ABGR_8888,

        DXT1,
        DXT5,

        FORMAT_MAX,
    };


    enum ImageFlags
    {
        OWNS_TEXELS_F = (1 << 0),
        OWNS_PALETTE_F = (1 << 1),
        SERIALISE_NO_TEXELS_F = (1 << 2),
        USE_FIXED_BUFFER_F = (1 << 11),
        HAS_ALPHA_FROM_SOURCE_F = (1 << 12),
        NO_CONVERT_MAGENTA_F = (1 <<13),
        PAL_ZERO_IS_ALPHA_ZERO_F = (1 << 14),


        NON_PERSISTENT_FLAGS_MASK = OWNS_TEXELS_F | OWNS_PALETTE_F | USE_FIXED_BUFFER_F

    } ImageFlags;





    CIwImage();





    CIwImage(const CIwImage& img);




    ~CIwImage();

    void operator=(CIwImage const &pImg);
# 258 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    void Serialise();

    void SerialisePaletteOnly();
# 269 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    uint32 GetBitDepth() const { return GetBitDepth(m_Format); }
# 279 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    static uint32 GetBitDepth(const Format &format);
# 288 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    uint32 GetByteDepth() const { return GetByteDepth(m_Format); }
# 298 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    static uint32 GetByteDepth(const Format &format) { return GetBitDepth(format) >> 3;}
# 307 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    uint32 GetTexelBitDepth() const { return GetTexelBitDepth(m_Format); }
# 317 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    static uint32 GetTexelBitDepth(const Format &format);
# 326 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    uint32 GetPaletteSize() const { return GetPaletteSize(m_Format); }
# 336 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    static uint32 GetPaletteSize(const Format &format);
# 346 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    inline uint32 GetTexelsMemSize() const
    {
        if (!IsCompressedFormat(GetFormat()))
        {
            return m_Pitch * m_Height;
        }

        return m_CompressedImageSize;
    }
# 363 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    uint32 GetPaletteMemSize() const { return GetPaletteMemSize(m_Format); }
# 373 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    static uint32 GetPaletteMemSize(const Format &format);
# 382 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    void SetFormat(Format format);
# 391 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    inline Format GetFormat() const {return m_Format;}







    inline FormatData GetFormatData() const {return s_FormatData[m_Format];};






    inline uint16 GetFlags() const {return m_Flags;}






    void SetWidth(uint32 width);







    inline uint32 GetWidth() const {return m_Width;}
# 430 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    inline uint32 GetByteWidth() const
    {
        uint32 texBitDepth = GetTexelBitDepth();
        uint32 byteWidth = (m_Width * texBitDepth + 7)/8;

        ((void)0);

        return byteWidth;
    }







    void SetHeight(uint32 height);







    inline uint32 GetHeight() const {return m_Height;}






    void SetPitch(uint32 pitch);







    inline uint32 GetPitch() const {return m_Pitch;}







    inline uint8* GetTexels() const {return m_Texels;}







    inline uint8* GetPalette() const {return m_Palette;}
# 495 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    uint32 FormatColour(uint8 red, uint8 green, uint8 blue, uint8 alpha = 0xff);
# 505 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    void SetOwnedBuffers(uint8* pTexels, uint8* pPalette);







    inline uint8 HasAlpha() const {return (s_FormatData[m_Format].m_Flags & ALPHA_F) != 0;}







    bool UsesAlpha(uint8 threshold = 0xff) const;
# 530 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    bool UsesChromakey() const;
# 539 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    bool TestForChromakey() const;
# 549 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    void ReadFile(s3eFile* pFile);
# 562 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    void ReadFile(s3eFile* pFile, uint8* pTexels, uint32 texelsSize, uint8* pPalette, uint32 palSize);
# 573 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    void LoadFromFile(const char* imageFile);
# 588 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    void ConvertToImage(CIwImage* pImage, bool chooseDepth = false);
# 607 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    void ConvertToImage(CIwImage* pImage, uint8* pTexels, uint32 texelsSize, uint8* pPalette, uint32 palSize, bool chooseDepth);
# 616 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    void ReplacePalette(uint8* pPalette);
# 635 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    uint32 ReplaceColour(uint8 srcR, uint8 srcG, uint8 srcB, uint8 srcA,
        uint8 dstR, uint8 dstG, uint8 dstB, uint8 dstA);




    uint32 ReplaceAlpha(uint8 threshold, uint8 chromaR, uint8 chromaG, uint8 chromaB);





    uint32 ReplaceAlphaColourWithSurrounding(uint8 threshold=0x80, uint8 numSurrounding=0x2);
# 662 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    uint32 MakeAlphaPalZero(uint8 threshold, uint8 keyR, uint8 keyG, uint8 keyB);







    void SetCompressed(CIwGxCompressedTextureBlock* pBlock);
# 735 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    static void FixedBufferSetSize(uint32 size);






    static void FixedBufferFree();






    static void FixedBufferCheckOverflow();
# 758 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    inline static bool FixedBufferAvailable()
    {
        return s_FixedBucket != __null;
    }






    inline void UseFixedBuffer(bool use)
    {
        if (use == true)
            m_Flags |= USE_FIXED_BUFFER_F;
        else
            m_Flags &= ~USE_FIXED_BUFFER_F;
    }



    static bool IsCompressedFormat(Format format)
    {
        return ( ((format >= PVRTC_2) && (format <= COMPRESSED))
            || ( format == ETC ) || ( format == DXT1 ) || ( format == DXT3 ) || ( format == DXT5 ) );
    }
# 800 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    void SetBuffers(uint8* pTexels = __null, uint32 texelLen = 0, uint8* pPalette = __null, uint32 palSize = 0);







    void ReadPalette(uint8* pPaletteSrc);







    void ReadTexels(uint8* pTexelsSrc);





    int CountColours();
# 831 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    void SaveBmp(const char* filename);
# 840 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    void SaveTga(const char* filename);







    void SavePng(const char* filename);







    void SaveJpg(const char* filename, uint32 quality = 100);
# 866 "c:/marmalade/6.2/modules/iwutil/h/IwImage.h"
    void MakeOwner(uint32 flags);






    void SetOwn(CIwImage* pImg);


    void SetNoOwn(CIwImage* pImg);

private:

    void ReadData(uint32 pitch, uint8* pTexelsSrc, uint8* pPalette);


    void UpdateInfo(CIwImage* pImg);


    inline void SetFlags(uint16 flags) {m_Flags = flags;}


    void FreeData();

    void ConvertToPalettisedImage(CIwImage* pImage, bool useExistingPalette = false);
    void do_neuquant( CIwImage* destImage);
    bool ConvertToPalettisedImageSimple(CIwImage* pImage);
    void ConvertDataToFormat(uint8* pSrcBuffer, uint8* pDstBuffer, CIwImage* pImage, uint32 height, uint32 width);
    void ConvertIndexedDataToFormat(uint8* pPalette, uint8* pIndexData, uint8* pDstBuffer, CIwImage* pImage);
    void ConvertPixelToFormat(uint8* pSrc, uint8* pDst, const FormatData* pSrcFormat, const FormatData* pDstFormat);
    void DecodePixelRGBAFromFormat(uint8* pSrc, uint16* r, uint16* g, uint16* b, uint16* a, const FormatData* srcFormat) const;
    void EncodePixelRGBAToFormat(uint8* pDst, uint16 r, uint16 g, uint16 b, uint16 a, const FormatData* srcFormat, const FormatData* dstFormat) const;
    int ColourLookup(uint32 colour, uint8* pPalette, CIwImage* pImage, int32 paletteSize = -1) const;
    int ColourLookupNearest(uint8* colour, uint8* pPalette, CIwImage* pImage);

    void SetDefaultPitch();


    uint8* IwImageMakePow2(uint32 *outWidth, uint32 *outHeight,
                           uint32 minWidth = 1, uint32 minHeight = 1,
                           uint32 maxWidth = (uint32)-1, uint32 maxHeight = (uint32)-1);


    uint8* IwImageMakePow2Square(uint32 *outWidth, uint32 *outHeight, uint32 minWidth = 1, uint32 minHeight = 1);

    inline uint32 MapColourToResolution(uint32 bitDepthIn, uint32 bitDepthOut, uint16 col)
    {
        uint32 resIn = (1<<bitDepthIn)-1;
        uint32 resOut = (1<<bitDepthOut)-1;

        uint32 oldVal = (uint32)col;

        if(resIn == 0)
            return oldVal;

        return (resOut - (resOut*((resIn) - oldVal)/(resIn)));

    }

    inline uint32 ReformatColourComponent(uint32 bitDepthIn, uint32 bitDepthOut, uint16 col) const
    {
        uint32 mid = ((1<<bitDepthOut)-1)>>1;

        if(bitDepthOut<bitDepthIn)
        {

            uint16 rounded_col = col | (0x1<<(bitDepthIn-bitDepthOut-1));

            return rounded_col>>(bitDepthIn-bitDepthOut);
        }

        uint32 outCol = col<<(bitDepthOut-bitDepthIn);



        if(bitDepthIn && outCol >= mid)
        {
            outCol |= (1<<(bitDepthOut-bitDepthIn))-1;

        }

        return outCol;
    }

    inline void AssignRGB(uint8* pDst, uint8* pSrc, uint8 reverse)
    {
        pDst[0] = pSrc[reverse ? 2:0];
        pDst[1] = pSrc[1];
        pDst[2] = pSrc[reverse ? 0:2];

    }

    inline void AssignRGBA(uint8* pDst, uint8* pSrc, uint8 reverse)
    {
        pDst[0] = pSrc[reverse ? 3:0];
        pDst[1] = pSrc[reverse ? 2:1];
        pDst[2] = pSrc[reverse ? 1:2];
        pDst[3] = pSrc[reverse ? 0:3];
    }

    inline void AssignARGB(uint8* pDst, uint8* pSrc, uint8 reverse)
    {
        pDst[0] = pSrc[reverse ? 2:3];
        pDst[1] = pSrc[reverse ? 1:0];
        pDst[2] = pSrc[reverse ? 0:1];
        pDst[3] = pSrc[reverse ? 3:2];
    }

    void DecodeGIF(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);
    void DecodeTGA(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);
    void DecodePNG(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);
    void DecodeRAW(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);
    void DecodeRP4(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);
    void DecodeJPG(void* pSrc, uint32 srcLen, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);


    void DecodePVR(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);

    void DecodeATI(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);

    uint32 ByteRead32(uint8* pSrc, int32 length) const;

    void ByteWrite32(uint32 val, uint8* pDst, int32 length) const;






    void IwImageReplicateColumns(uint32 outWidth, uint8 *outImage);






    void IwImageReplicateRows(uint32 outWidth, uint32 outHeight, uint8 *outImage);





    void ReduceImagePalette8( CIwImage* pImage, bool chooseDepth );





    void ResizeToImage(CIwImage* pImage);



    bool CanMipMapImage() const;
    uint32 CalculateMipMapLevels() const;
    uint32 CalculateMipMapBufferSize(uint32 level) const;
    void CalculateMipMapDimensions(uint32* width, uint32* height, uint32 level) const;
    bool CreateMipMip(CIwImage* pImage, uint32 level, uint8* pTexels, uint32 texelLen,
        bool doChromaKeyTransparency) const;
    inline void ReadAndAccumulateSample(uint16* pR, uint16* pG, uint16* pB, uint16* pA,
        uint8* pSrc, uint32 stepX, uint32 stepY, uint32 numX, uint32 numY,
        bool doChromaKeyTransparency) const;

protected:


    static void ConvertTexelsBetweenFormats ( void* pSrcTexels, void* pDstTexels, Format srcFormat, Format dstFormat, uint32 width, uint32 height);
    static void ConvertPaletteBetweenFormats( void* pSrcPalette, void* pDstPalette,Format srcFormat, Format dstFormat);

private:
    uint16 m_Flags;
    Format m_Format;
    uint8 pad0;
    uint16 pad1;
    uint16 m_Width;
    uint16 m_Height;
    uint16 m_Pitch;
    uint8* m_Texels;
    uint8* m_Palette;
    uint32 m_CompressedImageSize;

    static const FormatData s_FormatData[];
    static CIwMemBucket* s_FixedBucket;
    static uint8* s_FixedBucketControlled;
    static uint32 s_FixedBufferSize;
    friend class CIwTexture;





    uint8* Alloc(uint32 size);

public:
    static const char* g_FormatNames[];

    friend class CIwGxMipMapBuilder;
    friend void CopyTGATexel(CIwImage* image, uint8* dest, uint8* src);
    friend void DecodeIHDRChunk(void* pSrc, PNGHeader* pHeader, CIwImage* pImg,uint8* pTexels, uint32 texelsLen,uint8* pPalette, uint32 palLen);
    friend void DecodePLTEChunk(void* pSrc, PNGChunk* pChunk, CIwImage* pImg);
    friend void FinishIDATDecode(PNGHeader* pHeader, CIwImage* pImg);
    friend void DecodetRNSChunk(void* pSrc, PNGHeader* pHeader, PNGChunk* pChunk, CIwImage* pImg);
    friend void SelectImageFormat(PNGHeader* pHeader, uint8 alpha, CIwImage* pImg);
    void _DecodeBMP(void* pHdr, void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);
    void _SetMagentaConversion(bool on) {on?m_Flags &= ~NO_CONVERT_MAGENTA_F:m_Flags |= NO_CONVERT_MAGENTA_F; };




};


enum CompressedBlockVersion
{
    IW_GX_COMP_OLD_DATA = 0,
    IW_GX_COMP_VERS_1 = 1,
    IW_GX_COMP_VERS_2 = 2,
};

struct CIwGxCompressedTextureBlock
{

    enum { MAX_MIPMAPS_LEVELS = 12 };

    static CIwGxCompressedTextureBlock* Create(CIwImage::Format fmt,
        uint32 uploadFormat,
        uint32 width,
        uint32 height,
        uint32 numLevels,
        uint8** levels,
        uint32 *sizes);

    uint16 m_ImageFormat;
    uint16 m_Version;
    uint32 m_BlockSize;
    uint32 m_OpenGLFormat;
    uint32 m_NumMipmaps;
    uint32 m_TextureWidth;
    uint32 m_TextureHeight;
    uint32 m_CompressedTextureSizes[MAX_MIPMAPS_LEVELS];
};
# 23 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2

# 1 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h" 1
       
# 21 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
class CIwMemBucket;

typedef int32 IwMemBlockIterator(CIwMemBucket* bucket, void* item, void* user);
# 43 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
class CIwMemBucket
{
protected:
    CIwMemBucket();

public:
    virtual ~CIwMemBucket();






    void SetName(const char* name);






    inline const char* GetName() {return m_Name;}


    inline const char* DebugGetName() {return GetName();}




    const char* m_Name;
# 80 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual void Free(void* item) = 0;
# 90 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual void* Realloc(void* item, int32 size) = 0;
# 99 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual int32 Owns(void* item) = 0;






    virtual int32 DebugTestIntegrity() {return 0;}
# 119 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual int32 GetSize(void* item) {return -1;}
# 131 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual int32 GetMemUsage(void* item) {return -1;}
# 142 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual int32 GetFree() {return -1;}







    virtual int32 GetUsed() {return -1;}
# 160 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual int32 GetLargestFreeBlock() {return -1;}
# 170 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual int32 GetFragmentation() {return -1;}
# 180 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual int32 GetTotalSize(){return -1;}
# 192 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual int32 IterateBlocks(IwMemBlockIterator* fn, void* user) {return -1;}
};
# 203 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
class CIwMemBucketDebuggerInterface
{
protected:
    CIwMemBucketDebuggerInterface() : m_NextDebugger(0)
    {}

public:
    virtual ~CIwMemBucketDebuggerInterface() {}
# 219 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual void PreFree(CIwMemBucket* bucket, void* item){};
# 228 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual void PostFree(CIwMemBucket* bucket, void* item) {};
# 238 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual void PreRealloc(CIwMemBucket* bucket, void* old_item, int32 new_size) {};
# 247 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual void PostRealloc(CIwMemBucket* oldBucket, void* old_item, CIwMemBucket* newBucket, void* new_item, int32 new_size) {};
# 257 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual void DebugSetName(CIwMemBucket* bucket, void* item, const char* name) {};
# 267 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual void AllocationFailure(CIwMemBucket* bucket, void* item, int32 size_requested) {};

    CIwMemBucketDebuggerInterface* m_NextDebugger;
};
# 280 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
class CIwMemBucketSelector
{
    CIwMemBucketDebuggerInterface* m_FirstDebugger;

protected:
    CIwMemBucketSelector() : m_FirstDebugger(0) {}

public:
    virtual ~CIwMemBucketSelector() {}
# 299 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual CIwMemBucket* FindBucket(void* item) = 0;
# 309 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual CIwMemBucket* SelectBucket(int32 size) = 0;
# 322 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    virtual CIwMemBucket* SelectRebucket(CIwMemBucket* oldBucket, void* item, int32 newSize) = 0;







    void AddDebugger(CIwMemBucketDebuggerInterface* p);







    void RemoveDebugger(CIwMemBucketDebuggerInterface* p);

    CIwMemBucketDebuggerInterface* GetFirstDebugger() { return m_FirstDebugger; }

private:
    CIwMemBucket* _SysFindBucket(void* item);
    CIwMemBucket* _SysSelectBucket(int32 size);
    CIwMemBucket* _SysSelectRebucket(CIwMemBucket* oldBucket, void* item, int32 newSize);
    friend void* IwMallocNamed(int32, const char*);
    friend void IwMallocRename(void*, const char*);
    friend void* IwRealloc2(void*, int);
    friend void IwFree2(void*);
};







void IwMemBucketSetSelector(CIwMemBucketSelector* s);
# 367 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
CIwMemBucketSelector* IwMemBucketGetSelector();
# 377 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
CIwMemBucket* IwMemBucketSetOverride(CIwMemBucket* s);
# 442 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
void* IwMalloc2(int size);
# 452 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    void* IwRealloc2(void* item, int new_size);






void IwFree2(void* item);
# 478 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    void* IwMallocBucket(CIwMemBucket* bucket, int32 new_size);
# 489 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    void* IwReallocBucket(CIwMemBucket* bucket, void* item, int32 new_size);
# 502 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    void* IwReallocBucketChange(CIwMemBucket* bucket, void* item, CIwMemBucket* newBucket, int32 new_size);
# 511 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
    void IwFreeBucket(CIwMemBucket* bucket, void* item);
# 523 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
void IwMemBucketDebugAdd(CIwMemBucketDebuggerInterface* debug);
# 533 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
void IwMemBucketDebugRemove(CIwMemBucketDebuggerInterface* debug);







class CIwMemBucketSystem : public CIwMemBucket
{
public:
    CIwMemBucketSystem();
    virtual ~CIwMemBucketSystem() {}

    virtual void Free(void* item);
    virtual void* Realloc(void* item, int32 size);
    virtual int32 Owns(void* item);
    virtual int32 GetFree();
    virtual int32 GetUsed();
    virtual int32 GetLargestFreeBlock();
    virtual int32 GetTotalSize();
};


void IwMemBucketInit();
void IwMemBucketTerminate();
# 584 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
inline void * operator new(size_t size, const char* name, CIwMemBucket* bucket)
{
    return IwMallocBucket(bucket, size);
}
# 597 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
inline void operator delete(void* item, const char* name, CIwMemBucket* bucket)
{
    s3eFree(item);
}

inline void * operator new [] (size_t size, const char* name, CIwMemBucket* bucket)
{
    return IwMallocBucket(bucket, size);
}
inline void operator delete [] (void* item, const char* name, CIwMemBucket* bucket)
{
    s3eFree(item);
}
inline void * operator new(size_t size, const char* name, CIwMemBucket& bucket)
{
    return IwMallocBucket(&bucket, size);
}
inline void operator delete(void* item, const char* name, CIwMemBucket& bucket)
{
    s3eFree(item);
}
inline void * operator new(size_t size, CIwMemBucket& bucket)
{
    return IwMallocBucket(&bucket, size);
}
inline void operator delete(void* item, CIwMemBucket& bucket)
{
    IwFreeBucket(&bucket, item);
}
inline void * operator new [] (size_t size, CIwMemBucket& bucket)
{
    return IwMallocBucket(&bucket, size);
}
inline void operator delete [] (void* item, CIwMemBucket& bucket)
{
    IwFreeBucket(&bucket, item);
}
inline void * operator new(size_t size, CIwMemBucket* bucket)
{
    return IwMallocBucket(bucket, size);
}
inline void operator delete(void* item, CIwMemBucket* bucket)
{
    IwFreeBucket(bucket, item);
}
inline void * operator new [] (size_t size, CIwMemBucket* bucket)
{
    return IwMallocBucket(bucket, size);
}
inline void operator delete [] (void* item, CIwMemBucket* bucket)
{
    IwFreeBucket(bucket, item);
}
# 667 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucket.h"
extern CIwMemBucketSystem* g_SystemBucket;
# 25 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2

# 1 "c:/marmalade/6.2/modules/iwutil/h/IwKeymap.h" 1
       
# 17 "c:/marmalade/6.2/modules/iwutil/h/IwKeymap.h"
# 1 "c:/marmalade/6.2/s3e/h/s3eKeyboard.h" 1
# 18 "c:/marmalade/6.2/modules/iwutil/h/IwKeymap.h" 2
# 47 "c:/marmalade/6.2/modules/iwutil/h/IwKeymap.h"
void IwKeymapMapKey(uint32 gameKey, s3eKey sysKey);
# 56 "c:/marmalade/6.2/modules/iwutil/h/IwKeymap.h"
int32 IwKeymapGetKey(s3eKey sysKey);
# 65 "c:/marmalade/6.2/modules/iwutil/h/IwKeymap.h"
s3eKey IwKeymapGetSystemKey(uint32 gameKey);
# 76 "c:/marmalade/6.2/modules/iwutil/h/IwKeymap.h"
int32 IwKeymapGetState(uint32 gameKey);





s3eBool IwKeymapCanBind(s3eKey key);
# 97 "c:/marmalade/6.2/modules/iwutil/h/IwKeymap.h"
typedef enum
{
        IwGameKeyFirst,


        IwKeyPSX_Start ,
        IwKeyPSX_Select ,
        IwKeyPSX_Left ,
        IwKeyPSX_Up ,
        IwKeyPSX_Right ,
        IwKeyPSX_Down ,
        IwKeyPSX_Triangle ,
        IwKeyPSX_Circle ,
        IwKeyPSX_Cross ,
        IwKeyPSX_Square ,
        IwKeyPSX_Left_Shoulder ,
        IwKeyPSX_Right_Shoulder ,
        IwKeyPSX_Left_Shoulder2 ,
        IwKeyPSX_Right_Shoulder2 ,
        IwKeyPSX_Escape ,


        IwKeyGameSpecific_0 ,
        IwKeyGameSpecific_1 ,
        IwKeyGameSpecific_2 ,
        IwKeyGameSpecific_3 ,
        IwKeyGameSpecific_4 ,
        IwKeyGameSpecific_5 ,
        IwKeyGameSpecific_6 ,
        IwKeyGameSpecific_7 ,
        IwKeyGameSpecific_8 ,
        IwKeyGameSpecific_9 ,
        IwKeyGameSpecific_10 ,
        IwKeyGameSpecific_11 ,
        IwKeyGameSpecific_12 ,
        IwKeyGameSpecific_13 ,
        IwKeyGameSpecific_14 ,
        IwKeyGameSpecific_15 ,
        IwKeyGameSpecific_16 ,
        IwKeyGameSpecific_17 ,
        IwKeyGameSpecific_18 ,
        IwKeyGameSpecific_19 ,
        IwKeyGameSpecific_20 ,
        IwKeyGameSpecific_21 ,
        IwKeyGameSpecific_22 ,
        IwKeyGameSpecific_23 ,
        IwKeyGameSpecific_24 ,
        IwKeyGameSpecific_25 ,
        IwKeyGameSpecific_26 ,
        IwKeyGameSpecific_27 ,
        IwKeyGameSpecific_28 ,
        IwKeyGameSpecific_29 ,
        IwKeyGameSpecific_30 ,
        IwKeyGameSpecific_31 ,

} IwGameKey;


extern "C" {
# 166 "c:/marmalade/6.2/modules/iwutil/h/IwKeymap.h"
s3eKey IwKeymapGetSegKey(IwGameKey gameKey);
# 176 "c:/marmalade/6.2/modules/iwutil/h/IwKeymap.h"
IwGameKey IwKeymapGetGameKey(s3eKey mapKey);
# 185 "c:/marmalade/6.2/modules/iwutil/h/IwKeymap.h"
int32 IwKeymapGetGameKeyState(IwGameKey gameKey);







void IwKeymapClearGameKeyState(IwGameKey gameKey);







void IwKeymapEnable();







void IwKeymapDisable();


}
# 27 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2

# 1 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucketHelpers.h" 1
       
# 20 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucketHelpers.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwMemManagerDL.h" 1
# 40 "c:/marmalade/6.2/modules/iwutil/h/IwMemManagerDL.h"
struct DL_Malloc_Info {
  int arena;
  int ordblks;
  int smblks;
  int hblks;
  int hblkhd;
  int usmblks;
  int fsmblks;
  int uordblks;
  int fordblks;
  int keepcost;
  int maxblock;
  int freeattop;
};

struct malloc_state;


extern "C" {


void* DL_Malloc_malloc(struct malloc_state * av, uint32 bytes);



void DL_Malloc_free(struct malloc_state * av, void* mem);

void* DL_Malloc_realloc(struct malloc_state * av, void* oldmem, uint32 bytes);
struct DL_Malloc_Info DL_Malloc_mallinfo(struct malloc_state * av);
void DL_Malloc_malloc_consolidate(struct malloc_state * av);
void DL_Malloc_setnoncontiguous(struct malloc_state * av);


int DL_Malloc_GetSize(void* p);
# 85 "c:/marmalade/6.2/modules/iwutil/h/IwMemManagerDL.h"
}

class DL_Malloc
{
    char av_[888];
    malloc_state* m_State;

    typedef unsigned int uint32;
    typedef unsigned int INTERNAL_SIZE_T;

    void* sYSMALLOc(INTERNAL_SIZE_T nb);
    void malloc_consolidate();
    void** iALLOc(uint32 n_elements, uint32* sizes, int opts, void* chunks[]);

public:
    friend void *DL_Malloc_MORECORE (malloc_state * av, long size);

    DL_Malloc_Info mallinfo() { return DL_Malloc_mallinfo(m_State); }

    char * dl_malloc_buffer;
    int dl_malloc_buffer_pos;
    int dl_malloc_buffer_len;







    DL_Malloc(void * a, int l)
    {
        Init(a, l);
    }

    void Init(void* a, int l)
    {
        memset(av_, 0, 888);
        m_State = (malloc_state*)(void*)av_;
        dl_malloc_buffer_pos = 0;
        dl_malloc_buffer_len = l&~7;
        dl_malloc_buffer = (char*)a;






        Free(Alloc((dl_malloc_buffer_len)-16-4));
    }
# 197 "c:/marmalade/6.2/modules/iwutil/h/IwMemManagerDL.h"
    void* Finish() {

        void* p = dl_malloc_buffer;

        dl_malloc_buffer_pos = 0;
        dl_malloc_buffer_len = 0;
        dl_malloc_buffer = 0;

        return p;
    }
# 215 "c:/marmalade/6.2/modules/iwutil/h/IwMemManagerDL.h"
    void Free(void * data)
    {
        DL_Malloc_free(m_State, data);
    }
    void* Realloc(void * data, int bytes)
    {
        return DL_Malloc_realloc(m_State, data,bytes);
    }
    void* Alloc(int bytes)
    {
        return DL_Malloc_malloc(m_State, bytes);
    }

    bool Owned(void * data)
    {
# 242 "c:/marmalade/6.2/modules/iwutil/h/IwMemManagerDL.h"
        if(data<dl_malloc_buffer || data>=dl_malloc_buffer+dl_malloc_buffer_len)
            return false;
        return true;
    }

    int GetFree()
    {
        return dl_malloc_buffer_len - mallinfo().uordblks;
    }

    int GetLFB()
    {
        DL_Malloc_malloc_consolidate(m_State);
        DL_Malloc_Info m(mallinfo());
        return m.maxblock;
    }

    int GetSize()
    {
        return dl_malloc_buffer_len;
    }

    bool IsEmpty()
    {
        if (dl_malloc_buffer)
            return (mallinfo().uordblks <= 4);
        else
            return true;
    }
};
# 21 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucketHelpers.h" 2
# 44 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucketHelpers.h"
int32 BlockIteratorMeasureInt(CIwMemBucket* bucket, void* item, void* user);




class CIwMemBucketBuffer : public CIwMemBucket
{
protected:
    uint32* mem32;
    uint32 size32;

public:






    CIwMemBucketBuffer(void* mem, int32 size, const char* _name)
    {
        ((void)0);

        intptr_t begin = (((intptr_t)mem + 3) & ~3);
        intptr_t end = (intptr_t)mem + size;

        mem32 = (uint32*)begin;
        size32 = (end-begin) >> 2;

        SetName(_name);
    }

    virtual ~CIwMemBucketBuffer()
    {}

    virtual int32 GetTotalSize()
    {
        return size32<<2;
    }

    virtual int32 Owns(void* item)
    {
        return (uint32)((uint32*)item - mem32) < size32;
    }
};




class CIwMemBucketDLBuffer : public CIwMemBucketBuffer
{
    DL_Malloc DL_Manager;

public:






    CIwMemBucketDLBuffer(void* mem, int32 size, const char* _name)
        : CIwMemBucketBuffer(mem, size, _name),
            DL_Manager(mem,size)
    {
    }

    virtual ~CIwMemBucketDLBuffer() {}

    virtual int32 GetSize(void* item)
    {
        return 0;
    }

    virtual int32 GetMemUsage(void* item)
    {
        return 0;
    }

    virtual void Free(void* item)
    {
        DL_Manager.Free(item);
    }

    virtual void* Realloc(void* item, int32 size)
    {
        return DL_Manager.Realloc(item, size);
    }

    virtual int32 GetFree();

    virtual int32 GetUsed() ;

    virtual int32 GetLargestFreeBlock();

    virtual int32 Owns(void* item)
    {
        if(item<mem32 || item>=mem32+size32)
            return false;

        return true;
    }
};





class CIwMemBucketFixedSize : public CIwMemBucketBuffer
{
    struct Item
    {
        Item* prev;
        Item* next;
        char _data[1];
    };

    Item* used;
    Item* free;
    int32 componentSize;
    int32 realComponentSize;
    int32 capacity;
    int32 numFree;

    Item* GetItem(int i)
    {
        return (Item*)(((intptr_t)mem32) + realComponentSize*i);
    }

    Item* GetItem(void* item)
    {
        ((void)0);
        return (Item*)((intptr_t)item - sizeof(Item*)*2);
    }

    void Free(Item* item)
    {

        if (used==item)
            used = item->next;
        if (item->prev) item->prev->next = item->next;
        if (item->next) item->next->prev = item->prev;


        numFree++;
        item->prev = 0;
        item->next = free;
        free = item;
        if (item->next) item->next->prev = item;
    }

    void* AllocNew()
    {
        if (!free)
            return 0;

        Item* item = free;


        numFree--;
        free = free->next;
        if (item->next) item->next->prev = 0;



        item->next = used;
        used = item;
        if (item->next) item->next->prev = item;

        return item->_data;
    }

public:
# 223 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucketHelpers.h"
    CIwMemBucketFixedSize(void* mem, int32 size, int32 component_size, const char * _name)
        : CIwMemBucketBuffer(mem, size, _name)
    {

        componentSize = ((component_size+3) & ~3);
        realComponentSize = componentSize + 2*sizeof(Item*);
        capacity = (size32 * sizeof(uint32)) / realComponentSize;


        for (int32 i=0; i<capacity; i++)
        {
            GetItem(i)->prev = (i==0) ? 0 : GetItem(i-1);
            GetItem(i)->next = (i==capacity-1) ? 0 : GetItem(i+1);
        }
        used = 0;
        free = GetItem(0);
        numFree = capacity;
    }

    virtual int32 GetSize(void* item)
    {
        ((void)0);
        return componentSize;
    }

    virtual int32 GetMemUsage(void* item)
    {
        ((void)0);
        return realComponentSize;
    }

    virtual void Free(void* item)
    {

        Free(GetItem(item));
    }

    virtual void* Realloc(void* item, int32 size)
    {
        if (size > componentSize)
        {

            return 0;
        }
        else if (item)
        {

            return item;
        }
        else
        {
            return AllocNew();
        }
    }

    virtual int32 GetFree()
    {
        return numFree * componentSize;
    }

    virtual int32 GetUsed()
    {
        return (capacity - numFree) * componentSize;
    }

    virtual int32 GetLargestFreeBlock()
    {
        return numFree>0 ? componentSize : -1;
    }

    virtual int32 GetFragmentation()
    {
        return 0;
    }

    virtual int32 IterateBlocks(IwMemBlockIterator* fn, void* user)
    {
        for (Item * i = used; i; i=i->next)
        {
            int32 r = fn(this, i, user);
            if (r)
                return r;
        }
        return 0;
    }
};







template <class X, int32 size>
class CIwMemBucketBuiltin : public X
{
    char internal[size - sizeof(X)];

public:






    CIwMemBucketBuiltin(const char* name) : X(internal, sizeof(internal), name)
    {}

    virtual ~CIwMemBucketBuiltin() {}
};






template <int32 size>
class CIwMemBucketBuiltinFixedSize : public CIwMemBucketFixedSize
{
    char internal[size - sizeof(CIwMemBucketFixedSize)];

public:
    CIwMemBucketBuiltinFixedSize(int32 component_size, const char * name) : CIwMemBucketFixedSize(internal, sizeof(internal), component_size, name)
    {}
};
# 361 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucketHelpers.h"
class CIwMemBucketGuarded : public CIwMemBucket
{
    CIwMemBucket* const m_Parent;
    const bool m_OwnsParent;
    int32 m_NumMarked;





    struct Footer
    {
        uint32 magicDefense;
        uint32 blockSize;
    };
    struct Header
    {
        uint32 blockSize;
        Header *prev, *next;
        uint32 magicDefense;

        Footer* GetFooter();
        void Test();
        void Unmark();
        void Mark(int32 size);
    };
    Header* m_FirstHeader;
    friend struct CIwMemBucketGuarded::Header;

    void* ConvertToInternal(void* item);
    void* ConvertToExternal(void* item);
    void* Mark(void* item, int32 size);
    void* Unmark(void* item);
    void* TestExternal(void* item);
    void* TestInternal(void* item);
    void TestAll();
    int32 GetSize(int32 requestSize);

    static int32 IterateWrapFn(CIwMemBucket* bucket, void* item, void* user);

public:







    CIwMemBucketGuarded(CIwMemBucket* _parent, bool ownership);

    ~CIwMemBucketGuarded() ;


    virtual void Free(void* item);
    virtual void* Realloc(void* item, int32 size);
    virtual int32 Owns(void* item) { return m_Parent->Owns(ConvertToInternal(item)); }

    virtual int32 GetSize(void* item) {return m_Parent->GetSize(TestExternal(item));}
    virtual int32 GetMemUsage(void* item) {return m_Parent->GetMemUsage(TestExternal(item));}

    virtual int32 DebugTestIntegrity() {int32 i=m_Parent->DebugTestIntegrity(); TestAll(); return i;}

    virtual int32 GetFree() {return m_Parent->GetFree()-sizeof(Header)-sizeof(Footer);}
    virtual int32 GetUsed() {return m_Parent->GetUsed();}
    virtual int32 GetLargestFreeBlock() {return m_Parent->GetLargestFreeBlock()-sizeof(Header)-sizeof(Footer);}
    virtual int32 GetFragmentation() {return m_Parent->GetFragmentation();}

public:
    virtual int32 IterateBlocks(IwMemBlockIterator* fn, void* user) ;
};






class CIwMemBucketDebugBigAllocationSpotter : public CIwMemBucketDebuggerInterface
{
    int32 m_WarnSize;

public:
    CIwMemBucketDebugBigAllocationSpotter(int32 warnSize) : m_WarnSize(warnSize)
    {
    }

    ~CIwMemBucketDebugBigAllocationSpotter()
    {
    }

    virtual void PreRealloc (CIwMemBucket* bucket, void* old_item, int32 new_size)
    {
        ((void)0);
    }
};





class CIwMemBucketDebugTester : public CIwMemBucketDebuggerInterface
{

    CIwMemBucket* m_Watching[20];

public:

    bool m_TestFree;

    bool m_TestRealloc;

    CIwMemBucketDebugTester() : m_TestFree(true), m_TestRealloc(true)
    {
        for (int32 i=0; i<20; i++)
            m_Watching[i] = 0;
    }
    virtual ~CIwMemBucketDebugTester()
    {}







    void TestAll();
# 494 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucketHelpers.h"
    void Add(CIwMemBucket* i);
# 503 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucketHelpers.h"
    void Remove(CIwMemBucket* i);




    virtual void PreFree (CIwMemBucket* bucket, void* item) { if (m_TestFree) TestAll(); }



    virtual void PreRealloc (CIwMemBucket* bucket, void* old_item, int32 new_size) { if (m_TestRealloc) TestAll(); }
};





class CIwMemBucketDebugWatcher : public CIwMemBucketDebuggerInterface
{
# 530 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucketHelpers.h"
public:



    struct Info
    {
        const char* callstack[0x50];
        char name[20];
        void* item;
        CIwMemBucket* bucket;
        int32 itemSize;







        void Clear();






        void SetName(const char * n);





        void SetCallstack();
    };

private:

    Info mInfo[20000];
    int32 used[20000];
    int32 numInfo;

    Info* AllocInfo(CIwMemBucket* bucket, void* item, const char* name);
    void FindAndFreeInfo(void* item);

public:

    CIwMemBucketDebugWatcher();
    virtual ~CIwMemBucketDebugWatcher() {}
# 586 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucketHelpers.h"
    Info* FindInfo(void* item);
# 595 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucketHelpers.h"
    int32 NumInfo() { return numInfo; }
# 605 "c:/marmalade/6.2/modules/iwutil/h/IwMemBucketHelpers.h"
    Info* GetInfoID(int32 i) { return &mInfo[used[i]]; }



    virtual void PreFree (CIwMemBucket* bucket, void* item);



    virtual void PostFree (CIwMemBucket* bucket, void* item);



    virtual void PreRealloc (CIwMemBucket* bucket, void* old_item, int32 new_size);






    virtual void PostRealloc (CIwMemBucket* oldBucket, void* old_item, CIwMemBucket* newBucket, void* new_item, int32 new_size);



    virtual void SetDebugName (CIwMemBucket* bucket, void* item, const char* name);



    virtual void AllocationFailure (CIwMemBucket* bucket, void* item, int32 size_requested);
};







class CIwMemBucketSystemDebug : public CIwMemBucketDLBuffer
{
public:
    CIwMemBucketSystemDebug(void* mem, int32 size, const char* _name) :
        CIwMemBucketDLBuffer(mem, size, _name) {};
};
# 29 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2

# 1 "c:/marmalade/6.2/modules/iwutil/h/IwProfileMenu.h" 1
       
# 29 "c:/marmalade/6.2/modules/iwutil/h/IwProfileMenu.h"
class CIwProfileMenuItem : public CIwMenuItem
{
public:

    CIwProfileMenuItem(const char* text, uint16 id, CIwMenuItem::ColourID colID);
    ~CIwProfileMenuItem() {};
    virtual void Select();
    virtual void Back();
    virtual void Render(int32 x, int32 y);
    virtual void Plus();
    virtual void Minus();


    uint16 m_Index;

    static const int32 g_CharW;
    static const int32 g_FieldW0;
    static const int32 g_FieldW1;
};
# 59 "c:/marmalade/6.2/modules/iwutil/h/IwProfileMenu.h"
class CIwProfileMenuList : public CIwMenu
{
public:

    CIwProfileMenuList(CIwProfileIterator* pIt);
    void Enter();


    CIwProfileIterator* m_ProfileIt;
};





class CIwProfileMenu
{
public:

    CIwProfileMenu();
    ~CIwProfileMenu();


    static CIwProfileMenu& Get() {return *g_Singleton;}


    CIwMenu* m_Menu;
    CIwProfileIterator* m_ProfileIt;


    static CIwProfileMenu* g_Singleton;

    static uint32 g_ProfilePage;
};
# 31 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwResource.h" 1
       
# 28 "c:/marmalade/6.2/modules/iwutil/h/IwResource.h"
class CIwMenu;
class CIwResTemplate;






class CIwManagedRefCount : public CIwManaged
{
public:
    enum
    {
        RESOLVED_F = (1 << 0),
    };

    typedef CIwArray<CIwManagedRefCount*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    inline CIwManagedRefCount()
    {
        m_RefCount = 0;
        m_Flags = 0;
    }
    virtual void DebugAddMenuItems(CIwMenu* pMenu);

    inline void IncCount() {m_RefCount++;}
    inline void DecCount()
    {
        ((void)0);
        --m_RefCount;
    }
    inline bool IsCountZero() const {return m_RefCount == 0;}
    inline void SetResolved() {m_Flags |= RESOLVED_F;}
    inline bool IsResolved() const {return (m_Flags & RESOLVED_F) != 0;}

    const CIwManagedRefCount& operator= (const CIwManagedRefCount &source)
    {
        CIwManaged::operator=(source);
        m_Flags = source.m_Flags;
        return *this;
    }

    virtual void _Replace(CIwManaged* pRHS);

private:
    uint16 m_RefCount;
    uint16 m_Flags;
};






class CIwResource : public CIwManagedRefCount
{
public:
    typedef CIwArray<CIwResource*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;

    CIwResource() {};


    virtual void ApplyScale(int32 scale) {}

    virtual void ApplyScale(float scale) {}

};
# 32 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2


# 1 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h" 1
       
# 20 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwTextParser.h" 1
       
# 54 "c:/marmalade/6.2/modules/iwutil/h/IwTextParser.h"
class CIwTextParser
{
public:
# 70 "c:/marmalade/6.2/modules/iwutil/h/IwTextParser.h"
    virtual void* ParseFile(const char* pPathname, bool allowNonExist = false);







    virtual void* ParseString(const char* pString, const char* pPathname = __null);





    typedef void(*TokenFn)(CIwTextParser* pImp);


    inline bool IsWhitespace(char c) {return (c == ' ') || (c == '\t') || (c == '\n') || (c == '\r');}


    inline bool IsTerminator(char c) {return (c == ' ') || (c == '\t') || (c == '\n') || (c == '\r') || (c == '\0');}


    struct TokenInfo
    {
        const char* m_String;
        TokenFn m_Fn;
    };



    typedef CIwArray<TokenInfo> TokenInfoArray;


    typedef TokenInfoArray::iterator TokenInfoArrayIt;


    struct State
    {
        s3eFile* m_File;
        const char* m_Pathname;
        const char* m_CharStart;
        const char* m_Char;
        int32 m_TokenOfs;
        char m_Token[200];
        void* m_ReturnValue;
        int32 m_Line;
        int32 m_Col;
    };


    typedef CIwArray<State> StateArray;


    typedef StateArray::iterator StateArrayIt;

    CIwTextParser();
    virtual ~CIwTextParser();






    void AddTokenFunction(const char* pString, TokenFn pFn);





    inline void _PushState(const State& state) {m_StateStack.push_back(state);}




    inline void _PopState() {m_StateStack.pop_back();}





    inline State* _GetState()
    {
        ((void)0);
        return m_StateStack.end() - 1;
    }





    inline void SetReturnValue(void* value)
    {
        State* pState = _GetState();
        pState->m_ReturnValue = value;
    }






    inline State* _GetStateNoAssert()
    {
        if (!m_StateStack.size())
            return __null;
        else
            return m_StateStack.end() - 1;
    }





    bool ParseToken();





    char ReadChar(bool checkValid = true);

    void UnreadChar();







    bool MatchStrings(const char* pChar0, const char* pChar1);
# 209 "c:/marmalade/6.2/modules/iwutil/h/IwTextParser.h"
    bool MatchStringsIgnoreCase(const char* pChar0, const char* pChar1);




    void SkipBackToken();

private:
    void _Parse();
    TokenInfoArray m_TokenInfos;
    StateArray m_StateStack;
    friend void IwTextParserAssertCallback(char* pBuffer);
};
# 21 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h" 2
# 41 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
class CIwParseable;
class CIwTextParserITX;
# 65 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
class CIwTextParserITX : public CIwTextParser
{
public:




    typedef CIwString<40> Field;




    typedef CIwArray<Field> FieldArray;




    typedef FieldArray::iterator FieldArrayIt;




    CIwTextParserITX();




    ~CIwTextParserITX();
# 102 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    virtual void* ParseFile(const char* pPathname, bool allowNonExist = false);
# 116 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void SkipScope();
# 139 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    inline void SetAssertOnUnrecognisedTokens(bool as)
    {
        m_AssertOnUnrecognisedTokens = as;
    }
# 154 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadString(char* pBuffer, uint32 buffSize, bool checkValid = true);
# 163 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadString(CIwStringS& string, bool checkValid = true) { ReadString((char*)string.c_str(), 32, checkValid); }
# 172 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadString(CIwStringL& string, bool checkValid = true) { ReadString((char*)string.c_str(), 160, checkValid); }
# 182 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    char* ReadString(bool checkValid = true);
# 191 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void PeekString(char* pString, int32 len, bool checkValid = true);
# 200 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadStringHash(uint32* pValue);
# 211 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadScope(char* pBuffer, uint32 buffSize);
# 221 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadLine(char* pBuffer, uint32 buffSize);
# 230 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    static void FieldStripQuotes(Field& f);
# 241 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    static void FilterString(const char*& pChar, FieldArray& fields, const char* fieldBreaks, const char* stringBreaks);
# 252 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    static uint32 FilterStringGetFlags(const char* pChar, const char** ppNames);
# 264 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    static bool FilterStringSetFlags(const char* pChar, const char** ppNames, uint32& flags);
# 276 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    static bool FilterStringResetFlags(const char* pChar, const char** ppNames, uint32& flags);
# 287 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    static bool FilterStringGetEnum(const char* pChar, const char** ppNames, uint32& value);
# 298 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    static bool FilterStringGetEnumAsserted(const char* pChar, const char** ppNames, uint32& value);
# 307 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadInt32(int32* pValue);
# 316 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadUInt32(uint32* pValue);
# 325 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadInt16(int16* pValue);
# 334 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadUInt16(uint16* pValue);
# 343 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadInt8(int8* pValue);
# 352 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadUInt8(uint8* pValue);
# 361 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadBool(bool* pValue);

    enum IntType
    {
        S_8 = 0,
        U_8,
        S_16,
        U_16,
        S_32,
        U_32
    };
# 382 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    inline void ReadInt32Array(int32* pValue, uint32 maxVals) {ReadIntArray(pValue, maxVals, S_32);}
# 393 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    inline void ReadUInt32Array(uint32* pValue, uint32 maxVals) {ReadIntArray(pValue, maxVals, U_32);}
# 404 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    inline void ReadInt16Array(int16* pValue, uint32 maxVals) {ReadIntArray(pValue, maxVals, S_16);}
# 415 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    inline void ReadUInt16Array(uint16* pValue, uint32 maxVals) {ReadIntArray(pValue, maxVals, U_16);}
# 426 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    inline void ReadInt8Array(int8* pValue, uint32 maxVals) {ReadIntArray(pValue, maxVals, S_8);}
# 437 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    inline void ReadUInt8Array(uint8* pValue, uint32 maxVals) {ReadIntArray(pValue, maxVals, U_8);}
# 446 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadFloat(float* pValue);
# 455 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadDouble(double* pValue);
# 466 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadFloatArray(float* pValue, uint32 maxVals);
# 477 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadDoubleArray(double* pValue, uint32 maxVals);
# 488 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadFixed(iwfixed* pValue, uint32 shift = 12);
# 500 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadFixedArray(iwfixed* pValue, uint32 maxVals, uint32 shift = 12);






    void ReadAngleRadians(iwangle* pValue);
# 516 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadAngleDegrees(iwangle* pValue);
# 525 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    CIwManaged* GetObject(int32 level = 0);







    void PushObject(CIwManaged* pObject);







    CIwManaged* PopObject();
# 553 "c:/marmalade/6.2/modules/iwutil/h/IwTextParserITX.h"
    void ReadManagedReference(CIwManaged** pPointer);






    inline void StoreObject(CIwManaged* pObject)
    {
        m_NamedObjects.push_back(pObject);
    }


    void ResolveReferences();

private:

    class CIwReference
    {
    public:
        CIwReference() : m_pPointer(__null), m_Hash(0) {};
        CIwManaged** m_pPointer;
        uint32 m_Hash;





    };

    void ReadIntArray(void *pValue, uint32 maxVals, IntType type);


    CIwManaged* ForceCurrentObject(CIwManaged* pObj);

    char m_String[0x100];
    CIwArray<CIwManaged*> m_ObjectStack;
    CIwArray<CIwManaged*> m_NamedObjects;
    CIwArray<CIwReference> m_UnresolvedReferences;
    bool m_AssertOnUnrecognisedTokens;

    friend class CIwManaged;
    friend void _ITXReadUnknown(CIwTextParser* _pParser);
};

extern CIwTextParserITX* g_IwTextParserITX;




inline CIwTextParserITX* IwGetTextParserITX()
{

    if( !g_IwTextParserITX )
        do { IwDebugErrorShow ("To use the text parser in non-resource-building builds you must explicitly instantiate it using \"new CIwTextParserITX();\"") ; do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); } while(0);

    return g_IwTextParserITX;
}
# 35 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2


# 1 "c:/marmalade/6.2/modules/iwutil/h/IwUncopyable.h" 1
       
# 24 "c:/marmalade/6.2/modules/iwutil/h/IwUncopyable.h"
class CIwUncopyable
{
public:
    CIwUncopyable() {}

private:
    CIwUncopyable(const CIwUncopyable& rhs);
    CIwUncopyable& operator=(const CIwUncopyable& rhs);
};
# 38 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwUtilInitTerm.h" 1
       
# 33 "c:/marmalade/6.2/modules/iwutil/h/IwUtilInitTerm.h"
void IwUtilInit();







void IwUtilTerminate();
# 39 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2




# 1 "c:/marmalade/6.2/modules/iwutil/h/IwAutoFile.h" 1
# 43 "c:/marmalade/6.2/modules/iwutil/h/IwAutoFile.h"
class CIwAutoFile
{
    s3eFile* m_File;

public:




    CIwAutoFile(const char* filename, const char* mode = "rb")
    {
        m_File = s3eFileOpen(filename, mode);
    }





    CIwAutoFile(void* buffer, uint32 size)
    {
        m_File = s3eFileOpenFromMemory(buffer,size);
    }




    ~CIwAutoFile()
    {
        if (m_File)
            s3eFileClose(m_File);
        m_File = 0;
    }






    s3eFile* s3eFileGet()
    {
        return m_File;
    }





    operator s3eFile* ()
    {
        return m_File;
    }
};
# 44 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwBuffer.h" 1
# 35 "c:/marmalade/6.2/modules/iwutil/h/IwBuffer.h"
class CIwBuffer
{
public:






    class ByteProxy
    {
        public:
            ByteProxy(CIwBuffer& buffer, uint32 index);
            ByteProxy& operator=(const ByteProxy& right);
            ByteProxy& operator=(uint8 b);
            operator uint8() const;
            operator uint8&();
            uint8* operator&();
            const uint8* operator&() const;

        private:
            CIwBuffer& buffer;
            uint32 index;

    };




    CIwBuffer();




    CIwBuffer(const void *newData, uint32 newLength);







    explicit CIwBuffer(const char *string);




    CIwBuffer(const CIwBuffer& that);




    const CIwBuffer& operator=(const CIwBuffer& right);




    virtual ~CIwBuffer();







    int32 SetData(const void* newData, uint32 newLength);






    int32 SetData(const char* string);







    int32 SetData(const CIwBuffer& that);






    void Dump(CIwBuffer& out, int start = 0, int end = -1);
# 134 "c:/marmalade/6.2/modules/iwutil/h/IwBuffer.h"
    void SetDataNoCopy(void *newData, uint32 newLength);
# 145 "c:/marmalade/6.2/modules/iwutil/h/IwBuffer.h"
    void SetDataNoOwn(void* newData, uint32 newLength);
    void SetDataNoOwn(void* newData, uint32 newLength, uint32 maxLength);
# 155 "c:/marmalade/6.2/modules/iwutil/h/IwBuffer.h"
    void SetDataResizableNoOwn(void* newData, uint32 newLength, uint32 maxLength);





    void Move(CIwBuffer& buffer);






    void SetEmpty();






    int32 SetValue(const uint8 b, uint32 length);
# 185 "c:/marmalade/6.2/modules/iwutil/h/IwBuffer.h"
    s3eResult Resize(uint32 newLength);






    void ResizeMax();
# 202 "c:/marmalade/6.2/modules/iwutil/h/IwBuffer.h"
    s3eResult TrimBack(uint32 bytesToTrim);
# 211 "c:/marmalade/6.2/modules/iwutil/h/IwBuffer.h"
    s3eResult HintLength(uint32 hintedSize);

    void DontFree();

    void UseIntegerCompression(bool compress);
# 227 "c:/marmalade/6.2/modules/iwutil/h/IwBuffer.h"
    const uint8* GetData() const;
    const uint8* ptr() const { return GetData(); }
    uint8* GetDataWritable() { return (uint8*)GetData();};







    uint32 GetLength() const { return m_DataLength; }
    uint32 size() const { return GetLength(); }




    const ByteProxy operator[](uint32 index) const;




    ByteProxy operator[](uint32 index);
# 259 "c:/marmalade/6.2/modules/iwutil/h/IwBuffer.h"
    s3eResult Overlay(uint32 destIndex, const void* src, uint32 length);




    CIwBuffer& operator+=(const CIwBuffer& that);

    bool operator==(const CIwBuffer& that) const;
    bool operator!=(const CIwBuffer& that) const { return !(*this == that);};

    friend class ByteProxy;







    CIwBuffer Slice(uint32 start, uint32 len);
# 287 "c:/marmalade/6.2/modules/iwutil/h/IwBuffer.h"
    CIwBuffer DestructiveSlice(uint32 start, uint32 len);
# 298 "c:/marmalade/6.2/modules/iwutil/h/IwBuffer.h"
    bool Unpack(uint64* number, uint32& offset, uint32 len=1) const;
    bool Unpack(int64* number, uint32& offset, uint32 len=1) const;
    bool Unpack(uint32* number, uint32& offset, uint32 len=1) const;
    bool Unpack(int32* number, uint32& offset, uint32 len=1) const;
    bool Unpack(uint16* number, uint32& offset, uint32 len=1) const;
    bool Unpack(int16* number, uint32& offset, uint32 len=1) const;
    bool Unpack(uint8* number, uint32& offset, uint32 len=1) const;
    bool Unpack(int8* number, uint32& offset, uint32 len=1) const;
    bool Unpack(float* number, uint32& offset, uint32 len=1) const;
# 317 "c:/marmalade/6.2/modules/iwutil/h/IwBuffer.h"
    bool Unpack(CIwBuffer &bufffer, uint32 &offset, bool destructive=false);






    virtual s3eResult Pack(const void* data, uint32 length);






    virtual s3eResult Pack(const char*);






    virtual s3eResult Pack(float n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const float* n, uint32 num);






    virtual s3eResult Pack(int64 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const int64* n, uint32 num) { return Pack((const uint64*)n, num); }






    virtual s3eResult Pack(int32 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const int32* n, uint32 num) { return Pack((const uint32*)n, num); }






    virtual s3eResult Pack(int16 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const int16* n, uint32 num) { return Pack((const uint16*)n, num); }






    virtual s3eResult Pack(int8 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const int8* n, uint32 num) { return Pack((const uint8*)n, num); }






    virtual s3eResult Pack(uint64 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const uint64* n, uint32 num);






    virtual s3eResult Pack(uint32 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const uint32* n, uint32 num);






    virtual s3eResult Pack(uint16 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const uint16* n, uint32 num);






    virtual s3eResult Pack(uint8 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const uint8* n, uint32 num);






    virtual s3eResult Pack(bool b) { return Pack((uint8) b); }







    virtual s3eResult Pack(const CIwBuffer &);

    s3eResult PackSize(uint32 size);

    s3eResult PackNumber(uint32 num, bool reverse=false);

    s3eResult UnpackNumber(uint32& num, uint32& offset, bool reverse=false) const;

    s3eResult Append(const uint8* data, int len);

    uint32 Flags() { return m_Flags; }

protected:
    void CopyIfNeeded();

    static int PackUint64 (uint64 n, uint8* to, bool bendian=false);
    static int PackUint32 (uint32 n, uint8* to, bool bendian=false);
    static int PackUint16 (uint16 n, uint8* to, bool bendian=false);
    static int PackUint8 (uint8 n, uint8* to, bool bendian=false);
    static int UnpackUint64(uint64* n, const uint8* from, bool bendian=false);
    static int UnpackUint32(uint32* n, const uint8* from, bool bendian=false);
    static int UnpackUint16(uint16* n, const uint8* from, bool bendian=false);
    static int UnpackUint8 (uint8* n, const uint8* from, bool bendian=false);

    virtual uint8* Alloc(uint32 size);
    virtual void Free(uint8* ptr);
private:
    uint32& GetRefCount() const;
    int32& GetOffsetWord() const;
    void DeleteData();

protected:
    uint8* m_Data;
    uint32 m_DataLength;
    uint32 m_ActualLength;
    uint32 m_Flags;
};




CIwBuffer operator+(const CIwBuffer& left, const CIwBuffer& right);
# 45 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2

# 1 "c:/marmalade/6.2/modules/iwutil/h/IwPath.h" 1
# 38 "c:/marmalade/6.2/modules/iwutil/h/IwPath.h"
extern "C" {
# 52 "c:/marmalade/6.2/modules/iwutil/h/IwPath.h"
char* IwPathGetExtension(const char* filename, char* pExt);
# 66 "c:/marmalade/6.2/modules/iwutil/h/IwPath.h"
char* IwPathGetFilename(const char* filename, char* leaf, s3eBool withExt =(1));
# 81 "c:/marmalade/6.2/modules/iwutil/h/IwPath.h"
char* IwPathGetDirname(const char* filename, char* path);
# 91 "c:/marmalade/6.2/modules/iwutil/h/IwPath.h"
char* IwPathGetDrive(const char* filename, char *drive);






s3eBool IwPathHasDrive(const char* filename);
# 108 "c:/marmalade/6.2/modules/iwutil/h/IwPath.h"
char* IwPathStripDrive(char *filename);
# 120 "c:/marmalade/6.2/modules/iwutil/h/IwPath.h"
char* IwPathJoin(char* path, const char* file, int len =128);
# 130 "c:/marmalade/6.2/modules/iwutil/h/IwPath.h"
char* IwPathNorm(char* path, s3eBool useCase = (0));

}
# 47 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwList.h" 1
# 52 "c:/marmalade/6.2/modules/iwutil/h/IwList.h"
class CIwListNode
{
public:
    CIwListNode* m_Prev;
    CIwListNode* m_Next;
    inline CIwListNode() { Init(); }
    virtual ~CIwListNode() {};
    inline void Init() { m_Prev = m_Next = this; }
};






void IwListAddNode(CIwListNode* pRoot, CIwListNode* pNode);






void IwListRemoveNode(CIwListNode* pRoot, CIwListNode* pNode);
# 88 "c:/marmalade/6.2/modules/iwutil/h/IwList.h"
static inline void IwListAddNodeEnd(CIwListNode* pRoot, CIwListNode* pNode)
{
    ((void)0);
    ((void)0);
    pNode->m_Next = pRoot;
    pNode->m_Prev = pRoot->m_Prev;
    pNode->m_Prev->m_Next = pNode;
    pRoot->m_Prev = pNode;
}







static inline bool IwListEmpty(CIwListNode* pRoot)
{
    return pRoot->m_Next == pRoot;
}
# 128 "c:/marmalade/6.2/modules/iwutil/h/IwList.h"
typedef CIwListNode IwListNode;





template<class X>
class CIwList
{
public:
    uint32 num_p;






    class Store
    {
    public:
        Store(X const& _el) : el(_el), next(0),prev(0) {}
        X el;
        Store* next;
        Store* prev;
    } *head, *last;

    class iterator
    {
    public:
        iterator(Store* _st) : st(_st) {}
        X* operator->() {return &st->el;}
        X& operator*() {return st->el;}
        iterator& operator++() {((void)0); st = st->next; return *this;}
        iterator operator++(int) {((void)0); iterator tp = *this; st = st->next; return tp;}
        iterator& operator--() {((void)0); st = st->prev; return *this;}
        iterator operator--(int) {((void)0); iterator tp = *this; st = st->prev; return tp;}
        bool operator==(const iterator& r) const
        {
            return (st == r.st);
        }
        bool operator!=(const iterator& r) const
            {
            return (st != r.st);
            }
        Store* st;
    };


    CIwList () : num_p(0), head(0), last(0) {}
    ~CIwList () {clear();}





    void clear()
    {
        iterator i = begin();
        while (i != end())
            i=erase(i);
    }

    int size() const
    {
        return num_p;
    }
# 202 "c:/marmalade/6.2/modules/iwutil/h/IwList.h"
    void push_back(X const& x)
    {
        if (!head) {
            ((void)0);
            head = last = new Store(x);
        }
        else {
            last->next = new Store(x);
            last->next->prev = last;
            last = last->next;
        }
        num_p++;
    }
# 223 "c:/marmalade/6.2/modules/iwutil/h/IwList.h"
    void append(X const & x) { push_back(x); }






    iterator erase(const iterator& it)
    {
        if (it.st->prev)
            it.st->prev->next = it.st->next;
        else {
            ((void)0);
            head = it.st->next;
        }
        if (it.st->next)
            it.st->next->prev = it.st->prev;
        else {
            last = it.st->prev;
        }
        iterator ret = ++iterator(it.st);
        delete it.st;
        num_p--;
        return ret;
    }






    iterator erase(X* el)
    {
        iterator it((Store*) el);
        return erase(it);
    }






    bool find_and_remove(X& el)
    {
        Store* st = head;
        while (st)
        {
            if (st->el == el) {
                erase(st);
                return true;
            }
            st=st->next;
        }
        return false;
    }






    iterator begin() {return iterator(head);}






    iterator end() {return iterator(__null);}






    X& element_at(int idx)
    {
        ((void)0);
        Store* s = head;
        while (idx--)
        {
            ((void)0);
            s = s->next;
        }
        ((void)0);
        return s->el;
    }




    X & front()
    {
        ((void)0);
        return head->el;
    }




    X & back()
    {
        ((void)0);
        return last->el;
    }

};
# 48 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2


# 1 "c:/marmalade/6.2/modules/iwutil/h/IwRandom.h" 1
# 23 "c:/marmalade/6.2/modules/iwutil/h/IwRandom.h"
extern "C" {
# 48 "c:/marmalade/6.2/modules/iwutil/h/IwRandom.h"
void IwRandSeed(int32 seed);
# 57 "c:/marmalade/6.2/modules/iwutil/h/IwRandom.h"
int32 IwRand();
# 71 "c:/marmalade/6.2/modules/iwutil/h/IwRandom.h"
static inline int32 IwRandRange(int range) { if (!range) return 0; return IwRand() % range; }
# 82 "c:/marmalade/6.2/modules/iwutil/h/IwRandom.h"
static inline int32 IwRandMinMax(int min, int max) { return IwRandRange(max-min) + min; }


}
# 51 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2



# 1 "c:/marmalade/6.2/modules/iwutil/h/IwUTF8.h" 1
# 43 "c:/marmalade/6.2/modules/iwutil/h/IwUTF8.h"
typedef unsigned short ucs2char;
# 85 "c:/marmalade/6.2/modules/iwutil/h/IwUTF8.h"
int IwWideCharToUTF8( const ucs2char * wideString,
                        int wideStringLength,
                        char * utf8Buffer,
                        unsigned int utf8BufferSize );
# 125 "c:/marmalade/6.2/modules/iwutil/h/IwUTF8.h"
int IwUTF8ToWideChar( const char * utf8String,
                        int utf8StringSize,
                        ucs2char * wideBuffer,
                        unsigned int wideBufferSize );
# 55 "c:/marmalade/6.2/modules/iwutil/h/IwUtil.h" 2
# 24 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h" 2
# 37 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
class CIwMaterial;




class CIw2DImage
{
public:






    virtual int16 GetWidth() = 0;







    virtual int16 GetHeight() = 0;







    virtual CIwMaterial* GetMaterial() = 0;

    virtual ~CIw2DImage() {};
};




class CIw2DFont
{
public:






    virtual int32 GetHeight() = 0;

    virtual ~CIw2DFont() {};
};




class CIw2DSurface
{
public:
    virtual ~CIw2DSurface() {};
};
# 118 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DSetColour(CIwColour colour);
# 132 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DSetColour(uint32 colour);
# 141 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIwColour Iw2DGetColour();






enum CIw2DImageTransform
{
        IW_2D_IMAGE_TRANSFORM_NONE,
        IW_2D_IMAGE_TRANSFORM_ROT90 = ((1 << 0) | (1 << 2)),
        IW_2D_IMAGE_TRANSFORM_ROT180 = ((1 << 0) | (1 << 1)),
        IW_2D_IMAGE_TRANSFORM_ROT270 = ((1 << 1) | (1 << 2)),
        IW_2D_IMAGE_TRANSFORM_FLIP_X = ((1 << 0)),
        IW_2D_IMAGE_TRANSFORM_FLIP_Y = ((1 << 1)),
};
# 168 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIw2DImageTransform Iw2DImageTransformOp(CIw2DImageTransform state, CIw2DImageTransform operation);
# 177 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DSetImageTransform(CIw2DImageTransform trans);
# 186 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIw2DImageTransform Iw2DGetImageTransform();
# 197 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DSetFont(CIw2DFont* font);
# 206 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIw2DFont* Iw2DGetFont();
# 219 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
bool Iw2DSetSurface(CIw2DSurface* surface);







CIw2DSurface* Iw2DGetSurface();


enum CIw2DAlphaMode
{
    IW_2D_ALPHA_NONE,
    IW_2D_ALPHA_HALF,
    IW_2D_ALPHA_ADD,
    IW_2D_ALPHA_SUB,
};
# 246 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DSetAlphaMode(CIw2DAlphaMode mode);
# 255 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIw2DAlphaMode Iw2DGetAlphaMode();
# 266 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DSetTransformMatrix(const CIwMat2D& matrix);
# 275 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIwMat2D Iw2DGetTransformMatrix();
# 285 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DSetTransformMatrixSubPixel(const CIwMat2D& matrix);
# 295 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIwMat2D Iw2DGetTransformMatrixSubPixel();







void Iw2DSetSubPixelCoords(bool subPixel);






bool Iw2DGetSubPixelCoords();
# 322 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DSetUseMipMapping(bool mipmapping);






bool Iw2DGetUseMipMapping();
# 345 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
typedef void (*CIw2DPostTransformFn)(CIwSVec2* pPoints, CIwColour* pCols, int32 numberPoints);
# 358 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DSetPostTransformFn(CIw2DPostTransformFn fn);
# 367 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIw2DPostTransformFn Iw2DGetPostTransformFn();
# 395 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DDrawArc(CIwSVec2 centre, CIwSVec2 size, iwangle start, iwangle end, int32 numberSegments = 0);
# 405 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DDrawLine(CIwSVec2 start, CIwSVec2 end);
# 416 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DDrawPolygon(CIwSVec2* verts, int32 numberVerts, bool closed);
# 426 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DDrawRect(CIwSVec2 topLeft, CIwSVec2 size);
# 439 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DFillArc(CIwSVec2 centre, CIwSVec2 size, iwangle start, iwangle end, int32 numberSegments = 0);
# 449 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DFillPolygon(CIwSVec2* verts, int32 numberVerts);
# 459 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DFillRect(CIwSVec2 topLeft, CIwSVec2 size);
# 482 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIw2DImage* Iw2DCreateImage(const char* filename);
# 492 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIw2DImage* Iw2DCreateImageResource(const char* resource);
# 503 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIw2DImage* Iw2DCreateImageResource(uint32 resourceHash);
# 513 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIw2DImage* Iw2DCreateImage(CIwImage& image);
# 524 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIw2DImage* Iw2DCreateImage(CIw2DSurface* surface);
# 535 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DDrawImage(CIw2DImage* image, CIwSVec2 topLeft);
# 547 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DDrawImage(CIw2DImage* image, CIwSVec2 topLeft, CIwSVec2 size);
# 559 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DDrawImageRegion(CIw2DImage* image, CIwSVec2 topLeft, CIwSVec2 regionOffset, CIwSVec2 regionSize);
# 573 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DDrawImageRegion(CIw2DImage* image, CIwSVec2 topLeft, CIwSVec2 size, CIwSVec2 regionOffset, CIwSVec2 regionSize);
# 589 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DDrawImageStretch(CIw2DImage* image, CIwSVec2* areas, CIwSVec2* regions);
# 614 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIw2DFont* Iw2DCreateFontResource(const char* resource);
# 627 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIw2DFont* Iw2DCreateFont(const char* filename);


enum CIw2DFontAlign
{
    IW_2D_FONT_ALIGN_TOP,
    IW_2D_FONT_ALIGN_LEFT = IW_2D_FONT_ALIGN_TOP,
    IW_2D_FONT_ALIGN_CENTRE,
    IW_2D_FONT_ALIGN_BOTTOM,
    IW_2D_FONT_ALIGN_RIGHT = IW_2D_FONT_ALIGN_BOTTOM,
};
# 650 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DDrawString(const char* string, CIwSVec2 topLeft, CIwSVec2 size, CIw2DFontAlign horzAlign, CIw2DFontAlign vertAlign);
# 663 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DDrawString(uint16* string, CIwSVec2 topLeft, CIwSVec2 size, CIw2DFontAlign horzAlign, CIw2DFontAlign vertAlign);
# 673 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
int32 Iw2DGetStringWidth(const char* string);
# 683 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
int32 Iw2DGetStringWidth(uint16* string);
# 699 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DInit();







void Iw2DTerminate();






void Iw2DFinishDrawing();







void Iw2DSurfaceShow();







void Iw2DSurfaceClear(CIwColour c);
void Iw2DSurfaceClear(uint32 c);
# 740 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
void Iw2DGetSurfaceInfo(s3eSurfaceInfo& outInfo);







int32 Iw2DGetSurfaceWidth();







int32 Iw2DGetSurfaceHeight();
# 767 "c:/marmalade/6.2/modules/iw2d/h/Iw2D.h"
CIw2DSurface* Iw2DCreateSurface(int32 w, int32 h);
# 15 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/game.cpp" 2
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h" 1
       
# 25 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwGxState.h" 1
       
# 17 "c:/marmalade/6.2/modules/iwgx/h/IwGxState.h"
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwGxStream.h" 1
       
# 81 "c:/marmalade/6.2/modules/iwgx/h/IwGxStream.h"
# 1 "c:/marmalade/6.2/s3e/h/GLES/gl.h" 1





# 1 "c:/marmalade/6.2/s3e/h/GLES/glplatform.h" 1
# 32 "c:/marmalade/6.2/s3e/h/GLES/glplatform.h"
typedef signed char khronos_int8_t;
typedef unsigned char khronos_uint8_t;
typedef float khronos_float_t;
typedef int khronos_int32_t;





typedef intptr_t khronos_intptr_t;
typedef int khronos_ssize_t;
# 7 "c:/marmalade/6.2/s3e/h/GLES/gl.h" 2


extern "C" {







typedef void GLvoid;
typedef char GLchar;
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef khronos_int8_t GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef khronos_uint8_t GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef khronos_float_t GLfloat;
typedef khronos_float_t GLclampf;
typedef khronos_int32_t GLfixed;
typedef khronos_int32_t GLclampx;

typedef khronos_intptr_t GLintptr;
typedef khronos_ssize_t GLsizeiptr;
# 593 "c:/marmalade/6.2/s3e/h/GLES/gl.h"
extern "C" void glAlphaFunc (GLenum func, GLclampf ref);
extern "C" void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern "C" void glClearDepthf (GLclampf depth);
extern "C" void glClipPlanef (GLenum plane, const GLfloat *equation);
extern "C" void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern "C" void glDepthRangef (GLclampf zNear, GLclampf zFar);
extern "C" void glFogf (GLenum pname, GLfloat param);
extern "C" void glFogfv (GLenum pname, const GLfloat *params);
extern "C" void glFrustumf (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
extern "C" void glGetClipPlanef (GLenum pname, GLfloat eqn[4]);
extern "C" void glGetFloatv (GLenum pname, GLfloat *params);
extern "C" void glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
extern "C" void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
extern "C" void glGetTexEnvfv (GLenum env, GLenum pname, GLfloat *params);
extern "C" void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern "C" void glLightModelf (GLenum pname, GLfloat param);
extern "C" void glLightModelfv (GLenum pname, const GLfloat *params);
extern "C" void glLightf (GLenum light, GLenum pname, GLfloat param);
extern "C" void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
extern "C" void glLineWidth (GLfloat width);
extern "C" void glLoadMatrixf (const GLfloat *m);
extern "C" void glMaterialf (GLenum face, GLenum pname, GLfloat param);
extern "C" void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
extern "C" void glMultMatrixf (const GLfloat *m);
extern "C" void glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern "C" void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
extern "C" void glOrthof (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
extern "C" void glPointParameterf (GLenum pname, GLfloat param);
extern "C" void glPointParameterfv (GLenum pname, const GLfloat *params);
extern "C" void glPointSize (GLfloat size);
extern "C" void glPolygonOffset (GLfloat factor, GLfloat units);
extern "C" void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern "C" void glScalef (GLfloat x, GLfloat y, GLfloat z);
extern "C" void glTexEnvf (GLenum target, GLenum pname, GLfloat param);
extern "C" void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
extern "C" void glTexParameterf (GLenum target, GLenum pname, GLfloat param);
extern "C" void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern "C" void glTranslatef (GLfloat x, GLfloat y, GLfloat z);


extern "C" void glActiveTexture (GLenum texture);
extern "C" void glAlphaFuncx (GLenum func, GLclampx ref);
extern "C" void glBindBuffer (GLenum target, GLuint buffer);
extern "C" void glBindTexture (GLenum target, GLuint texture);
extern "C" void glBlendFunc (GLenum sfactor, GLenum dfactor);
extern "C" void glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
extern "C" void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
extern "C" void glClear (GLbitfield mask);
extern "C" void glClearColorx (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
extern "C" void glClearDepthx (GLclampx depth);
extern "C" void glClearStencil (GLint s);
extern "C" void glClientActiveTexture (GLenum texture);
extern "C" void glClipPlanex (GLenum plane, const GLfixed *equation);
extern "C" void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern "C" void glColor4x (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
extern "C" void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern "C" void glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern "C" void glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
extern "C" void glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
extern "C" void glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern "C" void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern "C" void glCullFace (GLenum mode);
extern "C" void glDeleteBuffers (GLsizei n, const GLuint *buffers);
extern "C" void glDeleteTextures (GLsizei n, const GLuint *textures);
extern "C" void glDepthFunc (GLenum func);
extern "C" void glDepthMask (GLboolean flag);
extern "C" void glDepthRangex (GLclampx zNear, GLclampx zFar);
extern "C" void glDisable (GLenum cap);
extern "C" void glDisableClientState (GLenum array);
extern "C" void glDrawArrays (GLenum mode, GLint first, GLsizei count);
extern "C" void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
extern "C" void glEnable (GLenum cap);
extern "C" void glEnableClientState (GLenum array);
extern "C" void glFinish (void);
extern "C" void glFlush (void);
extern "C" void glFogx (GLenum pname, GLfixed param);
extern "C" void glFogxv (GLenum pname, const GLfixed *params);
extern "C" void glFrontFace (GLenum mode);
extern "C" void glFrustumx (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
extern "C" void glGetBooleanv (GLenum pname, GLboolean *params);
extern "C" void glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
extern "C" void glGetClipPlanex (GLenum pname, GLfixed eqn[4]);
extern "C" void glGenBuffers (GLsizei n, GLuint *buffers);
extern "C" void glGenTextures (GLsizei n, GLuint *textures);
extern "C" GLenum glGetError (void);
extern "C" void glGetFixedv (GLenum pname, GLfixed *params);
extern "C" void glGetIntegerv (GLenum pname, GLint *params);
extern "C" void glGetLightxv (GLenum light, GLenum pname, GLfixed *params);
extern "C" void glGetMaterialxv (GLenum face, GLenum pname, GLfixed *params);
extern "C" void glGetPointerv (GLenum pname, GLvoid **params);
extern "C" const GLubyte * glGetString (GLenum name);
extern "C" void glGetTexEnviv (GLenum env, GLenum pname, GLint *params);
extern "C" void glGetTexEnvxv (GLenum env, GLenum pname, GLfixed *params);
extern "C" void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
extern "C" void glGetTexParameterxv (GLenum target, GLenum pname, GLfixed *params);
extern "C" void glHint (GLenum target, GLenum mode);
extern "C" GLboolean glIsBuffer (GLuint buffer);
extern "C" GLboolean glIsEnabled (GLenum cap);
extern "C" GLboolean glIsTexture (GLuint texture);
extern "C" void glLightModelx (GLenum pname, GLfixed param);
extern "C" void glLightModelxv (GLenum pname, const GLfixed *params);
extern "C" void glLightx (GLenum light, GLenum pname, GLfixed param);
extern "C" void glLightxv (GLenum light, GLenum pname, const GLfixed *params);
extern "C" void glLineWidthx (GLfixed width);
extern "C" void glLoadIdentity (void);
extern "C" void glLoadMatrixx (const GLfixed *m);
extern "C" void glLogicOp (GLenum opcode);
extern "C" void glMaterialx (GLenum face, GLenum pname, GLfixed param);
extern "C" void glMaterialxv (GLenum face, GLenum pname, const GLfixed *params);
extern "C" void glMatrixMode (GLenum mode);
extern "C" void glMultMatrixx (const GLfixed *m);
extern "C" void glMultiTexCoord4x (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
extern "C" void glNormal3x (GLfixed nx, GLfixed ny, GLfixed nz);
extern "C" void glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern "C" void glOrthox (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
extern "C" void glPixelStorei (GLenum pname, GLint param);
extern "C" void glPointParameterx (GLenum pname, GLfixed param);
extern "C" void glPointParameterxv (GLenum pname, const GLfixed *params);
extern "C" void glPointSizex (GLfixed size);
extern "C" void glPolygonOffsetx (GLfixed factor, GLfixed units);
extern "C" void glPopMatrix (void);
extern "C" void glPushMatrix (void);
extern "C" void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
extern "C" void glRotatex (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
extern "C" void glSampleCoverage (GLclampf value, GLboolean invert);
extern "C" void glSampleCoveragex (GLclampx value, GLboolean invert);
extern "C" void glScalex (GLfixed x, GLfixed y, GLfixed z);
extern "C" void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
extern "C" void glShadeModel (GLenum mode);
extern "C" void glStencilFunc (GLenum func, GLint ref, GLuint mask);
extern "C" void glStencilMask (GLuint mask);
extern "C" void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
extern "C" void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern "C" void glTexEnvi (GLenum target, GLenum pname, GLint param);
extern "C" void glTexEnvx (GLenum target, GLenum pname, GLfixed param);
extern "C" void glTexEnviv (GLenum target, GLenum pname, const GLint *params);
extern "C" void glTexEnvxv (GLenum target, GLenum pname, const GLfixed *params);

extern "C" void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);

extern "C" void glTexParameteri (GLenum target, GLenum pname, GLint param);
extern "C" void glTexParameterx (GLenum target, GLenum pname, GLfixed param);
extern "C" void glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
extern "C" void glTexParameterxv (GLenum target, GLenum pname, const GLfixed *params);
extern "C" void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern "C" void glTranslatex (GLfixed x, GLfixed y, GLfixed z);
extern "C" void glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern "C" void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
# 759 "c:/marmalade/6.2/s3e/h/GLES/gl.h"
extern "C" void glPointSizePointerOES (GLenum type, GLsizei stride, const GLvoid *pointer);
# 768 "c:/marmalade/6.2/s3e/h/GLES/gl.h"
}
# 82 "c:/marmalade/6.2/modules/iwgx/h/IwGxStream.h" 2






class CIwGxStream
{
public:
# 99 "c:/marmalade/6.2/modules/iwgx/h/IwGxStream.h"
    typedef enum Type
    {
        TYPE_INT8,
        TYPE_UINT8,

        TYPE_INT16,
        TYPE_UINT16,

        TYPE_FLOAT = (0x1406 & 0xf),

        TYPE_FIXED = (0x140C & 0xf),

        COMPONENTS_1 = (1 << 11),
        COMPONENTS_2 = (2 << 11),
        COMPONENTS_3 = (3 << 11),
        COMPONENTS_4 = (4 << 11),

        SVEC3 = COMPONENTS_3 | TYPE_INT16,
        SVEC2 = COMPONENTS_2 | TYPE_INT16,
        VEC4 = COMPONENTS_4 | TYPE_FLOAT,
        VEC3 = COMPONENTS_3 | TYPE_FLOAT,
        VEC2 = COMPONENTS_2 | TYPE_FLOAT,
        COLOUR = COMPONENTS_4 | TYPE_UINT8,
        UINT16 = COMPONENTS_1 | TYPE_UINT16,
        XVEC3 = COMPONENTS_3 | TYPE_FIXED,

        TYPE_MASK = 0xf,
        COMPONENTS_MASK = (0x7 << 11),

        INTERLEAVED_STORAGE = COMPONENTS_1 | 0xf,
    } IwGxStreamType;







    CIwGxStream() { Set((IwGxStreamType)0, __null, 0, 0); }
# 148 "c:/marmalade/6.2/modules/iwgx/h/IwGxStream.h"
    CIwGxStream(Type type, void* data, uint32 length = 0, uint16 stride = 0)
    {
        Set(type, data, length, stride);
    }
# 160 "c:/marmalade/6.2/modules/iwgx/h/IwGxStream.h"
    CIwGxStream(CIwSVec2* data, uint32 length = 0) { Set(SVEC2, data, length, 0); }







    CIwGxStream(CIwSVec3* data, uint32 length = 0) { Set(SVEC3, data, length, 0); }
# 177 "c:/marmalade/6.2/modules/iwgx/h/IwGxStream.h"
    CIwGxStream(CIwFVec2* data, uint32 length = 0) { Set(VEC2, data, length, 0); }







    CIwGxStream(CIwFVec3* data, uint32 length = 0) { Set(VEC3, data, length, 0); }







    CIwGxStream(CIwColour* data, uint32 length = 0) { Set(COLOUR, data, length, 0); }







    CIwGxStream(uint16* data, uint32 length = 0) { Set(UINT16, data, length, 0); }
# 211 "c:/marmalade/6.2/modules/iwgx/h/IwGxStream.h"
    CIwGxStream(CIwGxStream& share, uint16 type, uint32 offset)
    {
        Set(type, share.m_Data, share.m_Length, 0);
        m_Offset = offset;
        m_Stride = share.m_Stride;
        m_Handle = share.m_Handle;
        m_Flags = share.m_Flags & ~(OWN_ALLOC_F | OWN_HW_ALLOC_F);
    }







    void* GetData() const { return m_Data; }






    uint16 GetType() const { return m_Type; }






    int32 GetLength() const { return m_Length; }






    uint16 GetStride() const { return m_Stride; }






    uint32 GetOffset() const { return m_Offset; }







    uint32 GetMemSize() const;
# 279 "c:/marmalade/6.2/modules/iwgx/h/IwGxStream.h"
    void Upload(bool staticUsage, bool freeLocal);







    bool IsUploaded()
    {
        return m_Handle != 0;
    }






    void Free();
# 309 "c:/marmalade/6.2/modules/iwgx/h/IwGxStream.h"
    CIwSVec2* GetSVec2() const { if (!m_Stride && !m_Offset && CIwGxStream::SVEC2 == m_Type) return (CIwSVec2*)m_Data; else return __null;; }







    CIwSVec3* GetSVec3() const { if (!m_Stride && !m_Offset && CIwGxStream::SVEC3 == m_Type) return (CIwSVec3*)m_Data; else return __null;; }







    CIwFVec2* GetVec2() const { if (!m_Stride && !m_Offset && CIwGxStream::VEC2 == m_Type) return (CIwFVec2*)m_Data; else return __null;; }







    CIwFVec3* GetVec3() const { if (!m_Stride && !m_Offset && CIwGxStream::VEC3 == m_Type) return (CIwFVec3*)m_Data; else return __null;; }







    CIwColour* GetColour() const { if (!m_Stride && !m_Offset && CIwGxStream::COLOUR == m_Type) return (CIwColour*)m_Data; else return __null;; }







    uint16* GetUInt16() const { if (!m_Stride && !m_Offset && CIwGxStream::UINT16 == m_Type) return (uint16*)m_Data; else return __null;; }




    bool IsSet() const { return m_Data != __null || m_Handle != 0; }

    void ConvertToFloat();

    static CIwGxStream Interleave(CIwGxStream** streams, bool* free, uint32 number);

    void Set(uint16 type, void* data, uint32 length, uint16 stride)
    {
# 379 "c:/marmalade/6.2/modules/iwgx/h/IwGxStream.h"
        m_Type = type;
        m_Handle = 0;
        m_Data = data;
        m_Length = length;
        m_Stride = stride;
        m_Flags = OWN_ALLOC_F;
        m_Offset = 0;
    }

    void Clear() { m_Data = __null; m_Handle = 0; }


    unsigned int GetHandle() { return m_Handle; }
    void SetHandle(unsigned int handle) { m_Handle = handle; }
    uint32 GetTypeSize() const;
    int32 GetNumberComponents() const { return (m_Type >> 11) & 0x7; }

    typedef void (*glBindPointerFn) (GLint, GLenum, GLsizei, const GLvoid *);
    typedef void (*glBindNormalPointerFn) (GLenum, GLsizei, const GLvoid *);

    void BindGL(glBindPointerFn fn, int type = 0);
    void BindGL(glBindNormalPointerFn fn);
    void BindAttribGL(int32 array, int32 normalise);

    void DrawElementsGL(int primtype, int32 count);
    GLenum GetGLType() const
    {
        if (m_Flags & FLOAT_IN_HW_F)
            return 0x1406;
        return ((m_Type & 0xf) | (0x140C & ~0xf));
    }

private:
    void _PostUpload(bool freeLocal);
    bool _NeedsConversionToFloat();

    enum
    {
        OWN_ALLOC_F = (1 << 0),
        OWN_HW_ALLOC_F = (1 << 1),
        UPLOADED_F = (1 << 2),
        FLOAT_IN_HW_F = (1 << 3),
    };

    uint16 m_Type;
    uint16 m_Flags;
    uint16 m_Stride;
    uint32 m_Offset;
    unsigned int m_Handle;
    void* m_Data;
    uint32 m_Length;
};
# 18 "c:/marmalade/6.2/modules/iwgx/h/IwGxState.h" 2



# 1 "c:/marmalade/6.2/modules/iwgx/h/IwGxMetrics.h" 1
       
# 321 "c:/marmalade/6.2/modules/iwgx/h/IwGxMetrics.h"
struct _IwGxMetrics
{
};
# 334 "c:/marmalade/6.2/modules/iwgx/h/IwGxMetrics.h"
extern _IwGxMetrics s_IwGxMetrics;
# 22 "c:/marmalade/6.2/modules/iwgx/h/IwGxState.h" 2
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h" 1
       
# 43 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h"
extern uint32 IW_GX_DRAW_UNINDEXED_STREAM_MAX;
# 53 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h"
typedef enum IwGxScreenOrient
{
    IW_GX_ORIENT_NONE,
    IW_GX_ORIENT_90,
    IW_GX_ORIENT_180,
    IW_GX_ORIENT_270,
} IwGxScreenOrient;

IwGxScreenOrient GetInverseOrient(IwGxScreenOrient orient);







class CIwRect
{
public:
    int16 x;
    int16 y;
    int16 w;
    int16 h;






    CIwRect() {}
# 93 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h"
    CIwRect(int16 _x, int16 _y, int16 _w, int16 _h) : x(_x), y(_y), w(_w), h(_h) {}
# 104 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h"
    inline void Make(int16 _x, int16 _y, int16 _w, int16 _h) {x = _x, y = _y, w = _w, h =_h;}

    void Rotate(IwGxScreenOrient orient, int32 devWidth, int32 devHeight);
};




enum IwGxScreenOrient;



class CIwRect32
{
public:
    int32 x;
    int32 y;
    int32 w;
    int32 h;






    CIwRect32() {}
# 140 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h"
    CIwRect32(int32 _x, int32 _y, int32 _w, int32 _h) : x(_x), y(_y), w(_w), h(_h) {}
# 151 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h"
    inline void Make(int32 _x, int32 _y, int32 _w, int32 _h) {x = _x, y = _y, w = _w, h = _h;}

    bool operator == (const CIwRect32& rhs) { return x == rhs.x && y == rhs.y && w == rhs.w && h == rhs.h; }
};


typedef CIwRect IwRect;
typedef CIwRect32 IwRect32;
# 168 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h"
typedef enum IwGxLightType
{
    IW_GX_LIGHT_UNUSED,
    IW_GX_LIGHT_AMBIENT,
    IW_GX_LIGHT_DIFFUSE,
} IwGxLightType;





struct CIwLight
{
    IwGxLightType m_Type;
    CIwColour m_Colour;
    CIwColour m_SpecColour;
    CIwFVec3 m_Pos;
    CIwFVec3 m_Dirn;

    inline void IwLight() {m_Type = IW_GX_LIGHT_UNUSED;}
};
# 201 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h"
typedef enum IwGxCoordSpace
{
    IW_GX_WORLDSPACE,
    IW_GX_MODELSPACE,
    IW_GX_VIEWSPACE,
    IW_GX_SCREENSPACE,
    IW_GX_VIEWSPACE_32,

    IW_GX_COORDSPACE_NONE = -1,

} IwGxCoordSpace;
# 221 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h"
typedef enum IwGxCullResult
{
    IW_GX_CULL_RESULT_FAIL,
    IW_GX_CULL_RESULT_PASS,
    IW_GX_CULL_RESULT_REVERSE,
    IW_GX_CULL_RESULT_DRAW_BOTH
} IwGxCullResult;
# 237 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h"
typedef enum IwGxPrimType
{
    IW_GX_TRI_LIST,
    IW_GX_TRI_STRIP,
    IW_GX_TRI_FAN,
    IW_GX_QUAD_LIST,
    IW_GX_QUAD_STRIP,
    IW_GX_LINE_LIST,
    IW_GX_LINE_STRIP,
    IW_GX_SPRITE_LIST,
    IW_GX_NPOLY_LIST,
} IwGxPrimType;
# 258 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h"
typedef enum IwGxSortMode
{
    IW_GX_SORT_NONE = 0,
    IW_GX_SORT_BY_MATERIAL = 1,
    IW_GX_SORT_BY_Z = 2,
    IW_GX_SORT_BY_SLOT = 3,

    IW_GX_SORT_REVERSE = 0x80,
    IW_GX_SORT_BY_MATERIAL_REVERSE = 0x81,
    IW_GX_SORT_BY_Z_REVERSE = 0x82,
} IwGxSortMode;




typedef enum IwGxClearBufferFlags
{
    IW_GX_COLOUR_BUFFER_F = (1 << 0),
    IW_GX_DEPTH_BUFFER_F = (1 << 1),
} IwGxClearBufferFlags;




typedef enum IwGxMaterialCopyState
{
    IW_GX_MATERIAL_COPY_STATE_COLS,
    IW_GX_MATERIAL_COPY_STATE_ZDEPTHOFS,
    IW_GX_MATERIAL_COPY_STATE_UVOFS,
    IW_GX_MATERIAL_COPY_STATE_MAX,
} IwGxMaterialCopyState;
# 298 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h"
typedef enum IwGxHWType
{
    IW_GX_HWTYPE_UNKNOWN,
    IW_GX_HWTYPE_GL1,
    IW_GX_HWTYPE_GL2,
} IwGxHWType;




typedef enum IwGxGLExtension
{
    GL_IMG_TEXTURE_COMPRESSION_PVRTC = 0,
    GL_ATI_COMPRESSED_TEXTURE_ATITC,
    GL_OES_COMPRESSED_ETC1_RGB8_TEXTURE,
    GL_EXT_TEXTURE_COMPRESSION_S3TC,
    GL_EXT_TEXTURE_COMPRESSION_DXT1,
} IwGxGLExtension;




typedef enum IwGxRenderQuality
{
    IW_GX_RENDER_QUALITY_HALF,
    IW_GX_RENDER_QUALITY_HALF_INTERP,
    IW_GX_RENDER_QUALITY_NORMAL,
    IW_GX_RENDER_QUALITY_MAX,
} IwGxRenderQuality;
# 346 "c:/marmalade/6.2/modules/iwgx/h/IwGxTypes.h"
typedef void (*IwGxCallbackFn)();


typedef void (*IwGxProgressCallbackFn)(int32 progress);

typedef enum IwGxCallback
{
    _IW_GX_NONE,
    IW_GX_PRE_FLUSH,
    IW_GX_SCREENSIZE,
} IwGxCallback;


struct _IwGxCallbackRegistration
{
    IwGxCallback m_CallbackID;
    IwGxCallbackFn m_CallbackFn;
};
# 23 "c:/marmalade/6.2/modules/iwgx/h/IwGxState.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwList.h" 1
# 24 "c:/marmalade/6.2/modules/iwgx/h/IwGxState.h" 2

# 1 "c:/marmalade/6.2/modules/iwutil/h/IwSingleton.h" 1
# 26 "c:/marmalade/6.2/modules/iwgx/h/IwGxState.h" 2
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwRandom.h" 1
# 27 "c:/marmalade/6.2/modules/iwgx/h/IwGxState.h" 2


class CIwMaterial;
class CIwTexture;
class CIwGxSurface;
# 62 "c:/marmalade/6.2/modules/iwgx/h/IwGxState.h"
typedef enum IwGxFlags
{
    IW_GX_SHARE_8BIT_PALS = (1 << 0),
    IW_GX_SHARE_4BIT_PALS = (1 << 1),

    IW_GX_LIGHTING_EMISSIVE_F = (1 << 11),
    IW_GX_LIGHTING_AMBIENT_F = (1 << 12),
    IW_GX_LIGHTING_DIFFUSE_F = (1 << 13),
    IW_GX_LIGHTING_SPECULAR_F = (1 << 14),

    IW_GX_FOG_F = (1 << 15),
    IW_GX_PALETTE_SATURATION_F = (1 << 16),

    IW_GX_ENVIRONMENT_MAP_F = (1 << 17),
    IW_GX_TRILINEAR_MIPMAPPING_F = (1 << 18),

    IW_GX_MATERIAL_COPY_STATE_COLS_F = (1 << 19),
    IW_GX_MATERIAL_COPY_STATE_ZDEPTHOFS_F = (1 << 20),
    IW_GX_MATERIAL_COPY_STATE_UVOFS_F = (1 << 21),

    IW_GX_PALETTE_TINTING = (1 << 22),

    IW_GX_DISABLE_CUSTOM_SHADERS_F = (1 << 23),

    IW_GX_DISPLAY_FRAMERATE_F = (1 << 24),

    IW_GX_DRAW_PRIORITY_FIFO_F = (1 << 25),

    IW_GX_LEAVE_PREALLOCBUFFERS_F = (1 << 26),

    IW_GX_GL2_FLAT_SHADING_F = (1 << 27),

    IW_GX_SKIN_NORMALS_F = (1 << 28),
    IW_GX_SKIN_MAJOR_BONE_F = (1 << 29),

    IW_GX_FLOAT_TRANSFORM_F = (1 << 30),

    IW_GX_ORTHO_PROJ_F = (1u << 31),

    IW_GX_LIGHTING_MASK = IW_GX_LIGHTING_EMISSIVE_F | IW_GX_LIGHTING_AMBIENT_F | IW_GX_LIGHTING_DIFFUSE_F | IW_GX_LIGHTING_SPECULAR_F,
} IwGxFlags;


typedef enum IwGxInternalFlags
{
    IW_GX_INTERNAL_MODELMAT_ROT_IDENT_F = (1 << 0),
    IW_GX_INTERNAL_MATVIEWMODEL_ROT_IDENT_F = (1 << 1),

    IW_GX_INTERNAL_CALCED_ENV_COORDS_F = (1 << 5),

    IW_GX_INTERNAL_SURFACE_IS_S3E_SURFACE_F = (1 << 7),
    IW_GX_INTERNAL_MATS_ANIMS_RESERVED_F = (1 << 8),

    IW_GX_INTERNAL_VERTICAL_FLIP_RENDER_F = (1 << 9),

    IW_GX_INTERNAL_DISABLE_SURFACES_F = (1 << 10),

    IW_GX_INTERNAL_INVALID_TEXTURE_IN_MATERIAL_F = (1 << 11),

    IW_GX_INTERNAL_MULTIPLE_SURFACES_USED_F = (1 << 12),

    IW_GX_INTERNAL_FORCE_FLOAT_F = (1 << 13),

    IW_GX_INTERNAL_LEGACY_MATERIAL_DEFAULT_F = (1 << 14),
} IwGxInternalFlags;







typedef enum IwGxDebugFlags
{
    IW_GX_DEBUG_DISPLAY_METRICS_F = (1 << 0),
    IW_GX_DEBUG_WIREFRAME_F = (1 << 1),
    IW_GX_DEBUG_DUMP_GEOM_INFO_F = (1 << 2),

    IW_GX_DEBUG_NO_TEXTURES_F = (1 << 3),
    IW_GX_DEBUG_NO_MULTITEXTURES_F = (1 << 4),
    IW_GX_DEBUG_NO_ALPHA_F = (1 << 5),
    IW_GX_DEBUG_FORCE_ALPHA_BLEND_TO_ADD_F = (1 << 6),
    IW_GX_DEBUG_FORCE_SMOOTH_F = (1 << 7),
    IW_GX_DEBUG_FORCE_TEXTURE_F = (1 << 8),

    IW_GX_DEBUG_OVERDRAW_F = (1 << 9),

    IW_GX_DEBUG_DRAWCALLS_F = (1 << 10),

    IW_GX_DEBUG_DRAW_STRIPS_F = (1 << 11),


    IW_GX_DEBUG_DONT_TRACK_MATERIAL_USE_F = (1 << 16),

} IwGxDebugFlags;






class IwMatUsed : public CIwListNode
{
public:
    CIwMaterial* m_Material;
};
# 180 "c:/marmalade/6.2/modules/iwgx/h/IwGxState.h"
class CIwGxStateBase {
protected:
    CIwGxStateBase(uint32 gxStateSize){
        memset(this, 0, gxStateSize);
    }
};



struct ScissorRect
{
    union {
        uint32 xy32;
        struct {
            uint16 x;
            uint16 y;
        } ;
    } ;
    union {
        uint32 wh32;
        struct {
            uint16 w;
            uint16 h;
        } ;
    } ;

    bool IsEqual(ScissorRect* s){return ( s->xy32 == xy32 && s->wh32 == wh32);}

    bool operator == (const ScissorRect & src) const
    {
        if (this == &src)
        {
            return true;
        }

        return ( ( xy32 == src.xy32 ) && ( wh32 == src.wh32 ) );
    }

    bool operator!=( const ScissorRect & src ) const
    {
        return !( *this == src );
    }
};

struct OTScissorRects
{
    ScissorRect start;
    ScissorRect end;
};

struct EnvCoords
{
    uint8 m;
    uint8 n;
};

class CIwGxState : CIwGxStateBase
{
public:

    CIwGxState();
    ~CIwGxState();


    void SetVertCacheSize(uint32 n);


    uint32 m_Flags;
    uint32 m_InternalFlags;
    uint32 m_Platform;
    IwGxHWType m_HWType;


    CIwFMat m_MatModel;
    CIwFMat m_MatView;
    CIwFMat m_MatViewWorld;
    CIwFMat m_MatViewModel;
    CIwFMat m_MatClipViewWorld;
    CIwFMat m_MatClipViewModel;

    CIwFMat m_MatPerspective;
    bool m_UseMatPerspective;

    CIwFVec2 m_UVOfs[2];
    CIwSVec2 m_ScreenSpaceOrg;
    CIwFVec3 m_ViewSpaceOrg;


    float m_NearZ;
    float m_FarZ;
    float m_NearClip;
    float m_FarClip;
    int32 m_FarClipOT;
    float m_PerspMul;
    float m_XClipPlaneLen;
    float m_YClipPlaneLen;
    int32 m_Clip2DTop;
    int32 m_Clip2DBottom;
    int32 m_Clip2DLeft;
    int32 m_Clip2DRight;
    ScissorRect m_CurrentScissor;
    CIwRect32 m_OrthoRect;

    int32 m_XPostScale;
    int32 m_YPostScale;
    int32 m_DisplayXCentre;
    int32 m_DisplayYCentre;
    int32 m_DeviceXCentre;
    int32 m_DeviceYCentre;
    int32 m_RealDeviceYCentre;
    float m_ZFactor;
    float m_XFactor;
    float m_YFactor;

    uint32 m_ScreenSpaceSlot;

    uint32 m_DeviceWidth;
    uint32 m_DeviceHeight;
    uint32 m_ScreenWidth;
    uint32 m_ScreenHeight;
    uint32 m_DisplayWidth;
    uint32 m_DisplayHeight;
    IwGxScreenOrient m_ScreenOrient;
    IwGxScreenOrient m_DisplayScreenOrient;
    int32 m_RequestScreenOrientChange;
    int32 m_RequestScreenClearSW;


    uint32 m_DataCacheSize;
    uint8* m_DataCache;
    uint8* m_DataCacheCurr;
    uint8* m_DataCacheNext;


    uint32* m_PolyBuffer;
    int32 m_PolyBufferSize;
    uint32* m_PolyPtr;
    uint32* m_OT;
    uint32* m_OTMain;
    uint32* m_OTFront;
    uint32* m_OTBack;
    int32 m_OTSize;
    int32 m_OTSizeMain;
    int32 m_OTSizeFront;
    int32 m_OTSizeBack;
    OTScissorRects* m_OTScissors;
    OTScissorRects* m_OTScissorsFront;
    OTScissorRects* m_OTScissorsBack;
    int32 m_OTSizeSafety;
    int32 m_ZDepthOfsSafety;
    int32 m_OTBucketShift;


    float m_FogNearZ;
    float m_FogFarZ;
    CIwColour m_FogCol;
    float m_FogNearClipZ;
    float m_FogFarClipZ;
    EnvCoords* m_EnvCoords;
    int32 m_NumEnvCoords;


    uint32* m_PolyPtrSafety;





    IwGxCoordSpace m_CoordSpace;
    uint32 m_ScreenSpaceShift;

    CIwGxStream* m_StreamVerts;
    CIwGxStream* m_StreamNorms;
    CIwGxStream* m_StreamTangents;
    CIwGxStream* m_StreamBiTangents;
    CIwGxStream* m_StreamUVs[2];
    CIwGxStream* m_StreamCols;

    uint16 m_SkinNumWeightsPerEntry;
    uint16 m_SkinNumMats;
    float* m_SkinMats;
    float* m_SkinWeights;
    uint8* m_SkinMatInds;

    CIwGxStream* m_StreamSkinWeights;
    CIwGxStream* m_StreamSkinMatInds;


    uint32 m_NumVerts;


    void* m_Verts;
    CIwFVec3* m_Norms;
    CIwFVec3* m_Tangents;
    CIwFVec3* m_BiTangents;
    CIwFVec2* m_UVs[2];
    CIwColour* m_Cols;

    uint32 m_NumNorms;
    uint32 m_NumCols;

    int16* m_PreAllocNormDots;
    uint32 m_PreAllocNormDotsSize;
    int16* m_PreAllocTanDots;
    uint32 m_PreAllocTanDotsSize;
    int16* m_PreAllocBiTanDots;
    uint32 m_PreAllocBiTanDotsSize;
    CIwColour* m_PreAllocColBuffer;
    uint32 m_PreAllocColBufferSize;


    CIwMaterial* m_Material;
    CIwMaterial* m_MaterialFixed;
    CIwMaterial* m_MaterialIdentity;
    CIwMaterial* m_MaterialTemplate;


    IwGxSortMode m_SortMode;
    IwGxSortMode m_SortModeOpaque;
    IwGxSortMode m_SortModeAlpha;
    IwGxSortMode m_SortModeScreenSpace;
    CIwListNode m_MatsUsedRoot;
    CIwListNode m_GeomInfoOpaque;
    CIwListNode m_GeomInfoAlpha;
    CIwListNode* m_GeomInfoFront;
    CIwListNode* m_GeomInfoBack;


    CIwManagedList m_MatsAnims;
    uint32 m_MatsAnimsUpdateTimeStamp;


    int16 m_ZDepthOfs;
    int16 m_ZDepthOfsBase;
    float m_ZDepthFixed;
    int16 m_Gamma;


    CIwColour m_ColClear;
    CIwColour m_ColEmissive;
    CIwColour m_ColAmbient;
    CIwColour m_ColDiffuse;


    CIwLight m_Lights[2];
    CIwColour m_LightColAmbient;
    CIwColour m_LightColDiffuse;
    CIwColour m_LightColSpecular;
    CIwFVec3 m_LightDirnDiffuse;

    uint32 m_UpdateTimeStamp;
    uint16 m_FlushTimeStamp;
    uint32 m_SwapTimeStamp;

    uint64 m_SwapTimer;
    iwfixed m_MsPerFrame;

    _IwGxMetrics& m_Metrics;


    uint32 m_DebugFlags;
    const char* m_DebugPathName;
    CIwTexture* m_DebugTexture;
    CIwManagedList m_DebugDataCacheTypes;
    uint8 m_DebugOverdrawOpacity;


    uint32 m_GLVersion;
    uint32 m_MaxTextureStages;
    uint32 m_MaxVertexAttribs;
    uint32 m_HWCaps;

    bool m_ScreenOrientAutoHandled;


    uint32 m_DefaultDepthFuncGL;

    _IwGxCallbackRegistration m_Callbacks[20];

    IwGxRenderQuality m_RenderQuality;
    int32 m_YShift;
    int32 m_DrawCallIndex;

    IwGxProgressCallbackFn m_ContextRestoreCB;
    bool m_IsNotShadowCaster;

    CIwGxSurface* m_pCurrentSurface;
    bool m_FlushRequired;
    uint32 m_ClearFlags;
    CIwListNode m_GeomInfoAlphaTest;

};

extern CIwGxState* g_IwGxState;
inline CIwGxState* IwGetGxState() {return g_IwGxState;}


inline float _IW_GX_CLIPSCALE_MUL(float a, float b)
{
    return (a * b) / (1 << 12);
}
# 26 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h" 2
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwGxFuncTable.h" 1
       
# 25 "c:/marmalade/6.2/modules/iwgx/h/IwGxFuncTable.h"
class CIwColour;
class CIwMaterial;
class CIwMatGeomInfo;
class CIwSVec2;
class CIwFVec2;
class CIwFVec3;
class CIwMatGeomInfo;




enum
{
    IWGXFNE_NULL = 0,


    IWGXFNE_SetVertStreamWorldSpace,
    IWGXFNE_SetVertStreamModelSpace,
    IWGXFNE_SetVertStreamViewSpace,
    IWGXFNE_SetVertStreamScreenSpace,


    IWGXFNE_CalculateLighting,
    IWGXFNE_PrepareLighting,


    IWGXFNE_Clear,
    IWGXFNE_DrawPrims,
    IWGXFNE_Flush,
    IWGXFNE_SwapBuffers,
    IWGXFNE_MaterialSetRenderState,
    IWGXFNE_MaterialClearRenderState,
    IWGXFNE_Terminate,


    IWGXFNE_MAX,
};





typedef void(*IWGXFNT_SetVertStreamWorldSpace)(CIwFVec3* pVec, uint32 numVerts);
typedef void(*IWGXFNT_SetVertStreamModelSpace)(CIwFVec3* pVec, uint32 numVerts);
typedef void(*IWGXFNT_SetVertStreamViewSpace)(CIwFVec3* pVec, uint32 numVerts);
typedef void(*IWGXFNT_SetVertStreamScreenSpace)(CIwSVec2* pVec, uint32 numVerts, uint32 shift);


typedef void(*IWGXFNT_CalculateLighting)(CIwMaterial* pMaterial, CIwColour*& pColUse);
typedef void(*IWGXFNT_PrepareLighting)(CIwMatGeomInfo *pInfo);


typedef void(*IWGXFNT_Clear)(uint32 clearFlags);
typedef void(*IWGXFNT_DrawPrims)(IwGxPrimType primType, uint16* pInds, uint32 numInds);
typedef void(*IWGXFNT_Flush)();
typedef void(*IWGXFNT_SwapBuffers)();
typedef void(*IWGXFNT_MaterialSetRenderState)(CIwMaterial* pMat);
typedef void(*IWGXFNT_MaterialClearRenderState)(CIwMaterial* pMat);
typedef void(*IWGXFNT_Terminate)();
# 120 "c:/marmalade/6.2/modules/iwgx/h/IwGxFuncTable.h"
extern void* g_IwGxFuncTable[IWGXFNE_MAX];




enum
{
    IWGXFN_TYPE_SW = 0,
    IWGXFN_TYPE_HW,
    IWGXFN_TYPE_GL,
    IWGXFN_TYPE_GL2,
    IWGXFN_TYPE_MAX,
};

extern void* g_IwGxFuncTableOptions[IWGXFN_TYPE_MAX][IWGXFNE_MAX];
extern void* g_pIWGXFNI_HW_DrawPrims_THW;
extern void* g_pIWGXFNI_HW_DrawPrims_TSW;
# 27 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h" 2



# 1 "c:/marmalade/6.2/modules/iwgx/h/IwGxDebug.h" 1
       
# 31 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h" 2


class CIwColour;
class CIwFMat;
class CIwMaterial;
class CIwSVec2;
class CIwFVec3;
class CIwTexture;
class CIwFVec3;





extern void _IwGxSetOverdrawRender(IwGxPrimType primType);
# 74 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxDataCacheReset();
# 108 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline uint8* IwGxDataAlloc(uint32 n)
{

    n = (n + 3) & ~0x3;
    ((void)0);
    uint8* pData = IwGetGxState()->m_DataCacheNext;
    IwGetGxState()->m_DataCacheCurr = pData;
    IwGetGxState()->m_DataCacheNext += n;

    ;
    return pData;
}

static inline uint32* IwGxPolyAlloc(uint32 n)
{

    n = (n + 3) & ~0x3;
    uint32* pData = IwGetGxState()->m_PolyPtr;
    IwGetGxState()->m_PolyPtr += n/4;
    ((void)0);

    ;
    return pData;
}







static inline int32 IwGxDataCacheGetFree()
{
    return IwGetGxState()->m_DataCacheSize - (IwGetGxState()->m_DataCacheNext - IwGetGxState()->m_DataCache);
}
# 205 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline bool _IW_GX_IS_ON_DATA_CACHE(void* addr)
{
    return (
            ((uint8*)addr >= g_IwGxState->m_DataCache) &&
            ((uint8*)addr < g_IwGxState->m_DataCache + g_IwGxState->m_DataCacheSize)
            );
}
# 246 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxInit();



void _IwGxMakeSurfaceCurrent(s3eSurfaceInfo& ps3eSurface);



void _IwGxClearState();







void IwGxTerminate();
# 274 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxReset();







void IwGxTickUpdate();
# 295 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
int IwGxContextShadowSuspend();
# 309 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
int IwGxContextShadowResume();
# 325 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetContextRestoreCallback(IwGxProgressCallbackFn fn)
{
    IwGetGxState()->m_ContextRestoreCB = fn;
}
# 337 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxRegister(IwGxCallback cbid, IwGxCallbackFn fn);
# 346 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxUnRegister(IwGxCallback cbid, IwGxCallbackFn fn);
# 369 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
extern "C"
{
# 380 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline uint32 IwGxGetDeviceWidth() {return IwGetGxState()->m_DeviceWidth;}
# 389 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline uint32 IwGxGetDeviceHeight() {return IwGetGxState()->m_DeviceHeight;}
# 400 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline uint32 IwGxGetScreenWidth() {return IwGetGxState()->m_ScreenWidth;}
# 411 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline uint32 IwGxGetScreenHeight() {return IwGetGxState()->m_ScreenHeight;}
# 422 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline uint32 IwGxGetDisplayWidth() {return IwGetGxState()->m_DisplayWidth;}
# 433 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline uint32 IwGxGetDisplayHeight() {return IwGetGxState()->m_DisplayHeight;}


}
# 446 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetScreenOrient(IwGxScreenOrient i);
# 455 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void _IwGxSetScreenOrient(IwGxScreenOrient i);
# 464 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline IwGxScreenOrient IwGxGetScreenOrient() {return IwGetGxState()->m_ScreenOrient;}
# 473 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxClear(uint32 clearFlags = IW_GX_DEPTH_BUFFER_F | IW_GX_COLOUR_BUFFER_F)
{
    ((void)0); ((IWGXFNT_Clear)g_IwGxFuncTable[IWGXFNE_Clear])(clearFlags);
}
# 488 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetColClear(uint8 r, uint8 g, uint8 b, uint8 a);
# 497 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwColour& IwGxGetColClear() {return IwGetGxState()->m_ColClear;}
# 518 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetColEmissive(uint32 col) {IwGetGxState()->m_ColEmissive.Set(col);}
# 530 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetColEmissive(uint8 _r, uint8 _g, uint8 _b, uint8 _a) {IwGetGxState()->m_ColEmissive.r = _r; IwGetGxState()->m_ColEmissive.g = _g; IwGetGxState()->m_ColEmissive.b = _b; IwGetGxState()->m_ColEmissive.a = _a;}
# 539 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetColEmissive(const CIwColour& col) {IwGetGxState()->m_ColEmissive.Set(col);}
# 548 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwColour& IwGxGetColEmissive() {return IwGetGxState()->m_ColEmissive;}
# 557 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetColAmbient(uint32 col) {IwGetGxState()->m_ColAmbient.Set(col);}
# 569 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetColAmbient(uint8 _r, uint8 _g, uint8 _b, uint8 _a) {IwGetGxState()->m_ColAmbient.r = _r; IwGetGxState()->m_ColAmbient.g = _g; IwGetGxState()->m_ColAmbient.b = _b; IwGetGxState()->m_ColAmbient.a = _a;}
# 578 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetColAmbient(const CIwColour& col) {(*(uint32*)&(IwGetGxState()->m_ColAmbient) = *(uint32*)&(col));}
# 587 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwColour& IwGxGetColAmbient() {return IwGetGxState()->m_ColAmbient;}
# 596 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetColDiffuse(uint32 col) {IwGetGxState()->m_ColDiffuse.Set(col);}
# 608 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetColDiffuse(uint8 _r, uint8 _g, uint8 _b, uint8 _a) {IwGetGxState()->m_ColDiffuse.r = _r; IwGetGxState()->m_ColDiffuse.g = _g; IwGetGxState()->m_ColDiffuse.b = _b; IwGetGxState()->m_ColDiffuse.a = _a;}
# 617 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetColDiffuse(const CIwColour& col) {(*(uint32*)&(IwGetGxState()->m_ColDiffuse) = *(uint32*)&(col));}
# 626 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwColour& IwGxGetColDiffuse() {return IwGetGxState()->m_ColDiffuse;}
# 646 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetFlags(uint32 flags)
{
    IwGetGxState()->m_Flags |= flags;
}



static inline void IwGxClearFlags(uint32 flags)
{
    IwGetGxState()->m_Flags &= ~flags;
}
# 665 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline uint32 IwGxGetFlags() {return IwGetGxState()->m_Flags;}

static inline uint32 IwGxGetInternalFlags() {return IwGetGxState()->m_InternalFlags;}
# 680 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetDebugFlags(uint32 flags) {};
# 692 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxClearDebugFlags(uint32 flags) {};
# 704 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline uint32 IwGxGetDebugFlags() {return 0;}
# 731 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetTransformHW();


void IwGxSetLightingHW();


void IwGxSetRasterisationHW();







static inline IwGxHWType IwGxGetHWType()
{


    return IwGetGxState()->m_HWType;
}
# 783 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxInit_Base();


void IwGxInit_GLRender();


void IwGxInit_GL2Render();





inline void IwGxActivateEnvMapSW() { }
# 824 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetZDepthOfs(int32 ofs) {IwGetGxState()->m_ZDepthOfs = (int16)ofs+IwGetGxState()->m_ZDepthOfsBase;}
# 833 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline int32 IwGxGetZDepthOfs() {return (int32)IwGetGxState()->m_ZDepthOfs;}
# 842 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetZDepthOfsBase(int32 ofs) {IwGetGxState()->m_ZDepthOfsBase = (int16)ofs;}
# 851 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline int32 IwGxGetZDepthOfsBase() {return (int32)IwGetGxState()->m_ZDepthOfsBase;}
# 860 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetZDepthFixed(float val)
{
    ((void)0);
    IwGetGxState()->m_ZDepthFixed = val;
}
# 873 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline float IwGxGetZDepthFixed() {return IwGetGxState()->m_ZDepthFixed;}
# 905 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxFogOn();
# 915 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxFogOff();
# 927 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetFogFarZNearZ(float fz, float nz);
# 937 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetFogCol(const CIwColour& col);
# 946 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline float IwGxGetFogNearZ() {return IwGetGxState()->m_FogNearZ;}
# 955 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline float IwGxGetFogFarZ() {return IwGetGxState()->m_FogFarZ;}
# 964 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwColour& IwGxGetFogColour() {return IwGetGxState()->m_FogCol;}
# 998 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetVertStreamWorldSpace(CIwFVec3* pVec, uint32 numVerts)
{
    ((void)0); ((IWGXFNT_SetVertStreamWorldSpace)g_IwGxFuncTable[IWGXFNE_SetVertStreamWorldSpace])(pVec, numVerts);
}
# 1011 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetVertStreamModelSpace(CIwFVec3* pVec, uint32 numVerts)
{
    ((void)0); ((IWGXFNT_SetVertStreamModelSpace)g_IwGxFuncTable[IWGXFNE_SetVertStreamModelSpace])(pVec, numVerts);
}
# 1027 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetVertStream(CIwFVec3* pVec, uint32 numVerts)
{
    IwGxSetVertStreamModelSpace(pVec, numVerts);
}
# 1040 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetVertStreamViewSpace(CIwFVec3* pVec, uint32 numVerts)
{
    ((void)0); ((IWGXFNT_SetVertStreamViewSpace)g_IwGxFuncTable[IWGXFNE_SetVertStreamViewSpace])(pVec, numVerts);
}
# 1053 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetVertStreamScreenSpace(CIwSVec2* pVec, uint32 numVerts)
{
    ((void)0); ((IWGXFNT_SetVertStreamScreenSpace)g_IwGxFuncTable[IWGXFNE_SetVertStreamScreenSpace])(pVec, numVerts, 3);
}
# 1066 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetVertStreamScreenSpaceSubPixel(CIwSVec2* pVec, uint32 numVerts)
{
    ((void)0); ((IWGXFNT_SetVertStreamScreenSpace)g_IwGxFuncTable[IWGXFNE_SetVertStreamScreenSpace])(pVec, numVerts, 0);
}
# 1078 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetViewSpaceOrg(const CIwFVec3* pOrg)
{
    IwGetGxState()->m_ViewSpaceOrg = *pOrg;
}
# 1090 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline const CIwFVec3 &IwGxGetViewSpaceOrg()
{
    return IwGetGxState()->m_ViewSpaceOrg;
}
# 1102 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetScreenSpaceOrg(const CIwSVec2* pOrg)
{
    IwGetGxState()->m_ScreenSpaceOrg.x = pOrg->x;
    IwGetGxState()->m_ScreenSpaceOrg.y = pOrg->y;
}
# 1116 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetScreenSpaceSlot(int32 slotID)
{
# 1136 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
    IwGetGxState()->m_ScreenSpaceSlot = slotID;
}
# 1147 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline int32 IwGxGetScreenSpaceSlot()
{
    return IwGetGxState()->m_ScreenSpaceSlot;
}
# 1180 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetNormStream(CIwFVec3* pVec, uint32 numNorms = 0);
# 1190 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetNormStream(CIwSVec3* pVec, uint32 numNorms);







void IwGxSetTangentStream(CIwFVec3* pVec);







void IwGxSetBiTangentStream(CIwFVec3* pVec);
# 1236 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetColStream(CIwColour* pCol, uint32 numCols = 0);
# 1265 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetUVStream(CIwFVec2* pUV, int32 stream_id = 0);
# 1275 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetUVStream(CIwSVec2* pUV, int32 stream_id, int num);
# 1284 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetUVOfs(const CIwFVec2* pOfs, uint32 stream = 0)
{
    IwGetGxState()->m_UVOfs[stream].x = pOfs->x;
    IwGetGxState()->m_UVOfs[stream].y = pOfs->y;
}
# 1297 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwFVec2& _IwGxGetUVOfs(uint32 stream = 0) {return IwGetGxState()->m_UVOfs[stream];}
# 1334 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetSortMode(IwGxSortMode type)
{
    ((void)0);
    IwGetGxState()->m_SortMode = type;
}







static inline void IwGxSetSortModeOpaque(IwGxSortMode type)
{
    ((void)0);
    IwGetGxState()->m_SortModeOpaque = type;
}







static inline void IwGxSetSortModeAlpha(IwGxSortMode type)
{
    ((void)0);
    IwGetGxState()->m_SortModeAlpha = type;
}







static inline void IwGxSetSortModeScreenSpace(IwGxSortMode type)
{
    IwGetGxState()->m_SortModeScreenSpace = type;
}
# 1385 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxDrawPrims(IwGxPrimType primType, uint16* pInds, uint32 numInds)
{
    if (IwGxGetInternalFlags() & IW_GX_INTERNAL_INVALID_TEXTURE_IN_MATERIAL_F)
        return;

    if (!numInds)
        return;





    IwGetGxState()->m_FlushRequired = true;

    ((void)0); ((IWGXFNT_DrawPrims)g_IwGxFuncTable[IWGXFNE_DrawPrims])(primType, pInds, numInds);
}







void IwGxFlush();







void IwGxSwapBuffers();
# 1425 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline uint32 IwGxGetFrameRate()
{
    return (1000<<12)/IwGetGxState()->m_MsPerFrame;
}
# 1437 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxDrawRectScreenSpace(const CIwSVec2* pXY, const CIwSVec2* pWH);
# 1448 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxDrawRectScreenSpace(const CIwSVec2* pXY, const CIwSVec2* pWH,
                                const CIwFVec2* pUV, const CIwFVec2* pDUV);
# 1459 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxDrawRectScreenSpace(const CIwSVec2* pXY, const CIwSVec2* pWH,
                                const CIwColour* pCols);




void IwGxDrawRectScreenSpace(const CIwSVec2* pXY, const CIwSVec2* pDXY,
                                const CIwFVec2* pUV, const CIwFVec2* pDUV, const CIwColour* pCols);
# 1495 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetFarZNearZ(float ifar, float inear);
# 1507 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline float IwGxGetFarZ() { return IwGetGxState()->m_FarZ; }
# 1516 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline float IwGxGetNearZ() { return IwGetGxState()->m_NearZ; }
# 1527 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetPerspMul(float pm);
# 1536 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline float IwGxGetPerspMul() {return IwGetGxState()->m_PerspMul;}
# 1552 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetOrtho(iwfixed left, iwfixed right, iwfixed bottom, iwfixed top, float nearz=-1, float farz=-1);







static inline bool IwGxIsOrthoProjection() { return (IwGetGxState()->m_Flags & IW_GX_ORTHO_PROJ_F) != 0; }
# 1571 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetPerspectiveMatrix(CIwFMat* pMat);
# 1580 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwFMat& IwGxGetPerspectiveMatrix() {return IwGetGxState()->m_MatPerspective;}
# 1589 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline bool IwGxGetUsePerspectiveMatrix() {return IwGetGxState()->m_UseMatPerspective;}
# 1599 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetViewMatrix(const CIwFMat* pMat);







void IwGxUpdateModelViewMatrix();







void IwGxUpdateWorldViewMatrix();
# 1625 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetModelMatrix(const CIwFMat* pMat);







static inline CIwFMat& IwGxGetModelMatrix() {return IwGetGxState()->m_MatModel;}







static inline CIwFMat& IwGxGetViewMatrix() {return IwGetGxState()->m_MatView;}
# 1651 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwFMat& IwGxGetWorldViewMatrix() {return IwGetGxState()->m_MatViewWorld;}
# 1661 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwFMat& IwGxGetModelViewMatrix() {return IwGetGxState()->m_MatViewModel;}
# 1671 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwFMat& IwGxGetWorldViewClipMatrix() {return IwGetGxState()->m_MatClipViewWorld;}
# 1681 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwFMat& IwGxGetModelViewClipMatrix() {return IwGetGxState()->m_MatClipViewModel;}
# 1694 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxWorldToViewXYZ(float& vx, float& vy, float& vz, const CIwFVec3& worldPos)
{
    CIwFVec3 viewPos = IwGetGxState()->m_MatViewWorld.TransformVec(worldPos);
    vx = viewPos.x; vy = viewPos.y; vz = viewPos.z;
}
# 1711 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void _IwGxSetViewRect(int32 x, int32 y, int32 w, int32 h);
# 1722 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetScissorScreenSpace(int32 x, int32 y, int32 w, int32 h);







CIwRect IwGxGetScissorScreenSpace();






void IwGxClearScissorScreenSpace();



void _IwGxSetMatrixFactors();



void _IwGxScaleMatToClip(CIwFMat* pMatV, CIwFMat* pMatC);
# 1781 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetLightType(uint32 id, IwGxLightType type)
{
    ((void)0);
    IwGetGxState()->m_Lights[id].m_Type = type;
}
# 1795 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline IwGxLightType IwGxGetLightType(uint32 id)
{
    ((void)0);
    return IwGetGxState()->m_Lights[id].m_Type;
}
# 1811 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetLightCol(uint32 id, uint8 r, uint8 g, uint8 b);
# 1821 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetLightCol(uint32 id, const CIwColour* pCol);
# 1835 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetLightSpecularCol(uint32 id, uint8 r, uint8 g, uint8 b, uint8 a);
# 1845 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetLightSpecularCol(uint32 id, const CIwColour* pCol);
# 1856 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwColour& IwGxGetLightCol(uint32 id)
{
    ((void)0);
    return IwGetGxState()->m_Lights[id].m_Colour;
}
# 1870 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline void IwGxSetLightPos(uint32 id, const CIwFVec3* pVec)
{
    ((void)0);
    IwGetGxState()->m_Lights[id].m_Pos = *pVec;
}
# 1884 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwFVec3& IwGxGetLightPos(uint32 id)
{
    ((void)0);
    return IwGetGxState()->m_Lights[id].m_Pos;
}
# 1898 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetLightDirn(uint32 id, const CIwFVec3* pVec);
# 1908 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwFVec3& IwGxGetLightDirn(uint32 id)
{
    ((void)0);
    return IwGetGxState()->m_Lights[id].m_Dirn;
}







static inline void IwGxLightingEmissive(bool state)
{
    if (state == true)
        IwGxSetFlags(IW_GX_LIGHTING_EMISSIVE_F);
    else
        IwGxClearFlags(IW_GX_LIGHTING_EMISSIVE_F);
}







static inline void IwGxLightingAmbient(bool state)
{
    if (state == true)
        IwGxSetFlags(IW_GX_LIGHTING_AMBIENT_F);
    else
        IwGxClearFlags(IW_GX_LIGHTING_AMBIENT_F);
}







static inline void IwGxLightingDiffuse(bool state)
{
    if (state == true)
        IwGxSetFlags(IW_GX_LIGHTING_DIFFUSE_F);
    else
        IwGxClearFlags(IW_GX_LIGHTING_DIFFUSE_F);
}







static inline void IwGxLightingSpecular(bool state)
{
    if (state == true)
        IwGxSetFlags(IW_GX_LIGHTING_SPECULAR_F);
    else
        IwGxClearFlags(IW_GX_LIGHTING_SPECULAR_F);
}







static inline void IwGxLightingOn()
{
    IwGxLightingEmissive(true);
    IwGxLightingAmbient(true);
    IwGxLightingDiffuse(true);
    IwGxLightingSpecular(true);
}







static inline void IwGxLightingOff()
{
    IwGxLightingEmissive(false);
    IwGxLightingAmbient(false);
    IwGxLightingDiffuse(false);
    IwGxLightingSpecular(false);
}
# 2028 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxAddPaletteSharing(uint32 flags);
# 2039 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxRemovePaletteSharing(uint32 flags);
# 2048 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxMipMappingOn();
# 2057 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxMipMappingOff();
# 2069 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetPalette16Tint(uint8 r, uint8 g, uint8 b, bool noClear);
# 2100 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetMipmapOffset(int32 offset);
# 2129 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetMaterial(CIwMaterial* pMat);
# 2138 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwMaterial* IwGxGetMaterial() {return IwGetGxState()->m_Material;}
# 2149 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetMaterialFixed(CIwMaterial* pMat);
# 2158 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwMaterial* IwGxGetMaterialFixed() {return IwGetGxState()->m_MaterialFixed;}
# 2170 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
static inline CIwMaterial* IwGxGetMaterialTemplate() {return IwGetGxState()->m_MaterialTemplate;}







static inline void IwGxSetMaterialCopyState(IwGxMaterialCopyState cs)
{

    ((void)0);



    IwGetGxState()->m_Flags |= (IW_GX_MATERIAL_COPY_STATE_COLS_F << cs);
}







static inline void IwGxClearMaterialCopyState(IwGxMaterialCopyState cs)
{

    ((void)0);



    IwGetGxState()->m_Flags &= ~(IW_GX_MATERIAL_COPY_STATE_COLS_F << cs);
}
# 2232 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
int32 IwGxGetPixelsDrawnBeforeYield();
# 2242 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
int32 IwGxSetPixelsDrawnBeforeYield(int32 pdby);
# 2251 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
int32 IwGxGetGamma();
# 2260 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
void IwGxSetGamma(int32 g);


bool IwGxRenderCheck();







static inline int32 IwGxPolyBufferGetFree()
{
     return (IwGetGxState()->m_PolyBufferSize - (IwGetGxState()->m_PolyPtr - IwGetGxState()->m_PolyBuffer)) * 4;
}


void _IwGxCallbackPreFlushRegister(IwGxCallbackFn fn);
void _IwGxCallbackPreFlushRemove(IwGxCallbackFn fn);

void _IwGxSetRenderQuality(IwGxRenderQuality quality);


void _IwGxMapOTRange(iwfixed nearz, iwfixed farz, int32 nearslot, int32 farslot);
# 2293 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h"
bool IwGxIsGLExtensionSupported(IwGxGLExtension extEnumVal);







bool IwGxIsNormalMappingSupported();







bool IwGxIsHWSkinningSupported();






inline void IwGxSetScreenSpaceZ(int32)
{
    ((void)0);
    IwGxSetScreenSpaceSlot(-1);
}







void IwGxDrawPrims(IwGxPrimType primType, CIwGxStream& inds, uint32 numInds = 0);
void IwGxSetUVStream(CIwGxStream& pUV, int32 stream_id = 0);
void IwGxSetColStream(CIwGxStream& Col, uint32 numCols = 0);
void IwGxSetBiTangentStream(CIwGxStream& pVec);
void IwGxSetTangentStream(CIwGxStream& pVec);
void IwGxSetNormStream(CIwGxStream& pVec);
void IwGxSetVertStreamWorldSpace(CIwGxStream& pVec);
void IwGxSetVertStreamModelSpace(CIwGxStream& pVec);
void IwGxSetVertStreamViewSpace(CIwGxStream& pVec);
void IwGxSetVertStreamViewSpace(CIwGxStream& pVec);
void IwGxSetVertStreamScreenSpace(CIwGxStream& pVec);
void IwGxSetVertStreamScreenSpaceSubPixel(CIwGxStream& pVec);
void IwGxSetSkinStream(CIwGxStream& weights, CIwGxStream& inds);


# 1 "c:/marmalade/6.2/modules/iwgx/h/IwGxPrint.h" 1
       
# 64 "c:/marmalade/6.2/modules/iwgx/h/IwGxPrint.h"
void IwGxPrintString(int32 x0, int32 y0, const char* txt, bool wrap = true);







void IwGxPrintSetColour(uint8 r, uint8 g, uint8 b);






void IwGxPrintSetScale(int scale);





int IwGxPrintGetScale();




void IwGxPrintFrameRate(int32 x0, int32 y0);






void IwGxPrintMenuCallback(const char* line, int32 x, int32 y, CIwMenuItem::ColourID colID);




void _IwGxPrintFlush();
void _IwGxPrintBuffersAlloc(uint32 printBuffSize, uint32 stringBuffSize);
void _IwGxPrintBuffersFree();
# 2344 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h" 2
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwGxShaderTechnique.h" 1
       
# 16 "c:/marmalade/6.2/modules/iwgx/h/IwGxShaderTechnique.h"
class CIwMatGeomInfo;
class CIwGxDefaultUniformParams;
# 490 "c:/marmalade/6.2/modules/iwgx/h/IwGxShaderTechnique.h"
class CIwGxGL2ShaderParam;
class CIwGxGL2Shader;
class CIwGxDefaultGL2UniformParams;





class CIwGxShaderUniform
{
public:
# 509 "c:/marmalade/6.2/modules/iwgx/h/IwGxShaderTechnique.h"
    enum CIwGxShaderUniformType
    {

        COMPONENT_1 = 0,
        COMPONENT_2 = 1,
        COMPONENT_3 = 2,
        COMPONENT_4 = 3,
        TYPE_FLOAT = (1 << 2),
        TYPE_INT = (2 << 2),
        TYPE_MAT = (3 << 2),

        FLOAT = TYPE_FLOAT | COMPONENT_1,
        VEC2 = TYPE_FLOAT | COMPONENT_2,
        VEC3 = TYPE_FLOAT | COMPONENT_3,
        VEC4 = TYPE_FLOAT | COMPONENT_4,

        INT = TYPE_INT | COMPONENT_1,
        IVEC2 = TYPE_INT | COMPONENT_2,
        IVEC3 = TYPE_INT | COMPONENT_3,
        IVEC4 = TYPE_INT | COMPONENT_4,

        MAT2 = TYPE_MAT | COMPONENT_2,
        MAT3 = TYPE_MAT | COMPONENT_3,
        MAT4 = TYPE_MAT | COMPONENT_4,

        TYPE_MASK = 0xffff << 2,
    };




    CIwGxShaderUniform();




    ~CIwGxShaderUniform();
# 555 "c:/marmalade/6.2/modules/iwgx/h/IwGxShaderTechnique.h"
    void Set(CIwGxShaderUniformType type, int32 offset, const void* value);
# 565 "c:/marmalade/6.2/modules/iwgx/h/IwGxShaderTechnique.h"
    void Set(const float value, int32 offset = 0);
# 574 "c:/marmalade/6.2/modules/iwgx/h/IwGxShaderTechnique.h"
    void Set(const CIwVec3& value, int32 offset = 0);
# 583 "c:/marmalade/6.2/modules/iwgx/h/IwGxShaderTechnique.h"
    void Set(const CIwSVec3& value, int32 offset = 0);







    void Set(const CIwFVec3& value, int32 offset = 0);
# 603 "c:/marmalade/6.2/modules/iwgx/h/IwGxShaderTechnique.h"
    void Set(const CIwFMat& value, int32 offset = 0);
# 613 "c:/marmalade/6.2/modules/iwgx/h/IwGxShaderTechnique.h"
    void SetWorldSpace(const CIwFVec3& pos, int32 offset = 0);
# 622 "c:/marmalade/6.2/modules/iwgx/h/IwGxShaderTechnique.h"
    void SetWorldSpaceDirection(const CIwFVec3& pos, int32 offset = 0);







    int32 GetElementSize()
    {
        int32 components = (m_Type & 0x3) + 1;
        if (GetElementType() == TYPE_MAT)
            components *= components;
        return components;
    }






    int32 GetElementType()
    {
        return m_Type & TYPE_MASK;
    }







    int32 GetArraySize()
    {
        return m_ArraySize;
    }





    void Init(const CIwGxGL2Shader * shader);
    void SetGL(CIwMatGeomInfo* pMGInfo);
    void SetDirty();


    bool Parse(CIwTextParserITX* pParser);
    void Serialise();

    void AddToMenu(CIwMenu* pMenu);

    enum
    {
        DIRTY_F = (1 << 0),
        WORLD_SPACE_POS_F = (1 << 1),
        WORLD_SPACE_DIR_F = (1 << 2),
        PER_INSTANCE_F = (1 << 3),

        DYNAMIC_MASK = WORLD_SPACE_POS_F | WORLD_SPACE_DIR_F,
    };

private:
    char* m_Name;
    CIwGxShaderUniformType m_Type;
    int32 m_ArraySize;
    void* m_Value;
    CIwGxGL2ShaderParam * m_UniformID;
    uint32 m_Flags;

    friend class CIwGxShaderTechnique;
};




class CIwGxShaderTechnique : public CIwResource
{
public:



    typedef CIwArray<CIwGxShaderTechnique*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;




    CIwGxShaderTechnique();



    ~CIwGxShaderTechnique();
# 722 "c:/marmalade/6.2/modules/iwgx/h/IwGxShaderTechnique.h"
    CIwGxShaderUniform* GetParam(const char* name, bool allowNull = false);
# 732 "c:/marmalade/6.2/modules/iwgx/h/IwGxShaderTechnique.h"
    void SetEnabled(bool enable) { m_Enabled = enable; }






    bool IsEnabled() { return m_Enabled; }







    void SaveTemp();







    void LoadTemp();




    void Compile();
    void FreeHW();
    void Render(CIwMatGeomInfo* pMGInfo, CIwGxGL2Shader * & outProgramID, bool& perInstance);
    void CopyInstance(CIwMatGeomInfo* pMGInfo);
    CIwGxDefaultUniformParams* GetUniformLocations()
    {
        return m_pUniformLocations;
    }

    void Serialise();


    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
    virtual void ParseClose(CIwTextParserITX* pParser);


    bool NeedsTangentSpace();






    CIwGxGL2Shader * GetShader() const
    {
        return m_ProgramID;
    }

    int32 GetHWID();

private:
    char* m_ShaderSource[2];
    int32 m_ShaderSourceLen[2];
    CIwArray<CIwGxShaderUniform> m_Params;
    CIwGxGL2Shader * m_ProgramID;
    CIwGxDefaultUniformParams* m_pUniformLocations;
    bool m_Enabled;
};
# 2345 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h" 2


# 1 "c:/marmalade/6.2/modules/iwgx/h/IwDebugPrim.h" 1
       
# 26 "c:/marmalade/6.2/modules/iwgx/h/IwDebugPrim.h"
# 1 "c:/marmalade/6.2/modules/iwgeom/h/IwGeomFSphere.h" 1
# 27 "c:/marmalade/6.2/modules/iwgx/h/IwDebugPrim.h" 2
# 55 "c:/marmalade/6.2/modules/iwgx/h/IwDebugPrim.h"
extern void IwGxDebugPrimCross(const CIwFVec3& v, float size = 20, const CIwColour& col = IwGxGetColFixed(IW_GX_COLOUR_MAGENTA));
# 65 "c:/marmalade/6.2/modules/iwgx/h/IwDebugPrim.h"
extern void IwGxDebugPrimLine(const CIwFVec3& v0, const CIwFVec3& v1, const CIwColour& col = IwGxGetColFixed(IW_GX_COLOUR_MAGENTA));
# 76 "c:/marmalade/6.2/modules/iwgx/h/IwDebugPrim.h"
extern void IwGxDebugPrimLineList(CIwFVec3* pVec, int32 n, const CIwColour& col = IwGxGetColFixed(IW_GX_COLOUR_MAGENTA), bool closed = false );
# 87 "c:/marmalade/6.2/modules/iwgx/h/IwDebugPrim.h"
extern void IwGxDebugPrimLineStrip(CIwFVec3* pVec, int32 n, const CIwColour& col = IwGxGetColFixed(IW_GX_COLOUR_MAGENTA), bool closed = false);
# 99 "c:/marmalade/6.2/modules/iwgx/h/IwDebugPrim.h"
extern void IwGxDebugPrimTri(const CIwFVec3& v0, const CIwFVec3& v1, const CIwFVec3& v2, const CIwColour& col = IwGxGetColFixed(IW_GX_COLOUR_MAGENTA), bool solid = false);
# 109 "c:/marmalade/6.2/modules/iwgx/h/IwDebugPrim.h"
extern void IwGxDebugPrimSphere(const CIwFSphere& s, const CIwColour& col = IwGxGetColFixed(IW_GX_COLOUR_MAGENTA), bool drawRadialLines = false);
# 120 "c:/marmalade/6.2/modules/iwgx/h/IwDebugPrim.h"
extern void IwGxDebugPrimBBox(const CIwFBBox& s, const CIwColour& col = IwGxGetColFixed(IW_GX_COLOUR_MAGENTA));
# 132 "c:/marmalade/6.2/modules/iwgx/h/IwDebugPrim.h"
extern void IwGxDebugPrimCircle(const CIwFMat& m0, float r, uint32 axis, const CIwColour& col = IwGxGetColFixed(IW_GX_COLOUR_MAGENTA), bool drawRadialLines = false);
# 141 "c:/marmalade/6.2/modules/iwgx/h/IwDebugPrim.h"
extern void IwGxDebugPrimAxes(const CIwFMat& m0, float len);
# 2348 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h" 2
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwGxError.h" 1
       
# 54 "c:/marmalade/6.2/modules/iwgx/h/IwGxError.h"
void IwGxAssertError(unsigned int error, const char* file, int line);







void IwGxClearErrors();
# 2349 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h" 2
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwGxSurface.h" 1
       
# 75 "c:/marmalade/6.2/modules/iwgx/h/IwGxSurface.h"
# 1 "c:/marmalade/6.2/s3e/h/GLES/egl.h" 1
# 12 "c:/marmalade/6.2/s3e/h/GLES/egl.h"
# 1 "c:/marmalade/6.2/s3e/h/EGL/egl.h" 1
# 36 "c:/marmalade/6.2/s3e/h/EGL/egl.h"
# 1 "c:/marmalade/6.2/s3e/h/EGL/eglplatform.h" 1
# 29 "c:/marmalade/6.2/s3e/h/EGL/eglplatform.h"
typedef signed int EGLint;
# 38 "c:/marmalade/6.2/s3e/h/EGL/eglplatform.h"
typedef void* NativeDisplayType;
typedef void* NativeWindowType;
typedef void *NativePixmapType;


typedef NativeDisplayType EGLNativeDisplayType;
typedef NativePixmapType EGLNativePixmapType;
typedef NativeWindowType EGLNativeWindowType;
# 37 "c:/marmalade/6.2/s3e/h/EGL/egl.h" 2


extern "C" {




typedef unsigned int EGLBoolean;
typedef unsigned int EGLenum;
typedef void *EGLConfig;
typedef void *EGLContext;
typedef void *EGLDisplay;
typedef void *EGLSurface;
typedef void *EGLClientBuffer;
# 250 "c:/marmalade/6.2/s3e/h/EGL/egl.h"
extern "C" EGLint eglGetError(void);

extern "C" EGLDisplay eglGetDisplay(EGLNativeDisplayType display_id);
extern "C" EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor);
extern "C" EGLBoolean eglTerminate(EGLDisplay dpy);

extern "C" const char * eglQueryString(EGLDisplay dpy, EGLint name);

extern "C" EGLBoolean eglGetConfigs(EGLDisplay dpy, EGLConfig *configs,
    EGLint config_size, EGLint *num_config);
extern "C" EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *attrib_list,
      EGLConfig *configs, EGLint config_size,
      EGLint *num_config);
extern "C" EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config,
         EGLint attribute, EGLint *value);

extern "C" EGLSurface eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config,
      EGLNativeWindowType win,
      const EGLint *attrib_list);
extern "C" EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config,
       const EGLint *attrib_list);
extern "C" EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config,
      EGLNativePixmapType pixmap,
      const EGLint *attrib_list);
extern "C" EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface);
extern "C" EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface surface,
      EGLint attribute, EGLint *value);

extern "C" EGLBoolean eglBindAPI(EGLenum api);
extern "C" EGLenum eglQueryAPI(void);

extern "C" EGLBoolean eglWaitClient(void);

extern "C" EGLBoolean eglReleaseThread(void);

extern "C" EGLSurface eglCreatePbufferFromClientBuffer(
       EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer,
       EGLConfig config, const EGLint *attrib_list);

extern "C" EGLBoolean eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface,
       EGLint attribute, EGLint value);
extern "C" EGLBoolean eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer);
extern "C" EGLBoolean eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer);


extern "C" EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval);


extern "C" EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config,
       EGLContext share_context,
       const EGLint *attrib_list);
extern "C" EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx);
extern "C" EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw,
     EGLSurface read, EGLContext ctx);

extern "C" EGLContext eglGetCurrentContext(void);
extern "C" EGLSurface eglGetCurrentSurface(EGLint readdraw);
extern "C" EGLDisplay eglGetCurrentDisplay(void);
extern "C" EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx,
      EGLint attribute, EGLint *value);

extern "C" EGLBoolean eglWaitGL(void);
extern "C" EGLBoolean eglWaitNative(EGLint engine);
extern "C" EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface);
extern "C" EGLBoolean eglCopyBuffers(EGLDisplay dpy, EGLSurface surface,
     EGLNativePixmapType target);




typedef void (*__eglMustCastToProperFunctionPointerType)(void);


extern "C" __eglMustCastToProperFunctionPointerType
       eglGetProcAddress(const char *procname);


}
# 13 "c:/marmalade/6.2/s3e/h/GLES/egl.h" 2
# 76 "c:/marmalade/6.2/modules/iwgx/h/IwGxSurface.h" 2
# 1 "c:/marmalade/6.2/s3e/h/s3eGL.h" 1
# 77 "c:/marmalade/6.2/modules/iwgx/h/IwGxSurface.h" 2







class CIwTexture;
class CIwTexturePage;




class CIwGxSurface
{
public:






    CIwGxSurface();




    ~CIwGxSurface();




    enum
    {
        EXACT_MATCH_F = (1 << 0),
        ALPHA_F = (1 << 1),
        PERSISTENT_F = (1 << 2),
        FREE_ASPECT_F = (1 << 3),
        PRESERVE_FRAME_BUFFER_F = (1 << 4),
        CREATE_565_SURFACE_F = (1 << 5),
        CREATE_8888_SURFACE_F = (1 << 6),
    };




    enum CIwGxSurfaceImplementation
    {
        SW,
        CTI,
        EGL_10,
        EGL_11,
        FBO_OES,
        FBO,
    };
# 185 "c:/marmalade/6.2/modules/iwgx/h/IwGxSurface.h"
    bool CreateSurface(CIwTexture* pTexture, uint32 width, uint32 height, uint32 usage);
# 194 "c:/marmalade/6.2/modules/iwgx/h/IwGxSurface.h"
    bool RecreateSurface(uint32 width, uint32 height);







    void MakeCurrent();







    static void MakeDisplayCurrent();
# 220 "c:/marmalade/6.2/modules/iwgx/h/IwGxSurface.h"
    const CIwSVec2& GetClientUVExtent();





    const CIwFVec2& GetClientUVExtentFloat();





    uint32 GetWidth();





    uint32 GetHeight();





    uint32 GetClientWidth();





    uint32 GetClientHeight();







    bool HasAlphaChannel();





    bool IsValid()
    {
        return m_State != UNCREATED;
    }





    inline CIwTexture* GetTexture()
    {
        return m_pAttachedTexture;
    }





    CIwGxSurfaceImplementation GetImplementation();






    const s3eSurfaceInfo& GetSurfaceInfo();


    void BindSurface();
    void ReleaseSurface();
    bool _HasAlphaInSurface()
    {
        return (m_Flags & HAS_ALPHA_IN_SURFACE_F) != 0;
    }
    void DestroySurface();
    uint32 _GetFlags() { return m_Flags; }
private:

    enum
    {
        OWNED_TEXTURE_F = (1 << 16),
        HAS_ALPHA_IN_SURFACE_F = (1 << 17),
        CLIENT_WINDOW_F = (1 << 18),
    };

    void SetSizeAndClientWindow(s3eSurfaceInfo& info, CIwSVec2& client, uint32 maxWidth, uint32 maxHeight, bool allowNonPower2 = false);


    void SW_CreateSurface();
    void SW_RecreateSurface(uint32 width, uint32 height);
    void SW_DestroySurface();
    void SW_BindSurface();
    void SW_ReleaseSurface();
    void SW_MakeCurrent();
    void SW_MakeDisplayCurrent();


    typedef void (CIwGxSurface::*CIwGxSurfaceFunc)();
    typedef void (*CIwGxSurfaceStaticFunc)();
    CIwGxSurfaceFunc HW_CreateSurface;
    CIwGxSurfaceFunc HW_RecreateSurface;
    CIwGxSurfaceFunc HW_DestroySurface;
    CIwGxSurfaceFunc HW_BindSurface;
    CIwGxSurfaceFunc HW_ReleaseSurface;
    CIwGxSurfaceFunc HW_MakeCurrent;
    CIwGxSurfaceFunc HW_MakeDisplayCurrent;


    void CTI_CreateSurface();
    void CTI_RecreateSurface();
    void CTI_DestroySurface();
    void CTI_BindSurface();
    void CTI_ReleaseSurface();
    void CTI_MakeCurrent();
    void CTI_MakeDisplayCurrent();


    void CreateEGLSurface();

    void EGL_CreateSurface();
    void EGL_RecreateSurface();
    void EGL_DestroySurface();
    void EGL_BindSurface();
    void EGL_ReleaseSurface();
    void EGL_MakeCurrent();
    void EGL_MakeDisplayCurrent();


    void CreateFBOTexture();
    void CreateFBOBuffers();

    void FBO_CreateSurface();
    void FBO_RecreateSurface();
    void FBO_DestroySurface();
    void FBO_BindSurface();
    void FBO_ReleaseSurface();
    void FBO_MakeCurrent();
    void FBO_MakeDisplayCurrent();

    CIwTexture* m_pAttachedTexture;

    enum SurfaceState
    {
        UNCREATED = 0,
        CREATED = 1,
        BOUND = 2,
        ACTIVE = 4,
    };
    SurfaceState m_State;
    uint32 m_Flags;


    CIwTexturePage* m_TPage;


    CIwGxSurfaceImplementation m_HWImpl;

    s3eSurfaceInfo m_HW_SurfaceInfo;

    CIwSVec2 m_HW_ClientWindow;
    CIwFVec2 m_F_ClientWindow;


    EGLContext m_EGLContext;
    EGLSurface m_EGLSurface;
    EGLConfig m_EGLConfig;


    GLuint m_Fbo;
    GLuint m_DepthTex;
};



void IwGxGetS3ESurface(s3eSurfaceInfo& s);
# 2350 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h" 2
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h" 1
       
# 22 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwArray.h" 1
# 23 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h" 2







# 1 "c:/marmalade/6.2/modules/iwgx/h/IwMatAnim.h" 1
       
# 21 "c:/marmalade/6.2/modules/iwgx/h/IwMatAnim.h"
class CIwMaterial;
# 36 "c:/marmalade/6.2/modules/iwgx/h/IwMatAnim.h"
class CIwMatAnim
{
private:
    enum Flags
    {
        PAUSED_F = (1 << 0),
    };

    CIwMatAnim();
    ~CIwMatAnim();
    void Serialise();

    inline void SetCelNum(uint8 n) { ((void)0); m_CelNum = n; }
    inline void SetCelNumU(uint8 n) { ((void)0); m_CelNumU = n; }
    inline void SetCelW(uint8 n) { ((void)0); m_CelW = n; }
    inline void SetCelH(uint8 n) { ((void)0); m_CelH = n; }
    inline void SetCelPeriod(uint8 n) { ((void)0); m_CelPeriod = n; m_FrameCountDown = m_CelPeriod; }
    inline void Pause() { m_Flags |= PAUSED_F; }
    inline void Restart() { m_Flags &= ~PAUSED_F; }
    inline bool IsPaused() const { return (m_Flags & PAUSED_F) != 0; }
    inline uint8 GetCelNum() const { return m_CelNum; }
    inline uint8 GetCelNumU() const { return m_CelNumU; }
    inline uint8 GetCelID() const { return m_CelID; }
    inline uint8 GetCelW() const { return m_CelW; }
    inline uint8 GetCelH() const { return m_CelH; }
    inline uint8 GetCelPeriod() const { return m_CelPeriod; }


    uint8 m_Flags;
    uint8 m_FrameCountDown;

    uint8 m_CelNum;
    uint8 m_CelNumU;
    uint8 m_CelID;
    uint8 m_CelW;
    uint8 m_CelH;
    uint8 m_CelPeriod;


    friend class CIwMaterial;
    friend void _IwGxUpdateMaterialAnims();
};
# 31 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h" 2

# 1 "c:/marmalade/6.2/modules/iwutil/h/IwString.h" 1
# 33 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h" 2
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h" 1
       
# 19 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwTPage.h" 1
       
# 87 "c:/marmalade/6.2/modules/iwgx/h/IwTPage.h"
class CIwTexture;
class CIwTexturePage;
class CIwClut;
class CIwTexturePageArea;
class CIwTPageInfo;
struct _palInfo;





struct MIPInfo
{
    union {
        struct {
        uint16 u, v;
        } uvMask;
        uint32 uvMasks;
    };
    uint8 *pMipped;
};






typedef struct _shortrect
{
    int left;
    int top;
    int right;
    int bottom;

}ShortRect;







class CIwTPageInfo
{
public:
    uint16 m_U0;
    uint16 m_V0;
    uint16 m_Vs;
    uint16 m_Us;
    uint16* m_Palette;
private:
    uint32 m_UVTopLeft;
    uint32 m_UVSize;
    CIwTexturePage* m_TPage;
public:
    CIwClut* m_Clut;
    uint8 m_Depth;
    uint8 m_RendererFlags;
    uint8 m_maxMipMap;
    uint8 m_Unlit;
    MIPInfo m_MIPInfo[8];
    _palInfo* m_cachedPalette;





    void SetTPage(CIwTexturePage* tp);
    void SetTPageNULL();
    uint32 GetWidthInPixels();

    void SetTPageNULLInit(){m_TPage = __null;}

    CIwTexturePage* GetTPage() {return m_TPage;}

    uint32 GetWidth() const {return (m_UVSize & 0xffff);}
    uint32 GetHeight() const {return (m_UVSize >> 16);}

    void SetUVSize(uint16 w, uint16 h)
    { m_UVSize = (w) | (h << 16);
    };

    uint32 GetLeft() const {return m_UVTopLeft & 0xffff;}
    uint32 GetTop() const {return m_UVTopLeft >> 16;}

    void SetUVTopLeft(uint16 x, uint16 y)
    { m_UVTopLeft = (x) | (y << 16);
    };

    inline CIwTexture* GetTexture();
};





class CIwClut
{
public:
    virtual ~CIwClut() {}
    typedef CIwArray<CIwClut*> ClutArray;
    typedef CIwArray<CIwClut*>::iterator ClutIt;

    uint16 m_RefCount;

    virtual uint16* GetPalettePtr() = 0;

    void operator delete (void *p);


    static bool DataEqual(uint16* clut1,uint16* clut2,uint16 size);
};





class CIwClut16 : public CIwClut
{
public:
    uint16 m_Palette[16];
    CIwClut16(int r) {m_RefCount = r;} ;
    uint16* GetPalettePtr() {return m_Palette;};
    void * operator new (size_t size);
};

class CIwClut256 : public CIwClut
{
public:
    uint16 m_Palette[256];
    CIwClut256(int r) {m_RefCount = r;} ;
    uint16* GetPalettePtr() {return m_Palette;};
    void * operator new (size_t size);
};
# 229 "c:/marmalade/6.2/modules/iwgx/h/IwTPage.h"
class CIwTexturePageArea
{

public:

    typedef CIwArray<CIwTexturePageArea> AreaArray;
    typedef CIwArray<CIwTexturePageArea>::iterator AreaArrayIt;

    uint16 x,y,w,h;


    CIwTexturePageArea(int a=0, int b=0, int c=128, int d=256) : x(a), y(b), w(c), h(d)
    {

    };

    bool isVirgin() { return (x == 0 && y == 0 && w == 128 && h ==256);}

    bool operator != (const CIwTexturePageArea& rhs) const
    {
        return !(*this == rhs);
    }
    bool operator == (const CIwTexturePageArea& rhs) const
    {
        return x == rhs.x && y == rhs.y && w == rhs.w && h == rhs.h;
    }


    bool Alloc(uint16 allocW, uint16 allocH, int & allocX, int & allocY, CIwTexturePage * tp);


    inline bool Contains(int _x, int _y) {return _x >= x && _x < x+w && _y >= y && _y < y+h;}


    bool Merge(CIwTexturePageArea& area);
};






class CIwTexturePage
{

public:

    uint16* m_TPageMemory;
    uint8* m_TPageMipMapMemory;
    uint32 m_TPageID;
    bool m_OwnsAllocation;
    bool m_DefragOnNextAlloc;
    int32 m_UsedStackBased;
    uint32 m_GroupSize;
    int16 m_ShortsWide;
    int16 m_LinesHigh;

    typedef CIwArray<CIwTexturePage*> TexturePageArray;
    typedef CIwArray<CIwTexturePage*>::iterator TexturePageIt;
    typedef CIwArray<CIwTexture*> TextureArray;



    CIwTexturePageArea::AreaArray m_FreeRects;
    CIwTexturePageArea::AreaArray m_UsedRects;
    TextureArray m_Textures;
# 312 "c:/marmalade/6.2/modules/iwgx/h/IwTPage.h"
    CIwTexturePage(bool hasMipmaps, uint16* alloc = __null);
    ~CIwTexturePage();


    bool isVirgin(){ return (m_FreeRects.size() == 1 && m_FreeRects[0].isVirgin() && m_GroupSize == 1 && !m_OwnsAllocation);}


    void LoadTexelsToTPage(CIwTPageInfo* tex, uint8* dataIn);


    bool FreeArea(int w, int h, int x, int y);


    void LoadImageToTPage(int left, int top, int width, int height, uint16* data, uint32 dataPitch);


    int TryAlloc(int w, int h);


    void DoAlloc(int resID, int w, int h, int & x, int & y);


    bool Alloc(int w, int h, int & x, int & y);


    void MakeMipMap(uint16* clut, CIwRect32* r, int colourDepth, bool padded );


    void ReplaceMipMap( CIwRect32* r, int level, int colourDepth, bool padded, uint8* dataIn, uint32 dataPitch);


    void MoveMipMaps(bool mipmapped, int16 shortsWide, int16 linesHigh );


    uint8* StoreTexelsFromTPage(CIwTPageInfo* tex);


    uint16* GetTextelAddress( CIwTPageInfo* tex);


    void Defragment();






private:


    bool AllocArea(int w, int h, int & t, int & x, int & y);


    void CopyImageTexture( int tall, int wide, int strideOut, int strideIn, uint16* src, uint16* dest);


    unsigned short* GetTPageBufferOffset(int x, int y);

};







class CIwTexturePageManager
{
public:

    CIwTexturePageManager();
    ~CIwTexturePageManager();
    friend class CIwTexture;
    friend class CIwTexturePage;
    friend class CIwTexturePageArea;
    friend class CIwClut16;
    friend class CIwClut256;
    friend class CIwClut;

    friend void IwGxVRAMDump(int32);






    int32 CountUsedClut16s();
    int32 CountUsedClut256s();

private:

    CIwMemBucketFixedSize* m_Clut16Bucket;
    CIwMemBucketFixedSize* m_Clut256Bucket;


    uint8* m_Clut16BucketMem;
    uint8* m_Clut256BucketMem;

    CIwTexturePage::TexturePageArray m_TPageArray;
public:

    CIwClut::ClutArray m_ClutArray16;
    CIwClut::ClutArray m_ClutArray256;
private:

    uint32 m_NumberOfTPages;
    uint32 m_NumberOfTPagesNoMipMap;
    uint32 m_NumberOfClut16s;
    uint32 m_NumberOfClut256s;
    uint32 m_NumberOfFreeRectsPerPage;
    uint32 m_MaxTexturesPerTPage;


    uint16* m_VRAMMemory;
# 443 "c:/marmalade/6.2/modules/iwgx/h/IwTPage.h"
    void FreeClut(CIwClut* clut);


    void FreeClut16(CIwTPageInfo* clut);


    void FreeClut256(CIwTPageInfo* clut);


    CIwClut* AllocClut16(uint16* clut);


    CIwClut* AllocClut256(uint16* clut);




    uint8* GetTexelsFromTPage(CIwTPageInfo* tex);


    void LoadTexelsToTPage(CIwTPageInfo* tex, uint8* dataIn);


    void MakeMipMap(CIwTPageInfo* tex, CIwImage* image);


    void ReplaceMipMap(CIwTPageInfo* tex, int32 level, uint8* dataIn, uint32 dataPitch);


    void ReadSegundoParameters();



    void AllocTextureNbit(int pixelWidth, int pitch, int h, int bpt, uint32 * data, uint16 * clut, CIwTPageInfo* tex, CIwImage::Format format, bool mipmap);


    void UploadTextureNbit(int bpt, uint32* data, uint32 dataPitch, uint16* clut, CIwTPageInfo* tex, bool mipmap);


    void FreeTexelsNbit(int bpt, CIwTPageInfo* tex);


    void FreeTextureNbit(int bpt, CIwTPageInfo* tex);
public:

    void LoadImageByDepth(CIwTPageInfo* tex, CIwRect32* rect, uint8* _data, uint32 dataPitch, bool odd);





private:

    void ClearBuffer(uint16* buf, bool hasMipMaps);
    void DoBufferCopyAndConvert(CIwTPageInfo* tex);
    void PrepareBuffer(CIwTexturePage* tPage);
    void ProcessMipMaps(CIwTPageInfo* tex);
    void ReverseBuffer(uint16* srcPtr);


    bool AllocArea(int w, int h, uint32 & t, int & x, int & y, bool mipmapped);


    void LoadImage(CIwTPageInfo* tpage, CIwRect32* rect, uint32* _data, uint32 dataPitch);


    CIwClut* AllocClut(uint16* clut, CIwClut::ClutArray* clutArray, uint16 size);

    int32 CountClut(CIwClut::ClutArray* clutArray);


    void BucketSetupClut16();
    void BucketSetupClut256();
    void BucketSetupTexturePage();



};

extern CIwTexturePageManager* g_IwTexturePageManager; inline CIwTexturePageManager* IwGetTexturePageManager() {return g_IwTexturePageManager;};
# 20 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h" 2



class CIwColour;
class CIwMenu;
class CIwMaterial;
class CIwTexture;
class CIwAtlasInfo;
class CIwManagedList;
# 43 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
class CIwTexture : public CIwResource
{
public:
    typedef CIwArray<CIwTexture*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const; private: CIwTexture(const CIwTexture &copy) { ((void)0); } const CIwTexture& operator= (const CIwTexture &rhs) { ((void)0); return *this; } public:;
# 57 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    enum Flags
    {

        UPLOADED_F = (1 << 0),
        NEEDS_SW_TRANSPARENCY_F = (1 << 1),
        UPLOAD_ON_LOAD_F = (1 << 2),
        USES_TRANSPARENCY_F = (1 << 3),
        NO_TRANSPARENCY_F = (1 << 4),

        NO_FILTER_F = (1 << 6),

        OWNS_TEXELS_F = (1 << 8),
        OWNS_PALETTE_F = (1 << 9),
        OWNS_PALETTE_CACHE_RGBS_F = (1 << 10),
        NATIVE_16BIT_F = (1 << 11),
        SHARES_TEXELS_F = (1 << 12),

        DO_SW_F = (1 << 13),
        DO_HW_F = (1 << 14),

        KEEP_DATA_AFTER_UPLOAD_F = (1 << 15),
        ANIMATE_UV_F = (1 << 16),

        NEVER_SW_F = (1 << 17),
        NO_MIPMAPPING_F = (1 << 18),
        CLAMP_UV_F = (1 << 19),

        SKIPPED_MIPMAP_GENERATION = (1 << 20),

        CREATE_FOR_3D_API_F = (1 << 21),
        CREATE_FOR_2D_API_F = (1 << 22),

        SHARED_SOURCE_F = (1 << 23),

        CLAMP_UV_SET_F = (1 << 24),

        DONT_SERIALISE_IMAGE_F = (1 << 25),

        ATTACHED_TO_SURFACE_F = (1 << 26),
        BOUND_TO_ACTIVE_SURFACE_F = (1 << 27),
        OWNS_HW_TEXELS_F = (1 << 28),

        CUBE_MAP_F = (1 << 29),

        IGNORE_MIPMAP_OFFSET_F = (1 << 30),

        ALLOW_LOW_QUALITY_F = (1u << 31),
    };




    CIwTexture();




    virtual ~CIwTexture();



    virtual void Serialise();

    virtual void Resolve();
# 129 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    void LoadFromFile(const char* imageFile);
# 143 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    void CopyFromBuffer(uint16 w, uint16 h, CIwImage::Format format, uint16 pitch, uint8* pImageData, uint16* pPalette);
# 152 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    void CopyFromImage(CIwImage* pImg);
# 161 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    void SetImage(CIwImage* pImg);







    inline uint8 HasAlpha() const {return m_Image.HasAlpha();}







    inline bool UsesAlpha(uint8 threshold = 0xff) const {return m_Image.UsesAlpha(threshold);}







    inline bool UsesChromakey() const {return m_Image.UsesChromakey();}
# 194 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    virtual void Upload();
# 208 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    CIwTexture* ExtractSubTexture(uint16 x, uint16 y, uint16 w, uint16 h, const char* name);
# 219 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    void ChangePalette(uint16* pPalette, CIwImage::Format format);
# 230 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    void ChangeTexels(uint8* pTexels, CIwImage::Format format);







    void RemakeMipmaps();
# 247 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline int32 GetPaletteMemSize() const
    {
        return m_Image.GetPaletteMemSize();
    }
# 259 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline int32 GetPaletteNumEntries() const
    {
        return m_Image.GetPaletteSize();
    }
# 271 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline int32 GetTexelsMemSize() const
    {
        return m_Image.GetTexelsMemSize();
    }
# 283 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline uint32 GetWidth() const {return m_Image.GetWidth();}
# 292 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline uint32 GetHeight() const {return m_Image.GetHeight();}
# 301 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline uint16 GetDepth() const {return (uint16)m_Image.GetTexelBitDepth();}







    inline CIwImage::Format GetFormatSW() const {return (CIwImage::Format)m_FormatSW;}







    inline CIwImage::Format GetFormatHW() const {return (CIwImage::Format)m_FormatHW;}
# 326 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline CIwImage::Format GetFormat() const {return m_Image.GetFormat();}
# 344 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline void SetFormatSW(CIwImage::Format formatSW) { m_FormatSW = formatSW;}
# 354 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline void SetFormatHW(CIwImage::Format formatHW) { m_FormatHW = formatHW;}
# 364 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline uint32 GetFlags() const {return m_Flags;}
# 381 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline uint8* GetTexels() const
    {
        ((void)0);


        return m_Image.GetTexels();
    }
# 411 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    void GetTexels(uint8* pTexels, CIwImage::Format format) const;
# 424 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline const uint8* GetPalette() const
    {
        ((void)0);


        return m_Image.GetPalette();
    }
# 440 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    void GetPalette(uint16* pPalette, CIwImage::Format format) const;
# 449 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    uint32 GetPitch() const
    {
        ((void)0);
        return m_Image.GetPitch();
    }
# 462 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    void SetFiltering(bool bOn);
# 471 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline bool GetFiltering() const {return (m_Flags & NO_FILTER_F) == 0;}
# 480 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    void SetMipMapping(bool bOn);
# 489 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline bool GetMipMapping() const {return (m_Flags & NO_MIPMAPPING_F) == 0;}
# 498 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    void SetClamping(bool bOn);
# 507 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline bool GetClamping() const
    {
        return (m_Flags & CLAMP_UV_F) != 0;
    }







    void SetModifiable(bool modifiable);
# 528 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    inline CIwImage& GetImage() {return m_Image;}







    bool GetModifiable() const
    {
        return (0 != (m_Flags & KEEP_DATA_AFTER_UPLOAD_F));
    }
# 550 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    void UseAsHandle(CIwTexture* pTex);
# 559 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    CIwTexture* CloneWithNewPalette(const char* name, uint16* pPalette);
# 568 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    CIwTexture* UploadSubRegion(int u0, int v0, int u1, int v1);




    void PreparePalette(CIwImage* pImg);





    bool UsesTransparency(CIwImage* pImg = __null, int32 threshhold = 30);



    void ReplaceTexture(CIwTexture* pTex);


    void ChangePalette(uint16* pPalette);
    void ChangeTexels(uint8* pTexels);




    void MakeModifiable(bool modifiable)
    {
        ((void)0);
        SetModifiable(modifiable);
    }




    inline void _SetUploaded() {m_Flags |= UPLOADED_F;}
    inline void _SetUploadOnLoad() {m_Flags |= UPLOAD_ON_LOAD_F;}
    inline void _SetFlags(uint32 flags) {m_Flags |= flags;}
    inline void _ClearFlags(uint32 flags) {m_Flags &= ~flags;}
    inline CIwImage& _GetImage() {return m_Image;}
    void _FreeTexelData();
    void _FreePaletteData();
    void _SetTransparencyFlags(CIwImage* pImg, int threshhold = 30);
    void _SetTransparencyFlags(int threshhold = 30);
    void _Refresh();
    void SW_BindToSurface(s3eSurfaceInfo* pSurfaceInfo);
    void SW_ReleaseFromSurface();
    void MakeTransPalIdxZero() { PreparePalette(&m_Image); }
    CIwImage::Format _DetermineFormatSW() const;
    void _SetFormatFromImageTemplate();
    void _UpdateTexParamsGL(bool always = false);


    uint16* _GetPaletteFromVRAM();
    uint8* _GetTexelsFromVRAM();
    uint16* _GetPaletteCopy();
    uint8* _GetTexelsCopy();
    uint32 _GetTexelVRAMAddress();
    uint32 _GetPaletteVRAMAddress() const;


    int GetActualColourDepth();





    void ColourReduce();


    bool IsSharedSource();


    bool GetSharedForename(char* sharename, uint32 buffSize);


    void CopySharedTexels();


    void GL_GetContents();

private:
    uint32 _UploadIndividualImageGL(uint32 target, CIwImage& img);
    void FreeCustomMipMaps();
    void FindSharedTexels();
    CIwGxCompressedTextureBlock* _Compress();


protected:

    CIwImage m_Image;
    uint32 m_Flags;

    CIwImage** m_CustomMipMaps;
    int32 m_NumCustomMipMaps;


    uint8 m_FormatSW;
    uint8 m_FormatHW;

public:
    CIwTPageInfo m_VRAMInfo;
    CIwColour* m_PaletteCacheRGBs;
    CIwTexture* m_NonTransparentTex;
    uint32 m_SharedTexelHash;


    uint32 m_HWID;
    uint8 m_UShiftFactor;
    uint8 m_VShiftFactor;
    CIwFVec2 m_UVScale;

    static CIwTexture* g_Context;
    static uint32 g_Stage;

    static void SetContext(CIwTexture* tex){g_Context = tex;};
    static CIwTexture* GetContext(){return g_Context;};

    typedef CIwTexture* GetSharedTexelsFn(CIwTexture* pTexture);
    static void _SetCallback_GetSharedTexels(GetSharedTexelsFn* pCallback){ g_GetSharedTexelsCallback = pCallback; };





    virtual void _Replace(CIwManaged* pRHS);

    friend class CIwResGroup;
    friend class CIwResHandlerImage;
    friend class CIwTexturePageManager;
    friend void _IwGxResManagerCallbackTextureSharedTexels(void*);
    friend void _Serialise_ResGroupResources();

    friend void IwGxSetMaterial(CIwMaterial* pMat);
    friend class CIwModelBlockSWOptim1;
    friend void _IwGxInit_InitSWTextures();
    friend void _IwGxInit_InitHWTextures();
    friend class CIwAtlasInfo;


    inline void SW_VerifyModulation(CIwMaterial *pMat);

    void _GL_UploadRegion(CIwImage& img, CIwRect& pRect);

private:
# 727 "c:/marmalade/6.2/modules/iwgx/h/IwTexture.h"
    void SW_Constructor(); void SW_Destructor(); void SW_GetTexelsFromVRAM(uint8*& pTexels); void SW_GetPaletteFromVRAM(uint16*& pPalette); void SW_Upload(CIwImage& newImage); void SW_Convert(CIwImage& dstImage); void SW_ReplaceTexture(CIwTexture* pTex); CIwTexture* SW_CloneWithNewPalette(const char* name, uint16* pPalette); void SW_ChangePalette(uint16* pPalette, CIwImage::Format format); void SW_ChangeTexels(uint8* pTexels, CIwImage::Format format); void SW_RemakeMipmaps(); void SW_UseAsHandle(CIwTexture* pTex); CIwTexture* SW_UploadSubRegion(int u0, int v0, int u1, int v1);
    void GL_Constructor(); void GL_Destructor(); void GL_GetTexelsFromVRAM(uint8*& pTexels); void GL_GetPaletteFromVRAM(uint16*& pPalette); void GL_Upload(CIwImage& newImage); void GL_Convert(CIwImage& dstImage); void GL_ReplaceTexture(CIwTexture* pTex); CIwTexture* GL_CloneWithNewPalette(const char* name, uint16* pPalette); void GL_ChangePalette(uint16* pPalette, CIwImage::Format format); void GL_ChangeTexels(uint8* pTexels, CIwImage::Format format); void GL_RemakeMipmaps(); void GL_UseAsHandle(CIwTexture* pTex); CIwTexture* GL_UploadSubRegion(int u0, int v0, int u1, int v1);
    void D3D_Constructor(); void D3D_Destructor(); void D3D_GetTexelsFromVRAM(uint8*& pTexels); void D3D_GetPaletteFromVRAM(uint16*& pPalette); void D3D_Upload(CIwImage& newImage); void D3D_Convert(CIwImage& dstImage); void D3D_ReplaceTexture(CIwTexture* pTex); CIwTexture* D3D_CloneWithNewPalette(const char* name, uint16* pPalette); void D3D_ChangePalette(uint16* pPalette, CIwImage::Format format); void D3D_ChangeTexels(uint8* pTexels, CIwImage::Format format); void D3D_RemakeMipmaps(); void D3D_UseAsHandle(CIwTexture* pTex); CIwTexture* D3D_UploadSubRegion(int u0, int v0, int u1, int v1);
    void DS_Constructor(); void DS_Destructor(); void DS_GetTexelsFromVRAM(uint8*& pTexels); void DS_GetPaletteFromVRAM(uint16*& pPalette); void DS_Upload(CIwImage& newImage); void DS_Convert(CIwImage& dstImage); void DS_ReplaceTexture(CIwTexture* pTex); CIwTexture* DS_CloneWithNewPalette(const char* name, uint16* pPalette); void DS_ChangePalette(uint16* pPalette, CIwImage::Format format); void DS_ChangeTexels(uint8* pTexels, CIwImage::Format format); void DS_RemakeMipmaps(); void DS_UseAsHandle(CIwTexture* pTex); CIwTexture* DS_UploadSubRegion(int u0, int v0, int u1, int v1);
    void PSP_Constructor(); void PSP_Destructor(); void PSP_GetTexelsFromVRAM(uint8*& pTexels); void PSP_GetPaletteFromVRAM(uint16*& pPalette); void PSP_Upload(CIwImage& newImage); void PSP_Convert(CIwImage& dstImage); void PSP_ReplaceTexture(CIwTexture* pTex); CIwTexture* PSP_CloneWithNewPalette(const char* name, uint16* pPalette); void PSP_ChangePalette(uint16* pPalette, CIwImage::Format format); void PSP_ChangeTexels(uint8* pTexels, CIwImage::Format format); void PSP_RemakeMipmaps(); void PSP_UseAsHandle(CIwTexture* pTex); CIwTexture* PSP_UploadSubRegion(int u0, int v0, int u1, int v1);
    void WII_Constructor(); void WII_Destructor(); void WII_GetTexelsFromVRAM(uint8*& pTexels); void WII_GetPaletteFromVRAM(uint16*& pPalette); void WII_Upload(CIwImage& newImage); void WII_Convert(CIwImage& dstImage); void WII_ReplaceTexture(CIwTexture* pTex); CIwTexture* WII_CloneWithNewPalette(const char* name, uint16* pPalette); void WII_ChangePalette(uint16* pPalette, CIwImage::Format format); void WII_ChangeTexels(uint8* pTexels, CIwImage::Format format); void WII_RemakeMipmaps(); void WII_UseAsHandle(CIwTexture* pTex); CIwTexture* WII_UploadSubRegion(int u0, int v0, int u1, int v1);

    void GL_Convert(CIwImage& img, CIwImage& newImage);
    uint32 DS_GetTexelVRAMAddress() const;
    uint32 DS_GetPaletteVRAMAddress() const;

    static CIwTexture* g_SharedTexels;
    static GetSharedTexelsFn* g_GetSharedTexelsCallback;
};
# 34 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h" 2






class CIwMatAnim;
class CIwMatGeomInfo;
class CIwTextParserITX;
class CIwTexture;
class CIwVertexShader;
class CIwGxShaderTechnique;
class CIwAtlasInfo;
# 319 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
class CIwMaterial : public CIwResource
{
public:



    typedef CIwArray<CIwMaterial*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const; private: CIwMaterial(const CIwMaterial &copy) { ((void)0); } const CIwMaterial& operator= (const CIwMaterial &rhs) { ((void)0); return *this; } public:;
    virtual void SetName(const char* pName);
    virtual void DebugAddMenuItems(CIwMenu* pMenu);







    enum ShadeMode
    {




        SHADE_FLAT,




        SHADE_GOURAUD,
    };







    enum ModulateMode
    {







        MODULATE_RGB,





        MODULATE_R,





        MODULATE_NONE,

        MODULATE_MASK
    };







    enum CullMode
    {



        CULL_FRONT,




        CULL_BACK,




        CULL_NONE,
    };







    enum AlphaMode
    {



        ALPHA_NONE,






        ALPHA_HALF,






        ALPHA_ADD,






        ALPHA_SUB,







        ALPHA_BLEND,






        ALPHA_DEFAULT,
    };
# 462 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    enum AlphaTestMode
    {
        ALPHATEST_DISABLED,
        ALPHATEST_NEVER,
        ALPHATEST_LESS,
        ALPHATEST_EQUAL,
        ALPHATEST_LEQUAL,
        ALPHATEST_GREATER,
        ALPHATEST_NOTEQUAL,
        ALPHATEST_GEQUAL,
        ALPHATEST_ALWAYS
    };







    enum BlendMode
    {
        BLEND_MODULATE,
        BLEND_DECAL,
        BLEND_ADD,
        BLEND_REPLACE,
        BLEND_BLEND,
        BLEND_MODULATE_2X,
        BLEND_MODULATE_4X,
    };







    enum EffectPreset
    {
        EFFECT_DEFAULT,
        EFFECT_NORMAL_MAPPING,
        EFFECT_REFLECTION_MAPPING,
        EFFECT_ENVIRONMENT_MAPPING,
        EFFECT_CONSTANT_COLOUR_CHANNEL,
        EFFECT_LIGHTMAP_POST_PROCESS,
        EFFECT_NORMAL_MAPPING_SPECULAR,
        EFFECT_TEXTURE0_ONLY,
    };







    enum DepthWriteMode
    {
        DEPTH_WRITE_NORMAL,
        DEPTH_WRITE_DISABLED,
    };


    enum
    {
        INTENSITY_F = (1 << 0),
        UNMODULATE_F = (1 << 1),
        FLAT_F = (1 << 2),
        TWO_SIDED_F = (1 << 3),
        CULL_FRONT_F = (1 << 4),
        NO_FILTERING_F = (1 << 5),
        NO_RENDER_F = (1 << 6),
        MERGE_GEOM_F = (1 << 7),
        CLAMP_UV_F = (1 << 8),
        ATLAS_MATERIAL_F = (1 << 9),
        NO_FOG_F = (1 <<10),


        IN_USE_F = (1 << 12),




        ALPHA_MODE_SHIFT = 16,
        ALPHA_MODE_MASK = 0x00070000,
        BLEND_MODE_SHIFT = 19,
        BLEND_MODE_MASK = 0x00380000,
        EFFECT_PRESET_SHIFT = 22,
        EFFECT_PRESET_MASK = 0x01C00000,
        ALPHATEST_MODE_SHIFT = 25,
        ALPHATEST_MODE_MASK = 0x1e000000,
        DEPTH_WRITE_MODE_SHIFT = 29,
        DEPTH_WRITE_MODE_MASK = 0x1 << DEPTH_WRITE_MODE_SHIFT,

        PRIVATE_FLAGS_MASK = 0xffffffff,
    };
# 582 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    CIwMaterial();
    CIwMaterial(bool c);





    virtual ~CIwMaterial();






    void Copy(const CIwMaterial& mat);







    bool IsEquivalent(const CIwMaterial& mat);





    inline void Reset() {Copy(*IwGxGetMaterialTemplate());}



    virtual void Serialise();
    virtual void Resolve();
    virtual void ParseOpen(CIwTextParserITX* pParser);
    virtual void ParseClose(CIwTextParserITX* pParser);
    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
# 630 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline uint16 GetUserFlags() const {return m_UserFlags;}
# 641 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetUserFlags(uint16 flags) { m_UserFlags = flags; }
# 652 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetShadeMode(ShadeMode m)
    {
        ((void)0);
        ((void)0);

        if (m == SHADE_FLAT)
            m_Flags |= FLAT_F;
        else
            m_Flags &= ~FLAT_F;
        ((void)0);

    }
# 672 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline ShadeMode GetShadeMode()
    {
        return (m_Flags & FLAT_F) ? SHADE_FLAT : SHADE_GOURAUD;
    }
# 686 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetModulateMode(ModulateMode m)
    {
        ((void)0);
        m_Flags &= ~MODULATE_MASK;
        m_Flags |= m;
        ((void)0);


        if (m == MODULATE_NONE)
            SetShadeMode(SHADE_FLAT);
    }
# 705 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline ModulateMode GetModulateMode()
    {







        ((void)0);
        if (m_Flags & MODULATE_NONE)
            return MODULATE_NONE;
        return (m_Flags & INTENSITY_F) ? MODULATE_R : MODULATE_RGB;
    }
# 728 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    void SetCullMode(CullMode m);
# 737 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    CullMode GetCullMode();
# 746 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    void SetInvisible(bool b);
# 755 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    bool IsInvisible();
# 765 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    void SetFiltering(bool b);
# 774 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    bool GetFiltering();
# 786 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetAlphaMode(AlphaMode mode)
    {
        ((void)0);
        ((void)0);;

        _ClearFlags(ALPHA_MODE_MASK);
        _SetFlags(mode << ALPHA_MODE_SHIFT);
    }
# 802 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline AlphaMode GetAlphaMode() const
    {






        return (AlphaMode)((m_Flags&ALPHA_MODE_MASK)>>ALPHA_MODE_SHIFT);
    }
# 823 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetAlphaTestMode( AlphaTestMode mode )
    {
        ((void)0);
        ((void)0);;

        _ClearFlags(ALPHATEST_MODE_MASK );
        _SetFlags( mode << ALPHATEST_MODE_SHIFT );
    }
# 839 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline AlphaTestMode GetAlphaTestMode() const {return (AlphaTestMode)((m_Flags & ALPHATEST_MODE_MASK) >> ALPHATEST_MODE_SHIFT);}
# 851 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetAlphaTestRefVal( uint8 alphaRefVal )
    {
        m_AlphaTestRefVal = alphaRefVal;
    }
# 863 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline uint8 GetAlphaTestRefVal() const { return m_AlphaTestRefVal; }


    void SetDepthWriteMode(DepthWriteMode mode)
    {
        m_Flags &= ~DEPTH_WRITE_MODE_MASK;
        m_Flags |= mode << DEPTH_WRITE_MODE_SHIFT;
    }

    inline DepthWriteMode GetDepthWriteMode() const
    {
        return (DepthWriteMode)((m_Flags & DEPTH_WRITE_MODE_MASK) >> DEPTH_WRITE_MODE_SHIFT);
    }
# 887 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetBlendMode(BlendMode mode)
    {
        ((void)0);
        ((void)0);;
        _ClearFlags(BLEND_MODE_MASK);
        _SetFlags(((uint8)mode) << BLEND_MODE_SHIFT);
    }
# 902 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline BlendMode GetBlendMode() const
    {
        return (BlendMode)((m_Flags&BLEND_MODE_MASK)>>BLEND_MODE_SHIFT);
    }
# 928 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    void SetEffectPreset(EffectPreset effectpreset)
    {
        ((void)0);
        ((void)0);;
        _ClearFlags(EFFECT_PRESET_MASK);
        _SetFlags(((uint8)effectpreset) << EFFECT_PRESET_SHIFT);
    }
# 943 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline EffectPreset GetEffectPreset() const
    {







        return (EffectPreset)((m_Flags&EFFECT_PRESET_MASK)>>EFFECT_PRESET_SHIFT);
    }
# 963 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetColEmissive(uint32 col) { m_ColEmissive.Set(col);}
# 976 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetColEmissive(uint8 _r, uint8 _g, uint8 _b, uint8 _a) {m_ColEmissive.r = _r; m_ColEmissive.g = _g; m_ColEmissive.b = _b; m_ColEmissive.a = _a;}
# 986 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetColEmissive(const CIwColour& col) {m_ColEmissive.Set(col);}
# 995 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline CIwColour& GetColEmissive() {return m_ColEmissive;}
# 1005 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetColAmbient(uint32 col) {m_ColAmbient.Set(col);}
# 1018 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetColAmbient(uint8 _r, uint8 _g, uint8 _b, uint8 _a) {m_ColAmbient.r = _r; m_ColAmbient.g = _g; m_ColAmbient.b = _b; m_ColAmbient.a = _a;}
# 1028 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetColAmbient(const CIwColour& col) {(*(uint32*)&(m_ColAmbient) = *(uint32*)&(col));}
# 1037 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline CIwColour& GetColAmbient() {return m_ColAmbient;}
# 1047 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetColDiffuse(uint32 col) {m_ColDiffuse.Set(col);}
# 1060 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetColDiffuse(uint8 _r, uint8 _g, uint8 _b, uint8 _a) {m_ColDiffuse.r = _r; m_ColDiffuse.g = _g; m_ColDiffuse.b = _b; m_ColDiffuse.a = _a;}
# 1070 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetColDiffuse(const CIwColour& col) {(*(uint32*)&(m_ColDiffuse) = *(uint32*)&(col));}
# 1079 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline CIwColour& GetColDiffuse() {return m_ColDiffuse;}
# 1090 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetColSpecular(uint32 col)
    {
        uint8 specPower = m_ColSpecular.a;
        (*(uint32*)&(m_ColSpecular) = (col));
        m_ColSpecular.a = specPower;
    }
# 1107 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetColSpecular(uint8 _r, uint8 _g, uint8 _b) { m_ColSpecular.r = _r; m_ColSpecular.g = _g; m_ColSpecular.b = _b; }
# 1117 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetColSpecular(const CIwColour& col) { m_ColSpecular.r = col.r; m_ColSpecular.g = col.g; m_ColSpecular.b = col.b; }
# 1127 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline CIwColour& GetColSpecular() { return m_ColSpecular; }
# 1137 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetSpecularPower(uint8 power) { m_ColSpecular.a = power; }
# 1147 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline uint8 GetSpecularPower() { return m_ColSpecular.a; }
# 1161 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetTexture(CIwTexture* pTex, uint32 t = 0)
    {
        ((void)0);
        m_Textures[t] = pTex;
    }
# 1177 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline CIwTexture* GetTexture(uint32 t = 0) const {return m_Textures[t];}


    inline void SetShaderTechnique(CIwGxShaderTechnique* tech) { m_ShaderTechnique = tech; }
    inline CIwGxShaderTechnique* GetShaderTechnique() const { return m_ShaderTechnique; }
# 1191 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetZDepthOfs(int32 val) {m_ZDepthOfs = (int16)val;}
# 1200 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline int32 GetZDepthOfs() const {return (int32)m_ZDepthOfs;}
# 1210 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetZDepthOfsHW(int32 val) {m_ZDepthOfs = (int16)val;}
# 1219 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline int32 GetZDepthOfsHW() const {return (int32)m_ZDepthOfs;}
# 1228 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetFogged(bool fogged)
    {
        if (fogged)
            m_Flags &= ~NO_FOG_F;
        else
            m_Flags |= NO_FOG_F;
    }
# 1243 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline bool GetFogged() const
    {
        return (m_Flags & NO_FOG_F) != 0;
    }
# 1258 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
     inline void SetMergeGeom(bool set)
     {
         if (set == true)
             m_Flags |= MERGE_GEOM_F;
         else
             m_Flags &= ~MERGE_GEOM_F;
     }







     inline bool GetMergeGeom() const {return (m_Flags & MERGE_GEOM_F) != 0;}
# 1281 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline bool HasIdentityEmissive() const {return ((*(uint32*)&m_ColEmissive.r) & 0xffffff) == 0x0;}
# 1290 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline bool HasIdentityAmbient() const {return ((*(uint32*)&m_ColAmbient.r) & 0xffffff) == 0x808080;}
# 1299 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline bool HasIdentityDiffuse() const {return ((*(uint32*)&m_ColDiffuse.r) & 0xffffff) == 0x808080;}
# 1308 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline bool HasIdentityCols() const
    {
        return HasIdentityEmissive() && HasIdentityAmbient() && HasIdentityDiffuse();
    }
# 1325 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline void SetUVOfs(const CIwFVec2* pOfs, uint32 stream = 0)
    {
        ((void)0);
        m_UVOfs[stream] = *pOfs;
    }
# 1340 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    inline const CIwFVec2& GetUVOfs(uint32 stream = 0) const
    {
        ((void)0);
        return m_UVOfs[stream];
    }
# 1354 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    void CreateAnim();







    inline bool IsAnim() {return m_Anim != 0;}







    void SetAnimCelID(uint8 celID);
# 1379 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    void SetAnimCelNum(uint8 n)
    {
        ((void)0);
        m_Anim->SetCelNum(n);
        if (!m_Anim->GetCelNumU())
            m_Anim->SetCelNumU(n);
    }
# 1394 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    void SetAnimCelNumU(uint8 n)
    {
        ((void)0);
        m_Anim->SetCelNumU(n);
        if (!m_Anim->GetCelNum())
            m_Anim->SetCelNum(n);
    }
# 1409 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    void SetAnimCelW(uint8 n)
    {
        ((void)0);
        m_Anim->SetCelW(n);
        if (GetTexture())
            SetAnimCelNumU((uint8) (GetTexture()->GetWidth() / n));
    }







    void SetAnimOfsU(uint8 n) { SetAnimCelW(n); }
# 1432 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    void SetAnimCelH(uint8 n)
    {
        ((void)0);
        m_Anim->SetCelH(n);
        if (GetTexture())
            SetAnimCelNum((uint8) ((GetAnimCelNumU() * GetTexture()->GetHeight()) / n));
    }







    void SetAnimOfsV(uint8 n) { SetAnimCelH(n); }
# 1455 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    void SetAnimCelPeriod(uint8 n) { ((void)0); m_Anim->SetCelPeriod(n); }







    void PauseAnim() { ((void)0); m_Anim->Pause(); }







    void RestartAnim() { ((void)0); m_Anim->Restart(); }
# 1480 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    bool IsAnimPaused() const { ((void)0); return m_Anim->IsPaused(); }
# 1489 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    uint8 GetAnimCelNum() const { ((void)0); return m_Anim->GetCelNum(); }
# 1498 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    uint8 GetAnimCelNumU() const { ((void)0); return m_Anim->GetCelNumU(); }
# 1507 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    uint8 GetAnimCelID() const { ((void)0); return m_Anim->GetCelID(); }
# 1516 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    uint8 GetAnimCelW() const { ((void)0); return m_Anim->GetCelW(); }







    uint8 GetAnimOfsU() const { return GetAnimCelW(); }
# 1533 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    uint8 GetAnimCelH() const { ((void)0); return m_Anim->GetCelH(); }







    uint8 GetAnimOfsV() const { return GetAnimCelH(); }
# 1550 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    uint8 GetAnimCelPeriod() const { ((void)0); return m_Anim->GetCelPeriod(); }
# 1559 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    void SetClamping(bool b);
# 1568 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    bool GetClamping();




    inline void _SetFlags(uint32 flags) {m_Flags |= flags;}
    inline void _ClearFlags(uint32 flags) {m_Flags &= ~flags;}
    inline uint32 _GetFlags() {return m_Flags;}
    inline void _SetUnused()
    {
        m_GeomInfoOpaqueNode = __null;
        m_GeomInfoAlphaNode = __null;
        m_GeomInfoScreenSpaceNode = __null;
        m_Flags &= ~IN_USE_F;
    }
    inline void SetRenderState() {((void)0); ((IWGXFNT_MaterialSetRenderState)g_IwGxFuncTable[IWGXFNE_MaterialSetRenderState])(this);}
    inline void RevertRenderState() {((void)0); ((IWGXFNT_MaterialClearRenderState)g_IwGxFuncTable[IWGXFNE_MaterialClearRenderState])(this);}

    inline uint32 _GetAlphaRenderMode()
    {
        CIwTexture* pTex = GetTexture();
        uint32 lAlphaType = GetAlphaMode();
        if (lAlphaType == CIwMaterial::ALPHA_DEFAULT)
        {
            lAlphaType = CIwMaterial::ALPHA_NONE;
            if (pTex)
                if ((pTex->GetFlags() & CIwTexture::NEEDS_SW_TRANSPARENCY_F))
                    lAlphaType = CIwMaterial::ALPHA_BLEND;
        }
        return lAlphaType;
    }

    inline bool _UseChromakey()
    {
        return (GetAlphaMode() == CIwMaterial::ALPHA_DEFAULT) &&
            (GetTexture()) &&
            (GetTexture()->GetFlags() & CIwTexture::USES_TRANSPARENCY_F);
    }
    inline bool _IsNormalMapped()
    {
        return GetEffectPreset() == EFFECT_NORMAL_MAPPING
            || GetEffectPreset() == EFFECT_NORMAL_MAPPING_SPECULAR;
    }

    virtual void _Replace(CIwManaged* pRHS);




    inline void Init() const {};
    inline void SetFlags(uint16 flags) {m_Flags |= flags;}
    inline void SetAlphaMode(uint8 m) {SetAlphaMode((AlphaMode)m);}
    enum
    {
        NONE,
        HALF,
        ADD,
        SUB,
        BLEND = ADD,
    };

private:
    void AssertAnim();


private:
    uint32 m_Flags;
    uint16 m_UserFlags;


    uint8 m_NumVertexShaderConstants;

    uint8 m_AlphaTestRefVal;


    int16 m_ZDepthOfs;

    CIwColour m_ColEmissive;
    CIwColour m_ColAmbient;
    CIwColour m_ColDiffuse;
    CIwColour m_ColSpecular;

    CIwTexture* m_Textures[4];


    CIwListNode* m_GeomInfoOpaqueNode;
    CIwListNode* m_GeomInfoAlphaNode;
    CIwListNode* m_GeomInfoScreenSpaceNode;


    CIwMatAnim* m_Anim;
    CIwFVec2 m_UVOfs[2];

    CIwGxShaderTechnique* m_ShaderTechnique;


public:
    typedef bool UserParseAttributeFn(CIwMaterial*, CIwTextParserITX* pParser, const char* pAttrName);

    static const char* g_FlagNames[];
    static const char* g_AlphaModeNames[];
    static const char** g_UserFlagNames;
    static UserParseAttributeFn* g_UserCallback;
# 1681 "c:/marmalade/6.2/modules/iwgx/h/IwMaterial.h"
    static void SetUserFlagNames(const char** userFlagNames) { g_UserFlagNames = userFlagNames; }
    static void SetUserParseCallback(UserParseAttributeFn* fn) { g_UserCallback = fn; }

    friend class CIwMatGeomInfo;

    friend void IwGxDrawPrims(IwGxPrimType, uint16*, uint32);
    friend void IwGxFlush();
    friend CIwMaterial* IW_GX_ALLOC_MATERIAL();
    friend void IwGxSetRasterisationHW();
    friend void _IwGxUpdateMaterialAnims();
    friend void _IwGxDebugDumpGeomInfoNow();
    friend bool _isBatchableWith(CIwMaterial* mat1, CIwMaterial* mat2);
    friend bool _isBatchEquivalent(CIwMaterial* mat1, CIwMaterial* mat2);
    friend class CIwModelBuilder;
    friend class CIwTexture;
};







inline CIwMaterial* IW_GX_ALLOC_MATERIAL()
{



    CIwMaterial *pMaterial = (1 > 1 ? new (IwGxDataAlloc(4 + sizeof(CIwMaterial) * (1))) CIwMaterial[1] : new (IwGxDataAlloc(sizeof(CIwMaterial))) CIwMaterial);
    return pMaterial;
}
# 2351 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h" 2
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwGxTransformSW.h" 1
       
# 37 "c:/marmalade/6.2/modules/iwgx/h/IwGxTransformSW.h"
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwClip.h" 1
       
# 51 "c:/marmalade/6.2/modules/iwgx/h/IwClip.h"
typedef enum IwGxClipPlane
{
    IW_GX_CLIP_PLANE_NEAR,
    IW_GX_CLIP_PLANE_FAR,
    IW_GX_CLIP_PLANE_XPOS,
    IW_GX_CLIP_PLANE_XNEG,
    IW_GX_CLIP_PLANE_YPOS,
    IW_GX_CLIP_PLANE_YNEG,
} IwGxClipPlane;







typedef enum IwGxClipFlag
{
    IW_GX_CLIP_XPOS_F = (1 << IW_GX_CLIP_PLANE_XPOS),
    IW_GX_CLIP_XNEG_F = (1 << IW_GX_CLIP_PLANE_XNEG),
    IW_GX_CLIP_NEAR_F = (1 << IW_GX_CLIP_PLANE_NEAR),
    IW_GX_CLIP_FAR_F = (1 << IW_GX_CLIP_PLANE_FAR),
    IW_GX_CLIP_YPOS_F = (1 << IW_GX_CLIP_PLANE_YPOS),
    IW_GX_CLIP_YNEG_F = (1 << IW_GX_CLIP_PLANE_YNEG),

    IW_GX_CLIP_NOT_OK_F = (1 << 6),
    IW_GX_CLIP_NOT_DONE_SXY_F = (1 << 7),
    IW_GX_CLIP_EXTRA_F = (1 << 8),
    IW_GX_CLIP_2D_F = (1 << 9),
    IW_GX_CLIP_ORTHO_F = (1 << 10),


    IW_GX_CLIP_ALL = (1 << 6) - 1,
    IW_GX_CLIP_X = (IW_GX_CLIP_XNEG_F | IW_GX_CLIP_XPOS_F),
    IW_GX_CLIP_Y = (IW_GX_CLIP_YNEG_F | IW_GX_CLIP_YPOS_F),
    IW_GX_CLIP_Z = (IW_GX_CLIP_NEAR_F | IW_GX_CLIP_FAR_F),

    IW_GX_CLIP_XY = (IW_GX_CLIP_X | IW_GX_CLIP_Y),

    IW_GX_CLIP_XF = IW_GX_CLIP_X | IW_GX_CLIP_FAR_F,
    IW_GX_CLIP_YF = IW_GX_CLIP_Y | IW_GX_CLIP_FAR_F,
    IW_GX_CLIP_XYF = IW_GX_CLIP_XY | IW_GX_CLIP_FAR_F,
    IW_GX_CLIP_XN = IW_GX_CLIP_X | IW_GX_CLIP_NEAR_F,
    IW_GX_CLIP_YN = IW_GX_CLIP_Y | IW_GX_CLIP_NEAR_F,
    IW_GX_CLIP_XYN = IW_GX_CLIP_XY | IW_GX_CLIP_NEAR_F,

    IW_GX_CLIP_USER_F = (1 << 16),
} IwGxClipFlag;
# 38 "c:/marmalade/6.2/modules/iwgx/h/IwGxTransformSW.h" 2







static inline CIwFVec3 IwGxWorldToClip(const CIwFVec3& worldPos)
{
    return IwGetGxState()->m_MatClipViewWorld.TransformVec(worldPos);
}

static inline CIwFVec3 IwGxWorldToView(const CIwFVec3& worldPos)
{
    return IwGetGxState()->m_MatViewWorld.TransformVec(worldPos);
}

static inline CIwFVec3 IwGxModelToView(const CIwFVec3& modelPos)
{
    return IwGetGxState()->m_MatViewModel.TransformVec(modelPos);
}

static inline void IwGxViewToClip(const CIwFVec3& viewPos, CIwFVec3& clipPos)
{
    CIwGxState* pState = IwGetGxState();
    if (IwGxIsOrthoProjection())
    {
        CIwRect32& orr = pState->m_OrthoRect;
        int32 ofsX = (orr.w/2 + orr.x) * (2*(1 << 12)) / orr.w;
        int32 ofsY = (orr.h/2 + orr.y) * (2*(1 << 12)) / orr.h;

        clipPos.x = viewPos.x * 2*(1 << 12) / orr.w - ofsX;
        clipPos.y = viewPos.y * 2*(1 << 12) / orr.h - ofsY;
        clipPos.z = viewPos.z * pState->m_ZFactor;
    }
    else
    {
        clipPos.x = viewPos.x * pState->m_XFactor / (1 << (12 - 6));
        clipPos.y = viewPos.y * pState->m_YFactor / (1 << (12 - 6));
        clipPos.z = viewPos.z * pState->m_ZFactor / (1 << (12 - 6));
    }
}

# 1 "c:/marmalade/6.2/modules/iwgx/h/IwClip.inl" 1
# 39 "c:/marmalade/6.2/modules/iwgx/h/IwClip.inl"
static inline uint16 IwGxClipVec(const CIwFVec3& vt)
{
 uint16 outFlags = 0;
 float i, j;




 i = vt.x;
 j = vt.z;
 if (i > j)
  outFlags |= IW_GX_CLIP_XPOS_F;
 if (-i > j)
  outFlags |= IW_GX_CLIP_XNEG_F;
 i = vt.y;
 if (i > j)
  outFlags |= IW_GX_CLIP_YPOS_F;
 if (-i > j)
  outFlags |= IW_GX_CLIP_YNEG_F;


 if (vt.z < IwGetGxState()->m_NearClip * (float)(1 << 6))
  outFlags |= IW_GX_CLIP_NEAR_F;
 else
 if (vt.z > IwGetGxState()->m_FarClip * (float)(1 << 6))
  outFlags |= IW_GX_CLIP_FAR_F;

 return outFlags;
}

static inline uint16 IwGxClipVecOrtho(const CIwFVec3& vt)
{
 uint16 outFlags = 0;
 float i;

 i = vt.x;
 if (i > (1 << 12))
  outFlags |= IW_GX_CLIP_XPOS_F;
 else if (-i > (1 << 12))
  outFlags |= IW_GX_CLIP_XNEG_F;
 i = vt.y;
 if (i > (1 << 12))
  outFlags |= IW_GX_CLIP_YPOS_F;
 else if (-i > (1 << 12))
  outFlags |= IW_GX_CLIP_YNEG_F;


 if (vt.z < IwGetGxState()->m_NearClip * (float)(1 << 6))
  outFlags |= IW_GX_CLIP_NEAR_F;
 else
 if (vt.z > IwGetGxState()->m_FarClip * (float)(1 << 6))
  outFlags |= IW_GX_CLIP_FAR_F;

    outFlags |= IW_GX_CLIP_ORTHO_F;

 return outFlags;
}







static inline uint16 IwGxClipVecXY(const CIwFVec3& vt)
{
 uint16 outFlags = 0;
 float i, j;

 i = vt.x;
 j = vt.z;
 if (i > j)
  outFlags |= IW_GX_CLIP_XPOS_F;
 else
  if (-i > j)
   outFlags |= IW_GX_CLIP_XNEG_F;

 i = vt.y;
 j = vt.z;
 if (i > j)
  outFlags |= IW_GX_CLIP_YPOS_F;
 else
  if (-i > j)
   outFlags |= IW_GX_CLIP_YNEG_F;

 return outFlags;
}

static inline uint16 IwGxClipVecOrthoXY(const CIwFVec3& vt)
{
 uint16 outFlags = 0;
 float i;

 i = vt.x;
 if (i > (1 << 12))
  outFlags |= IW_GX_CLIP_XPOS_F;
 else
  if (-i > (1 << 12))
   outFlags |= IW_GX_CLIP_XNEG_F;

 i = vt.y;
 if (i > (1 << 12))
  outFlags |= IW_GX_CLIP_YPOS_F;
 else
  if (-i > (1 << 12))
   outFlags |= IW_GX_CLIP_YNEG_F;

 return outFlags;
}







static inline uint16 IwGxClipVecX(const CIwFVec3& vt)
{
 uint16 outFlags = 0;
 float i, j;

 i = vt.x;
 j = vt.z;
 if (i > j)
  outFlags |= IW_GX_CLIP_XPOS_F;
 else
 if (-i > j)
  outFlags |= IW_GX_CLIP_XNEG_F;

 return outFlags;
}







static inline uint16 IwGxClip2dVecX(int32 x)
{
 uint16 outFlags = 0;

 if (x > IwGetGxState()->m_Clip2DRight)
  outFlags |= IW_GX_CLIP_XPOS_F;
 else
 if (x < IwGetGxState()->m_Clip2DLeft)
  outFlags |= IW_GX_CLIP_XNEG_F;

 return outFlags;
}







static inline uint16 IwGxClipVecY(const CIwFVec3& vt)
{
 uint16 outFlags = 0;
 float i, j;

 i = vt.y;
 j = vt.z;
 if (i > j)
  outFlags |= IW_GX_CLIP_YPOS_F;
 else
 if (-i > j)
  outFlags |= IW_GX_CLIP_YNEG_F;

 return outFlags;
}







static inline uint16 IwGxClipVecOrthoY(const CIwFVec3& vt)
{
 uint16 outFlags = 0;
 float i;

 i = vt.y;
 if (i > (1 << 12))
  outFlags |= IW_GX_CLIP_YPOS_F;
 else
 if (-i > (1 << 12))
  outFlags |= IW_GX_CLIP_YNEG_F;

 return outFlags;
}







static inline uint16 IwGxClip2dVecY(int32 y)
{
 uint16 outFlags = 0;

 if (y > IwGetGxState()->m_Clip2DBottom)
  outFlags |= IW_GX_CLIP_YPOS_F;
 else
 if (y < IwGetGxState()->m_Clip2DTop)
  outFlags |= IW_GX_CLIP_YNEG_F;

 return outFlags;
}
# 259 "c:/marmalade/6.2/modules/iwgx/h/IwClip.inl"
static inline uint16 IwGxClipSphereViewSpace(const CIwFSphere& sphere, uint32 clipFlags = IW_GX_CLIP_ALL);







static inline uint16 IwGxClipSphereWorldSpace(const CIwFSphere& sphere, uint32 clipFlags = IW_GX_CLIP_ALL);





static inline uint16 IwGxClipSphere(const CIwFSphere& sphere, uint32 clipFlags = IW_GX_CLIP_ALL);







static inline uint16 IwGxClipSphereModelSpace(const CIwFSphere& sphere, uint32 clipFlags = IW_GX_CLIP_ALL);

static inline uint16 IwGxClipSphereClipSpace(const CIwFVec3& viewPos, float r, uint32 clipFlags = IW_GX_CLIP_ALL)
{


    if( IwGxIsOrthoProjection() )
    {
     if (clipFlags & IW_GX_CLIP_Z)
     {
      float nearClip = IwGetGxState()->m_NearClip * (1 << 6);
         float farClip = IwGetGxState()->m_FarClip * (1 << 6);

            float newr = r * (1 << 6);
         newr = newr * IwGetGxState()->m_ZFactor;

            if (viewPos.z-newr < nearClip)
      {
       if (viewPos.z+newr <= nearClip)
        return IW_GX_CLIP_NOT_OK_F;
      }

       clipFlags &= ~IW_GX_CLIP_NEAR_F;

      if (viewPos.z+newr > farClip)
      {
       if (viewPos.z-newr >= farClip)
        return IW_GX_CLIP_NOT_OK_F;
      }

       clipFlags &= ~IW_GX_CLIP_FAR_F;
     }

        CIwRect32& orr = IwGetGxState()->m_OrthoRect;
     if (clipFlags & IW_GX_CLIP_X)
     {
      float i = viewPos.x / 4096.0f;
      const float j = 1;


      float d = r*2.0f/orr.w;

      if (d > j-i)
      {
       if ((i-j) > d)
        return IW_GX_CLIP_NOT_OK_F;
      }

       clipFlags &= ~IW_GX_CLIP_XPOS_F;

      if (d > i+j)
      {
       if (-(i+j) > d)
        return IW_GX_CLIP_NOT_OK_F;
      }

       clipFlags &= ~IW_GX_CLIP_XNEG_F;
     }

     if (clipFlags & IW_GX_CLIP_Y)
     {
      float i = viewPos.y / 4096.0f;
      const float j = 1;

      float d = r*2.0f/orr.h;
            if (d > j-i)
      {
       if ((i-j) > d)
        return IW_GX_CLIP_NOT_OK_F;
      }

       clipFlags &= ~IW_GX_CLIP_YPOS_F;

      if (d > i+j)
      {
       if (-(i+j) > d)
        return IW_GX_CLIP_NOT_OK_F;
      }

       clipFlags &= ~IW_GX_CLIP_YNEG_F;
     }

     return (uint16)clipFlags;
    }
    else
    {
     r *= 1 << 6;
     float nearClip = IwGetGxState()->m_NearClip * (1 << 6);
     float farClip = IwGetGxState()->m_FarClip * (1 << 6);
     float normX = IwGetGxState()->m_XClipPlaneLen;
     float normY = IwGetGxState()->m_YClipPlaneLen;
     float newr = r * IwGetGxState()->m_ZFactor / 4096.0f;

     if (clipFlags & IW_GX_CLIP_Z)
     {
      if (viewPos.z-newr < nearClip)
      {
       if (viewPos.z+newr <= nearClip)
        return IW_GX_CLIP_NOT_OK_F;
      }

       clipFlags &= ~IW_GX_CLIP_NEAR_F;

      if (viewPos.z+newr > farClip)
      {
       if (viewPos.z-newr >= farClip)
        return IW_GX_CLIP_NOT_OK_F;
      }

       clipFlags &= ~IW_GX_CLIP_FAR_F;
     }

     if (clipFlags & IW_GX_CLIP_X)
     {
      float i = viewPos.x;
      float j = viewPos.z;


      float d = r * normX / 4096.0f;

      if (d > j-i)
      {
       if ((i-j) > d)
        return IW_GX_CLIP_NOT_OK_F;
      }

       clipFlags &= ~IW_GX_CLIP_XPOS_F;

      if (d > i+j)
      {
       if (-(i+j) > d)
        return IW_GX_CLIP_NOT_OK_F;
      }

       clipFlags &= ~IW_GX_CLIP_XNEG_F;
     }

     if (clipFlags & IW_GX_CLIP_Y)
     {
      float i = viewPos.y;
      float j = viewPos.z;

      float d = r * normY / 4096.0f;
      if (d > j-i)
      {
       if ((i-j) > d)
        return IW_GX_CLIP_NOT_OK_F;
      }

       clipFlags &= ~IW_GX_CLIP_YPOS_F;

      if (d > i+j)
      {
       if (-(i+j) > d)
        return IW_GX_CLIP_NOT_OK_F;
      }

       clipFlags &= ~IW_GX_CLIP_YNEG_F;
     }

     return (uint16)clipFlags;
    }
}

static inline uint16 IwGxClipSphereViewSpace(const CIwFVec3& viewPos, float r, uint32 clipFlags = IW_GX_CLIP_ALL)
{


    CIwFVec3 clipPos;
    IwGxViewToClip(viewPos, clipPos);
    return IwGxClipSphereClipSpace(clipPos, r, clipFlags);
}

static inline uint16 IwGxClipSphereViewSpace(const CIwFSphere& sphere, uint32 clipFlags)
{
 return IwGxClipSphereViewSpace(sphere.t, sphere.r, clipFlags);
}

static inline uint16 IwGxClipSphereWorldSpace(const CIwFSphere& sphere, uint32 clipFlags)
{
 CIwFVec3 clipPos = IwGetGxState()->m_MatClipViewWorld.TransformVec(sphere.t);
 return IwGxClipSphereClipSpace(clipPos, sphere.r, clipFlags);
}

static inline uint16 IwGxClipSphere(const CIwFSphere& sphere, uint32 clipFlags)
{
 return IwGxClipSphereWorldSpace(sphere, clipFlags);
}

static inline uint16 IwGxClipSphereModelSpace(const CIwFSphere& sphere, uint32 clipFlags)
{
 CIwFVec3 clipPos = IwGetGxState()->m_MatClipViewModel.TransformVec(sphere.t);
 return IwGxClipSphereClipSpace(clipPos, sphere.r, clipFlags);
}
# 82 "c:/marmalade/6.2/modules/iwgx/h/IwGxTransformSW.h" 2
# 93 "c:/marmalade/6.2/modules/iwgx/h/IwGxTransformSW.h"
static inline void IwGxViewToScreenXYSubPixel(int32& sx, int32& sy, const CIwFVec3& viewPos)
{
    if (!viewPos.z)
    {
        sx = 0;
        sy = 0;
        return;
    }

    if (IwGxIsOrthoProjection())
    {
        CIwRect32& orr = IwGetGxState()->m_OrthoRect;
        int32 ofsX = (orr.w/2 + orr.x) * (2*(1 << 12)) / orr.w;
        int32 ofsY = (orr.h/2 + orr.y) * (2*(1 << 12)) / orr.h;

        sx = ((int)viewPos.x * ((IwGxGetDisplayWidth() << 3)-1) / orr.w - ofsX)+IwGetGxState()->m_DisplayXCentre;
        sy = ((int)viewPos.y * ((IwGxGetDisplayHeight() << 3)-1) / orr.h - ofsY)+IwGetGxState()->m_DisplayYCentre;
    }
    else
    {
        sx = (int32)((viewPos.x / (2.0f * viewPos.z)) * IwGetGxState()->m_XPostScale + IwGetGxState()->m_DisplayXCentre);
        sy = (int32)((viewPos.y / (2.0f * viewPos.z)) * IwGetGxState()->m_YPostScale + IwGetGxState()->m_DisplayYCentre);
    }
}
# 131 "c:/marmalade/6.2/modules/iwgx/h/IwGxTransformSW.h"
static inline void IwGxViewToScreenXYSubPixel(int16& sx, int16& sy, const CIwFVec3& viewPos)
{
    int32 lsx = sx;
    int32 lsy = sy;

    IwGxViewToScreenXYSubPixel(lsx, lsy, viewPos);

    sx = (int16)lsx;
    sy = (int16)lsy;
}
# 153 "c:/marmalade/6.2/modules/iwgx/h/IwGxTransformSW.h"
static inline void IwGxViewToScreenXY(int32& sx, int32& sy, const CIwFVec3& viewPos)
{
    IwGxViewToScreenXYSubPixel(sx, sy, viewPos);

    sx >>= 3;
    sy >>= 3;
}
# 172 "c:/marmalade/6.2/modules/iwgx/h/IwGxTransformSW.h"
static inline void IwGxViewToScreenXY(int16& sx, int16& sy, const CIwFVec3& viewPos)
{
    int32 lsx = sx;
    int32 lsy = sy;

    IwGxViewToScreenXY(lsx, lsy, viewPos);

    sx = (int16)lsx;
    sy = (int16)lsy;
}
# 194 "c:/marmalade/6.2/modules/iwgx/h/IwGxTransformSW.h"
static inline void IwGxWorldToScreenXY(int16& sx, int16& sy, const CIwFVec3& worldPos)
{
    CIwFVec3 viewClipPos = IwGxWorldToClip(worldPos);
    viewClipPos.z = (((viewClipPos.z) > (1)) ? (viewClipPos.z) : (1));

    IwGxViewToScreenXY(sx, sy, viewClipPos);
}
# 212 "c:/marmalade/6.2/modules/iwgx/h/IwGxTransformSW.h"
static inline void IwGxWorldToScreenXY(int32& sx, int32& sy, const CIwFVec3& worldPos)
{
    CIwFVec3 viewClipPos = IwGxWorldToClip(worldPos);
    viewClipPos.z = (((viewClipPos.z) > (1)) ? (viewClipPos.z) : (1));

    IwGxViewToScreenXY(sx, sy, viewClipPos);
}
# 258 "c:/marmalade/6.2/modules/iwgx/h/IwGxTransformSW.h"
static inline void IwGxViewToScreenDist(int16& d, int32 viewD, int32 viewZ, int32 perspMul)
{
    d = (int16)(((int32)((viewD ) * perspMul))/((int32)(viewZ)));
}
# 274 "c:/marmalade/6.2/modules/iwgx/h/IwGxTransformSW.h"
static inline void IwGxViewToScreenDist(int32& d, int32 viewD, int32 viewZ, int32 perspMul)
{
    d = (((int32)((viewD ) * perspMul))/((int32)(viewZ)));
}
# 304 "c:/marmalade/6.2/modules/iwgx/h/IwGxTransformSW.h"
static inline void _IwGxViewToScreenXY(int16& sx, int16& sy, const CIwFVec3& viewPos)
{
    sx = (int16)((((viewPos.x * (1 << (12 - 1)) / viewPos.z) * IwGetGxState()->m_XPostScale) ) * (1 >> 3));
    sy = (int16)((((viewPos.y * (1 << (12 - 1)) / viewPos.z) * IwGetGxState()->m_YPostScale) ) * (1 >> 3));



    int16 tmp;
    switch (IwGxGetScreenOrient())
    {
    case IW_GX_ORIENT_NONE:
        break;
    case IW_GX_ORIENT_90:
        tmp = sx;
        sx = ~sy;
        sy = tmp;
        break;
    case IW_GX_ORIENT_180:
        sx = ~sx;
        sy = ~sy;
        break;
    case IW_GX_ORIENT_270:
        tmp = sx;
        sx = sy;
        sy = ~tmp;
        break;
    }
    sx += (int16)(IwGetGxState()->m_DeviceXCentre >> 3);
    sy += (int16)(IwGetGxState()->m_DeviceYCentre >> 3);
}

static inline CIwFVec3 IwGxClipTransformVec(CIwFMat const& mat, CIwFVec3 const &V)
{
    return CIwFVec3(
        ((mat.m[0][0] * V.x) + (mat.m[1][0] * V.y) + (mat.m[2][0] * V.z)) + mat.t.x,
        ((mat.m[0][1] * V.x) + (mat.m[1][1] * V.y) + (mat.m[2][1] * V.z)) + mat.t.y,
        ((mat.m[0][2] * V.x) + (mat.m[1][2] * V.y) + (mat.m[2][2] * V.z)) + mat.t.z
    );
}

static inline CIwFMat IwGxMatToFMat(CIwMat const& mat)
{
    CIwFMat m;
    for (uint32 x = 0; x < 3; x++)
        for (uint32 y = 0; y < 3; y++)
            m.m[x][y] = (float)mat.m[x][y] / (1 << 12);
    m.t.x = (float)mat.t.x;
    m.t.y = (float)mat.t.y;
    m.t.z = (float)mat.t.z;
    return m;
}
# 2352 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h" 2
# 1 "c:/marmalade/6.2/modules/iwgx/h/IwResHandlerMTL.h" 1
       
# 18 "c:/marmalade/6.2/modules/iwgx/h/IwResHandlerMTL.h"
# 1 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManager.h" 1
       
# 16 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManager.h"
# 1 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h" 1
       
# 21 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
class CIwResGroupHST;
class CIwAtlasInfo;
class CIwResGroup;
# 44 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
class CIwResGroupBuildData : public CIwResource
{
public:
    ~CIwResGroupBuildData()
    {
        m_ScaledModels.Delete();
        m_ScaledAnims.Delete();
        m_ScaledSkels.Delete();
        m_ScaledSkins.Delete();
    }

    class ResScale : public CIwManaged
    {
    public:
        typedef CIwArray<ResScale*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
        ResScale() {};
        ResScale(uint32 hash, int32 scale)
        {
            m_Hash = hash;
            m_Scale = scale;
        }
        void Serialise()
        {
            IwSerialiseUInt32(m_Hash);
            IwSerialiseInt32(m_Scale);
        }
        int32 m_Scale;
    };
    typedef CIwArray<CIwResGroupBuildData*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;


    CIwManagedList m_ScaledModels;
    CIwManagedList m_ScaledAnims;
    CIwManagedList m_ScaledSkels;
    CIwManagedList m_ScaledSkins;

    enum
    {
        MOUNT_F = (1 << 0),
        OPTIMISE_F = (1 << 1),
    };

    CIwArray<CIwStringL> m_ChildPaths;
    CIwArray<int32> m_ChildScales;
    CIwArray<uint32> m_ChildFlags;

    CIwArray<CIwStringL> m_LuaPaths;
};
# 103 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
class CIwResList : public CIwManaged
{
public:
    typedef CIwArray<CIwResList*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;

    CIwResList();

    typedef CIwArray<CIwResList> IArray;
    typedef IArray::iterator IArrayIt;
    virtual void Serialise();

    CIwManaged* _LoadResource(uint32 hashCN, bool add);
    int32 _FindDirectoryEntry(uint32 hash);
    CIwManaged* _LoadDirectoryEntry(s3eFile* file, int32 i, CIwResGroup* group);

    struct CIwGroupDirectoryEntry
    {
        void Serialise()
        {
            IwSerialiseUInt32(m_Hash);
            IwSerialiseUInt32(m_Offset);
        }

        uint32 m_Hash;
        uint32 m_Offset;
    };

    CIwManagedList m_Resources;
    CIwArray<CIwGroupDirectoryEntry> m_Directory;
    uint32* m_pBlockSizes;
};
# 180 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
class CIwResGroup : public CIwManaged
{
public:
    typedef CIwArray<CIwResGroup*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
# 192 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
    CIwResGroup(const char* name = __null);
# 203 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
    CIwResList* GetListNamed(const char* resType, uint32 flags = 0) const;
# 214 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
    CIwResList* GetListHashed(uint32 resTypeHash, uint32 flags = 0) const;
# 227 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
    CIwResource* GetResNamed(const char* name, const char* resType, uint32 flags = 0) const;
# 240 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
    CIwResource* GetResHashed(uint32 hash, const char* resType, uint32 flags = 0, bool topLevel = true) const;
# 253 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
    CIwResource* GetResHashed(uint32 hash, uint32 resTypeHash, uint32 flags = 0, bool topLevel = true) const;
# 265 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
    void AddRes(const char* resType, CIwResource* pData);
# 277 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
    void AddRes(uint32 resTypeHash, CIwResource* pData);
# 289 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
    void SetShared(bool shared);
# 298 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
    inline bool IsShared() const {return (m_Flags & SHARED_F) != 0;}
# 308 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
    void AddChild(CIwResGroup* pGroup, bool toOwn = true);




    void ReserveExtraChildren(int extra) { m_Children.Reserve(m_Children.GetSize()+extra); }







    inline CIwResGroup* GetOwner() const {return m_Owner;}







    inline const CIwManagedList& GetChildren() const {return m_Children;}






    void Write();





    virtual void Resolve();




    void Finalise();
# 365 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
    inline bool HasAtlas() const { return (ATLAS_F & m_Flags) != 0;}


    inline bool IsAtlasReady() const { return (ATLAS_READY_F & m_Flags) !=0;}


    inline void SetAtlasReady(bool state) { state?m_Flags |= ATLAS_READY_F:m_Flags &=~ATLAS_READY_F;}

    inline bool IsMountable() const { return (m_Flags & MOUNTABLE_F) != 0; }

    inline bool IsOptimised() const { return (m_Flags & OPTIMISED_F) != 0; }

    inline bool IsResolved() const { return (m_Flags & RESOLVED_F) != 0; }


    CIwAtlasInfo* GetAtlasInfo() const {return m_AtlasInfo;}
# 389 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
private:
    void ParseClose(CIwTextParserITX* pParser);
    void _Write();

    void _CreateDirectory();
    void _SerialiseResourceRequests(bool);


    void _Init(bool fromBin);


    void _WriteHST(const char* pathname);
    void _SerialiseAssets(const char* pathname);


    virtual void _Replace(CIwManaged* pNewGroup);

    virtual void DebugAddMenuItems(CIwMenu* pMenu);


    enum
    {
        SHARED_F = (1 << 0),
        LOADED_F = (1 << 1),
        ATLAS_F = (1 << 2),
        ATLAS_READY_F = (1 << 3),
        MOUNTABLE_F = (1 << 4),
        OPTIMISED_F = (1 << 5),
        RESOLVED_F = (1 << 6),
    };


    ~CIwResGroup();

    virtual void ParseOpen(CIwTextParserITX* pParser);
    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);


private:
    uint32 m_Flags;
    CIwResList::IArray m_ResLists;
    CIwManagedList m_Children;
    CIwResGroup* m_Owner;
    CIwResGroupHST* m_HST;
    CIwStringL m_GroupPathName;
    CIwAtlasInfo* m_AtlasInfo;
    CIwResGroup* m_DebugAssets;


    s3eFile* m_MountedFile;


    int m_DirectoryLocation;
    int m_ResourceLocation;


    struct CIwResRequest
    {
        CIwResList* m_pList;
        uint32 m_Hash;
    };
    mutable CIwArray<CIwResRequest> m_Requests;


    friend class CIwModelBuilder;
    friend class CIwResHandlerGROUP;
    friend class CIwResManager;
    friend void _ResGroupManagedConstructorCallback(CIwManaged*);
    friend void _ResGroupManagedDestructorCallback(CIwManaged*);
    friend void _ResGroupManagedSerialiseCallback(CIwManaged*);
    friend void _SerialiseDirectory(CIwResGroup*);
    friend void _Serialise_ResGroupHST();
    friend void _Serialise_ResGroupMembers();
    friend void _Serialise_ResGroupResources();
    friend void _Serialise_ResGroupChildPaths();
    friend void _Serialise_ResGroupDirectory();
    friend void _Serialise_BlockSizes(CIwResGroup*);
    friend void _PostResourceLoad();
    friend void IwResBinaryMount(const char*, bool);
    friend void _Serialise_ResGroupResourcesOptimised();
# 477 "c:/marmalade/6.2/modules/iwresmanager/h/IwResGroup.h"
};
# 17 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManager.h" 2
# 1 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h" 1
       
# 16 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
class CIwResource;
# 99 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
class CIwResTemplate : public CIwManaged
{
public:
    typedef CIwArray<CIwResTemplate*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
# 111 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
    virtual void Reset();
# 120 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
    virtual void Copy(CIwResTemplate* pSource) = 0;







    virtual void Apply() {};
# 138 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
# 149 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
    virtual void ParseClose(CIwTextParserITX* pParser);







    inline const char* GetResName() const {return m_ResName.c_str();}

    virtual const char* GetResExt() const = 0;

    CIwStringS m_ResName;
};
# 175 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
class CIwResHandler : public CIwManaged
{
public:
    typedef CIwArray<CIwResHandler*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const; private: CIwResHandler(const CIwResHandler &copy) { ((void)0); } const CIwResHandler& operator= (const CIwResHandler &rhs) { ((void)0); return *this; } public:;
# 190 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
    CIwResHandler(const char* ext, const char* resType);
    virtual ~CIwResHandler();







    void Reset();
# 212 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
    virtual CIwResource* Build(const CIwStringL& pathname) = 0;
# 222 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
    inline const char* GetExt() const {return m_Ext;}







    inline const char* GetResType() const {return m_ResType;}
# 240 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
    void AddTemplate(CIwResTemplate* pTemplate);







    inline void SetTemplate(CIwResTemplate* pTemplate)
    {
        m_TemplateCurr = pTemplate;
        Reset();
    }







    inline void SetTemplate(const char* name)
    {
        ((void)0);
        CIwResTemplate* pTemplate = GetTemplateNamed(name);
        ((void)0);
        SetTemplate(pTemplate);
    };







    inline CIwResTemplate* GetTemplate() const {return m_TemplateCurr;}
# 283 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
    inline CIwResTemplate* GetTemplateNamed(const char* name) const
    {
        ((void)0);
        return (CIwResTemplate*)m_Templates.GetObjNamed(name);
    }







    inline void ApplySettings() {m_Settings->Apply();}







    inline CIwResTemplate* GetSettings() const {return m_Settings;}
# 315 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
    void ConstructFullPathname(CIwStringL& ret, const CIwStringL& pathonly, const CIwStringL& fileonly, const char* ext);
    void ConstructFullPathname(CIwStringL& ret, const CIwStringL& pathonly, const CIwStringS& fileonly, const char* ext);


    inline CIwResTemplate* GetTemplateInit() const {return m_TemplateInit;}


protected:
    const char* m_Ext;
    const char* m_ResType;
    const char* m_ExtBin;
    CIwResTemplate* m_TemplateCurr;
    CIwResTemplate* m_TemplateInit;
    CIwResTemplate* m_Settings;
    CIwManagedList m_Templates;



    friend class CIwResGroup;
    friend class CIwResManager;
    friend class CIwMaterial;
};
# 346 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandler.h"
CIwResTemplate* IwGetResTemplateCurrentSettings(const char* type);
# 18 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManager.h" 2
# 1 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandlerGROUP.h" 1
       
# 31 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandlerGROUP.h"
class CIwTileSpecs;
class CIwResource;
# 116 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandlerGROUP.h"
class CIwResTemplateGROUP : public CIwResTemplate
{
public:
    typedef CIwArray<CIwResTemplateGROUP*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;


    CIwResTemplateGROUP();
    ~CIwResTemplateGROUP();
    virtual void Reset();
    virtual void Copy(CIwResTemplate* pSource);
    virtual void Apply() {}
    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
    virtual const char* GetResExt() const { return "group"; }

    bool IsInline() const;



    uint32 m_MaxAtlasTargets;
    CIwSVec2 m_PageSize;
    CIwArray<CIwTileSpecs*> m_TileSpecs;
    CIwSVec2 m_MaxAreaPerTexture;
    bool m_BakeAtlasTextures;
    uint32 m_AtlasPadding;
    bool m_AtlasAllMaterials;
    bool m_Atlas16Bit;

    bool m_Mount;
    bool m_Optimise;

private:
    bool m_Inline;
};
# 162 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandlerGROUP.h"
class CIwResHandlerGROUP : public CIwResHandler
{
public:
    typedef CIwArray<CIwResHandlerGROUP*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;


    CIwResHandlerGROUP();
    virtual CIwResource* Build(const CIwStringL& pathname);
};
# 19 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManager.h" 2
# 1 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandlerImage.h" 1
       
# 25 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandlerImage.h"
class CIwResource;
# 113 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandlerImage.h"
class CIwResTemplateImage : public CIwResTemplate
{
public:
    typedef CIwArray<CIwResTemplateImage*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;

    CIwResTemplateImage();
    virtual void Reset();
    virtual void Copy(CIwResTemplate* pSource);
    virtual void Apply();
    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
    virtual const char* GetResExt() const { return "bmp"; }

    bool m_Native16bit;
    bool m_KeepAfterUpload;
    bool m_UploadOnLoad;
    bool m_MipMapping;
    bool m_Filtering;
    uint8 m_FormatSW;
    uint8 m_FormatHW;
    bool m_CreateFor3DAPI;
    bool m_CreateFor2DAPI;
    bool m_CompressForDiskSpace;
    bool m_AllowLowQualityCompression;
    bool m_IgnoreImages;
    bool m_IgnoreMipMapOffset;
};
# 151 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandlerImage.h"
class CIwResHandlerImage : public CIwResHandler
{
public:
    typedef CIwArray<CIwResHandlerImage*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;


    CIwResHandlerImage();
    virtual CIwResource* Build(const CIwStringL& pathname);


    static const char* g_FlagNames[];
};
# 20 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManager.h" 2
# 1 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandlerITX.h" 1
       
# 25 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandlerITX.h"
class CIwResource;
# 38 "c:/marmalade/6.2/modules/iwresmanager/h/IwResHandlerITX.h"
class CIwResHandlerITX : public CIwResHandler
{
public:
    typedef CIwArray<CIwResHandlerITX*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;


    CIwResHandlerITX(const char* extentions = "itx cubemap");
    virtual CIwResource* Build(const CIwStringL& pathname);
};
# 21 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManager.h" 2
# 1 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h" 1
       
# 25 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
class CIwMenu;
class CIwResource;
class CIwResBuildStyle;
class CIwResGroup;
class CIwResGroupHST;
class CIwResHandler;
class CIwResManager;
class CIwRect;
class CIwMaterial;
# 62 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
void IwResManagerInit();







void IwResManagerTerminate();
# 108 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
typedef enum IwGxResManagerFlags
{
    IW_RES_PERMIT_NULL_F = (1 << 0),
    IW_RES_SEARCH_ALL_F = (1 << 1),
    IW_RES_IGNORE_SHARED_F = (1 << 2),
    IW_RES_IGNORE_CHILDREN_F = (1 << 3),
    IW_RES_INCLUDE_DEBUG_GROUPS_F = (1 << 4),
    IW_RES_SKIP_CURRENT_GROUP_F = (1 << 5),
} IwGxResManagerFlags;
# 144 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
class CIwResManager
{
public:



    enum GlobalMode
    {
        MODE_BUILD,
        MODE_LOAD,
    };






    typedef void (*BuildGroupCallbackPre)(void);






    typedef void (*BuildGroupCallbackPost)(void);
# 181 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    inline void SetMode(GlobalMode mode)
    {
        if (mode == MODE_BUILD)
            m_Flags |= BUILDRES_F;
        else
            m_Flags &= ~BUILDRES_F;
    };
# 196 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    inline GlobalMode GetMode() const
    {
        return (m_Flags & BUILDRES_F) ? MODE_BUILD : MODE_LOAD;
    };
# 219 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    void AddHandler(CIwResHandler* pHandler);







    void RemoveHandler(const char* classname);
# 236 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    void AddGroup(CIwResGroup* pGroup);







    CIwResGroup::ArrayIt DestroyGroup(const char* groupname);







    CIwResGroup::ArrayIt DestroyGroup(CIwResGroup* pGroup);
# 263 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    void ReserveGroups(int numGroups);
# 274 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    void ReserveHandlers(int numHandlers);
# 285 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    CIwResGroup* GetGroupNamed(const char* groupname, uint32 flags = 0) const;
# 296 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    CIwResGroup* GetGroupHashed(uint32 hash, uint32 flags = 0) const;







    uint32 GetNumGroups() const;
# 315 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    CIwResGroup* GetGroup(uint32 index) const;
# 326 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    CIwResHandler* GetHandler(const char* ext, uint32 flags = 0) const;
# 337 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    const char* GetResType(const char* ext, uint32 flags = 0) const;
# 358 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    void SplitPathName(const char* pathname, CIwStringL& pathonly, CIwStringL& fileonly, CIwStringS& ext);
    void SplitPathName(const char* pathname, CIwStringL& pathonly, CIwStringS& fileonly, CIwStringS& ext);
# 375 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    CIwResource* GetResNamed(const char* resName, const char* resType, uint32 flags = 0) const;
# 386 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    CIwResource* GetResHashed(uint32 hash, const char* resType, uint32 flags = 0) const;
# 397 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    void AddRes(const char* resType, CIwResource* pData);
# 406 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    inline void SetCurrentGroup(CIwResGroup* pGroup)
    {
        ((void)0);
        m_GroupCurr = pGroup;
    }
# 419 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    inline CIwResGroup* GetCurrentGroup() const {return m_GroupCurr;}
# 428 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    CIwResGroup* GetLastSearchGroup() const;
# 438 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    CIwResGroup* LoadGroup(const char* pathname, bool allowNonExist = false);
# 449 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    CIwResGroup* LoadGroupFromMemory(const uint8* buffer, uint32 length);
# 460 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    CIwResGroup* MountGroup(const char* pathname, bool allowNonExist = false);


    CIwResGroup* ReloadGroup(const char* pathname, bool allowNonExist = false);







    void SetBuildGroupCallbackPre(BuildGroupCallbackPre fn);







    void SetBuildGroupCallbackPost(BuildGroupCallbackPost fn);
# 495 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    void SerialiseResPtr(CIwManaged*& pData, const char* resType,
        bool resolveNow = true);
# 506 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    void ResolveResPtr(CIwManaged*& pData, const char* resType);
# 516 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    CIwMaterial* GetAtlasMaterial(CIwMaterial* pMaterial, CIwRect& outUVRect);
# 526 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
    void SetBuildStyle(const char* name);






    CIwStringL GetBuildStyleCurrName() const;




    enum
    {
        COLLISION_MODE_SHIFT = 17,


        BUILDRES_F = (1 << 0),
        LOADPVR_F = (1 << 1),


        OMIT_SHARED_F = (1 << 4),
        OMIT_CHILDREN_F = (1 << 5),
        IGNORE_SHADERS_F = (1 << 6),
        IGNORE_MULTIPASS_F = (1 << 7),
        DONT_TEST_BINARIES_F = ( 1 << 8),
        GROUP_LIST_RESERVED_F = (1 << 9),
        HANDLER_LIST_RESERVED_F = (1 << 10),
        DONT_SERIALISE_BLOCK_SIZES_F = (1 << 11),
        DONT_LOAD_CHILD_GROUPS_F = (1 << 12),
        OPTIMISE_INCLUDE_UNUSED_RES_F = (1 <<13),
        OPTIMISE_MOUNTED_BINARIES_F = (1 <<14),
        MANUAL_RESOLVE_F = (1 << 15),
        IGNORE_INLINING_F = (1 << 16),
        COLLISION_MODE_F = (3 << COLLISION_MODE_SHIFT),
        PATCH_BINARIES_F = (1 << (2 + COLLISION_MODE_SHIFT)),
        LEGACY_SERIALISE_F = (1 << (3 + COLLISION_MODE_SHIFT)),
        USE_DEPENDENCY_F = (1 << (4 + COLLISION_MODE_SHIFT)),
    };


    CIwResource* LoadRes(const char* pathname, const char* tokens = __null, uint32 flags = 0);


    inline void AddLoadPath(const CIwStringL& path) {m_LoadPaths.push_back(path);}


    inline void ClearLoadPaths() {m_LoadPaths.clear();}


    inline const char* GetPathName() const {return m_PathName;}







    static void ChangeExtension(CIwStringL& filename, const char* pExt);


    void DebugAddMenuItems(CIwMenu* pMenu);







    inline void DebugSetGroupBinCopyPath(const char* path)
    {
        m_DebugGroupBinCopyPath = path;
    }


    inline void AddBuildStyle(CIwResBuildStyle* pStyle) {m_BuildStyles.Add((CIwManaged*)pStyle);}
    inline CIwResBuildStyle* GetBuildStyleNamed(const char* name) const {return (CIwResBuildStyle*)m_BuildStyles.GetObjNamed(name);}
    inline CIwResBuildStyle* GetBuildStyleCurr() const {return m_BuildStyleCurr;}


    bool BuildResources();







public:
    uint32 m_Flags;
    CIwArray<CIwStringL> m_LoadPaths;
    const char* m_OwnerResName;
    const char* m_DebugGroupBinCopyPath;
    CIwManagedList m_GroupBuildData;
    int32 m_ChildBuildScale;


    void ClearAtlasOwner() {m_AtlasParentGroup = __null;}
    void SetAltasOwner(CIwResGroup* group) {m_AtlasParentGroup = group;}
    CIwResGroup* GetAtlasOwner() {return m_AtlasParentGroup;}
    uint32 GetUniqueRunStamp() { return m_UniqueRunStamp; }

private:

    void _TempRemoveGroup(CIwResGroup* pGroup);
    CIwStringL GetBinaryPath(const char* path);

    typedef enum IwResGroupCollisionHandling
    {
        IW_RES_GROUP_COLLISION_ERROR_F = 0,
        IW_RES_GROUP_COLLISION_REPLACE_F = 1,
        IW_RES_GROUP_COLLISION_PATCH_F = 2,
    } IwGxResManagerGroupCollisionHandling;

    void SetGroupCollisionHandling(IwResGroupCollisionHandling handling)
    {
        m_Flags = (m_Flags & ~COLLISION_MODE_F) | (handling << COLLISION_MODE_SHIFT);
    }

    IwResGroupCollisionHandling GetGroupCollisionHandling()
    {
        return (IwResGroupCollisionHandling)((m_Flags & COLLISION_MODE_F) >> COLLISION_MODE_SHIFT);
    }

    void OptimisedMountedGroups();

    CIwResGroup* m_AtlasParentGroup;
    CIwManagedList m_Handlers;
    CIwManagedList m_Groups;
    CIwManagedList m_ReplacingGroups;
    CIwResGroup* m_GroupCurr;
    const char* m_PathName;
    CIwStringL m_GroupPathNameCurr;
    CIwManagedList m_BuildStyles;
    CIwResBuildStyle* m_BuildStyleCurr;
    uint32 m_UniqueRunStamp;
    bool m_LoadingPatch;

    struct CRemovedGroup
    {
        int32 m_Index;
        CIwResGroup* m_Group;
    };
    CIwArray<CRemovedGroup> m_RemovedGroups;

    CIwArray<CIwStringL> m_GroupsMounted;

    CIwResManager();
    ~CIwResManager();

    friend class CIwMaterial;
    friend class CIwResGroup;
    friend class CIwResHandlerGROUP;
    friend void _Serialise_ResGroupMembers();
    friend void _Serialise_ResGroupChildPaths(void);
    friend void IwResManagerInit();
    friend void IwResManagerTerminate();
};


extern CIwResManager* g_IwResManager;




inline CIwResManager* IwGetResManager() {return g_IwResManager;}
# 720 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManagerClass.h"
void IwResolveManagedHash(void* pptr, const char* resType, uint32 flags = 0);
# 22 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManager.h" 2
# 1 "c:/marmalade/6.2/modules/iwresmanager/h/IwResSerialise.h" 1
       
# 21 "c:/marmalade/6.2/modules/iwresmanager/h/IwResSerialise.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwTypes.h" 1
# 22 "c:/marmalade/6.2/modules/iwresmanager/h/IwResSerialise.h" 2
# 51 "c:/marmalade/6.2/modules/iwresmanager/h/IwResSerialise.h"
struct _IwGxBinaryHeader
{
    uint8 m_Magic;
    uint8 m_Major;
    uint8 m_Minor;
    uint8 m_Rev;
};


typedef void(*_IwGxBinaryBlockSerialiseFn)();


struct _IwGxBinaryBlockHashedFn
{
    uint32 m_Hash;
    _IwGxBinaryBlockSerialiseFn m_Function;
};
# 83 "c:/marmalade/6.2/modules/iwresmanager/h/IwResSerialise.h"
void _IwGxBinaryBlockSerialiseAdd(uint32 hash, _IwGxBinaryBlockSerialiseFn fn);


bool _IwGxBinaryBlockSerialiseRemove(uint32 hash);


void _IwGxBinaryBlockSerialise(uint32 hash);


void IwResBinaryRead(const char* pathname, bool allowNonExist);


void IwResBinaryMount(const char* pathname, bool allowNonExist);


void IwResBinarySerialise();


bool IwResBinaryOpen(const char* pathname, bool allowNonExist);

bool IwResBinarySerialiseHeader();

uint32 IwResBinarySerialiseBlock();

void IwResBinaryClose();
# 23 "c:/marmalade/6.2/modules/iwresmanager/h/IwResManager.h" 2
# 19 "c:/marmalade/6.2/modules/iwgx/h/IwResHandlerMTL.h" 2


class CIwResource;
# 30 "c:/marmalade/6.2/modules/iwgx/h/IwResHandlerMTL.h"
class CIwResTemplateMTL : public CIwResTemplate
{
public:
    typedef CIwArray<CIwResTemplateMTL*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;

    CIwResTemplateMTL();
    virtual void Reset();
    virtual void Copy(CIwResTemplate* pSource);
    virtual void Apply();
    virtual void ParseOpen(CIwTextParserITX* pParser);
    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
    virtual const char* GetResExt() const { return "mtl"; }

    CIwMaterial m_Mat;
};
# 57 "c:/marmalade/6.2/modules/iwgx/h/IwResHandlerMTL.h"
class CIwResHandlerMTL : public CIwResHandler
{
public:
    typedef CIwArray<CIwResHandlerMTL*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;


    CIwResHandlerMTL();
    virtual CIwResource* Build(const CIwStringL& pathname);
};
# 2353 "c:/marmalade/6.2/modules/iwgx/h/IwGx.h" 2
# 16 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/game.cpp" 2
# 1 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h" 1
       
# 21 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
# 1 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontState.h" 1
       
# 22 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontState.h"
# 1 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontTypes.h" 1
       
# 21 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontTypes.h"
# 1 "c:/marmalade/6.2/modules/iwutil/h/IwChar.h" 1
# 20 "c:/marmalade/6.2/modules/iwutil/h/IwChar.h"
    typedef char IwChar;


extern "C" {
# 33 "c:/marmalade/6.2/modules/iwutil/h/IwChar.h"
char* IwStrcpyChar(IwChar* dest, const IwChar* src);
# 44 "c:/marmalade/6.2/modules/iwutil/h/IwChar.h"
char* IwStrncpyChar(IwChar* dest, const IwChar* src, unsigned int count);
# 53 "c:/marmalade/6.2/modules/iwutil/h/IwChar.h"
int IwStrlenChar(const IwChar* str);

}
# 22 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontTypes.h" 2
# 37 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontTypes.h"
enum IwGxFontEncoding
{
    IW_GX_FONT_ASCII,
    IW_GX_FONT_CP1250,
    IW_GX_FONT_CP1251,
    IW_GX_FONT_CP1252,
    IW_GX_FONT_CP1253,
    IW_GX_FONT_CP1254,
    IW_GX_FONT_CP1255,
    IW_GX_FONT_CP1256,
    IW_GX_FONT_CP1257,
    IW_GX_FONT_CP1258,
    IW_GX_FONT_CP936,
    IW_GX_FONT_CP949,
    IW_GX_FONT_EUC_KR,
    IW_GX_FONT_GB2312,
    IW_GX_FONT_GBK,
    IW_GX_FONT_ISO_2022_JP,
    IW_GX_FONT_ISO_2022_KR,
    IW_GX_FONT_ISO_8859_1,
    IW_GX_FONT_ISO_8859_2,
    IW_GX_FONT_ISO_8859_3,
    IW_GX_FONT_ISO_8859_4,
    IW_GX_FONT_ISO_8859_5,
    IW_GX_FONT_ISO_8859_6,
    IW_GX_FONT_ISO_8859_7,
    IW_GX_FONT_ISO_8859_8,
    IW_GX_FONT_ISO_8859_9,
    IW_GX_FONT_ISO_8859_10,
    IW_GX_FONT_ISO_8859_11,
    IW_GX_FONT_ISO_8859_13,
    IW_GX_FONT_ISO_8859_14,
    IW_GX_FONT_ISO_8859_15,
    IW_GX_FONT_ISO_8859_16,
    IW_GX_FONT_JOHAB,
    IW_GX_FONT_CP866,
    IW_GX_FONT_KOI8_R,
    IW_GX_FONT_KOI8_RU,
    IW_GX_FONT_KOI8_U,
    IW_GX_FONT_MACCYRILLIC,
    IW_GX_FONT_UCS_2,
    IW_GX_FONT_UTF_7,
    IW_GX_FONT_UTF_8,
    IW_GX_FONT_CHINESE,
    IW_GX_FONT_BIG5,
    IW_GX_FONT_KSC_5601,


    IW_GX_FONT_WINDOWS_CENTRAL_EUROPEAN = IW_GX_FONT_CP1250,
    IW_GX_FONT_WINDOWS_CYRILLIC = IW_GX_FONT_CP1251,
    IW_GX_FONT_WINDOWS_WESTERN_EUROPEAN = IW_GX_FONT_CP1252,
    IW_GX_FONT_WINDOWS_GREEK = IW_GX_FONT_CP1253,
    IW_GX_FONT_WINDOWS_TURKISH = IW_GX_FONT_CP1254,
    IW_GX_FONT_WINDOWS_HEBREW = IW_GX_FONT_CP1255,
    IW_GX_FONT_WINDOWS_ARABIC = IW_GX_FONT_CP1256,
    IW_GX_FONT_WINDOWS_BALTIC = IW_GX_FONT_CP1257,
    IW_GX_FONT_WINDOWS_VIETNAM = IW_GX_FONT_CP1258,
    IW_GX_FONT_WINDOWS_SIMPLIFIED_CHINESE = IW_GX_FONT_CP936,
    IW_GX_FONT_WINDOWS_KOREAN = IW_GX_FONT_CP949,
    IW_GX_FONT_WINDOWS_RUSSIAN = IW_GX_FONT_CP866,
};




enum IwGxFontAlignHor
{
    IW_GX_FONT_ALIGN_LEFT,
    IW_GX_FONT_ALIGN_CENTRE,
    IW_GX_FONT_ALIGN_RIGHT,
    IW_GX_FONT_ALIGN_PARAGRAPH,
};




enum IwGxFontAlignVer
{
    IW_GX_FONT_ALIGN_TOP,
    IW_GX_FONT_ALIGN_MIDDLE,
    IW_GX_FONT_ALIGN_BOTTOM,
};




enum IwGxFontFlags
{
    IW_GX_FONT_DEFAULT_F = (1 << 0),
    IW_GX_FONT_NOWRAP_F = (1 << 1),
    IW_GX_FONT_NOWORDWRAP_F = (1 << 2),
    IW_GX_FONT_ONELINE_F = (1 << 3),
    IW_GX_FONT_NUMBER_ALIGN_F = (1 << 4),
    IW_GX_FONT_UNDERLINE_F = (1 << 5),
    IW_GX_FONT_ITALIC_F = (1 << 6),
    IW_GX_FONT_RIGHTTOLEFT_F = (1 << 7),
    IW_GX_FONT_NOWORDSPLIT_F = (1 << 8),
};


typedef uint16 CIwGxFontGlyphID;


typedef struct CIwGxFontPreparedChar
{
    CIwGxFontGlyphID glyphID;
    int16 width;
    int16 x,y;
} IwGxFontPreparedChar;




typedef const IwChar *(*IwGxFontParameterCallback)(const IwChar * in_start, int in_length, IwChar* temp_buffer);
# 23 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontState.h" 2




class CIwGxFont;




class CIwGxFontState
{
public:

    CIwGxFontState();
    ~CIwGxFontState();

    uint32 m_Flags;
    IwGxFontEncoding m_Encoding;
    IwGxFontAlignHor m_AlignHor;
    IwGxFontAlignVer m_AlignVer;
    const CIwGxFont* m_Font;
    CIwRect m_Rect;
    CIwColour m_ColEmissive;
    iwfixed m_ScaleX;
    iwfixed m_ScaleY;
    CIwVec2 m_FormatStart;
    int32 m_GlobalKerning;
    int32 m_Leading;
    IwGxFontParameterCallback m_ParameterCallback;
};
extern CIwGxFontState* g_IwGxFontState; inline CIwGxFontState* IwGetGxFontState() {return g_IwGxFontState;};
# 22 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h" 2

# 1 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontPreparedData.h" 1
       
# 26 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontPreparedData.h"
class CIwGxFontPreparedData
{
public:
    CIwGxFontPreparedData() : m_pFont(__null) {};





    int32 GetWidth() const { return m_Width; }




    int32 GetHeight() const { return m_Height; }





    uint32 GetNumLines() const;





    int32 GetLineStart(uint32 line) const;







    int32 GetLineEnd(uint32 line) const;







    uint32 GetNumChars() const;





    CIwRect GetCharacterArea(uint32 c) const;






    CIwSVec2 GetNextCharacterPosition() const;







    void MoveCharacters(int32 c1, int32 c2, const CIwSVec2& offset);




    void Clear();






    void Reserve(int numChar, int numLines, bool allowGrowth = true);


    typedef CIwArray<CIwGxFontPreparedChar> CIwCharArray;

    CIwCharArray m_Text;

private:
    CIwArray<int32> m_LineStart;
    int32 m_Width;
    int32 m_Height;
    const CIwGxFont* m_pFont;
    CIwSVec2 m_NextCharacterPos;

    friend class CIwGxFontRenderer;
};
# 24 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h" 2
# 1 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontContainer.h" 1
       
# 23 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontContainer.h"
# 1 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontGlyph.h" 1
       
# 22 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontGlyph.h"
class CIwGxFontPaletteEntry;
class CIwTexture;
# 32 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontGlyph.h"
class CIwGxFontGlyph
{
public:
    uint8 m_Width;
    uint8 m_IndividuallyKerned;



    union
    {
        uint16 m_CoordWidth;
        uint16 m_CacheID;
    };

    union {
        struct
        {
            uint16 m_U;
            uint16 m_V;
        };
        int32 m_CacheChar;
    };

    CIwGxFontGlyph();
    ~CIwGxFontGlyph();
    void Serialise();
};
# 24 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontContainer.h" 2



class CIwGxFontCharMapBase;
class CIwGxFontGlyphCache;
class CIwMaterial;
class CIw2DImage;
# 161 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontContainer.h"
class CIwGxFont : public CIwResource
{
public:
    typedef CIwArray<CIwGxFont*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const; private: CIwGxFont(const CIwGxFont &copy) { ((void)0); } const CIwGxFont& operator= (const CIwGxFont &rhs) { ((void)0); return *this; } public:;


    CIwGxFont();
    CIwGxFont(const char* fontname, int pointsize, int numCacheGlyphs);
    CIwGxFont(const uint8* pFontBuffer, int bufferSize, int pointsize, int numCacheGlyphs);

    ~CIwGxFont();





    inline uint16 GetHeight() const
    {
        return m_Height;
    }





    CIwMaterial* GetMaterial(int32 id = 0) const;





    int32 GetNumberMaterials() const;

    virtual void Serialise();
    virtual void Resolve();

    void DebugAddMenuItems(CIwMenu* pMenu);
# 217 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFontContainer.h"
private:
    int32 GetGlyphKerning(CIwGxFontGlyphID glyph1, CIwGxFontGlyphID glyph2) const;

    inline int GetGlyphID (int c) const;
    inline const CIwGxFontGlyph& GetGlyph(int id) const;
    inline const CIwGxFontGlyph& GetCachedGlyph(int id) const;
    void FixupSharedFont();

    void Clear();
    void CreateTTFFromResource();
    void InitTTF();
    int32 AddTTFGlyph(int id);


    struct CIwGxFontTexturePage
    {
        CIwGxFontTexturePage();



        CIwTexture* m_Texture;
        class CIwMaterial* m_Material;
        CIwGxFontGlyphID m_GlyphTextureIndex;
        uint16 m_CoordHeight;
    };



    int8 m_UnderlineOffset;
    int8 m_GlobalKerning;
    uint16 m_Height;
    uint8 m_Flags;
    uint8 pad[3];
    int32 m_Leading;
    CIwGxFontGlyphID m_FallbackGlyph;
    CIwGxFontGlyphID m_InvisibleGlyph;
    CIwArray<CIwGxFontTexturePage> m_TexturePages;

    class CIwGxFontTTFont* m_TTFResource;
    int32 m_TTFPointSize;
    int32 m_TTFCacheSize;
    struct FT_FaceRec_* m_TTFFace;

    enum
    {
        INDIVIDUAL_KERNING = (1<<1),
        UTF8 = (1<<2),
        NO_FILTER = (1<<3),
    };

    CIwGxFontCharMapBase* m_CharMap;
    CIwArray<CIwGxFontGlyph> m_Glyph;


    CIwGxFontGlyphCache* m_Cache;

    CIwTexture* m_CacheTex;
    CIwMaterial* m_CacheMat;

    struct CIwGxFontIndividualKern
    {
        CIwGxFontGlyphID m_FirstGlyph;
        CIwGxFontGlyphID m_SecondGlyph;
        int16 m_Kerning;
    };
    CIwArray<CIwGxFontIndividualKern> m_IndividualKerning;

    uint32 m_SharedHash;
    CIwColour m_Tint;

    friend class CIwGxFontRenderer;
    friend class CIwGxFontBuilder;
    friend CIwTexture* LegacyResolveFontSharedTexels(CIwTexture*);
    friend class CIwGxFontGlyphCache;
    friend class CIwGxFontPreparedData;
    friend void IwGxFontSetFont(const CIwGxFont*);
};
# 25 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h" 2
class CIwMaterial;
# 62 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
void IwGxFontInit();







void IwGxFontInitEncodings();






void IwGxFontTerminate();
# 112 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
void IwGxFontDrawText(const IwChar* text, int32 len = -1);
void IwGxFontDrawText(const uint16* text, int32 len = -1);
# 124 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
void IwGxFontReserveBuffers(int32 numChars, int32 numLines);
# 133 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
void IwGxFontFreeBuffers();
# 147 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
void IwGxFontPrepareText(CIwGxFontPreparedData& data, const IwChar * text, int32 len = -1);
void IwGxFontPrepareText(CIwGxFontPreparedData& data, const uint16 * text, int32 len = -1);







void IwGxFontDrawText(CIwGxFontPreparedData& data, int32 start = -1, int32 len = -1);
# 173 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
int32 IwGxFontSetUVs(CIwGxFontPreparedData& data, int32 line = -1, int32 material = 0, uint32** charIDs = __null);
# 199 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
CIwGxFont* IwGxFontCreateTTFont(const char* fontname, int pointsize,
    int numCacheGlyphs = -1);
# 216 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
CIwGxFont* IwGxFontCreateTTFontFromBuffer(const uint8* pFontBuffer, int bufferSize,
    int pointsize, int numCacheGlyphs = -1);





inline void IwGxFontDestroyTTFont(CIwGxFont* pFont)
{
    delete pFont;
}
# 250 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
void IwGxFontResetState();





inline void IwGxFontSetFont(const CIwGxFont* pFont)
{
    IwGetGxFontState()->m_Font = pFont;
    IwGetGxFontState()->m_Leading = pFont->m_Leading;
    IwGetGxFontState()->m_GlobalKerning = pFont->m_GlobalKerning;
}





inline const CIwGxFont* IwGxFontGetFont()
{
    return IwGetGxFontState()->m_Font;
}
# 279 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
inline void IwGxFontSetEncoding(IwGxFontEncoding encoding)
{
    IwGetGxFontState()->m_Encoding = encoding;
}






inline IwGxFontEncoding IwGxFontGetEncoding()
{
    return IwGetGxFontState()->m_Encoding;
}
# 301 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
inline void IwGxFontSetCol(const CIwColour& col)
{
    IwGetGxFontState()->m_ColEmissive = col;
}




inline void IwGxFontSetCol(uint32 col)
{
    IwGetGxFontState()->m_ColEmissive.Set(col);
}





inline CIwColour& IwGxFontGetCol()
{
    return IwGetGxFontState()->m_ColEmissive;
}
# 331 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
inline void IwGxFontSetRect(const CIwRect& rect)
{
    IwGetGxFontState()->m_Rect = rect;
}





inline CIwRect& IwGxFontGetRect()
{
    return IwGetGxFontState()->m_Rect;
}





inline void IwGxFontSetAlignmentHor(IwGxFontAlignHor alignHor)
{
    IwGetGxFontState()->m_AlignHor = alignHor;
}





inline IwGxFontAlignHor IwGxFontGetAlignmentHor()
{
    return IwGetGxFontState()->m_AlignHor;
}





inline void IwGxFontSetAlignmentVer(IwGxFontAlignVer alignVer)
{
    IwGetGxFontState()->m_AlignVer = alignVer;
}





inline IwGxFontAlignVer IwGxFontGetAlignmentVer()
{
    return IwGetGxFontState()->m_AlignVer;
}
# 388 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
inline void IwGxFontSetFlags(uint32 flags)
{
    IwGetGxFontState()->m_Flags |= flags;
}







inline void IwGxFontClearFlags(uint32 flags)
{
    IwGetGxFontState()->m_Flags &= ~flags;
}






inline uint32 IwGxFontGetFlags()
{
    return IwGetGxFontState()->m_Flags;
}






inline void IwGxFontSetScale(iwfixed scalex, iwfixed scaley = -1)
{
    IwGetGxFontState()->m_ScaleX = scalex;
    IwGetGxFontState()->m_ScaleY = scaley == -1 ? scalex : scaley;
}






inline void IwGxFontSetFormatStart(const CIwSVec2& v)
{
    IwGetGxFontState()->m_FormatStart = v;
}






inline void IwGxFontSetLeading(int32 leading)
{
    IwGetGxFontState()->m_Leading = leading;
}






inline void IwGxFontSetGlobalKerning(int32 kerning)
{
    IwGetGxFontState()->m_GlobalKerning = kerning;
}
# 503 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
inline void IwGxFontSetParameterCallback(IwGxFontParameterCallback cb)
{
    IwGetGxFontState()->m_ParameterCallback = cb;
}
# 551 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
void IwGxFontSetLiteralEncoding(IwGxFontEncoding encoding);






IwGxFontEncoding IwGxFontGetLiteralEncoding();
# 570 "c:/marmalade/6.2/modules/iwgxfont/h/IwGxFont.h"
void IwGxFontDrawLiteral(const IwChar* stringLiteral, int32 len = -1);
# 17 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/game.cpp" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 1
# 31 "c:/marmalade/6.2/modules/iwui/h/IwUI.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIAlertDialog.h" 1
# 17 "c:/marmalade/6.2/modules/iwui/h/IwUIAlertDialog.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawable.h" 1
# 17 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawable.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIMemory.h" 1
# 34 "c:/marmalade/6.2/modules/iwui/h/IwUIMemory.h"
void IwUISetMemBucketID(int bucketID, bool setPropertyBucket = true);





void IwUIResetMemBucketID();





int IwUIGetMemBucketID();
# 55 "c:/marmalade/6.2/modules/iwui/h/IwUIMemory.h"
CIwMemBucket& IwUIGetMemBucket();
# 84 "c:/marmalade/6.2/modules/iwui/h/IwUIMemory.h"
template<class T>
class CIwUIAllocator
{
public:
    T* allocate(size_t size)
    {
        CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID());
        return (T*) s3eMalloc(size);
    }

    T* reallocate(T* ptr, size_t size)
    {
        CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID());
        return (T*) s3eRealloc(ptr, size);
    }

    void deallocate(T* ptr, size_t)
    {
        s3eFree(ptr);
    }
};

template<class T>
struct IwUI
{
    typedef CIwArray<T, CIwUIAllocator<T> > Array;
};
# 18 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawable.h" 2
# 33 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawable.h"
class CIwColour;
class CIwPropertySet;
class CIwVec2;
class CIwUIAnimData;
class CIwUIDebugGraphics;
class CIwUIGraphics;
class CIwUIRect;
# 88 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawable.h"
class IIwUIDrawable
{
public:
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    virtual ~IIwUIDrawable() {}





    virtual void Draw(CIwUIGraphics& graphics) const = 0;




    virtual void DebugDraw(CIwUIDebugGraphics& debugGraphics) const = 0;






    virtual CIwVec2 Measure(const CIwVec2& availableSize) const = 0;





    virtual void Animate(const CIwUIAnimData& animData) = 0;





    virtual void SetPosition(const CIwVec2& pos) = 0;





    virtual void SetSize(const CIwVec2& size) = 0;





    virtual void SetColour(const CIwColour& colour) = 0;





    virtual CIwVec2 GetPosition() const = 0;





    virtual CIwVec2 GetSize() const = 0;





    virtual CIwColour GetColour() const = 0;







    virtual CIwUIRect GetBounds() const = 0;







    virtual bool Intersects(const CIwVec2& pos) const = 0;
};
# 18 "c:/marmalade/6.2/modules/iwui/h/IwUIAlertDialog.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h" 1
# 23 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimData.h" 1
# 17 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimData.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwPropertySet.h" 1
# 16 "c:/marmalade/6.2/modules/iwui/h/IwPropertySet.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwDecomposable.h" 1
# 20 "c:/marmalade/6.2/modules/iwui/h/IwDecomposable.h"
class CIwTextDecomposer;
# 34 "c:/marmalade/6.2/modules/iwui/h/IwDecomposable.h"
class IIwDecomposable
{
public:
    virtual ~IIwDecomposable() {}






    virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const = 0;





    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const = 0;





    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const = 0;





    virtual void DecomposeClose(CIwTextDecomposer* pDecomposer) const = 0;




    static void AddHashString(const char* pString);





    static const char* GetHashString(uint32 hash);
};
# 17 "c:/marmalade/6.2/modules/iwui/h/IwPropertySet.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwProperty.h" 1
# 17 "c:/marmalade/6.2/modules/iwui/h/IwProperty.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwPropertyData.h" 1
# 17 "c:/marmalade/6.2/modules/iwui/h/IwPropertyData.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBase.h" 1
# 20 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBase.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwPropertyMap.h" 1
# 26 "c:/marmalade/6.2/modules/iwui/h/IwPropertyMap.h"
template <class Property>
class CIwPropertyNode
{
public:
    CIwPropertyNode() : m_Next(__null), m_Prev(__null) {}

    Property* GetPrev() const { return m_Prev; }
    void SetPrev(Property* pPrev) { m_Prev = pPrev; }

    Property* GetNext() const { return m_Next; }
    void SetNext(Property* pNext) { m_Next = pNext; }

private:

    Property* m_Prev;
    Property* m_Next;
};
# 51 "c:/marmalade/6.2/modules/iwui/h/IwPropertyMap.h"
template <class Property, class HashType=uint32, bool OwnsProperties=true>
class CIwPropertyMap
{
public:
    CIwPropertyMap() : m_Head(__null), m_Tail(__null), m_Num(0)
    {
    }

    ~CIwPropertyMap()
    {
        clear();
    }

    class iterator
    {
    public:
        iterator() : m_Property(__null) {}
        iterator(Property* pProperty) : m_Property(pProperty) {}
        iterator(const iterator& it) : m_Property(it.m_Property) {}

        Property* operator*() const { return m_Property; }

        iterator& operator++() { m_Property = m_Property->m_Node.GetNext(); return *this; }
        iterator& operator--() { m_Property = m_Property->m_Node.GetPrev(); return *this; }

        iterator& operator=(const iterator& it) { m_Property = it.m_Property; return *this; }
        bool operator==(const iterator& it) const { return m_Property == it.m_Property; }
        bool operator!=(const iterator& it) const { return m_Property != it.m_Property; }

    private:
        Property* m_Property;
    };

    int size() const { return m_Num; }

    iterator begin() const { return iterator(m_Head); }
    iterator end() const { return iterator(__null); }

    Property* front() const { return m_Head; }
    Property* back() const { return m_Tail; }

    void push_back(Property* pProperty)
    {
        ((void)0);


        if (m_Head)
        {
            iterator it;
            const iterator itE = end();
            const HashType hash = pProperty->m_Hash;
            if (search_from_head(hash))
            {

                for (it = begin(); it != itE; ++it)
                {
                    if (hash < (*it)->m_Hash)
                    {
                        break;
                    }
                }
                insert_before(pProperty, *it);
            }
            else if(hash <= m_Tail->m_Hash)
            {

                for (it = back(); it != itE; --it)
                {
                    if (hash > (*it)->m_Hash)
                    {
                        break;
                    }
                }
                insert_after(pProperty, *it);
            }
            else
            {

                insert_before(pProperty, __null);
            }
        }
        else
        {

            insert_after(pProperty, __null);
        }
    }

    void clear()
    {
        if (OwnsProperties)
        {
            Property* pProperty = m_Head;
            while (pProperty)
            {
                Property* pNext = pProperty->m_Node.GetNext();
                delete pProperty;
                pProperty = pNext;
            }
        }
        m_Head = m_Tail = __null;
        m_Num = 0;
    }

    void remove(iterator it)
    {
        remove(*it);
    }

    void remove(Property* pProperty)
    {
        ((void)0);

        Property* pPrev = pProperty->m_Node.GetPrev();
        Property* pNext = pProperty->m_Node.GetNext();

        pProperty->m_Node.SetPrev(__null);
        pProperty->m_Node.SetNext(__null);

        if (pPrev)
        {
            pPrev->m_Node.SetNext(pNext);
        }
        else
        {
            m_Head = pNext;
        }

        if (pNext)
        {
            pNext->m_Node.SetPrev(pPrev);
        }
        else
        {
            m_Tail = pPrev;
        }

        m_Num--;
    }

    void erase(iterator it)
    {
        erase(*it);
    }

    void erase(Property* pProperty)
    {
        remove(pProperty);

        if (OwnsProperties)
        {
            delete pProperty;
        }
    }

    Property* element_at(int id) const
    {
        ((void)0);


        if (id < m_Num - id)
        {
            Property* pProperty = m_Head;
            while (id--)
            {
                pProperty = pProperty->m_Node.GetNext();
            }
            return pProperty;
        }
        else
        {
            Property* pProperty = m_Tail;
            int rid = (m_Num - 1) - id;
            while (rid--)
            {
                pProperty = pProperty->m_Node.GetPrev();
            }
            return pProperty;
        }
    }

    Property* find(HashType hash) const
    {
        if (m_Head)
        {
            iterator it;
            const iterator itE = end();
            if (search_from_head(hash))
            {

                for (it = begin(); it != itE; ++it)
                {
                    if (hash == (*it)->m_Hash)
                    {
                        return *it;
                    }
                    else if (hash < (*it)->m_Hash)
                    {
                        return __null;
                    }
                }
            }
            else if(hash <= m_Tail->m_Hash)
            {

                for (it = back(); it != itE; --it)
                {
                    if (hash == (*it)->m_Hash)
                    {
                        return *it;
                    }
                    else if (hash > (*it)->m_Hash)
                    {
                        return __null;
                    }
                }
            }
        }

        return __null;
    }

    bool contains(Property* pProperty)
    {
        iterator it = begin();
        const iterator itE = end();

        for (it = begin(); it != itE; ++it)
        {
            if (pProperty == *it)
            {
                return true;
            }
        }

        return false;
    }

private:
    void insert_before(Property* pProperty, Property* pNext)
    {
        ((void)0);


        if (!pNext)
        {
            if (!m_Tail)
            {
                m_Head = m_Tail = pProperty;
            }
            else
            {
                ((void)0);
                m_Tail->m_Node.SetNext(pProperty);
                pProperty->m_Node.SetPrev(m_Tail);
                m_Tail = pProperty;
            }
        }
        else
        {
            ((void)0);
            Property* pPrev = pNext->m_Node.GetPrev();
            pProperty->m_Node.SetNext(pNext);
            pNext->m_Node.SetPrev(pProperty);

            if(pPrev)
            {
                pProperty->m_Node.SetPrev(pPrev);
                pPrev->m_Node.SetNext(pProperty);
            }
            else
            {
                m_Head = pProperty;
            }
        }
        m_Num++;
    }

    void insert_after(Property* pProperty, Property* pPrev)
    {
        ((void)0);


        if (!pPrev)
        {
            if (!m_Head)
            {
                m_Head = m_Tail = pProperty;
            }
            else
            {
                ((void)0);
                m_Head->m_Node.SetPrev(pProperty);
                pProperty->m_Node.SetNext(m_Head);
                m_Head = pProperty;
            }
        }
        else
        {
            ((void)0);
            Property* pNext = pPrev->m_Node.GetNext();
            pProperty->m_Node.SetPrev(pPrev);
            pPrev->m_Node.SetNext(pProperty);

            if(pNext)
            {
                pProperty->m_Node.SetNext(pNext);
                pNext->m_Node.SetPrev(pProperty);
            }
            else
            {
                m_Tail = pProperty;
            }
        }
        m_Num++;
    }

    bool search_from_head(HashType hash) const
    {
        return (hash < m_Head->m_Hash) ||
            ((hash < m_Tail->m_Hash) &&
            (hash - m_Head->m_Hash < m_Tail->m_Hash - hash));
    }

    Property* m_Head;
    Property* m_Tail;
    int32 m_Num;
};
# 21 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBase.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwPropertyMemory.h" 1
# 31 "c:/marmalade/6.2/modules/iwui/h/IwPropertyMemory.h"
void IwPropertySetMemBucketID(int bucketID);





void IwPropertyResetMemBucketID();





int IwPropertyGetMemBucketID();
# 53 "c:/marmalade/6.2/modules/iwui/h/IwPropertyMemory.h"
CIwMemBucket& IwPropertyGetMemBucket();
# 82 "c:/marmalade/6.2/modules/iwui/h/IwPropertyMemory.h"
template<class T>
class CIwPropertyAllocator
{
public:
    T* allocate(size_t size)
    {
        CIwAutoBucketSwitch iwbucketswitch(IwPropertyGetMemBucketID());
        return (T*) s3eMalloc(size);
    }

    T* reallocate(T* ptr, size_t size)
    {
        CIwAutoBucketSwitch iwbucketswitch(IwPropertyGetMemBucketID());
        return (T*) s3eRealloc(ptr, size);
    }

    void deallocate(T* ptr, size_t)
    {
        s3eFree(ptr);
    }
};

template<class T>
struct IwProperty
{
    typedef CIwArray<T, CIwPropertyAllocator<T> > Array;
};
# 22 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBase.h" 2


class CIwTextDecomposer;
# 37 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBase.h"
class CIwPropertyBase : private CIwManaged
{

public:
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwPropertyGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwPropertyGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwPropertyBase(uint32 defineId, const char* pDebugName);
    virtual ~CIwPropertyBase();

    typedef CIwPropertyMap<CIwPropertyBase> Array;
    typedef CIwPropertyMap<CIwPropertyBase>::iterator ArrayIt;
# 61 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBase.h"
    virtual CIwPropertyBase* Copy( ) const = 0;






    virtual CIwPropertyBase * Clone( ) const = 0;





    virtual uint32 GetDataType() const = 0;





    virtual const char * GetDataTypeString() const = 0;





    virtual void Parse(CIwTextParserITX* pParser) = 0;





    virtual void Decompose(CIwTextDecomposer* pDecomposer) const = 0;




    virtual void Serialise();




    virtual void Resolve();






    virtual bool isDataType(uint32 dataType) const = 0;
# 125 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBase.h"
    virtual const void* ExposeData() const = 0;
# 138 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBase.h"
    uint32 GetPropertyDefineID() const { return m_Hash; }





    void SetPropertyDefine(const char* pName);





    const char* DebugGetPropertyDefine() const;






    bool isDefineMatch(uint32 idToMatch) const { return idToMatch == m_Hash;}


private:

    CIwPropertyBase& operator=(const CIwPropertyBase&);
    bool operator==(const CIwPropertyBase&);


    CIwPropertyNode<CIwPropertyBase> m_Node;







    friend class CIwPropertyMap<CIwPropertyBase>;
    friend class CIwPropertyMap<CIwPropertyBase>::iterator;

};
# 18 "c:/marmalade/6.2/modules/iwui/h/IwPropertyData.h" 2
# 27 "c:/marmalade/6.2/modules/iwui/h/IwPropertyData.h"
template<class Type>
class CIwPropertyData : public CIwPropertyBase
{
public:
    template<class InType>
    CIwPropertyData(uint32 defineId, const char* pDebugName, const InType& val) :
        CIwPropertyBase(defineId, pDebugName), m_Data(val)
    {
    }

    CIwPropertyData(uint32 defineId, const char* pDebugName) :
        CIwPropertyBase(defineId, pDebugName)
    {
    }
# 52 "c:/marmalade/6.2/modules/iwui/h/IwPropertyData.h"
    virtual const void* ExposeData() const { return &m_Data; }
# 66 "c:/marmalade/6.2/modules/iwui/h/IwPropertyData.h"
    template<class InType>
    void Get(InType& data) const { data = m_Data; }





    const Type& Get() const { return m_Data; }





    Type& Get() { return m_Data; }
# 89 "c:/marmalade/6.2/modules/iwui/h/IwPropertyData.h"
    template<class InType>
    bool Set(const InType& data)
    {
        if (!(m_Data == data))
        {
            m_Data = data;
            return true;
        }
        else
        {
            return false;
        }
    }


private:

    Type m_Data;
};
# 18 "c:/marmalade/6.2/modules/iwui/h/IwProperty.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwPropertyDataType.h" 1
# 18 "c:/marmalade/6.2/modules/iwui/h/IwPropertyDataType.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwTextDecomposer.h" 1
# 20 "c:/marmalade/6.2/modules/iwui/h/IwTextDecomposer.h"
class CIwManaged;
class IIwDecomposable;
struct s3eFile;
# 53 "c:/marmalade/6.2/modules/iwui/h/IwTextDecomposer.h"
class CIwTextDecomposer
{
public:
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwPropertyGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwPropertyGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }
    CIwTextDecomposer();





    void DecomposeToFile(const char* pPathname, const IIwDecomposable* pDecomposable);




    void DecomposeChild(const IIwDecomposable* pDecomposable);







    const IIwDecomposable* GetObject(int32 level = 0);





    void OpenScope(bool inlineScope);





    void CloseScope(bool inlineScope);




    void OpenAttribute();




    void CloseAttribute();




    void WriteClassName(const char* pClassName);
    void WriteClassName(const CIwManaged* pManaged);




    void WriteObjectName(const char* pObjectName);
    void WriteObjectName(const CIwManaged* pManaged);





    void WriteAttribute(const char* pAttrName, const char* pAttrVal);





    void WriteAttributeName(const char* pAttrName);





    template<class Type>
    void WriteAttributeVal(Type val)
    {
        int32 i = val;
        _GetContext().WriteStringf("%ld", i);
    }

    void WriteAttributeVal(const char* pString);
    void WriteAttributeVal(bool val);
    void WriteAttributeVal(float val);






    void WriteAttributeHash(uint32 hash);






    void WriteAttibuteNameHash(const char* pName, uint32 hash);





    template<class Type>
    void WriteAttributeNameVal(const char* pName, Type val)
    {
        OpenAttribute();
        WriteAttributeName(pName);
        WriteAttributeVal(val);
        CloseAttribute();
    }





    template<class Type>
    void WriteAttributeValArray(const Type* val, int numVals)
    {
        OpenScope(true);
        for (int i=0; i<numVals; i++)
        {
            WriteAttributeVal(val[i]);
        }
        CloseScope(true);
    }






    template<class Type>
    void WriteAttributeNameValArray(const char* pName, const Type* val, int numVals)
    {
        OpenAttribute();
        WriteAttributeName(pName);
        WriteAttributeValArray(val, numVals);
        CloseAttribute();
    }

private:

    class Context
    {
    public:
        Context(s3eFile* pFile, const IIwDecomposable* pDecomposable);
        Context(const Context& context, const IIwDecomposable* pDecomposable);

        void OpenScope();
        void CloseScope();

        void OpenStatement();
        void CloseStatement();

        void WriteString(const char* pString);
        void WriteStringf(const char* pFormat, ...);

        void AddBreakWithinScope();

        const IIwDecomposable* GetObject(int32 level) const;

        int32 GetScopeDepth() const { return m_ScopeDepth; }
        int32 GetStatementDepth() const { return m_StatementDepth; }

    private:
        void _WriteScopeTabs() const;
        void _WriteSpace() const;
        void _WriteNewLine() const;

        s3eFile* m_File;
        const Context* m_PrevContext;
        const IIwDecomposable* m_Decomposable;
        int32 m_ScopeDepth;
        int32 m_StatementDepth;
        bool m_WritingStatement;
        bool m_WritingScope;
    };


    Context& _GetContext();
    Context* _PushContext(Context& context);
    void _PopContext(Context* pPrevContext);

    void _Decompose(const IIwDecomposable* pDecomposable);


    class Context* m_CurrentContext;
};
# 19 "c:/marmalade/6.2/modules/iwui/h/IwPropertyDataType.h" 2



class CIwManaged;
class CIwColour;
class CIwTexture;
class CIwMaterial;
class CIwGxFont;
class CIwLayout;
class CIwPropertyString;
class CIwPropertySet;
# 49 "c:/marmalade/6.2/modules/iwui/h/IwPropertyDataType.h"
template<class Type>
class CIwPropertyDataType
{
public:

    static void Parse(Type&, CIwTextParserITX*);
    static void Decompose(Type const&, CIwTextDecomposer*);
    static void Serialise(Type&);
    static void Resolve(Type&);
    static bool IsOfType(uint32 typeHash);
    static void Clone(Type const& src, Type& dst);


    static const char* s_DataType;
    static const uint32 s_DataTypeHash;
};
# 192 "c:/marmalade/6.2/modules/iwui/h/IwPropertyDataType.h"
template<class ResType>
ResType* FindResourceProperty(uint32 resHash, const char* resType)
{
    if (CIwResGroup* pCurrGroup = IwGetResManager()->GetCurrentGroup())
    {

        return IwSafeCast<ResType*>(pCurrGroup->GetResHashed(resHash,
            resType, IW_RES_SEARCH_ALL_F, true));
    }
    ((void)0);
    return __null;
}

template<class ResType>
ResType* ParseResourceProperty(CIwTextParserITX* pParser, const char* resType)
{
    CIwStringL resName;
    pParser->ReadString(resName);



    if ( !resName.size() )
    {
        return __null;
    }
    else
    {
        ResType* pResource = FindResourceProperty<ResType>(
            IwHashString(resName.c_str()), resType);
        ((void)0);

        return pResource;
    }
}

template<class ResType>
void DecomposeResourceProperty(CIwTextDecomposer* pDecomposer, ResType* pResource)
{
    pDecomposer->WriteAttributeVal(pResource ? pResource->DebugGetName() : "");
}

template<class ResType>
void SerialiseResourceProperty(ResType*& data)
{
    IwSerialiseManagedHash((CIwManaged**)&data);
}

template<class ResType>
void ResolveResourceProperty(ResType*& data, const char* resType)
{
    data = FindResourceProperty<ResType>((uintptr_t)data, resType);
}

template<class ResType>
bool IsOfTypeResourceProperty(uint32 typeHash, const char* typeName, const char* resName,
    ResType* = __null)
{

    static const uint32 type = IwHashString(typeName);
    static const uint32 resType = IwHashString(resName);
    static const uint32 iwResource = IwHashString("CIwResource*");
    static const uint32 iwManaged = IwHashString("CIwManaged*");
    return (typeHash == type) || (typeHash == resType) ||
        (typeHash == iwResource) || (typeHash == iwManaged);
}
# 338 "c:/marmalade/6.2/modules/iwui/h/IwPropertyDataType.h"


















# 19 "c:/marmalade/6.2/modules/iwui/h/IwProperty.h" 2
# 38 "c:/marmalade/6.2/modules/iwui/h/IwProperty.h"
template<class Key>
class CIwPropertyTypeMap
{
public:
    typedef Key Val;
};
# 83 "c:/marmalade/6.2/modules/iwui/h/IwProperty.h"
template<class Type, class DataType = CIwPropertyDataType<Type> >
class CIwProperty : public CIwPropertyData<Type>
{
public:
# 95 "c:/marmalade/6.2/modules/iwui/h/IwProperty.h"
    template<class InType>
    CIwProperty(uint32 defineId, const char* pDebugName, const InType& val) :
        CIwPropertyData<Type>(defineId, pDebugName, val)
    {
    }






    CIwProperty(uint32 defineId, const char* pDebugName) :
        CIwPropertyData<Type>(defineId, pDebugName)
    {
    }
# 122 "c:/marmalade/6.2/modules/iwui/h/IwProperty.h"
    virtual CIwPropertyBase* Copy( ) const
    {
        return new CIwProperty(this->GetPropertyDefineID(),
            this->DebugGetPropertyDefine(), this->Get());
    }







    virtual CIwPropertyBase* Clone( ) const
    {
        CIwProperty* pClone =
            new CIwProperty(this->GetPropertyDefineID(),
                this->DebugGetPropertyDefine());

        DataType::Clone(this->Get(), pClone->Get());

        return pClone;
    }





    virtual uint32 GetDataType() const
    {
        return DataType::s_DataTypeHash;
    }







    virtual const char * GetDataTypeString() const
    {
        return DataType::s_DataType;
    }







    virtual void Parse(CIwTextParserITX* pParser)
    {



    }







    virtual void Decompose(CIwTextDecomposer* pDecomposer) const
    {
# 194 "c:/marmalade/6.2/modules/iwui/h/IwProperty.h"
    }






    virtual void Serialise()
    {
        CIwPropertyData<Type>::Serialise();

        DataType::Serialise(this->Get());
    }






    virtual void Resolve()
    {
        CIwPropertyData<Type>::Resolve();

        DataType::Resolve(this->Get());
    }
# 227 "c:/marmalade/6.2/modules/iwui/h/IwProperty.h"
    virtual bool isDataType(uint32 dataType) const
    {
        return DataType::IsOfType(dataType);
    }
# 245 "c:/marmalade/6.2/modules/iwui/h/IwProperty.h"
    static CIwPropertyBase* ClassFactory(uint32 defineId, const char* pDebugName)
    {
        return new CIwProperty(defineId, pDebugName);
    }

};
# 18 "c:/marmalade/6.2/modules/iwui/h/IwPropertySet.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBinding.h" 1
# 25 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBinding.h"
class CIwPropertyBase;
# 47 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBinding.h"
class CIwPropertyBinding : public CIwResource, public IIwDecomposable
{
public:
    typedef CIwArray<CIwPropertyBinding*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwPropertyGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwPropertyGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwPropertyBinding() { }
    virtual ~CIwPropertyBinding() { }


    virtual void ParseClose(CIwTextParserITX* pParser);


    virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeClose(CIwTextDecomposer* pDecomposer) const;
# 75 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBinding.h"
    CIwPropertyBinding* Clone() const;
# 94 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBinding.h"
    virtual bool GetProperty(CIwPropertyBase* pProperty) = 0;
# 106 "c:/marmalade/6.2/modules/iwui/h/IwPropertyBinding.h"
    virtual bool SetProperty(CIwPropertyBase* pProperty) = 0;





    virtual void Clone(CIwPropertyBinding* pTarget) const;

};


# 19 "c:/marmalade/6.2/modules/iwui/h/IwPropertySet.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwPropertySetFuncs.h" 1
# 20 "c:/marmalade/6.2/modules/iwui/h/IwPropertySetFuncs.h"
class CIwPropertySet;


typedef CIwPropertyBase*(*IwPropertyFactoryFn)(uint32 defineId,
    const char* pDebugName);
# 35 "c:/marmalade/6.2/modules/iwui/h/IwPropertySetFuncs.h"
void IwPropertySetInit();






void IwPropertySetTerminate();






bool IwPropertyIsProperty(uint32 hash);






bool IwPropertyIsProperty(const char* pName);







CIwPropertyBase* IwPropertyCreateProperty(uint32 hash, uint32 defineId,
    const char* pDebugName);






CIwPropertyBase* IwPropertyCreatePropertyFromDefine(uint32 propertyDefine);






const CIwPropertyBase* IwPropertyDefaultPropertyFromDefine(uint32 propertyDefine);





bool IwPropertyFactoryExists(uint32 hash);






void IwPropertyAddPropertyFactory(const char* pPropertyName, IwPropertyFactoryFn facFunc);





template<class Type>
Type* IwPropertyAddPropertyFactory()
{
    IwPropertyAddPropertyFactory(CIwPropertyDataType<Type>::s_DataType,
        CIwProperty<Type>::ClassFactory);


    return __null;
}


template<class Type, class DataType >
Type* IwPropertyAddPropertyFactoryCustom(DataType* dummy = __null)
{
    IwPropertyAddPropertyFactory(DataType::s_DataType,
        CIwProperty<Type, DataType>::ClassFactory);


    return __null;
}





void IwPropertyRemovePropertyFactory(const char* pPropertyName);





template<class Type>
Type* IwPropertyRemovePropertyFactory()
{
    IwPropertyRemovePropertyFactory(CIwPropertyDataType<Type>::s_DataType);


    return __null;
}
# 20 "c:/marmalade/6.2/modules/iwui/h/IwPropertySet.h" 2
# 42 "c:/marmalade/6.2/modules/iwui/h/IwPropertySet.h"
class CIwPropertySet;



template<> class CIwPropertyTypeMap<CIwPropertySet const* > { public: typedef CIwPropertySet* Val; };
# 63 "c:/marmalade/6.2/modules/iwui/h/IwPropertySet.h"
class CIwPropertySet : public CIwResource, public IIwDecomposable
{
public:
    typedef CIwArray<CIwPropertySet*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwPropertyGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwPropertyGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwPropertySet();
    CIwPropertySet(const CIwPropertySet& other);
    virtual ~CIwPropertySet();

    typedef CIwPropertyBase::ArrayIt iterator;


    CIwPropertySet& operator= ( const CIwPropertySet& other );


    virtual void ParseOpen(CIwTextParserITX* pParser);
    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
    virtual void ParseCloseChild(CIwTextParserITX* pParser, CIwManaged* pChild);
    virtual void ParseClose(CIwTextParserITX* pParser);


    virtual void Serialise();
    virtual void Resolve();


    virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeClose(CIwTextDecomposer* pDecomposer) const;
# 107 "c:/marmalade/6.2/modules/iwui/h/IwPropertySet.h"
    template<class Type>
    bool GetProperty(const char* name, Type& val, bool allowMissing = false,
        bool checkParent = true) const
    {
        uint32 propDefHash = IwHashString(name);

        if (m_Binding)
        {
            CIwProperty<typename CIwPropertyTypeMap<Type>::Val> tempProperty(propDefHash, name);

            if (m_Binding->GetProperty(&tempProperty))
            {
                tempProperty.Get(val);
                return true;
            }
        }

        const CIwPropertyData<typename CIwPropertyTypeMap<Type>::Val>* pProperty = __null;
        _LookupProperty(pProperty, propDefHash, checkParent, name);

        if (!pProperty && !allowMissing)
        {
            ((void)0);



            pProperty = IwSafeCast<const CIwPropertyData<typename CIwPropertyTypeMap<Type>::Val>*>(
                IwPropertyDefaultPropertyFromDefine(propDefHash));
        }

        if(pProperty)
        {
            pProperty->Get(val);
            return true;
        }

        ((void)0);




        return false;
    }




    virtual void SetParent(const CIwPropertySet* pPropertySet);




    virtual const CIwPropertySet* GetParent() const;






    void AddProperty(CIwPropertyBase* pProperty);






    void RemoveProperty(CIwPropertyBase* pProperty);







    template <typename Type>
    bool SetProperty(const char* name, const Type& val)
    {
        uint32 propDefHash = IwHashString(name);

        if (m_Binding)
        {
            CIwProperty<typename CIwPropertyTypeMap<Type>::Val>
                tempProperty(propDefHash, name, val);

            if (m_Binding->SetProperty(&tempProperty))
            {

                return true;
            }
        }


        CIwPropertyData<typename CIwPropertyTypeMap<Type>::Val>* pProperty = __null;
        _LookupProperty(pProperty, propDefHash, false, name);

        if (pProperty)
        {
            return pProperty->Set(val);
        }
        else
        {

            CIwPropertyData<typename CIwPropertyTypeMap<Type>::Val> *newProperty =
                IwSafeCast<CIwPropertyData<typename CIwPropertyTypeMap<Type>::Val>*>(
                    IwPropertyCreatePropertyFromDefine(propDefHash));

            if (newProperty)
            {
                newProperty->Set(val);







                m_PropertyMap.push_back(newProperty);


                return true;
            }
            else
            {
                ((void)0);



                return false;
            }
        }
    }




    void Clone(const CIwPropertySet& other);




    uint32 GetNumProperties() const;






    const CIwPropertyBase* GetPropertyByIndex(uint32 index) const;






    const CIwPropertyBase* GetPropertyByHash(uint32 hash, bool checkParent = true) const;




    inline iterator GetBegin() const { return m_PropertyMap.begin(); }




    inline iterator GetEnd() const { return m_PropertyMap.end(); }





    void SetBinding(CIwPropertyBinding* pBinding);




    CIwPropertyBinding* GetBinding() const { return m_Binding; }

private:

    const CIwPropertySet* m_Parent;


    CIwPropertyBase::Array m_PropertyMap;


    CIwPropertyBinding* m_Binding;


    void _CheckPropertyDataType(const char* propDefName,
        CIwPropertyBase* pProperty);
    void _GeneratePropertyDataTypeError(const char* propDefName,
        const char *expectedDataType ) const;
    const CIwPropertySet* _LookupParent(const char* pName) const;
    const CIwPropertySet* _LookupParent(uint32 hash) const;
    void _DestroyPropertyList();
    void _DestroyBinding();

    template<class PropertyType>
    void _LookupProperty(PropertyType*& pProperty, uint32 propDefine,
        bool checkParent, const char* pDebugPropDef) const
    {
        const CIwPropertyBase* pBase = GetPropertyByHash(propDefine, checkParent);
# 319 "c:/marmalade/6.2/modules/iwui/h/IwPropertySet.h"
        pProperty = (PropertyType*) pBase;
    }
};
# 18 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimData.h" 2


# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIAlignment.h" 1
# 33 "c:/marmalade/6.2/modules/iwui/h/IwUIAlignment.h"
class CIwTextParserITX;






enum IwUIAlignmentH
{
    IW_UI_ALIGN_LEFT,
    IW_UI_ALIGN_CENTRE,
    IW_UI_ALIGN_RIGHT
};






enum IwUIAlignmentV
{
    IW_UI_ALIGN_TOP,
    IW_UI_ALIGN_MIDDLE,
    IW_UI_ALIGN_BOTTOM
};
# 66 "c:/marmalade/6.2/modules/iwui/h/IwUIAlignment.h"
IwGxFontAlignHor IwUIAlignmentGxFont(IwUIAlignmentH halign);
# 75 "c:/marmalade/6.2/modules/iwui/h/IwUIAlignment.h"
IwGxFontAlignVer IwUIAlignmentGxFont(IwUIAlignmentV valign);



# 21 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimData.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIElementPtr.h" 1
# 25 "c:/marmalade/6.2/modules/iwui/h/IwUIElementPtr.h"
class CIwUIElement;
# 38 "c:/marmalade/6.2/modules/iwui/h/IwUIElementPtr.h"
class CIwUIElementPtr
{
public:
    CIwUIElementPtr();
    explicit CIwUIElementPtr(CIwUIElement* pElement);
    CIwUIElementPtr(const CIwUIElementPtr& rhs);
    ~CIwUIElementPtr();


    typedef CIwArray<CIwUIElementPtr, CIwAllocator<CIwUIElementPtr>,
        ReallocateStandard<CIwUIElementPtr, CIwAllocator<CIwUIElementPtr> > > Array;
    typedef Array::iterator ArrayIt;


    CIwUIElementPtr& operator=(CIwUIElement* pElement);


    CIwUIElement& operator*() const;
    CIwUIElement* operator->() const;
    bool operator==(CIwUIElement* pElement) const;
    bool operator!=(CIwUIElement* pElement) const;
    operator CIwUIElement*() const;

private:

    CIwUIElement* m_Element;
};
# 22 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimData.h" 2
# 30 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimData.h"
class CIwColour;
class CIwUIAnimator;
class CIwUIElement;
class IIwUIDrawable;
# 42 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimData.h"
template<class Type>
class CIwUIAnimDataType
{
public:






    static Type Interpolate(const Type& start, const Type& end, iwfixed prop);
};
# 66 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimData.h"
class CIwUIAnimDataLocator
{
public:
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    virtual ~CIwUIAnimDataLocator() {}





    template<class Type>
    bool GetCurrent(const char* propDef, Type& val, int32& time)
    {
        ResetCurrent();

        while(const CIwPropertySet* pPropertySet = GetCurrent(time))
        {
            if (pPropertySet->GetProperty(propDef, val, true))
            {
                return true;
            }
            DecrementCurrent();
        }
        return false;
    }





    template<class Type>
    bool GetNext(const char* propDef, Type& val, int32& time)
    {
        ResetNext();

        while(const CIwPropertySet* pPropertySet = GetNext(time))
        {
            if (pPropertySet->GetProperty(propDef, val, true))
            {
                return true;
            }
            IncrementNext();
        }
        return false;
    }


    virtual void ResetCurrent() = 0;


    virtual void DecrementCurrent() = 0;


    virtual const CIwPropertySet* GetCurrent(int32& time) = 0;


    virtual void ResetNext() = 0;


    virtual void IncrementNext() = 0;


    virtual const CIwPropertySet* GetNext(int32& time) = 0;





    virtual const CIwPropertySet* GetBase() const = 0;





    virtual CIwPropertySet* CreateDestination() = 0;
};
# 151 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimData.h"
class CIwUIAnimData
{
public:
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUIAnimData(int32 time, const CIwVec2& scale,
        CIwUIAnimDataLocator* pLocator);
# 169 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimData.h"
    template<class Type>
    bool AnimateProperty(const char* propDef, Type& val) const
    {
        if (QueryAnimationValue(propDef, val))
        {

            return StoreAnimationValue(propDef, val);
        }


        return false;
    }





    template<class Type>
    bool AnimateScaledProperty(const char* propDef, Type& val) const
    {
        Type unscaledVal;
        if (QueryAnimationValue(propDef, unscaledVal))
        {
            val[0] = IW_FIXED_MUL(m_Scale[0], unscaledVal[0]);
            val[1] = IW_FIXED_MUL(m_Scale[1], unscaledVal[1]);


            return StoreAnimationValue(propDef, val);
        }

        return false;
    }






    void AnimateDrawableStyle(IIwUIDrawable* pDrawable,
        const char* pStyleName) const;
# 221 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimData.h"
    void AnimateElementStyles(CIwUIElement* pParentElement,
        const CIwArray<CIwUIElement*>& childElements,
        const char* pStyleListName) const;




    const CIwPropertySet& GetPropertySet() const;

private:

    template<class Type>
    inline bool QueryAnimationValue(const char* propDef, Type& val) const
    {
        Type startVal; int32 startTime = -1;
        if(!m_Locator->GetCurrent(propDef, startVal, startTime))
        {

            return false;
        }

        if (startTime > m_Time)
        {

            return false;
        }

        Type endVal; int32 endTime = -1;
        if (startTime == m_Time)
        {
            val = startVal;
        }
        else if (m_Locator->GetNext(propDef, endVal, endTime))
        {

            const iwfixed prop = GetProportion(startTime, endTime);
            val = CIwUIAnimDataType<typename CIwPropertyTypeMap<Type>::Val>::Interpolate(
                startVal, endVal, prop);
        }
        else
        {

            val = startVal;
        }

        return true;
    }

    template<class Type>
    inline bool StoreAnimationValue(const char* propDef, Type& val) const
    {

        Type currVal;
        const CIwPropertySet* pBase = m_Locator->GetBase();
        if (pBase)
        {
            if (pBase->GetProperty(propDef, currVal, true) && (currVal == val))
            {

                return false;
            }
        }



        m_Locator->CreateDestination()->SetProperty(propDef, val);

        return true;
    }

    inline iwfixed GetProportion(int32 startTime, int32 endTime) const
    {
        return startTime < endTime ?
            IW_FIXED_DIV(m_Time - startTime, endTime - startTime) :
            (1 << 12);
    }

    const int32 m_Time;
    const CIwVec2 m_Scale;
    CIwUIAnimDataLocator* m_Locator;
};
# 321 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimData.h"
;
;
;
;
;
;
;
;
;
;
;
;
# 24 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIColour.h" 1
# 27 "c:/marmalade/6.2/modules/iwui/h/IwUIColour.h"
template<> class CIwPropertyTypeMap<class CIwUIColour > { public: typedef CIwColour Val; };
# 37 "c:/marmalade/6.2/modules/iwui/h/IwUIColour.h"
class CIwUIColour : public CIwColour
{
public:





    CIwUIColour();
    CIwUIColour(uint32 rgba);
    CIwUIColour(uint8 _r, uint8 _g, uint8 _b, uint _a = 0xff);
    CIwUIColour(const CIwColour& c);
    CIwUIColour(IwGxColourFixed fixedCol);
# 62 "c:/marmalade/6.2/modules/iwui/h/IwUIColour.h"
    CIwColour& operator= (const CIwColour& other);






    const CIwUIColour operator* (const CIwUIColour& other) const;







    CIwColour& operator*= (const CIwColour& other){ return (*this = (*this) * other); }






    uint8& operator[] (int n) { return (&r)[n]; }
    const uint8& operator[] (int n) const { return (&r)[n]; }
# 98 "c:/marmalade/6.2/modules/iwui/h/IwUIColour.h"
    void Parse(CIwTextParserITX* pParser);




    void Serialise();





    void SetColourFixed(IwGxColourFixed fixedCol);

};
# 25 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIElementSignal.h" 1
# 19 "c:/marmalade/6.2/modules/iwui/h/IwUIElementSignal.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwPropertyList.h" 1
# 25 "c:/marmalade/6.2/modules/iwui/h/IwPropertyList.h"
extern bool s_ParsingPropertyList;
# 44 "c:/marmalade/6.2/modules/iwui/h/IwPropertyList.h"
template <typename Type, typename DataType = CIwPropertyDataType<Type> >
class CIwPropertyList : private CIwParseable
{
public:

    CIwPropertyList() : m_Impl(__null)
    {

    }

    CIwPropertyList(const CIwPropertyList& rhs)
    {
        m_Impl = rhs.m_Impl;
        if (m_Impl)
        {
            m_Impl->AddRef();
        }
    }

    template<class InType>
    CIwPropertyList(const InType* pFirst, const InType* pLast) : m_Impl(__null)
    {
        for(const InType* pIt = pFirst; pIt != pLast; ++pIt)
        {
            push_back(*pIt);
        }
    }

    CIwPropertyList& operator=(const CIwPropertyList& rhs)
    {
        class CIwPropertyListImpl* pOldImpl = m_Impl;
        m_Impl = rhs.m_Impl;
        if (m_Impl)
        {
            m_Impl->AddRef();
        }
        if (pOldImpl)
        {
            pOldImpl->ReleaseRef();
        }
        return *this;
    }

    ~CIwPropertyList()
    {
        if (m_Impl)
        {
            m_Impl->ReleaseRef();
            m_Impl = __null;
        }
    }


    void push_back(const Type& object)
    {
        _EnsureOwnsImpl();


        m_Impl->push_back(object);
    }

    void Parse(CIwTextParserITX* pParser)
    {





    }

    virtual void ParseOpen(CIwTextParserITX* pParser)
    {
# 128 "c:/marmalade/6.2/modules/iwui/h/IwPropertyList.h"
    }

    virtual void ParseClose(CIwTextParserITX* pParser)
    {

    }

    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName)
    {
# 149 "c:/marmalade/6.2/modules/iwui/h/IwPropertyList.h"
        return false;

    }

    void Decompose(CIwTextDecomposer* pDecomposer) const
    {
        pDecomposer->OpenScope(true);

        for (int i=0; i<size(); i++)
        {
            DataType::Decompose((*this)[i], pDecomposer);
        }

        pDecomposer->CloseScope(true);
    }

    void Serialise()
    {

        int32 num;
        if (IwSerialiseIsWriting())
        {
            num = size();
        }
        IwSerialiseInt32(num);


        if (IwSerialiseIsReading() && num)
        {
            m_Impl = new CIwPropertyListImpl;
            m_Impl->AddRef();


            m_Impl->reserve(num);
            for (int i = 0; i < num; ++i)
            {
                m_Impl->push_back();
                DataType::Serialise(m_Impl->back());
            }
        }

        if (IwSerialiseIsWriting())
        {
            for (int i = 0; i < num; ++i)
            {
                DataType::Serialise((*m_Impl)[i]);
            }
        }
    }

    void Resolve()
    {
        int num = m_Impl->size();
        for (int i = 0; i < num; ++i)
        {
            DataType::Resolve((*m_Impl)[i]);
        }
    }

    void Clone(const CIwPropertyList& other)
    {
        if (m_Impl)
        {
            m_Impl->ReleaseRef();
            m_Impl = __null;
        }

        if (other.m_Impl)
        {
            m_Impl = new CIwPropertyListImpl;
            m_Impl->AddRef();

            int num = other.size();
            m_Impl->reserve(num);
            for (int i=0; i<num; i++)
            {
                const Type& srcData = (*other.m_Impl)[i];
                Type clonedData;
                DataType::Clone(srcData, clonedData);
                m_Impl->push_back(clonedData);
            }
        }
    }


    int size() const
    {
        return m_Impl ? m_Impl->size() : 0;
    }

    const Type& operator[](int i) const
    {
        ((void)0);


        return m_Impl ? m_Impl->operator[](i) : *(Type*)__null;
    }

    Type& expose_index(int i)
    {
        ((void)0);


        _EnsureOwnsImpl();

        return m_Impl->operator[](i);
    }

    bool contains(const Type& value) const
    {
        return m_Impl ? m_Impl->contains(value) : false;
    }

    int erase(int i)
    {
        _EnsureOwnsImpl();

        return m_Impl->erase(i);
    }

    bool operator==(const CIwPropertyList& rhs) const
    {
        if (m_Impl == rhs.m_Impl)
        {
            return true;
        }

        if (size() != rhs.size())
        {
            return false;
        }

        for (int i = 0; i < size(); ++i)
        {
            if (!(operator[](i) == rhs[i]))
            {
                return false;
            }
        }

        return true;
    }

private:

    class CIwPropertyListImpl : public IwProperty<Type>::Array
    {
    public:
        void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwPropertyGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwPropertyGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

        CIwPropertyListImpl() : m_RefCount(0)
        {

        }

        CIwPropertyListImpl(const CIwPropertyListImpl& other) :
            CIwArray<Type, CIwPropertyAllocator<Type> >(other), m_RefCount(0)
        {

        }


        void AddRef()
        {
            m_RefCount += 1;
        }

        void ReleaseRef()
        {
            ((void)0);

            --m_RefCount;
            if (!m_RefCount)
            {
                delete this;
            }
        }

        bool IsShared() const
        {
            return m_RefCount > 1;
        }

    private:

        int m_RefCount;
    };

    void _EnsureOwnsImpl()
    {


        if (m_Impl)
        {
            if (m_Impl->IsShared())
            {
                m_Impl->ReleaseRef();
                m_Impl = new CIwPropertyListImpl(*m_Impl);
                m_Impl->AddRef();
            }
        }
        else
        {
            m_Impl = new CIwPropertyListImpl;
            m_Impl->AddRef();
        }
    }

    char _PeekPreviousChar(CIwTextParserITX* pParser)
    {
        pParser->UnreadChar();
        char c = pParser->ReadChar();

        return c;
    }

    void _UnreadToken(CIwTextParserITX* pParser, const char* pToken)
    {

        char c = _PeekPreviousChar(pParser);

        bool quoted = c == '\"';

        pParser->UnreadChar();

        if (c == '\n' || c == '\r')
            pParser->UnreadChar();
        while(c)
        {
            c = _PeekPreviousChar(pParser);

            if (!quoted && pParser->IsWhitespace(c))
            {
                break;
            }
            else if (c == '\"')
            {
                pParser->UnreadChar();
                c = _PeekPreviousChar(pParser);
                if (c != '\\')
                {
                    if (!quoted)
                        pParser->ReadChar();
                    break;
                }
            }

            pParser->UnreadChar();
        }
    }


    CIwPropertyListImpl* m_Impl;
};




# 20 "c:/marmalade/6.2/modules/iwui/h/IwUIElementSignal.h" 2


# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h" 1
# 75 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template<class Type>
class IDelegateParamType
{
public:
    static const char* s_String;
    static uint32 s_Hash;
};
# 90 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
class IDelegateQuery
{
public:
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }


    typedef IwUI<IDelegateQuery*>::Array Array;
    typedef Array::iterator ArrayIt;


    virtual ~IDelegateQuery() {}

    virtual bool AddDelegate(IDelegateQuery* pDelegate)
    {
        ((void)0);

        return false;
    }
    virtual bool RemoveDelegate(IDelegateQuery* pDelegate)
    {
        ((void)0);

        return false;
    }
    virtual bool RemoveDelegatesByHandler(void* pHandler)
    {
        ((void)0);

        return false;
    }
    virtual bool RemoveDelegateByHash(uint32 hash)
    {
        ((void)0);
        return false;
    }

    virtual void* GetHandler() const = 0;
    virtual uint32 GetHash() const = 0;
    virtual int GetNumParams() const = 0;
    virtual uint32 GetParamHash(int i) const = 0;
    virtual const char* GetParamString(int i) const = 0;

    bool MatchSignature(IDelegateQuery& delegate)
    {
        int params = delegate.GetNumParams();
        if(GetNumParams() == params)
        {
            for(int i=0; i<params; i++)
            {
                if(GetParamHash(i) != delegate.GetParamHash(i))
                    return false;
            }
            return true;
        }
        return false;
    }
};
# 155 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
class IDelegate0 : public IDelegateQuery
{
public:

    typedef IwUI<IDelegate0*>::Array Array;
    typedef Array::iterator ArrayIt;

    virtual void operator() () = 0;

    virtual int GetNumParams() const { return 0; }
    virtual uint32 GetParamHash(int i) const { return 0; }
    virtual const char* GetParamString(int i) const { return __null; }
};
# 176 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template <typename Param1>
class IDelegate1 : public IDelegateQuery
{
public:
    typedef typename IwUI<IDelegate1*>::Array Array; typedef typename Array::iterator ArrayIt;;
    virtual void operator() (Param1) = 0;

    virtual int GetNumParams() const { return 1; }
    virtual uint32 GetParamHash(int i) const
    {
        switch(i) {
            case 0: return IDelegateParamType<Param1>::s_Hash;
            default: return 0;
        }
    }
    virtual const char* GetParamString(int i) const
    {
        switch(i) {
            case 0: return IDelegateParamType<Param1>::s_String;
            default: return __null;
        }
    }
};
# 207 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template <typename Param1, typename Param2>
class IDelegate2 : public IDelegateQuery
{
public:
    typedef typename IwUI<IDelegate2*>::Array Array; typedef typename Array::iterator ArrayIt;;
    virtual void operator() (Param1, Param2) = 0;

    virtual int GetNumParams() const { return 2; }
    virtual uint32 GetParamHash(int i) const
    {
        switch(i) {
            case 0: return IDelegateParamType<Param1>::s_Hash;
            case 1: return IDelegateParamType<Param2>::s_Hash;
            default: return 0;
        }
    }
    virtual const char* GetParamString(int i) const
    {
        switch(i) {
            case 0: return IDelegateParamType<Param1>::s_String;
            case 1: return IDelegateParamType<Param2>::s_String;
            default: return __null;
        }
    }
};
# 240 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template <typename Param1, typename Param2, typename Param3>
class IDelegate3 : public IDelegateQuery
{
public:
    typedef typename IwUI<IDelegate3*>::Array Array; typedef typename Array::iterator ArrayIt;;
    virtual void operator() (Param1, Param2, Param3) = 0;

    virtual int GetNumParams() const { return 3; }
    virtual uint32 GetParamHash(int i) const
    {
        switch(i) {
            case 0: return IDelegateParamType<Param1>::s_Hash;
            case 1: return IDelegateParamType<Param2>::s_Hash;
            case 2: return IDelegateParamType<Param3>::s_Hash;
            default: return 0;
        }
    }
    virtual const char* GetParamString(int i) const
    {
        switch(i) {
            case 0: return IDelegateParamType<Param1>::s_String;
            case 1: return IDelegateParamType<Param2>::s_String;
            case 2: return IDelegateParamType<Param3>::s_String;
            default: return __null;
        }
    }
};
# 285 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template <typename Handler, typename Member, typename Interface>
class CIwUISlot_ : public Interface
{
public:
    CIwUISlot_() : m_Handler(__null), m_Member(__null), m_Hash(__null)
    {
    }

    CIwUISlot_(Handler* pHandler, const char* pSlotName, Member pMember) :
        m_Handler(pHandler), m_Member(pMember)
    {
        m_Hash = IwHashString(pSlotName);
    }

    CIwUISlot_(const CIwUISlot_& slot) :
        m_Member(slot.m_Member),
        m_Handler(slot.m_Handler),
        m_Hash(slot.m_Hash)
    {
    }

    CIwUISlot_& operator = (const CIwUISlot_& slot)
    {
        m_Member = slot.m_Member;
        m_Handler = slot.m_Handler;
        m_Hash = slot.m_Hash;

        return *this;
    }

    bool operator == (const CIwUISlot_& slot) const
    {
        return (m_Member == slot.m_Member) && (m_Handler == slot.m_Handler) &&
            (m_Hash == slot.m_Hash);
    }


    virtual void* GetHandler() const { return m_Handler; }
    virtual uint32 GetHash() const { return m_Hash; }

protected:
    Member m_Member;
    Handler* m_Handler;

private:
    uint32 m_Hash;
};
# 344 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template <typename Handler, typename Interface = IDelegate0>
class CIwUISlot : public CIwUISlot_<Handler, void (Handler::*)(), Interface>
{
public:
    typedef void (Handler::*Member)();
    typedef CIwUISlot_<Handler, Member, Interface> CIwUISlotBase; CIwUISlot() : CIwUISlotBase() {} CIwUISlot(Handler* pHandler, const char* pSlotName, Member pMember) : CIwUISlotBase(pHandler, pSlotName, pMember) {} CIwUISlot(const CIwUISlot& slot) : CIwUISlotBase(slot) {};

    virtual void operator() ()
    {
        (CIwUISlotBase::m_Handler->*CIwUISlotBase::m_Member)();
    }
};
# 364 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template <typename Handler, typename Param1, typename Interface = IDelegate1<Param1> >
class CIwUISlot1 : public CIwUISlot_<Handler, void (Handler::*)(Param1), Interface>
{
public:
    typedef void (Handler::*Member)(Param1);
    typedef CIwUISlot_<Handler, Member, Interface> CIwUISlotBase; CIwUISlot1() : CIwUISlotBase() {} CIwUISlot1(Handler* pHandler, const char* pSlotName, Member pMember) : CIwUISlotBase(pHandler, pSlotName, pMember) {} CIwUISlot1(const CIwUISlot1& slot) : CIwUISlotBase(slot) {};

    virtual void operator() (Param1 param1)
    {
        (CIwUISlotBase::m_Handler->*CIwUISlotBase::m_Member)(param1);
    }
};
# 384 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template <typename Handler, typename Param1, typename Param2,
    typename Interface = IDelegate2<Param1, Param2> >
class CIwUISlot2 :
    public CIwUISlot_<Handler, void (Handler::*)(Param1, Param2), Interface>
{
public:
    typedef void (Handler::*Member)(Param1, Param2);
    typedef CIwUISlot_<Handler, Member, Interface> CIwUISlotBase; CIwUISlot2() : CIwUISlotBase() {} CIwUISlot2(Handler* pHandler, const char* pSlotName, Member pMember) : CIwUISlotBase(pHandler, pSlotName, pMember) {} CIwUISlot2(const CIwUISlot2& slot) : CIwUISlotBase(slot) {};

    virtual void operator() (Param1 param1, Param2 param2)
    {
        (CIwUISlotBase::m_Handler->*CIwUISlotBase::m_Member)(param1, param2);
    }
};
# 406 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template <typename Handler, typename Param1, typename Param2, typename Param3,
    typename Interface = IDelegate3<Param1, Param2, Param3> >
class CIwUISlot3 :
    public CIwUISlot_<Handler, void (Handler::*)(Param1, Param2, Param3), Interface>
{
public:
    typedef void (Handler::*Member)(Param1, Param2, Param3);
    typedef CIwUISlot_<Handler, Member, Interface> CIwUISlotBase; CIwUISlot3() : CIwUISlotBase() {} CIwUISlot3(Handler* pHandler, const char* pSlotName, Member pMember) : CIwUISlotBase(pHandler, pSlotName, pMember) {} CIwUISlot3(const CIwUISlot3& slot) : CIwUISlotBase(slot) {};

    virtual void operator() (Param1 param1, Param2 param2, Param3 param3)
    {
        (CIwUISlotBase::m_Handler->*CIwUISlotBase::m_Member)(param1, param2, param3);
    }
};
# 436 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template <typename Interface>
class CIwUISignal_ : public Interface
{
public:
    CIwUISignal_() : m_Hash(0) {}
    CIwUISignal_(uint32 hash) : m_Hash(hash) {}


    void AddSlot(Interface& handler)
    {
        ((void)0);


        m_Handlers.push_back(&handler);
    }

    bool RemoveSlot(Interface& handler)
    {
        return RemoveDelegate(&handler);
    }


    virtual bool AddDelegate(IDelegateQuery* pDelegate)
    {
        ((void)0);


        if(Interface::MatchSignature(*pDelegate))
        {
            Interface* pInterface = IwSafeCast<Interface*>(pDelegate);
            AddSlot(*pInterface);
            return true;
        }

        return false;
    }

    virtual bool RemoveDelegate(IDelegateQuery* pDelegate)
    {
        bool found = false;
        for (int i=0; i<(int)m_Handlers.size();)
        {
            if (pDelegate == m_Handlers[i])
            {
                m_Handlers.erase(i);
                found = true;
            }
            else
            {
                i++;
            }
        }
        return found;
    }

    virtual bool RemoveDelegatesByHandler(void* pHandler)
    {
        ((void)0);


        bool found = false;
        for (int i=0; i<(int)m_Handlers.size();)
        {
            if (pHandler == m_Handlers[i]->GetHandler())
            {
                m_Handlers.erase(i);
                found = true;
            }
            else
            {
                found |= m_Handlers[i]->RemoveDelegatesByHandler(pHandler);
                i++;
            }
        }
        return found;
    }

    virtual bool RemoveDelegateByHash(uint32 hash)
    {
        ((void)0);

        bool found = false;
        for (int i=0; i<(int)m_Handlers.size();)
        {
            if (hash == m_Handlers[i]->GetHash())
            {
                m_Handlers.erase(i);
                found = true;
            }
            else
            {
                found |= m_Handlers[i]->RemoveDelegateByHash(hash);
                i++;
            }
        }
        return found;
    }

    virtual uint32 GetHash() const { return m_Hash; }
    virtual void* GetHandler() const { return __null; }

protected:

    typename Interface::ArrayIt HandlersBegin() const
    {
        return m_Handlers.begin();
    }

    typename Interface::ArrayIt HandlersEnd() const
    {
        return m_Handlers.end();
    }

private:

    CIwUISignal_& operator = (const CIwUISignal_& slot);
    bool operator == (const CIwUISignal_& slot) const;


    uint32 m_Hash;
    typename Interface::Array m_Handlers;
};
# 570 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template <typename Interface = IDelegate0>
class CIwUISignal : public CIwUISignal_<Interface>
{
public:
    typedef CIwUISignal_<Interface> CIwUISignalBase; CIwUISignal() : CIwUISignalBase() {} CIwUISignal(uint32 hash) : CIwUISignalBase(hash) {};

    virtual void operator() ()
    {
        typename Interface::ArrayIt iter;
        for (iter = CIwUISignalBase::HandlersBegin();
            iter < CIwUISignalBase::HandlersEnd(); ++iter)
        {
            (*iter)->operator()();
        }
    }
};
# 594 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template <typename Param1, typename Interface = IDelegate1<Param1> >
class CIwUISignal1 : public CIwUISignal_<Interface>
{
public:
    typedef CIwUISignal_<Interface> CIwUISignalBase; CIwUISignal1() : CIwUISignalBase() {} CIwUISignal1(uint32 hash) : CIwUISignalBase(hash) {};

    virtual void operator() (Param1 param1)
    {
        typename Interface::ArrayIt iter;
        for (iter = CIwUISignalBase::HandlersBegin();
            iter < CIwUISignalBase::HandlersEnd(); ++iter)
        {
            (*iter)->operator()(param1);
        }
    }
};
# 618 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template <typename Param1, typename Param2,
    typename Interface = IDelegate2<Param1, Param2> >
class CIwUISignal2 : public CIwUISignal_<Interface>
{
public:
    typedef CIwUISignal_<Interface> CIwUISignalBase; CIwUISignal2() : CIwUISignalBase() {} CIwUISignal2(uint32 hash) : CIwUISignalBase(hash) {};

    virtual void operator() (Param1 param1, Param2 param2)
    {
        typename Interface::ArrayIt iter;
        for (iter = CIwUISignalBase::HandlersBegin();
            iter < CIwUISignalBase::HandlersEnd(); ++iter)
        {
            (*iter)->operator()(param1, param2);
        }
    }
};
# 643 "c:/marmalade/6.2/modules/iwui/h/IwUIDelegate.h"
template <typename Param1, typename Param2, typename Param3,
    typename Interface = IDelegate3<Param1, Param2, Param3> >
class CIwUISignal3 : public CIwUISignal_<Interface>
{
public:
    typedef CIwUISignal_<Interface> CIwUISignalBase; CIwUISignal3() : CIwUISignalBase() {} CIwUISignal3(uint32 hash) : CIwUISignalBase(hash) {};

    virtual void operator() (Param1 param1, Param2 param2, Param3 param3)
    {
        typename Interface::ArrayIt iter;
        for (iter = CIwUISignalBase::HandlersBegin();
            iter < CIwUISignalBase::HandlersEnd(); ++iter)
        {
            (*iter)->operator()(param1, param2, param3);
        }
    }
};
# 23 "c:/marmalade/6.2/modules/iwui/h/IwUIElementSignal.h" 2
# 31 "c:/marmalade/6.2/modules/iwui/h/IwUIElementSignal.h"
class CIwUIElement;
# 337 "c:/marmalade/6.2/modules/iwui/h/IwUIElementSignal.h"
class CIwUIElementSignalBase
{
public:
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUIElementSignalBase();
    CIwUIElementSignalBase(const CIwUIElementSignalBase& other);
    virtual ~CIwUIElementSignalBase();


    virtual IDelegateQuery* CreateSignal(uint32 signalNameHash) const = 0;


    void AddSlotReference(bool classNotObjectName, const char* pOwnerName,
        const char* pSlotName);
    bool RemoveSlotReference(bool classNotObjectName, const char* pOwnerName,
        const char* pSlotName);

    void AttachSlots(CIwUIElement* pSignalOwner, IDelegateQuery* pSignal) const;
    void Parse(CIwTextParserITX* pParser);
    void Decompose(CIwTextDecomposer* pDecomposer) const;
    void Serialise();


    CIwUIElementSignalBase& operator = (const CIwUIElementSignalBase& src);
    bool operator == (const CIwUIElementSignalBase& other) const;


    static const uint32 s_ClassNameHash;

protected:

    class SlotReference
    {
    public:
        SlotReference(bool classNotObjectName, const char* pOwnerName,
            const char* pSlotName);
        SlotReference(const SlotReference& other);
        SlotReference();

        typedef CIwPropertyList<SlotReference> Array;

        void Parse(CIwTextParserITX* pParser);
        void Decompose(CIwTextDecomposer* pDecomposer) const;
        void Serialise();
        void Resolve();
        void Clone(const SlotReference& other);

        CIwStringL DebugGetSlotName() const;

        IDelegateQuery* LookupSlot(CIwUIElement* pContext) const;

        bool operator == (const SlotReference& other) const;

    private:
        bool m_ClassNotObjectName;
        uint32 m_OwnerName;
        uint32 m_SlotName;
    };

    friend class CIwPropertyDataType<SlotReference>;

private:

    SlotReference::Array m_SlotReferences;
};



template<class Signal>
class CIwUIElementSignal : public CIwUIElementSignalBase
{
public:
    CIwUIElementSignal() : CIwUIElementSignalBase() {}
    CIwUIElementSignal(const CIwUIElementSignal& other) :
        CIwUIElementSignalBase(other) {}
    virtual ~CIwUIElementSignal() {}


    bool operator == (const CIwUIElementSignal& other) const
    {
        return CIwUIElementSignalBase::operator ==(other);
    }

private:

    virtual IDelegateQuery* CreateSignal(uint32 signalNameHash) const
    {
        return new Signal(signalNameHash);
    }
};



template<class Element>
bool CallSignal(Element* pElement, const char* pSignalName)
{
    IDelegate0* pSignal = __null;
    if((pSignal = IwSafeCast<IDelegate0*>(
        pElement->GetDelegate(IwHashString(pSignalName)))))
    {
        (*pSignal)();
        return true;
    }
    return false;
}

template<class Param1, class Element>
bool CallSignal1(Element* pElement, const char* pSignalName,
    const Param1& param1)
{
    IDelegate1<Param1>* pSignal = __null;
    if((pSignal = IwSafeCast<IDelegate1<Param1>*>(
        pElement->GetDelegate(IwHashString(pSignalName)))))
    {
        (*pSignal)(param1);
        return true;
    }
    return false;
}

template<class Param1, class Param2, class Element>
bool CallSignal2(Element* pElement, const char* pSignalName,
    const Param1& param1, const Param2& param2)
{
    IDelegate2<Param1, Param2>* pSignal = __null;
    if((pSignal = IwSafeCast<IDelegate2<Param1, Param2>*>(
        pElement->GetDelegate(IwHashString(pSignalName)))))
    {
        (*pSignal)(param1, param2);
        return true;
    }
    return false;
}

template<class Param1, class Param2, class Param3, class Element>
bool CallSignal3(Element* pElement, const char* pSignalName,
    const Param1& param1, const Param2& param2, const Param3& param3)
{
    IDelegate3<Param1, Param2, Param3>* pSignal = __null;
    if((pSignal = IwSafeCast<IDelegate3<Param1, Param2, Param3>*>(
        pElement->GetDelegate(IwHashString(pSignalName)))))
    {
        (*pSignal)(param1, param2, param3);
        return true;
    }
    return false;
}
# 539 "c:/marmalade/6.2/modules/iwui/h/IwUIElementSignal.h"

# 27 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIEventHandler.h" 1
# 20 "c:/marmalade/6.2/modules/iwui/h/IwUIEventHandler.h"
class CIwEvent;
# 34 "c:/marmalade/6.2/modules/iwui/h/IwUIEventHandler.h"
class IIwUIEventHandler
{
public:
    virtual ~IIwUIEventHandler() {}

    typedef IwUI<IIwUIEventHandler*>::Array Array;
    typedef Array::iterator ArrayIt;
# 53 "c:/marmalade/6.2/modules/iwui/h/IwUIEventHandler.h"
    virtual bool HandleEvent(CIwEvent* pEvent) = 0;






    virtual bool FilterEvent(CIwEvent* pEvent) = 0;

};
# 28 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIFuncs.h" 1
# 24 "c:/marmalade/6.2/modules/iwui/h/IwUIFuncs.h"
class CIwPropertySet;
class CIwUIStyle;
class CIwSVec2;
class CIwVec2;
class CIwUIController;
class CIwUIView;
class IIwUIDrawable;


extern bool g_IwUIAssertCloneOverride;


typedef IIwUIDrawable*(*IwUIDrawableFactoryFn)(const CIwVec2& size,
    const CIwPropertySet& propertySet);






void IwUIInit();






void IwUITerminate();




void IwUIReserveFontBuffers(int32 numChars, int32 numLines);




void IwUIFreeFontBuffers();





void IwUIAddDrawableFactory(const char* pDrawableName,
    IwUIDrawableFactoryFn facFunc);





void IwUIRemoveDrawableFactory(const char* pDrawableName);
# 84 "c:/marmalade/6.2/modules/iwui/h/IwUIFuncs.h"
IIwUIDrawable* IwUICreateDrawable(const CIwUIStyle& style,
    const CIwVec2& size, const char* defaultType = __null);
# 96 "c:/marmalade/6.2/modules/iwui/h/IwUIFuncs.h"
IIwUIDrawable* IwUICreateDrawable(const CIwVec2& size,
    const CIwPropertySet& propertySet, const char* defaultType = __null);
# 106 "c:/marmalade/6.2/modules/iwui/h/IwUIFuncs.h"
IIwUIDrawable* IwUICreateDrawable(uint32 classHash,
    const CIwVec2& size, const CIwPropertySet& propertySet);





typedef const char*(*IwUILocaliseCallbackFunc)(const CIwPropertySet&);





void IwUISetLocaliseCallback(IwUILocaliseCallbackFunc func);





IwUILocaliseCallbackFunc IwUIGetLocaliseCallback();






const char* IwUILocaliseCallback(const CIwPropertySet& pset);





bool IwUIShouldDisplayFocus();





void IwUISetDisplayFocus(bool displayFocus);







int32 IwUIGetDragTolerance();







void IwUISetDragTolerance(int32 tolerance);
# 29 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutPolicy.h" 1
# 18 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutPolicy.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIRect.h" 1
# 34 "c:/marmalade/6.2/modules/iwui/h/IwUIRect.h"
class CIwUIRect : public CIwRect32
{
public:
    CIwUIRect();
    CIwUIRect(iwfixed _x, iwfixed _y, iwfixed _w, iwfixed _h);
    CIwUIRect(const CIwVec2& pos, const CIwVec2& size);
    CIwUIRect(const CIwRect32& r);
    CIwUIRect(const CIwRect& r);

    static const CIwUIRect g_Zero;





    CIwRect32& operator = (const CIwRect32& r);


    CIwUIRect operator << (int32 s) const;


    CIwUIRect operator >> (int32 s) const;


    CIwUIRect operator * (iwfixed s) const;


    bool operator == (const CIwUIRect& r) const;


    bool operator != (const CIwUIRect& r) const;





    void Clone(const CIwUIRect& rect) { *this = rect; }


    void Parse(CIwTextParserITX* pParser);


    void Decompose(CIwTextDecomposer* pDecomposer) const;


    void Serialise();


    void Resolve() {}


    CIwUIRect& Translate(const CIwVec2& v) { x += v.x; y += v.y; return *this; }


    CIwUIRect Intersection(const CIwUIRect& rect) const;


    CIwUIRect Union(const CIwUIRect& rect) const;


    CIwUIRect Bound(const CIwVec2& pt) const;


    CIwUIRect& Normalise();




    void DebugRender(iwfixed scale = (1 << 12),
        CIwUIColour col = IwGxGetColFixed(IW_GX_COLOUR_MAGENTA)) const;




    void DebugRender(const CIwMat& matViewScreen,
        CIwUIColour col = IwGxGetColFixed(IW_GX_COLOUR_MAGENTA)) const;




    void DebugRenderCorners(iwfixed scale = (1 << 12),
        CIwUIColour col = IwGxGetColFixed(IW_GX_COLOUR_MAGENTA)) const;




    void DebugRenderCorners(const CIwMat& matViewScreen,
        CIwUIColour col = IwGxGetColFixed(IW_GX_COLOUR_MAGENTA)) const;




    CIwVec2 GetPosition() const { return CIwVec2(x, y); }
    void SetPosition(const CIwVec2& pos) { x = pos.x; y = pos.y; }

    CIwVec2 GetSize() const { return CIwVec2(w,h); }
    void SetSize(const CIwVec2& size) { w = size.x; h = size.y; }

    CIwVec2 GetCentre() const { return CIwVec2(x + w/2, y + h/2); }
    void SetCentre(const CIwVec2& centre) { x = centre.x - w/2, y = centre.y - h/2; }

    CIwVec2 GetTopLeft() const { return CIwVec2(x, y); }
    CIwVec2 GetTopRight() const { return CIwVec2(x + w, y); }
    CIwVec2 GetBottomLeft() const { return CIwVec2(x, y + h); }
    CIwVec2 GetBottomRight() const { return CIwVec2(x + w, y + h); }

    CIwVec2 GetCorner(int i) const;





    bool IsEmpty() const { return (w == 0) || (h == 0); }


    bool Intersects(const CIwUIRect& rect) const;


    bool Contains(const CIwUIRect& rect) const;


    bool Intersects(const CIwVec2& pos) const;


    bool IsNormalised() const { return (w >= 0) && (h >= 0); }


    int32 Area() const { return IW_MULCHECK(w, h); }
};


# 19 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutPolicy.h" 2





class CIwPropertySet;
# 41 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutPolicy.h"
class CIwUISizePolicy
{
public:
    CIwUISizePolicy() :
        m_Min(0, 0),
        m_Max(0x7fffffffL, 0x7fffffffL),
        m_Hint(0x7fffffffL, 0x7fffffffL),
        m_AspectRatio(0x7fffffffL, 0x7fffffffL)
    {
    }







    void Setup(const CIwPropertySet& propertySet);
    void SetupAspectRatio(const CIwPropertySet& propertySet);
    void SetupHint(const CIwPropertySet& propertySet);
    void SetupMin(const CIwPropertySet& propertySet);
    void SetupMax(const CIwPropertySet& propertySet);




    void Store(CIwPropertySet& propertySet);
    void StoreAspectRatio(CIwPropertySet& propertySet);
    void StoreHint(CIwPropertySet& propertySet);
    void StoreMin(CIwPropertySet& propertySet);
    void StoreMax(CIwPropertySet& propertySet);
# 82 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutPolicy.h"
    CIwVec2 Apply(const CIwVec2& size, bool applyHint = true,
        bool shrinkNotExpandToAspect = true) const;


    void SetAspectRatio(const CIwVec2& ratio);
    void SetHint(const CIwVec2& hint);
    void SetMin(const CIwVec2& min);
    void SetMax(const CIwVec2& max);


    const CIwVec2& GetAspectRatio() const { return m_AspectRatio; }
    const CIwVec2& GetHint() const { return m_Hint; }
    const CIwVec2& GetMin() const { return m_Min; }
    const CIwVec2& GetMax() const { return m_Max; }


    bool IsSizeHintSet() const;
    bool IsAspectRatioSet() const;

private:

    CIwVec2 ApplyHint(const CIwVec2& size) const;
    CIwVec2 ApplyMinAndMax(const CIwVec2& size) const;
    CIwVec2 ApplyAspectRatio(const CIwVec2& size, bool shrinkNotExpand) const;
    CIwVec2 InterpretMinimum(const CIwVec2& min) const;
    CIwVec2 InterpretUnbounded(const CIwVec2& size, bool retrieveNotStore) const;


    CIwVec2 m_Min;
    CIwVec2 m_Max;
    CIwVec2 m_Hint;
    CIwVec2 m_AspectRatio;
};
# 123 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutPolicy.h"
class CIwUIPositionPolicy
{
public:
    CIwUIPositionPolicy() :
        m_AlignH(IW_UI_ALIGN_LEFT),
        m_AlignV(IW_UI_ALIGN_TOP)
    {
    }







    void Setup(const CIwPropertySet& propertySet);
    void SetupAlignH(const CIwPropertySet& propertySet);
    void SetupAlignV(const CIwPropertySet& propertySet);




    void Store(CIwPropertySet& propertySet);
    void StoreAlignH(CIwPropertySet& propertySet);
    void StoreAlignV(CIwPropertySet& propertySet);







    CIwVec2 Apply(const CIwVec2& size, const CIwVec2& area,
        const CIwSVec2& border = CIwSVec2::g_Zero) const;


    void SetAlignH(IwUIAlignmentH alignH) { m_AlignH = alignH; }
    void SetAlignV(IwUIAlignmentV alignV) { m_AlignV = alignV; }


    IwUIAlignmentH GetAlignH() const { return m_AlignH; }
    IwUIAlignmentV GetAlignV() const { return m_AlignV; }

private:

    IwUIAlignmentH m_AlignH;
    IwUIAlignmentV m_AlignV;
};
# 30 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIMat.h" 1
# 35 "c:/marmalade/6.2/modules/iwui/h/IwUIMat.h"
typedef CIwMat2D CIwUIMat;
# 45 "c:/marmalade/6.2/modules/iwui/h/IwUIMat.h"
CIwUIRect IwUIGetTransformedBounds(const CIwUIMat& mat, const CIwUIRect& rect);
# 31 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIPropertySet.h" 1
# 21 "c:/marmalade/6.2/modules/iwui/h/IwUIPropertySet.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIStyle.h" 1
# 41 "c:/marmalade/6.2/modules/iwui/h/IwUIStyle.h"
class CIwPropertySet;
class CIwUIPropertySet;
class CIwUIStylesheet;
class CIwTextDecomposer;
# 53 "c:/marmalade/6.2/modules/iwui/h/IwUIStyle.h"
class CIwUIStyle : private CIwManaged
{
public:
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUIStyle();
    CIwUIStyle(const char* pName);
    CIwUIStyle(const CIwUIStyle& style);
    ~CIwUIStyle();


    operator bool() const;


    CIwUIStyle& operator=(const CIwUIStyle& rhs);
    bool operator==(const CIwUIStyle& rhs) const;


    void Parse(CIwTextParserITX* pParser);
    void Decompose(CIwTextDecomposer* pDecomposer) const;
    void Serialise();
    void Resolve();
    void Clone(const CIwUIStyle& src);
    void InlinePropertySet();


    bool HasInlinePropertySet() const;


    CIwUIPropertySet* GetInlinePropertySet();
    const CIwPropertySet* GetPropertySet(
        const CIwUIStylesheet* pContext = __null) const;
    uint32 GetHash() const;
    const char* DebugGetName() const;

private:

    CIwUIStyle(uint32 hash);


    virtual void ParseOpen(CIwTextParserITX* pParser);
    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
    virtual void ParseCloseChild(CIwTextParserITX* pParser, CIwManaged* pChild);
    virtual void ParseClose(CIwTextParserITX* pParser);


    virtual void SetName(const char* pName);


    void SetInlinePropertySet(CIwUIPropertySet& propertySet);


    CIwUIPropertySet* m_PropertySet;


    friend class CIwUIStylesheet;
};



# 22 "c:/marmalade/6.2/modules/iwui/h/IwUIPropertySet.h" 2


class CIwUIElement;
# 49 "c:/marmalade/6.2/modules/iwui/h/IwUIPropertySet.h"
class CIwUIPropertySet : public CIwPropertySet
{
public:
    typedef CIwArray<CIwUIPropertySet*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUIPropertySet();
    CIwUIPropertySet(const CIwUIPropertySet& propertySet);
    virtual ~CIwUIPropertySet();


    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
    virtual void ParseClose(CIwTextParserITX* pParser);
    virtual void Serialise();
    virtual void Resolve();


    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const;


    virtual void SetParent(const CIwPropertySet* pPropertySet);
    virtual const CIwPropertySet* GetParent() const;


    CIwUIPropertySet& operator= (const CIwUIPropertySet& other);


    void Clone(const CIwUIPropertySet& other);
    void AttachParentFromStyle();


    const CIwUIStyle& GetStyle() const;
    void SetStyle(const CIwUIStyle& style);

private:

    void _SetStylesheet(CIwUIStylesheet* pOwner);


    CIwUIStyle m_Style;


    CIwUIStylesheet* m_Stylesheet;


    friend class CIwUIStylesheet;
};
# 32 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h" 2


# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIVisitor.h" 1
# 17 "c:/marmalade/6.2/modules/iwui/h/IwUIVisitor.h"
class CIwUIElement;
class IIwUIDrawable;
class CIwUILayout;
class CIwUILayoutItemContainer;
class CIwUIElementItem;
class CIwUILayoutItem;
# 31 "c:/marmalade/6.2/modules/iwui/h/IwUIVisitor.h"
class IIwUIVisitor
{
public:
    virtual ~IIwUIVisitor() {}


    virtual void OnElement(CIwUIElement& element) = 0;
    virtual void OnDrawable(IIwUIDrawable& drawable) = 0;

    virtual void OnLayout(CIwUILayout& layout) = 0;
    virtual void OnLayoutItemContainer(CIwUILayoutItemContainer& container) = 0;
    virtual void OnLayoutItem(CIwUILayoutItem& item) = 0;
    virtual void OnLayoutElement(CIwUIElement& element) = 0;
};
# 35 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h" 2
# 55 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
class CIwUIDebugGraphics;
class CIwUIElementEventHandler;
class CIwUIElementItem;
class CIwUIElementPropertyBinding;
class CIwUIElementPtr;
class CIwUIEventKey;
class CIwUIEventChar;
class CIwUIEventClick;
class CIwUIEventFocus;
class CIwUIEventLayout;
class CIwUIEventMove;
class CIwUIEventPointerEnter;
class CIwUIEventPointerLeave;
class CIwUIEventPointerMove;
class CIwUIEventResize;
class CIwUIEventHandlerIt;
class CIwUIFocusHandler;
class CIwUIGraphics;
class CIwUILayout;
class IDelegateQuery;
# 245 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
class CIwUIElement : public CIwResource, public IIwDecomposable,
    public IIwUIEventHandler, private CIwUncopyable
{
public:
    typedef CIwArray<CIwUIElement*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUIElement();
    virtual ~CIwUIElement();
# 266 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    virtual void SetName(const char* pName);
# 285 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    virtual bool HandleEvent(CIwEvent* pEvent);







    virtual bool FilterEvent(CIwEvent* pEvent);
# 310 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    virtual void Update(int32 deltaMS);
# 322 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    virtual void Render(const CIwUIGraphics& parentGraphics);




    virtual void Animate(const CIwUIAnimData& animData);




    virtual void Traverse(IIwUIVisitor& visitor);







    virtual CIwUIElement* Intersect(const CIwVec2& pos) const;







    virtual void Intersect(CIwManagedList& contained, const CIwUIRect& rect) const;
# 365 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    static CIwUIElement* CreateFromResource(const char* pElementName,
        CIwResGroup* pResGroup = __null);
# 379 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    CIwUIElement* Clone() const;
# 396 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void SetPos(const CIwVec2& pos, bool invalidateLayout = false);
# 405 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void SetPosAbsolute(const CIwVec2& pos, const CIwVec2& offset = CIwVec2::g_Zero);
# 415 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void SetSize(const CIwVec2& size, bool invalidateLayout = false);





    void SetColour(const CIwColour& colour);
# 430 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void SetTransform(const CIwUIMat& transform);





    void ResetTransform();






    void SetTransformPos(const CIwVec2& pos);






    void SetVisible(bool val);






    void SetUpdatable(bool val);







    void SetClipped(bool val);




    CIwVec2 GetPos() const;
# 479 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    CIwVec2 GetPosAbsolute(const CIwVec2& offset = CIwVec2::g_Zero) const;




    CIwVec2 GetSize() const;






    CIwUIRect GetFrame() const;




    CIwColour GetColour() const;




    const CIwUIMat& GetTransform() const;




    const CIwVec2& GetTransformPos() const;




    virtual CIwUIMat GetElementViewTransform() const;




    bool IsVisible() const;




    bool IsUpdatable() const;




    bool IsClipped() const;




    bool IsActive() const;






    void SetRenderSlot(int32 slot);




    int32 GetRenderSlot() const;






    CIwUIRect GetChildBounds() const;
# 564 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void AddChild(CIwUIElement* pChild);
# 575 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void RemoveChild(CIwUIElement* pChild);




    void DestroyChildren();




    int GetNumChildren() const;





    CIwUIElement* GetParent() const { return m_Parent; }





    CIwUIElement* GetChild(int index) const;
# 607 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    CIwUIElement* GetChildNamed(const char* pName, bool recurse = true, bool permitNull = false) const;
# 617 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    CIwUIElement* GetChildHashed(uint32 hash, bool recurse = true, bool permitNull = false) const;
# 627 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    template <class Type>
    bool LookupChildNamed(Type*& ptr, const char* pName, bool recurse = true, bool permitNull = false) const
    {
        ptr = IwSafeCast<Type*>(GetChildNamed(pName, recurse, permitNull));
        return ptr != __null;
    }
# 642 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    template <class Type>
    bool LookupChildHashed(Type*& ptr, uint32 hash, bool recurse = true, bool permitNull = false) const
    {
        ptr = IwSafeCast<Type*>(GetChildHashed(hash, recurse, permitNull));
        return ptr != __null;
    }






    bool IsAncestor(const CIwUIElement* pElement) const;






    bool IsDescendant(const CIwUIElement* pElement) const;
# 677 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void SetLayout(CIwUILayout* pLayout);
# 686 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void ReplaceLayout(CIwUILayout* pLayout);




    CIwUILayout* GetLayout() const { return m_Layout; }







    void SetSizeMin(const CIwVec2& min);







    void SetSizeMax(const CIwVec2& max);







    void SetSizeHint(const CIwVec2& hint);




    void SetSizeToContent(bool val);





    void SetModulatesColour(bool val);




    void InvalidateLayout();




    bool IsLayoutInvalid() const;






    bool IsWithinLayout() const;






    CIwVec2 GetSizeMin() const;






    CIwVec2 GetSizeMax() const;






    CIwVec2 GetSizeHint() const;




    bool GetSizeToContent() const;





    bool GetModulatesColour() const;





    virtual CIwVec2 Measure(const CIwVec2& availableSize) const;







    virtual void Arrange(const CIwVec2& pos, const CIwVec2& size);
# 806 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void AddEventHandler(CIwUIElementEventHandler* pEventHandler);





    void RemoveEventHandler(CIwUIElementEventHandler* pEventHandler);







    int GetNumEventHandlers() const;





    CIwUIElementEventHandler* GetEventHandler(int index) const;
# 839 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    IDelegateQuery* GetDelegate(uint32 delegateName);
# 848 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void AddDelegate(IDelegateQuery* pDelegate);







    void RemoveDelegate(IDelegateQuery* pDelegate);







    void DestroyDelegates(void* pHandler);
# 877 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    CIwUIElement* GetFocus() const { return m_Focus; }




    bool HasFocus() const;




    void RequestFocus();





    void SetFocusHandler(CIwUIFocusHandler* pFocusHandler);




    CIwUIFocusHandler* GetFocusHandler() const { return m_FocusHandler; }






    virtual bool WantsFocus() const;







    virtual bool HandlesFocus() const;






    virtual CIwUIElement* FindWantsFocus();
# 936 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void SetStyle(const CIwUIStyle& style);
# 945 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    template <class Type>
    bool SetProperty(const char* pName, const Type& val)
    {
        const bool changed = m_PropertySet.SetProperty(pName, val);
        if (changed && IsActive() && !_IsActivating())
        {

            OnPropertyChanged(IwHashString(pName));
        }

        return changed;
    }
# 968 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    template<class Type>
    bool GetProperty(const char *pName, Type& val, bool allowMissing = false) const
    {
        if (_GetStateFlag(ALIVE_F))
        {
            return m_PropertySet.GetProperty(pName, val, allowMissing);
        }

        ((void)0);

        return false;
    }





    void NotifyPropertyChanged(uint32 hashName = 0);






    void SetPropertyBinding(CIwUIElementPropertyBinding* pBinding);




    CIwUIElementPropertyBinding* GetPropertyBinding() const;




    const CIwUIStyle& GetStyle() const;




    const CIwUIPropertySet& GetPropertySet() const;
# 1020 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    virtual void SetupGraphics(CIwUIGraphics& graphics) const;




    virtual void DebugRender(CIwUIDebugGraphics& debugGraphics);


protected:

    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
    virtual void ParseClose(CIwTextParserITX* pParser);
    virtual void ParseCloseChild(CIwTextParserITX* pParser, CIwManaged* pChild);


    virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeClose(CIwTextDecomposer* pDecomposer) const;


    virtual void Serialise();
    virtual void Resolve();
# 1061 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    virtual void Clone(CIwUIElement* pTarget) const;




    static const char* s_CloneExpectedClassName;
# 1082 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    virtual void Activate(bool val);
# 1097 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    virtual void UpdateElement(int32 deltaMS) {}







    void UpdateChildren(int32 deltaMS);






    virtual void TraverseElement(IIwUIVisitor& visitor) {}




    void TraverseLayout(IIwUIVisitor& visitor);






    void TraverseChildren(IIwUIVisitor& visitor);






    CIwUIElement* IntersectChildren(const CIwVec2& pos) const;
# 1147 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void Layout(const CIwVec2& pos, const CIwVec2& requestedSize);
# 1160 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    virtual bool HandleEventKey(CIwUIEventKey* pEventKey);





    virtual bool HandleEventChar(CIwUIEventChar* pEventChar) { return false; }





    virtual bool HandleEventClick(CIwUIEventClick* pEventClick);






    virtual bool HandleEventPointerMove(CIwUIEventPointerMove* pEventPointerMove) { return false; }






    virtual bool HandleEventPointerEnter(CIwUIEventPointerEnter* pEventPointerEnter) { return false; }
# 1196 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    virtual bool HandleEventPointerLeave(CIwUIEventPointerLeave* pEventPointerLeave) { return false; }







    virtual bool HandleEventFocus(CIwUIEventFocus* pEventFocus) { return false; }





    virtual bool HandleEventLayout(CIwUIEventLayout* pEventLayout) { return false; }
# 1235 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void AttachSignalSlot(const char* pSignalName, const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);
# 1249 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    void DetachSignalSlot(const char* pSignalName, const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);
# 1266 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    template <class Type>
    bool SetProperty(const char* pName, const Type& val,
        bool callOnPropertyChanged)
    {
        ((void)0);


        const bool changed = m_PropertySet.SetProperty(pName, val);

        if (changed && callOnPropertyChanged && IsActive() && !_IsActivating())
        {
            OnPropertyChanged(IwHashString(pName));
        }

        return changed;
    }







    virtual void OnPropertyChanged(uint32 hashName);
# 1304 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    IIwUIDrawable* CreateDrawable(const CIwVec2& size,
        const char* defaultType = __null);
# 1316 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    IIwUIDrawable* CreateDrawable(const char* styleName, const CIwVec2& size,
        const char* defaultType = __null, bool allowMissing = false) const;






    virtual void RenderElement(CIwUIGraphics& graphics) {}







    void RenderChildren(const CIwUIGraphics& graphics);


private:

    enum EStateFlags
    {




        ACTIVE_F = 1 << 0,


        IS_ACTIVATING_F = 1 << 1,


        LAYOUT_INVALID_F = 1 << 2,


        LAYOUT_FROM_PROPERTY_F = 1 << 3,


        FOCUS_HANDLER_FROM_PROPERTY_F = 1 << 4,


        TRANSFORM_FROM_PROPERTY_F = 1 << 5,


        EVENT_HANDLERS_FROM_PROPERTY_F = 1 << 6,


        PROPERTY_BINDING_FROM_PROPERTY_F = 1 << 7,


        ELEMENT_REQUIRES_UPDATE_F = 1 << 8,


        CHILD_REQUIRES_UPDATE_F = 1 << 9,


        ALIVE_F = 1 << 10,
    };

    enum EPropertyFlags
    {


        UPDATE_F = 1 << 0,


        VISIBLE_F = 1 << 1,




        CLIP_F = 1 << 2,


        SIZE_TO_CONTENT_F = 1 << 3,



        MODULATES_COLOUR_F = 1 << 4,


        NUM_PROPERTY_FLAGS = 5
    };




    static const char* s_PropertyFlagNames[];
    static const bool s_PropertyFlagDefaults[];


    CIwUIElement* m_Parent;


    CIwManagedList m_Children;


    uint16 m_StateFlags;


    uint16 m_PropertyFlags;


    CIwUIElement* m_Focus;


    CIwManagedList m_EventHandlers;


    CIwUIEventHandlerIt* m_ActiveIterator;


    IwUI<IDelegateQuery*>::Array m_Delegates;


    CIwUIFocusHandler* m_FocusHandler;


    CIwVec2 m_Pos;
    CIwVec2 m_Size;
    CIwUISizePolicy m_SizePolicy;
    CIwUILayout* m_Layout;
    CIwUIElementItem* m_ElementItem;


    int32 m_RenderSlot;



    CIwUIMat* m_Transform;


    CIwUIColour m_Colour;


    CIwUIPropertySet m_PropertySet;
# 1462 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    virtual bool IntersectElement(const CIwVec2& pos) const { return false; }
# 1472 "c:/marmalade/6.2/modules/iwui/h/IwUIElement.h"
    virtual CIwUIRect GetElementBounds() const { return CIwUIRect(0, 0, 0x7fffffffL, 0x7fffffffL); }







    virtual CIwVec2 MeasureElement(const CIwVec2& availableSize) const { return CIwVec2::g_Zero; }






    virtual void OnChildAdd(CIwUIElement* pChild) {}






    virtual void OnChildRemove(CIwUIElement* pChild) {}





    virtual void OnPosChanged() {}





    virtual void OnSizeChanged() {}





    virtual void OnVisibilityChanged() {}


    void _Activate(bool val);
    bool _IsActivating() const;
    void _SetActivating(bool val);
    void _ActivatePropertyBinding(bool val);
    void _ActivateEventHandlers(bool val);

    bool _GetElementRequiresUpdate() const;
    void _SetElementRequiresUpdate(bool val);
    void _RefreshElementRequiresUpdate();
    bool _GetChildRequiresUpdate() const;
    void _SetChildRequiresUpdate(bool val);
    void _RefreshChildRequiresUpdate(bool childUpdatable);

    void _SetParent(CIwUIElement* pParent);
    void _SetPos(CIwVec2 pos);
    void _SetSize(CIwVec2 size);
    void _SetFocus(CIwUIElement* pElement);
    void _SetActive(bool val);

    void _SetStateFlag(EStateFlags flag, bool val);
    bool _GetStateFlag(EStateFlags flag) const;
    void _SetPropertyFlag(EPropertyFlags flag, bool val);
    bool _GetPropertyFlag(EPropertyFlags flag) const;

    void _PopulateLayout();
    bool _IsLayoutFromProperty() const;
    void _SetLayoutFromProperty(bool val);
    void _CreateLayoutFromProperty();
    void _SetLayoutInvalid(bool val);

    bool _IsFocusHandlerFromProperty() const;
    void _SetFocusHandlerFromProperty(bool val);
    void _CreateFocusHandlerFromProperty();

    bool _IsEventHandlersFromProperty() const;
    void _SetEventHandlersFromProperty(bool val);
    void _CreateEventHandlersFromProperty();
    void _DestroyEventHandlers();

    bool _IsTransformFromProperty() const;
    void _SetTransformFromProperty(bool val);
    void _CreateTransformFromProperty();
    void _CreateTransform(const CIwVec2& offset, iwfixed scale, iwangle rotation);
    void _AdjustTransformOffset(const CIwVec2& offset);
    void _DestroyTransform();

    bool _IsPropertyBindingFromProperty() const;
    void _SetPropertyBindingFromProperty(bool val);
    void _CreatePropertyBindingFromProperty();

    void _SetPropertyBindingOwner(bool setDontClear);
    void _SetEventHandlerOwner(CIwUIElementEventHandler& eventHandler,
        bool setDontClear);


    void _SetElementItem(CIwUIElementItem* pElementItem);


    CIwUIElementSignalBase* _GetElementSignal(const char* pSignalName,
        bool createIfNotPresent);


    void _AttachSignalSlots(const CIwPropertySet& propertySet);


    void _DestroyDelegates();


    void _Intersect(CIwManagedList& contained, const CIwUIRect& rect,
        const CIwUIMat& rectMat, bool clipRectSet, const CIwUIRect& clipRect) const;


    CIwUIRect _GetBoundsRect() const;


    void _SetupFromProperties();


    static void AddPtr(CIwUIElementPtr* pPtr);
    static void RemovePtr(CIwUIElementPtr* pPtr);
    static void ClearPtrs(CIwUIElement* pElement);
    static IwUI<CIwUIElementPtr*>::Array s_Ptrs;


    static void Init();
    static void Terminate();


    friend class CIwUIController;
    friend class CIwUIElementItem;
    friend class CIwUIElementPtr;
    friend class CIwUIView;
    friend void IwUIInit();
    friend void IwUITerminate();
};
# 19 "c:/marmalade/6.2/modules/iwui/h/IwUIAlertDialog.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUILabel.h" 1
# 18 "c:/marmalade/6.2/modules/iwui/h/IwUILabel.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIHoldingPtr.h" 1
# 34 "c:/marmalade/6.2/modules/iwui/h/IwUIHoldingPtr.h"
template <typename Type>
class CIwUIHoldingPtr : private CIwUncopyable
{
public:
    explicit CIwUIHoldingPtr(Type* pPtr = __null) : m_Ptr(pPtr)
    {

    }

    ~CIwUIHoldingPtr()
    {
        delete m_Ptr;
        m_Ptr = __null;
    }

    Type& operator*()
    {
        return *m_Ptr;
    }

    const Type& operator*() const
    {
        return *m_Ptr;
    }

    Type* operator->()
    {
        return m_Ptr;
    }

    const Type* operator->() const
    {
        return m_Ptr;
    }

    operator Type*()
    {
        return m_Ptr;
    }

    operator const Type*() const
    {
        return m_Ptr;
    }

    bool operator==(Type const* pPtr) const
    {
        return m_Ptr == pPtr;
    }

    bool operator!=(Type const* pPtr) const
    {
        return m_Ptr != pPtr;
    }

    void operator=(Type* pPtr)
    {
        if (m_Ptr != pPtr)
        {
            delete m_Ptr;
            m_Ptr = pPtr;
        }
    }

private:

    Type* m_Ptr;
};
# 19 "c:/marmalade/6.2/modules/iwui/h/IwUILabel.h" 2


class CIwGxFont;
# 100 "c:/marmalade/6.2/modules/iwui/h/IwUILabel.h"
class CIwUILabel : public CIwUIElement
{
public:
    typedef CIwArray<CIwUILabel*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;






    void SetCaption(const char* pString);





    void SetFont(CIwGxFont* pFont);





    void SetTextColour(const CIwColour& colour);





    const char* GetCaption() const;





    CIwGxFont* GetFont() const;





    CIwColour GetTextColour() const;

protected:

    virtual void OnPropertyChanged(uint32 hashName);
    virtual CIwVec2 MeasureElement(const CIwVec2& availableSize) const;
    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual CIwUIRect GetElementBounds() const;
    virtual void OnSizeChanged();
    virtual void Animate(const CIwUIAnimData& animData);
    virtual void TraverseElement(IIwUIVisitor& visitor);


    IIwUIDrawable* GetText() { return m_Text; }
    IIwUIDrawable* GetBackground() { return m_Background; }

    const IIwUIDrawable* GetText() const { return m_Text; }
    const IIwUIDrawable* GetBackground() const { return m_Background; }

private:

    CIwUIHoldingPtr<IIwUIDrawable> m_Text;
    CIwUIHoldingPtr<IIwUIDrawable> m_Background;


    void _CreateDrawables();
    void _DestroyDrawables();
    CIwSVec2 _GetMargin() const;
    CIwVec2 _GetTextPos(const CIwVec2& textSize) const;
    CIwVec2 _GetTextSize() const;
};
# 20 "c:/marmalade/6.2/modules/iwui/h/IwUIAlertDialog.h" 2
# 29 "c:/marmalade/6.2/modules/iwui/h/IwUIAlertDialog.h"
class CIwUIButton;
# 81 "c:/marmalade/6.2/modules/iwui/h/IwUIAlertDialog.h"
class CIwUIAlertDialog : public CIwUIElement
{
public:
    typedef CIwArray<CIwUIAlertDialog*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUIAlertDialog();




    void SetLabelStyle(const CIwUIStyle& labelStyle);





    void SetLabelCaption(const char* pString);




    void SetButtonStyle(int16 buttonIndex, const CIwUIStyle& buttonStyle);




    void SetButtonCaption(int16 buttonIndex, const char* pString);
# 115 "c:/marmalade/6.2/modules/iwui/h/IwUIAlertDialog.h"
    void AttachButtonClickSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);







    void DetachButtonClickSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);

protected:

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual CIwUIRect GetElementBounds() const;
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual void OnPropertyChanged(uint32 hashName);
    virtual void OnSizeChanged();
    virtual CIwVec2 MeasureElement(const CIwVec2& availableSize) const;
    virtual bool HandleEvent(CIwEvent* pEvent);
    virtual bool HandlesFocus() const;
    virtual CIwUIElement* FindWantsFocus();
    virtual void Animate(const CIwUIAnimData& animData);
    virtual void OnChildRemove(CIwUIElement* pChild);


    IIwUIDrawable* GetBackground() { return m_Background; }
    const IIwUIDrawable* GetBackground() const { return m_Background; }
    CIwUILabel* GetLabel();
    CIwUIButton* GetButton(int index);
    int GetNumButtons();

private:

    CIwUIHoldingPtr<IIwUIDrawable> m_Background;
    CIwUILabel* m_Label;
    IwUI<CIwUIElement*>::Array m_Buttons;


    bool _HandleButtonClick(CIwUIButton* pButton);

    void _CreateDrawables();
    void _DestroyDrawables();

    void _CreateLayout();
    void _DestroyLayout();

    void _EnsureFocusHandler();
};
# 32 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimation.h" 1
# 55 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimation.h"
class CIwUIAnimKeyFrame : public CIwManaged, public IIwDecomposable
{
public:
    typedef CIwArray<CIwUIAnimKeyFrame*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUIAnimKeyFrame();


    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);


    virtual void Serialise();
    virtual void Resolve();
    virtual void SetName(const char* pName);


    virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeClose(CIwTextDecomposer* pDecomposer) const;
# 88 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimation.h"
    template <class Type>
    bool SetProperty(const char* pName, const Type& val)
    {
        return m_PropertySet.SetProperty(pName, val);
    }





    void AddProperty(CIwPropertyBase* pProperty);





    int32 GetTime() const { return m_Time; }






    void SetTime(int32 time) { m_Time = time; }





    const CIwUIPropertySet& GetPropertySet() const { return m_PropertySet; }







    CIwUIPropertySet& ExposePropertySet() { return m_PropertySet; }






    bool ContainsProperty(uint32 propertyDefine) const;


private:

    int32 m_Time;
    CIwUIPropertySet m_PropertySet;
};
# 148 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimation.h"
class CIwUIAnimation : public CIwResource, public IIwDecomposable
{
public:
    typedef CIwArray<CIwUIAnimation*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUIAnimation();
    ~CIwUIAnimation();


    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
    virtual void ParseClose(CIwTextParserITX* pParser);
    virtual void ParseCloseChild(CIwTextParserITX* pParser, CIwManaged* pChild);


    virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeClose(CIwTextDecomposer* pDecomposer) const;


    virtual void Serialise();
    virtual void Resolve();





    void AddKeyFrame(CIwUIAnimKeyFrame* pKeyFrame);







    template <class Type>
    void SetKeyFrameValue(int32 time, const char* pName, const Type& val)
    {
        CIwUIAnimKeyFrame* pKeyFrame = GetKeyFrameByTime(time);
        if (!pKeyFrame)
        {

            pKeyFrame = new CIwUIAnimKeyFrame;
            pKeyFrame->SetTime(time);
            AddKeyFrame(pKeyFrame);
        }


        pKeyFrame->SetProperty(pName, val);
    }





    void AttachPropertySets();
# 213 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimation.h"
    void SetAnimationSize(const CIwVec2& animationSize);






    bool GetAnimationSize(CIwVec2& animationSize) const;





    int GetNumKeyFrames() const;





    const CIwUIAnimKeyFrame* GetKeyFrame(int index) const;

private:

    CIwUIAnimKeyFrame* GetKeyFrameByTime(int32 time);


    CIwVec2 m_AnimationSize;
    IwUI<CIwUIAnimKeyFrame*>::Array m_KeyFrames;
};


# 34 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimator.h" 1
# 27 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimator.h"
class CIwUIAnimator;
class CIwUIElement;
class CIwPropertySet;
class IIwUIAnimatorObserver;
# 39 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimator.h"
class CIwUIAnimator
{
public:
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUIAnimator(uint32 handle, CIwUIAnimation* pAnimation,
        CIwUIElement* pTarget, bool onFinishRestore, bool looping,
        int32 blendInTime, int32 blendOutTime, iwfixed speed,
        const CIwVec2& size);
    ~CIwUIAnimator();





    bool Update(int32 deltaMS);






    void Stop(bool stopNextUpdate = false);






    bool SetPaused(bool paused);





    bool SetTime(int32 time);





    void SetObserver(IIwUIAnimatorObserver* pObserver) { m_Obsever = pObserver; }




    IIwUIAnimatorObserver* GetObserver() const { return m_Obsever; }






    int GetNumKeyFrames() const;





    int32 GetKeyFrameTime(int index) const;





    const CIwPropertySet* GetKeyFrameData(int index) const;






    uint32 GetHandle() const { return m_Handle; }





    CIwUIElement* GetTarget() const { return m_Target; }




    bool GetStopped() const { return m_State == eStopped; }





    bool GetPaused() const { return m_Paused; }





    int32 GetKeyFrame() const { return m_KeyFrame; }





    int32 GetTime() const { return IW_FIXED_MUL(m_Speed, m_Time); }






    int32 GetAnimationTime() const;

private:

    enum State
    {
        eWaiting,
        eStarted,
        eFinished,
        eStopped
    };


    void CreateInitialKeyFrame();

    bool BlendIn() const { return m_BlendInTime >= 0; }
    bool BlendOut() const { return m_BlendOutTime >= 0; }

    const CIwUIAnimKeyFrame* GetKeyFrame(int index) const;
    CIwPropertySet* GetTargetPropertySet() const;

    void NotifyProgress();
    void NotifyStopped();

    static CIwVec2 CalculateAnimationScale(CIwUIAnimation* pAnimation,
        const CIwVec2& desiredSize);


    const uint32 m_Handle;
    CIwUIAnimation* m_Animation;
    CIwUIElementPtr m_Target;
    State m_State;
    bool m_Paused;
    int32 m_Time;
    int32 m_KeyFrame;


    CIwUIAnimKeyFrame m_InitialKeyFrame;

    const bool m_OnFinishRestore;
    const bool m_Looping;
    const int32 m_BlendInTime;
    const int32 m_BlendOutTime;
    const iwfixed m_Speed;
    const CIwVec2 m_Scale;

    IIwUIAnimatorObserver* m_Obsever;
};
# 35 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimManager.h" 1
# 22 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimManager.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUISingleton.h" 1
# 23 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimManager.h" 2
# 33 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimManager.h"
class CIwUIAnimation;
class CIwUIAnimator;
# 44 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimManager.h"
class IIwUIAnimatorObserver
{
public:
    virtual ~IIwUIAnimatorObserver() {}
# 58 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimManager.h"
    virtual void NotifyProgress(CIwUIAnimator* pAnimator) = 0;




    virtual void NotifyStopped(CIwUIAnimator* pAnimator) = 0;

};
# 75 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimManager.h"
class CIwUIAnimManager
{
public:
    private: static CIwUIAnimManager* s_Singleton; public: static inline CIwUIAnimManager* GetSingleton() { return s_Singleton; }
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }
    CIwUIAnimManager();
    ~CIwUIAnimManager();
# 111 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimManager.h"
    uint32 PlayAnim(const char* pAnimResName, CIwUIElement* pElement,
        bool onFinishRestore = false, bool looping = false,
        int32 blendInTime = -1, int32 blendOutTime = -1,
        iwfixed speed = (1 << 12),
        const CIwVec2& size = CIwVec2(0x7fffffffL, 0x7fffffffL));

    uint32 PlayAnim(CIwUIAnimation* pAnim, CIwUIElement* pElement,
        bool onFinishRestore = false, bool looping = false,
        int32 blendInTime = -1, int32 blendOutTime = -1,
        iwfixed speed = (1 << 12),
        const CIwVec2& size = CIwVec2(0x7fffffffL, 0x7fffffffL));







    bool SetObserver(uint32 handle, IIwUIAnimatorObserver* pObserver);







    bool SetPaused(uint32 handle, bool paused);
# 147 "c:/marmalade/6.2/modules/iwui/h/IwUIAnimManager.h"
    bool SetTime(uint32 handle, int32 time);




    bool StopAnim(uint32 handle, bool stopNextUpdate = false);




    bool StopAnim(CIwUIElement* pElement, bool stopNextUpdate = false);




    void StopAllAnims(bool stopNextUpdate = false);







    bool Update(int32 deltaMS);




    bool IsAnimPlaying() const;

private:

    CIwUIAnimator* GetAnimator(uint32 handle);
    static uint32 AllocateHandle();


    IwUI<CIwUIAnimator*>::Array m_Animators;
};


inline CIwUIAnimManager* IwGetUIAnimManager() { ((void)0); return CIwUIAnimManager::GetSingleton(); } inline bool IwUIAnimManagerExists() { return CIwUIAnimManager::GetSingleton() != __null; };
# 37 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIAtlas.h" 1
# 21 "c:/marmalade/6.2/modules/iwui/h/IwUIAtlas.h"
class CIwMaterial;
class CIwTexture;
# 36 "c:/marmalade/6.2/modules/iwui/h/IwUIAtlas.h"
namespace IwUIAtlas
{





CIwSVec2 GetMaterialSize(CIwMaterial* pMaterial);






CIwSVec2 GetAtlasMaterialSize(CIwMaterial* pMaterial);
# 60 "c:/marmalade/6.2/modules/iwui/h/IwUIAtlas.h"
CIwMaterial* MapToAtlasMaterial(CIwMaterial* pMaterial, CIwRect* pUVMap);





CIwRect GetTextureUVMap(CIwTexture* pTexture);
# 77 "c:/marmalade/6.2/modules/iwui/h/IwUIAtlas.h"
const CIwSVec2 MapToFixedUV(const CIwRect& uvMap, const CIwSVec2& uv,
    bool offset = true);

}
# 38 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIButton.h" 1
# 22 "c:/marmalade/6.2/modules/iwui/h/IwUIButton.h"
class CIwGxFont;
# 138 "c:/marmalade/6.2/modules/iwui/h/IwUIButton.h"
class CIwUIButton : public CIwUIElement
{
public:
    typedef CIwArray<CIwUIButton*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUIButton();






    void SetCaption(const char* pString);





    void SetFont(CIwGxFont* pFont);





    void SetTextColour(const CIwColour& colour);







    void SetEnabled(bool val);





    const char* GetCaption() const;





    CIwGxFont* GetFont() const;





    CIwColour GetTextColour() const;





    bool GetEnabled() const;







    void AttachClickSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);







    void DetachClickSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);

protected:

    virtual bool HandleEventClick(CIwUIEventClick* pEventClick);
    virtual bool HandleEventKey(CIwUIEventKey* pEventKey);
    virtual bool HandleEventPointerEnter(CIwUIEventPointerEnter* pEventPointerEnter);
    virtual bool HandleEventPointerLeave(CIwUIEventPointerLeave* pEventPointerLeave);
    virtual bool HandleEventFocus(CIwUIEventFocus* pEventFocus);

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual bool IntersectElement(const CIwVec2& pos) const;
    virtual CIwUIRect GetElementBounds() const;
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual void OnPropertyChanged(uint32 hashName);
    virtual void OnSizeChanged();
    virtual CIwVec2 MeasureElement(const CIwVec2& availableSize) const;
    virtual void Animate(const CIwUIAnimData& animData);
    virtual void TraverseElement(IIwUIVisitor& visitor);
    virtual bool WantsFocus() const;


    bool IsDown() const;

    IIwUIDrawable* GetImageUp() { return m_ImageUp; }
    IIwUIDrawable* GetImageDown() { return m_ImageDown; }
    IIwUIDrawable* GetImageFocus() { return m_ImageFocus; }
    IIwUIDrawable* GetImageDisabled() { return m_ImageDisabled; }
    IIwUIDrawable* GetText() { return m_Text; }

    const IIwUIDrawable* GetImageUp() const { return m_ImageUp; }
    const IIwUIDrawable* GetImageDown() const { return m_ImageDown; }
    const IIwUIDrawable* GetImageFocus() const { return m_ImageFocus; }
    const IIwUIDrawable* GetImageDisabled() const { return m_ImageDisabled; }
    const IIwUIDrawable* GetText() const { return m_Text; }

private:

    CIwUIHoldingPtr<IIwUIDrawable> m_ImageUp;
    CIwUIHoldingPtr<IIwUIDrawable> m_ImageDown;
    CIwUIHoldingPtr<IIwUIDrawable> m_ImageFocus;
    CIwUIHoldingPtr<IIwUIDrawable> m_ImageDisabled;
    CIwUIHoldingPtr<IIwUIDrawable> m_Text;
    CIwUIColour m_CaptionColourDefault;
    bool m_Down;


    void _SetDown(bool val);
    void _HandlePress(bool is_pressed);
    void _CreateDrawables();
    void _DestroyDrawables();
    void _SetCaptionColour();

    CIwVec2 _GetCaptionPos(const CIwVec2& captionSize) const;
    CIwVec2 _GetCaptionSize() const;
    CIwSVec2 _GetMargin() const;
    CIwColour _GetColourDisabled() const;
    CIwColour _GetCaptionColourDisabled() const;
    CIwColour _GetCaptionColourDown() const;
    CIwColour _GetCaptionColourDefault() const;
};
# 39 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUICheckbox.h" 1
# 21 "c:/marmalade/6.2/modules/iwui/h/IwUICheckbox.h"
class CIwGxFont;
# 130 "c:/marmalade/6.2/modules/iwui/h/IwUICheckbox.h"
class CIwUICheckbox : public CIwUIElement
{
public:
    typedef CIwArray<CIwUICheckbox*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUICheckbox();






    void SetCaption(const char* pString);





    void SetFont(CIwGxFont* pFont);





    void SetTextColour(const CIwColour& colour);





    void SetChecked(bool val);





    const char* GetCaption() const;





    CIwGxFont* GetFont() const;





    CIwColour GetTextColour() const;





    bool GetChecked() const;







    void AttachCheckedSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);







    void DetachCheckedSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);

protected:

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual bool IntersectElement(const CIwVec2& pos) const;
    virtual CIwUIRect GetElementBounds() const;
    virtual bool HandleEventClick(CIwUIEventClick* pEventClick);
    virtual bool HandleEventKey(CIwUIEventKey* pEventKey);
    virtual void OnPropertyChanged(uint32 hashName);
    virtual void OnSizeChanged();
    virtual CIwVec2 MeasureElement(const CIwVec2& availableSize) const;
    virtual void Animate(const CIwUIAnimData& animData);
    virtual void TraverseElement(IIwUIVisitor& visitor);
    virtual bool WantsFocus() const { return true; }


    IIwUIDrawable* GetBox() { return m_Box; }
    IIwUIDrawable* GetCross() { return m_Cross; }
    IIwUIDrawable* GetImageFocus() { return m_ImageFocus; }
    IIwUIDrawable* GetText() { return m_Text; }
    IIwUIDrawable* GetBackground() { return m_Background; }

    const IIwUIDrawable* GetBox() const { return m_Box; }
    const IIwUIDrawable* GetCross() const { return m_Cross; }
    const IIwUIDrawable* GetImageFocus() const { return m_ImageFocus; }
    const IIwUIDrawable* GetText() const { return m_Text; }
    const IIwUIDrawable* GetBackground() const { return m_Background; }

private:

    CIwUIHoldingPtr<IIwUIDrawable> m_Box;
    CIwUIHoldingPtr<IIwUIDrawable> m_Cross;
    CIwUIHoldingPtr<IIwUIDrawable> m_ImageFocus;
    CIwUIHoldingPtr<IIwUIDrawable> m_Text;
    CIwUIHoldingPtr<IIwUIDrawable> m_Background;


    void _CreateDrawables();
    void _DestroyDrawables();
    void _SetChecked(bool val);
    bool _GetChecked() const;

    CIwVec2 _GetBoxPos(const CIwVec2& boxSize);
    CIwVec2 _GetBoxSize() const;
    CIwVec2 _GetTextPos(const CIwVec2& textSize) const;
    CIwVec2 _GetTextSize(const CIwVec2& boxSize) const;
    CIwSVec2 _GetMargin() const;
};
# 40 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIController.h" 1
# 34 "c:/marmalade/6.2/modules/iwui/h/IwUIController.h"
class CIwEvent;
class CIwUIElement;
class CIwUIEventKey;
class CIwUIEventClick;
class CIwUIEventPointerMove;
class CIwUIEventTextInput;
class CIwUIEventHandlerIt;
class CIwVec2;
# 53 "c:/marmalade/6.2/modules/iwui/h/IwUIController.h"
class CIwUIController
{
public:
    private: static CIwUIController* s_Singleton; public: static inline CIwUIController* GetSingleton() { return s_Singleton; }
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUIController();
    virtual ~CIwUIController();
# 70 "c:/marmalade/6.2/modules/iwui/h/IwUIController.h"
    virtual void Update();
# 84 "c:/marmalade/6.2/modules/iwui/h/IwUIController.h"
    bool SendEvent(CIwUIElement* pReceiver, CIwEvent* pEvent);
# 94 "c:/marmalade/6.2/modules/iwui/h/IwUIController.h"
    virtual void PostEvent(CIwUIElement* pReceiver, CIwEvent* pEvent);





    void BroadcastEvent(CIwEvent* pEvent);
# 114 "c:/marmalade/6.2/modules/iwui/h/IwUIController.h"
    void AddEventHandler(IIwUIEventHandler* pEventHandler);
# 123 "c:/marmalade/6.2/modules/iwui/h/IwUIController.h"
    void RemoveEventHandler(IIwUIEventHandler* pEventHandler);







    bool IsRegisteredEventHandler(IIwUIEventHandler* pEventHandler) const;





    bool IsHandlingEvent(IIwUIEventHandler* pHandler = __null) const;





    bool IsFilteringEvent(IIwUIEventHandler* pFilter = __null) const;




    void SetPointerCapture(CIwUIElement* pElement);




    bool HasPointerCapture(CIwUIElement* pElement);
# 164 "c:/marmalade/6.2/modules/iwui/h/IwUIController.h"
    bool EnableEventChar(bool val);




    bool IsEventCharEnabled() const;

protected:
# 185 "c:/marmalade/6.2/modules/iwui/h/IwUIController.h"
    virtual bool Notify(CIwUIElement* pReceiver, CIwEvent* pEvent);







    virtual bool FilterEvent(CIwEvent* pEvent);







    virtual bool HandleEvent(CIwEvent* pEvent);

private:

    struct QueuedEvent
    {
        void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }
        QueuedEvent(CIwEvent* pEvent, CIwUIElement* pElement);
        ~QueuedEvent();

        CIwEvent* m_Event;
        CIwUIElementPtr m_Receiver;
    };

    struct EventHandlerChain
    {
        EventHandlerChain(IIwUIEventHandler* handler, EventHandlerChain*& chain);
        ~EventHandlerChain();

        static bool IsEventHandlerInChain(IIwUIEventHandler* handler,
            EventHandlerChain* chain);

    private:
        IIwUIEventHandler* m_Handler;
        EventHandlerChain* m_Prev;
        EventHandlerChain*& m_Top;
    };

    struct TouchRecord
    {
        void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }
        TouchRecord(uint32 touchID, const CIwVec2& touchPos, CIwUIElement* pElement);

        const uint32 m_TouchID;
        CIwVec2 m_TouchPos;
        CIwUIElementPtr m_TouchOver;
    };


    IwUI<QueuedEvent*>::Array m_EventQueue;
    IIwUIEventHandler::Array m_EventHandlers;


    IwUI<TouchRecord*>::Array m_TouchRecords;


    CIwVec2 m_PointerPos;
    CIwUIElementPtr m_PointerOver;


    CIwUIElementPtr m_ClickOver;


    CIwUIElementPtr m_PointerCapture;


    EventHandlerChain* m_EventHandlerChain;


    EventHandlerChain* m_EventFilterChain;


    CIwUIEventHandlerIt* m_ActiveIterator;


    bool m_EventCharEnabled;


    void _ClearEventQueue();
    void _BroadcastEvent(CIwEvent* pEvent, CIwUIElement* pElement);
    bool _FilterEvent(CIwEvent* pEvent, CIwUIElement* pElement);

    void _SetPointerOver(const CIwVec2& pointerPos, CIwUIElement* pPointerOver);
    void _UpdatePointerOver(const CIwVec2& pointerPos, CIwUIElement* pPointerOver);

    void _UpdateTouchOver(uint32 touchID, const CIwVec2& touchPos, CIwUIElement* pTouchOver);
    CIwUIElement* _GetTouchOver(uint32 touchID) const;
    void _SetTouchOver(uint32 touchID, const CIwVec2& touchPos, CIwUIElement* pTouchOver);
    void _ClearTouchRecords();

    void _UpdateEventChar();

    bool _CallHandleEvent(IIwUIEventHandler* pElement, CIwEvent* pEvent);
    bool _CallFilterEvent(IIwUIEventHandler* pElement, CIwEvent* pEvent);


    static int32 _CallbackCharEvent(void* pSystemData, void* pUserData);
    static int32 _CallbackKeyEvent(void* pSystemData, void* pUserData);
    static int32 _CallbackClickEvent(void* pSystemData, void* pUserData);
    static int32 _CallbackPointerMoveEvent(void* pSystemData, void* pUserData);
    static int32 _CallbackTouchClickEvent(void* pSystemData, void* pUserData);
    static int32 _CallbackTouchMoveEvent(void* pSystemData, void* pUserData);
};


inline CIwUIController* IwGetUIController() { ((void)0); return CIwUIController::GetSingleton(); } inline bool IwUIControllerExists() { return CIwUIController::GetSingleton() != __null; };
# 42 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIDebug.h" 1
# 21 "c:/marmalade/6.2/modules/iwui/h/IwUIDebug.h"
class CIwUIElement;
class CIwUIRect;
class CIwUIColour;







enum IwUIDebugRenderFlags
{

    IW_UI_DEBUG_ELEMENT_OUTLINE_F = (1 << 0),


    IW_UI_DEBUG_DRAWABLE_OUTLINE_F = (1 << 1),


    IW_UI_DEBUG_LAYOUT_OUTLINE_F = (1 << 2),


    IW_UI_DEBUG_LAYOUT_ITEM_CONTAINER_OUTLINE_F = (1 << 3),


    IW_UI_DEBUG_HIERARCHY_F = (1 << 4),


    IW_UI_DEBUG_SIBLINGS_F = (1 << 5),


    IW_UI_DEBUG_TEXT_CURSOR_F = (1 << 6),
};
# 64 "c:/marmalade/6.2/modules/iwui/h/IwUIDebug.h"
void IwUIDebugRender(CIwUIElement* pElement = __null,
    uint32 flags = IW_UI_DEBUG_ELEMENT_OUTLINE_F,
    const CIwVec2& targetPos = CIwVec2(0x7fffffffL, 0x7fffffffL));
# 43 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2


# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableBorder.h" 1
# 27 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableBorder.h"
class CIwMaterial;
class CIwPropertySet;
# 90 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableBorder.h"
class CIwUIDrawableBorder : public IIwUIDrawable
{
public:
# 103 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableBorder.h"
    CIwUIDrawableBorder(CIwMaterial* pMaterial, const CIwSVec2& uv0,
        const CIwSVec2& uv1, const CIwVec2& size, const CIwSVec2& border,
        bool shrinkDontCrop);
# 117 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableBorder.h"
    CIwUIDrawableBorder(CIwTexture* pTexture, const CIwSVec2& uv0,
        const CIwSVec2& uv1, const CIwVec2& size, const CIwSVec2& border,
        bool shrinkDontCrop);







    CIwUIDrawableBorder(const CIwVec2& size, const CIwPropertySet& propertySet);
# 139 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableBorder.h"
    virtual void Draw(CIwUIGraphics& graphics) const;




    virtual void DebugDraw(CIwUIDebugGraphics& debugGraphics) const;




    virtual CIwVec2 Measure(const CIwVec2& availableSize) const;





    virtual void Animate(const CIwUIAnimData& animData);







    virtual void SetPosition(const CIwVec2& position);





    virtual void SetSize(const CIwVec2& size);





    virtual void SetColour(const CIwColour& colour);




    virtual CIwVec2 GetPosition() const;




    virtual CIwVec2 GetSize() const;




    virtual CIwColour GetColour() const;




    virtual CIwUIRect GetBounds() const;






    virtual bool Intersects(const CIwVec2& pos) const;


private:

    CIwMaterial* m_Material;
    CIwTexture* m_Texture;
    CIwSVec2 m_UV0;
    CIwSVec2 m_UV1;
    CIwUIRect m_Rect;
    CIwColour m_Colour;
    CIwSVec2 m_CornerSize;
    CIwSVec2 m_MiddleSize;
    CIwSVec2 m_CornerUVs;
    bool m_ShrinkDontCrop;


    void _Construct(const CIwUIRect& rect, const CIwPropertySet& propertySet);
    void _Construct(const CIwUIRect& rect, CIwTexture* pTexture, CIwMaterial* pMaterial,
        const CIwSVec2& uv0, const CIwSVec2& uv1, const CIwSVec2& border,
        bool shrinkDontCrop);

    int _GetNumImagesX() const;
    int _GetNumImagesY() const;
    int _GetImageX(int i, int numImagesX) const;
    int _GetImageY(int j, int numImagesY) const;
    int _GetImageU(int i, int segWidth) const;
    int _GetImageV(int j, int segHeight) const;
    int _ShrinkCrop(int texCoord, int length, int border) const;
};
# 46 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableImage.h" 1
# 26 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableImage.h"
class CIwMaterial;
class CIwUIGraphics;
class CIwPropertySet;
# 78 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableImage.h"
class CIwUIDrawableImage : public IIwUIDrawable
{
public:
# 90 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableImage.h"
    CIwUIDrawableImage(CIwMaterial* pMaterial, const CIwSVec2& uv0,
        const CIwSVec2& uv1, const CIwVec2& size);
# 102 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableImage.h"
    CIwUIDrawableImage(CIwTexture* pTexture, const CIwSVec2& uv0,
        const CIwSVec2& uv1, const CIwVec2& size);







    CIwUIDrawableImage(const CIwVec2& size, const CIwPropertySet& propertySet);
# 123 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableImage.h"
    virtual void Draw(CIwUIGraphics& graphics) const;




    virtual void DebugDraw(CIwUIDebugGraphics& debugGraphics) const;




    virtual CIwVec2 Measure(const CIwVec2& availableSize) const;





    virtual void Animate(const CIwUIAnimData& animData);







    virtual void SetPosition(const CIwVec2& position);





    virtual void SetSize(const CIwVec2& size);





    virtual void SetColour(const CIwColour& colour);




    virtual CIwVec2 GetPosition() const;




    virtual CIwVec2 GetSize() const;




    virtual CIwColour GetColour() const;




    virtual CIwUIRect GetBounds() const;






    virtual bool Intersects(const CIwVec2& pos) const;


private:

    CIwMaterial* m_Material;
    CIwTexture* m_Texture;
    CIwSVec2 m_UV0;
    CIwSVec2 m_UV1;
    CIwUIRect m_Rect;
    CIwColour m_Colour;


    void _Construct(const CIwUIRect& rect, const CIwPropertySet& propertySet);
    void _Construct(const CIwUIRect& rect, CIwTexture* pTexture,
        CIwMaterial* pMaterial, const CIwSVec2& uv0, const CIwSVec2& uv1);
};
# 47 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableText.h" 1
# 22 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableText.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwPropertyString.h" 1
# 20 "c:/marmalade/6.2/modules/iwui/h/IwPropertyString.h"
class CIwTextParserITX;


template<> class CIwPropertyTypeMap<const char* > { public: typedef class CIwPropertyString Val; };
template<> class CIwPropertyTypeMap<char* > { public: typedef class CIwPropertyString Val; };
# 36 "c:/marmalade/6.2/modules/iwui/h/IwPropertyString.h"
class CIwPropertyString
{
public:
    CIwPropertyString();
    CIwPropertyString(const char* pString);
    CIwPropertyString(const CIwPropertyString& rhs);
    ~CIwPropertyString();

    static const CIwPropertyString g_EmptyString;




    CIwPropertyString& operator=(const CIwPropertyString& rhs);
    CIwPropertyString& operator=(const char* pString);





    const char* c_str() const;




    void Parse(CIwTextParserITX* pParser);




    void Decompose(CIwTextDecomposer* pDecomposer) const;




    bool operator==(const CIwPropertyString& rhs) const;
    bool operator==(const char* pString) const;




    void Serialise();




    void Resolve();




    void Clone(const CIwPropertyString& src);

private:

    struct CIwPropertyStringData* m_Data;
};
# 23 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableText.h" 2







class CIwGxFont;
class CIwUIGraphics;
class CIwPropertySet;
# 90 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableText.h"
class CIwUIDrawableText : public IIwUIDrawable, private CIwUncopyable
{
public:
# 104 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableText.h"
    CIwUIDrawableText(const CIwGxFont* pFont, const IwChar* pString,
        const CIwVec2& size,
        IwGxFontAlignHor alignH = IW_GX_FONT_ALIGN_LEFT,
        IwGxFontAlignVer alignV = IW_GX_FONT_ALIGN_TOP,
        bool oneLine = false);







    CIwUIDrawableText(const CIwVec2& size, const CIwPropertySet& propertySet);
# 128 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableText.h"
    virtual void Draw(CIwUIGraphics& graphics) const;




    virtual void DebugDraw(CIwUIDebugGraphics& debugGraphics) const;







    virtual CIwVec2 Measure(const CIwVec2& availableSize) const;





    virtual void Animate(const CIwUIAnimData& animData);







    virtual void SetPosition(const CIwVec2& position);





    virtual void SetSize(const CIwVec2& size);





    virtual void SetColour(const CIwColour& colour);




    virtual CIwVec2 GetPosition() const;




    virtual CIwVec2 GetSize() const;




    virtual CIwColour GetColour() const;




    virtual CIwUIRect GetBounds() const;






    virtual bool Intersects(const CIwVec2& pos) const;
# 208 "c:/marmalade/6.2/modules/iwui/h/IwUIDrawableText.h"
    virtual CIwUIRect GetCharacterArea(int32 c) const;


private:

    CIwPropertyString m_String;
    const CIwGxFont* m_Font;
    IwGxFontAlignHor m_AlignHor;
    IwGxFontAlignVer m_AlignVer;
    bool m_OneLine;
    CIwVec2 m_Position;
    CIwColour m_Colour;
    CIwGxFontPreparedData m_PreparedData;
    CIwVec2 m_TextSize;
    CIwVec2 m_MinTextSize;
    CIwVec2 m_MaxTextSize;


    void _Construct(const CIwVec2& size, const CIwPropertySet& propertySet);
    void _Construct(const CIwVec2& size, const CIwGxFont* pFont,
        IwGxFontAlignHor alignH, IwGxFontAlignVer alignV, bool oneLine);
    void PrepareText(CIwGxFontPreparedData& prepareData,
        const CIwVec2& size, bool noWordSplit = false) const;
    void CalcTextSizeExtents();
    CIwVec2 GetGlyphAlignmentOffset() const;
};
# 48 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIElementEventHandler.h" 1
# 18 "c:/marmalade/6.2/modules/iwui/h/IwUIElementEventHandler.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo" 1
# 21 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h" 1
# 16 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h" 2
# 22 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo" 2





# 1 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo.h" 1
# 20 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/exception" 1
# 75 "c:/marmalade/6.2/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/6.2/s3e/h/std/c++/exception"
}
# 21 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo.h" 2
namespace std
{
    using _STL::exception;
}
# 1 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo_gcc" 1
# 39 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo_gcc"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/exception" 1
# 75 "c:/marmalade/6.2/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/6.2/s3e/h/std/c++/exception"
}
# 40 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo_gcc" 2

#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 85 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo_gcc"
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);

  protected:
    const char *__name;

  protected:
    explicit type_info(const char *__n): __name(__n) { }

  public:



    const char* name() const;


    bool before(const type_info& __arg) const;



    bool operator==(const type_info& __arg) const;
# 138 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo_gcc"
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


  public:

    virtual bool __is_pointer_p() const;

    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;
  };






  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }


    virtual ~bad_cast() throw();

    virtual const char* what() const throw();
  };


  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }


    virtual ~bad_typeid() throw();

    virtual const char* what() const throw();
  };
}

#pragma GCC visibility pop

}
# 26 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo.h" 2
# 28 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo" 2
# 43 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo"
namespace _STL {



using __std_alias::type_info;



using __std_alias::bad_typeid;
# 61 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo"
using __std_alias::bad_cast;


}
# 78 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 2
# 79 "c:/marmalade/6.2/s3e/h/std/c++/typeinfo" 2
# 19 "c:/marmalade/6.2/modules/iwui/h/IwUIElementEventHandler.h" 2
# 28 "c:/marmalade/6.2/modules/iwui/h/IwUIElementEventHandler.h"
class CIwUIElement;
# 51 "c:/marmalade/6.2/modules/iwui/h/IwUIElementEventHandler.h"
class CIwUIElementEventHandler : public CIwResource, public IIwDecomposable,
    public IIwUIEventHandler
{
public:
    typedef CIwArray<CIwUIElementEventHandler*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }
    CIwUIElementEventHandler();
    virtual ~CIwUIElementEventHandler();


    virtual void ParseClose(CIwTextParserITX* pParser);


    virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeClose(CIwTextDecomposer* pDecomposer) const;


    virtual bool HandleEvent(CIwEvent* pEvent) { return false; }
    virtual bool FilterEvent(CIwEvent* pEvent) { return false; }
# 83 "c:/marmalade/6.2/modules/iwui/h/IwUIElementEventHandler.h"
    virtual CIwUIElementEventHandler* Clone() const;




    CIwUIElement* GetElement() { return m_Element; }


protected:
# 101 "c:/marmalade/6.2/modules/iwui/h/IwUIElementEventHandler.h"
    virtual void Activate(bool val);




    virtual void Clone(CIwUIElementEventHandler* pTarget) const;



    static const char* s_CloneExpectedClassName;


private:

    void _SetElement(CIwUIElement* pOwner);


    CIwUIElement* m_Element;


    friend class CIwUIElement;
};



# 50 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIElementItem.h" 1
# 17 "c:/marmalade/6.2/modules/iwui/h/IwUIElementItem.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutItem.h" 1
# 27 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutItem.h"
class CIwUIDebugGraphics;
class CIwUIElement;
class CIwUILayoutItemContainer;
# 69 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutItem.h"
class CIwUILayoutItem : public CIwResource, public IIwDecomposable
{
public:
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUILayoutItem();
    virtual ~CIwUILayoutItem();




    virtual void SetName(const char* pName);
    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
    virtual void Serialise();
    virtual void Resolve();




    virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeClose(CIwTextDecomposer* pDecomposer) const;





    virtual CIwVec2 MeasureItem(const CIwVec2& availableSize) const = 0;



    virtual void ArrangeItem(const CIwVec2& pos, const CIwVec2& size) = 0;





    void SetParentItem(CIwUILayoutItem* pParentItem);


    CIwUILayoutItem* GetParentItem() const { return m_ParentItem; }


    CIwUILayoutItem* Clone() const;


    virtual void Attach();


    virtual void InvalidateLayout();



    virtual bool PopulateElement(CIwUIElement* pElement) { return false; }



    virtual bool RemoveElement(CIwUIElement* pElement) { return false; }


    virtual bool IsChildElement(CIwUIElement* pElement) const;



    virtual CIwUIElement* GetParentElement() const;



    virtual void Traverse(IIwUIVisitor& visitor) { }


    virtual void DebugRender(CIwUIDebugGraphics& debugGraphics) { }
# 163 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutItem.h"
    virtual bool InsertItem(CIwUILayoutItem* pItem,
        const CIwVec2& insertPos, int16 tolerance,
        const CIwVec2& arrangePos, const CIwVec2& arrangeSize) { return false; }







    template<class Type>
    bool GetProperty( const char *pName, Type& val, bool allowMissing = false) const
    {
        return m_PropertySet.GetProperty(pName, val, allowMissing);
    }




    const CIwUIPropertySet& GetPropertySet() const { return m_PropertySet; }

protected:




    virtual void RemoveChildItem(CIwUILayoutItem* pChild) = 0;
# 200 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutItem.h"
    virtual void Clone(CIwUILayoutItem* pTarget) const;







    CIwUIPropertySet& ExposePropertySet() { return m_PropertySet; }






    void SetStyle(const CIwUIStyle& style);







    template <class Type>
    bool SetProperty(const char* pName, const Type& val)
    {
        return m_PropertySet.SetProperty(pName, val);
    }


    static const char* s_CloneExpectedClassName;

private:

    CIwUILayoutItem(const CIwUILayoutItem& rhs);
    CIwUILayoutItem& operator=(const CIwUILayoutItem& rhs);





    CIwUILayoutItem* m_ParentItem;


    CIwUIPropertySet m_PropertySet;
};
# 18 "c:/marmalade/6.2/modules/iwui/h/IwUIElementItem.h" 2
# 32 "c:/marmalade/6.2/modules/iwui/h/IwUIElementItem.h"
class CIwUIElementItem : public CIwUILayoutItem
{
public:
    typedef CIwArray<CIwUIElementItem*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUIElementItem(CIwUIElement* pElement);
    ~CIwUIElementItem();



    static CIwUIElementItem* GetElementItem(CIwUIElement* pElement);

private:

    CIwUIElementItem();



    virtual void Serialise();



    virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeClose(CIwTextDecomposer* pDecomposer) const {}


    virtual void Attach();
    virtual void InvalidateLayout();
    virtual bool PopulateElement(CIwUIElement* pElement);
    virtual bool RemoveElement(CIwUIElement* pElement);
    virtual bool IsChildElement(CIwUIElement* pElement) const;
    virtual void Traverse(IIwUIVisitor& visitor);

    virtual CIwVec2 MeasureItem(const CIwVec2& availableSize) const;
    virtual void ArrangeItem(const CIwVec2& pos, const CIwVec2& size);
    virtual void RemoveChildItem(CIwUILayoutItem* pChild);
    virtual void Clone(CIwUILayoutItem* pTarget) const;


    CIwUIElement* m_Element;


    friend class CIwUIElement;
    friend void* _CIwUIElementItemFactory();
};
# 51 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIElementPropertyBinding.h" 1
# 22 "c:/marmalade/6.2/modules/iwui/h/IwUIElementPropertyBinding.h"
class CIwUIElement;
# 34 "c:/marmalade/6.2/modules/iwui/h/IwUIElementPropertyBinding.h"
class CIwUIElementPropertyBinding : public CIwPropertyBinding
{
public:
    typedef CIwArray<CIwUIElementPropertyBinding*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }
    CIwUIElementPropertyBinding();
    virtual ~CIwUIElementPropertyBinding();
# 52 "c:/marmalade/6.2/modules/iwui/h/IwUIElementPropertyBinding.h"
    CIwUIElementPropertyBinding* Clone() const;




    CIwUIElement* GetElement() { return m_Element; }







    void NotifyElementPropertyChanged(uint32 hashName = 0);


protected:
# 78 "c:/marmalade/6.2/modules/iwui/h/IwUIElementPropertyBinding.h"
    virtual void Activate(bool val);



    virtual void Clone(CIwPropertyBinding* pTarget) const;
    static const char* s_CloneExpectedClassName;


private:

    void _SetElement(CIwUIElement* pOwner);


    CIwUIElement* m_Element;


    friend class CIwUIElement;
};


# 52 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2


# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIElementUtil.h" 1
# 32 "c:/marmalade/6.2/modules/iwui/h/IwUIElementUtil.h"
CIwUIPropertySet* _IwUICreateInlineStyle(CIwUIElement* pElement,
    const char* pStyle);
CIwUIPropertySet* _IwUICreateInlineStyleInList(CIwUIElement* pElement,
    const char* pStyleList, int styleIndex, bool allowListMissing);
# 47 "c:/marmalade/6.2/modules/iwui/h/IwUIElementUtil.h"
template <typename Type>
void IwUISetPropertyOnInlineStyle(CIwUIElement* pElement, const char* pStyle,
    const char* pProperty, const Type& val)
{

    CIwUIPropertySet* pInlineStyle = _IwUICreateInlineStyle(pElement, pStyle);


    pInlineStyle->SetProperty(pProperty, val);


    pElement->NotifyPropertyChanged(IwHashString(pStyle));
}
# 71 "c:/marmalade/6.2/modules/iwui/h/IwUIElementUtil.h"
template<class Type>
bool IwUIGetPropertyFromInlineStyle(CIwUIElement* pElement, const char* pStyle,
    const char* pProperty, Type& val, bool allowMissing = false)
{
    CIwUIStyle style;
    if (pElement->GetProperty(pStyle, style, allowMissing))
    {
        const CIwPropertySet* pPropertySet = style ? style.GetPropertySet() : __null;
        ((void)0);


        if (pPropertySet)
        {
            return pPropertySet->GetProperty(pProperty, val, allowMissing);
        }
    }

    return false;
}
# 102 "c:/marmalade/6.2/modules/iwui/h/IwUIElementUtil.h"
void IwUISetStyleInList(CIwUIElement* pElement, const char* pStyleList,
    int styleIndex, const CIwUIStyle& style, bool allowListMissing = false);
# 114 "c:/marmalade/6.2/modules/iwui/h/IwUIElementUtil.h"
bool IwUIGetStyleFromList(CIwUIElement* pElement, const char* pStyleList,
    int styleIndex, CIwUIStyle& style, bool allowMissing = false);
# 130 "c:/marmalade/6.2/modules/iwui/h/IwUIElementUtil.h"
template <typename Type>
void IwUISetPropertyOnInlineStyleInList(CIwUIElement* pElement,
    const char* pStyleList, int styleIndex, const char* pProperty,
    const Type& val, bool allowListMissing = false)
{

    CIwUIPropertySet* pInlineStyle = _IwUICreateInlineStyleInList(pElement,
        pStyleList, styleIndex, allowListMissing);


    pInlineStyle->SetProperty(pProperty, val);


    pElement->NotifyPropertyChanged(IwHashString(pStyleList));
}
# 157 "c:/marmalade/6.2/modules/iwui/h/IwUIElementUtil.h"
template<class Type>
bool IwUIGetPropertyOnInlineStyleInList(CIwUIElement* pElement,
    const char* pStyleList, int styleIndex, const char* pProperty,
    Type& val, bool allowMissing = false)
{
    CIwUIStyle style;
    if (IwUIGetStyleFromList(pElement, pStyleList, styleIndex, style, allowMissing))
    {
        const CIwPropertySet* pPropertySet = style ? style.GetPropertySet() : __null;
        ((void)0);


        if (pPropertySet)
        {
            return pPropertySet->GetProperty(pProperty, val, allowMissing);
        }
    }

    return false;
}
# 55 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIEvent.h" 1
# 18 "c:/marmalade/6.2/modules/iwui/h/IwUIEvent.h"
# 1 "c:/marmalade/6.2/s3e/h/s3ePointer.h" 1
# 19 "c:/marmalade/6.2/modules/iwui/h/IwUIEvent.h" 2
# 40 "c:/marmalade/6.2/modules/iwui/h/IwUIEvent.h"
class CIwUIAlertDialog;
class CIwUIButton;
class CIwUICheckbox;
class CIwUIElement;
class CIwUIPickerView;
class CIwUIPickerWheel;
class CIwUIRadioButton;
class CIwUISlider;
class CIwUISoftKey;
class CIwUISoftKeyboard;
class CIwUITabBar;
class CIwUITableView;
# 61 "c:/marmalade/6.2/modules/iwui/h/IwUIEvent.h"
enum IWUI_EVENT
{

    IWUI_EVENT_KEY = IW_EVENT_GUI,
    IWUI_EVENT_CHAR,
    IWUI_EVENT_CLICK,
    IWUI_EVENT_POINTER_MOVE,
    IWUI_EVENT_POINTER_ENTER,
    IWUI_EVENT_POINTER_LEAVE,
    IWUI_EVENT_TOUCH_PRESS,
    IWUI_EVENT_TOUCH_MOVE,
    IWUI_EVENT_TOUCH_ENTER,
    IWUI_EVENT_TOUCH_LEAVE,
    IWUI_EVENT_FOCUS,
    IWUI_EVENT_LAYOUT,
    IWUI_EVENT_VISIBILITY,


    IWUI_EVENT_BUTTON,
    IWUI_EVENT_RADIO_BUTTON,
    IWUI_EVENT_ALERT_DIALOG_BUTTON,
    IWUI_EVENT_CHECKBOX,
    IWUI_EVENT_PICKER_VIEW,
    IWUI_EVENT_PICKER_WHEEL,
    IWUI_EVENT_TABBAR,
    IWUI_EVENT_TABLE_VIEW,
    IWUI_EVENT_TABLE_VIEW_ITEM,
    IWUI_EVENT_SLIDER,
    IWUI_EVENT_SOFTKEY,
    IWUI_EVENT_SOFTKEYBOARD,
    IWUI_EVENT_TEXT_INPUT,
};
# 111 "c:/marmalade/6.2/modules/iwui/h/IwUIEvent.h"
class CIwUIEvent : public CIwEvent
{
public:
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }


    void SetElement(CIwUIElement* pElement);
    CIwUIElement* GetElement() const;
};







class CIwUIEventKey : public CIwUIEvent
{
public:
    CIwUIEventKey(s3eKey key, bool pressed);
    public: CIwUIEventKey() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_KEY"); m_Hash = IWUI_EVENT_KEY ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_KEY };;


    s3eKey GetKey() { return m_Key; }
    bool GetPressed() { return m_Pressed; }

private:
    s3eKey m_Key;
    bool m_Pressed;
};







class CIwUIEventChar : public CIwUIEvent
{
public:
    CIwUIEventChar( uint16 val);
    public: CIwUIEventChar() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_CHAR"); m_Hash = IWUI_EVENT_CHAR ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_CHAR };;


    s3eWChar GetChar() { return m_Char; }

private:
    s3eWChar m_Char;
};







class CIwUIEventClick : public CIwUIEvent
{
public:
    CIwUIEventClick(s3ePointerButton button, bool pressed, const CIwVec2& pos);
    public: CIwUIEventClick() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_CLICK"); m_Hash = IWUI_EVENT_CLICK ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_CLICK };;


    s3ePointerButton GetButton() const { return m_Button; }
    bool GetPressed() const { return m_Pressed; }
    const CIwVec2 GetPos() const { return m_Pos; }

private:
    s3ePointerButton m_Button;
    bool m_Pressed;
    CIwVec2 m_Pos;
};







class CIwUIEventPointerMove : public CIwUIEvent
{
public:
    CIwUIEventPointerMove(const CIwVec2& pos);
    public: CIwUIEventPointerMove() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_POINTER_MOVE"); m_Hash = IWUI_EVENT_POINTER_MOVE ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_POINTER_MOVE };;


    const CIwVec2& GetPos() const { return m_Pos; }

private:
    CIwVec2 m_Pos;
};







class CIwUIEventTouchPress : public CIwUIEvent
{
public:
    CIwUIEventTouchPress(uint32 touchid, bool pressed, const CIwVec2& pos);
    public: CIwUIEventTouchPress() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_TOUCH_PRESS"); m_Hash = IWUI_EVENT_TOUCH_PRESS ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_TOUCH_PRESS };;


    uint32 GetTouchID() const { return m_TouchID; }
    bool GetPressed() const { return m_Pressed; }
    const CIwVec2 GetPos() const { return m_Pos; }

private:
    uint32 m_TouchID;
    bool m_Pressed;
    CIwVec2 m_Pos;
};







class CIwUIEventTouchMove : public CIwUIEvent
{
public:
    CIwUIEventTouchMove(uint32 touchid, const CIwVec2& pos);
    public: CIwUIEventTouchMove() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_TOUCH_MOVE"); m_Hash = IWUI_EVENT_TOUCH_MOVE ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_TOUCH_MOVE };;


    uint32 GetTouchID() const { return m_TouchID; }
    const CIwVec2& GetPos() const { return m_Pos; }

private:
    uint32 m_TouchID;
    CIwVec2 m_Pos;
};
# 254 "c:/marmalade/6.2/modules/iwui/h/IwUIEvent.h"
class CIwUIEventPointerEnter : public CIwUIEvent
{
public:
    CIwUIEventPointerEnter(CIwUIElement* pElement);
    public: CIwUIEventPointerEnter() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_POINTER_ENTER"); m_Hash = IWUI_EVENT_POINTER_ENTER ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_POINTER_ENTER };;
};
# 268 "c:/marmalade/6.2/modules/iwui/h/IwUIEvent.h"
class CIwUIEventPointerLeave : public CIwUIEvent
{
public:
    CIwUIEventPointerLeave(CIwUIElement* pElement);
    public: CIwUIEventPointerLeave() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_POINTER_LEAVE"); m_Hash = IWUI_EVENT_POINTER_LEAVE ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_POINTER_LEAVE };;
};
# 282 "c:/marmalade/6.2/modules/iwui/h/IwUIEvent.h"
class CIwUIEventTouchEnter : public CIwUIEvent
{
public:
    CIwUIEventTouchEnter(uint32 touchid, CIwUIElement* pElement);
    public: CIwUIEventTouchEnter() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_TOUCH_ENTER"); m_Hash = IWUI_EVENT_TOUCH_ENTER ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_TOUCH_ENTER };;


    uint32 GetTouchID() const { return m_TouchID; }

private:
    uint32 m_TouchID;
};
# 302 "c:/marmalade/6.2/modules/iwui/h/IwUIEvent.h"
class CIwUIEventTouchLeave : public CIwUIEvent
{
public:
    CIwUIEventTouchLeave(uint32 touchid, CIwUIElement* pElement);
    public: CIwUIEventTouchLeave() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_TOUCH_LEAVE"); m_Hash = IWUI_EVENT_TOUCH_LEAVE ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_TOUCH_LEAVE };;


    uint32 GetTouchID() const { return m_TouchID; }

private:
    uint32 m_TouchID;
};







class CIwUIEventFocus : public CIwUIEvent
{
public:
    CIwUIEventFocus(CIwUIElement* pElement, bool gainingFocus);
    public: CIwUIEventFocus() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_FOCUS"); m_Hash = IWUI_EVENT_FOCUS ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_FOCUS };;


    bool IsGainingFocus() const { return m_GainingFocus; }

private:
    bool m_GainingFocus;
};







class CIwUIEventButton : public CIwUIEvent
{
public:
    CIwUIEventButton(CIwUIButton* pButton);
    public: CIwUIEventButton() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_BUTTON"); m_Hash = IWUI_EVENT_BUTTON ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_BUTTON };;

    CIwUIButton* GetButton() const;
};







class CIwUIEventRadioButton : public CIwUIEvent
{
public:
    CIwUIEventRadioButton(CIwUIRadioButton* pRadioButton, bool selected);
    public: CIwUIEventRadioButton() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_RADIO_BUTTON"); m_Hash = IWUI_EVENT_RADIO_BUTTON ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_RADIO_BUTTON };;

    bool GetSelected() const { return m_Selected; }

    CIwUIRadioButton* GetRadioButton() const;

private:
    bool m_Selected;
};







class CIwUIEventLayout : public CIwUIEvent
{
public:
    CIwUIEventLayout(CIwUIElement* pElement);
    public: CIwUIEventLayout() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_LAYOUT"); m_Hash = IWUI_EVENT_LAYOUT ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_LAYOUT };;
};







class CIwUIEventVisibility : public CIwUIEvent
{
public:
    CIwUIEventVisibility(CIwUIElement* pElement);
    public: CIwUIEventVisibility() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_VISIBILITY"); m_Hash = IWUI_EVENT_VISIBILITY ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_VISIBILITY };;
};







class CIwUIEventAlertDialogButton : public CIwUIEvent
{
public:
    CIwUIEventAlertDialogButton(CIwUIAlertDialog* pAlertDialog, int index);
    public: CIwUIEventAlertDialogButton() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_ALERT_DIALOG_BUTTON"); m_Hash = IWUI_EVENT_ALERT_DIALOG_BUTTON ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_ALERT_DIALOG_BUTTON };;

    int GetButtonIndex() const { return m_ButtonIndex; }

    CIwUIAlertDialog* GetAlertDialog() const;

private:
    int m_ButtonIndex;
};







class CIwUIEventCheckbox : public CIwUIEvent
{
public:
    CIwUIEventCheckbox(CIwUICheckbox* pCheckbox, bool pressed);
    public: CIwUIEventCheckbox() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_CHECKBOX"); m_Hash = IWUI_EVENT_CHECKBOX ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_CHECKBOX };;

    bool GetPressed() const { return m_Pressed; }

    CIwUICheckbox* GetCheckbox() const;

private:
    bool m_Pressed;
};







class CIwUIEventPickerView : public CIwUIEvent
{
public:
    CIwUIEventPickerView(CIwUIPickerView* pPickerView, int32 column,
        int32 selectedRow);
    public: CIwUIEventPickerView() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_PICKER_VIEW"); m_Hash = IWUI_EVENT_PICKER_VIEW ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_PICKER_VIEW };;

    int32 GetColumn() const { return m_Column; }
    int32 GetSelectedRow() const { return m_SelectedRow; }

    CIwUIPickerView* GetPickerView() const;

private:
    int32 m_Column;
    int32 m_SelectedRow;
};







class CIwUIEventPickerWheel : public CIwUIEvent
{
public:
    CIwUIEventPickerWheel(CIwUIPickerWheel* pPickerWheel, int32 selectedRow);
    public: CIwUIEventPickerWheel() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_PICKER_WHEEL"); m_Hash = IWUI_EVENT_PICKER_WHEEL ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_PICKER_WHEEL };;

    int32 GetSelectedRow() const { return m_SelectedRow; }

    CIwUIPickerWheel* GetPickerWheel() const;

private:
    int32 m_SelectedRow;
};







class CIwUIEventTabBarButton : public CIwUIEvent
{
public:
    CIwUIEventTabBarButton(CIwUITabBar* pTabBar, int index);
    public: CIwUIEventTabBarButton() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_TABBAR"); m_Hash = IWUI_EVENT_TABBAR ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_TABBAR };;

    int GetButtonIndex() const { return m_ButtonIndex; }

    CIwUITabBar* GetTabBar() const;

private:
    int m_ButtonIndex;
};







class CIwUIEventTableView : public CIwUIEvent
{
public:
    CIwUIEventTableView(CIwUITableView* pTableView, int32 selectedRow);
    public: CIwUIEventTableView() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_TABLE_VIEW"); m_Hash = IWUI_EVENT_TABLE_VIEW ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_TABLE_VIEW };;

    int32 GetSelectedRow() const { return m_SelectedRow; }

    CIwUITableView* GetTableViewItem() const;

private:
    int32 m_SelectedRow;
};







class CIwUIEventTableViewItem : public CIwUIEvent
{
public:
    CIwUIEventTableViewItem(CIwUIElement* pItem, bool selected);
    public: CIwUIEventTableViewItem() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_TABLE_VIEW_ITEM"); m_Hash = IWUI_EVENT_TABLE_VIEW_ITEM ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_TABLE_VIEW_ITEM };;

    bool GetSelected() const { return m_Selected; }

    CIwUIElement* GetTableViewItem() const;

private:
    bool m_Selected;
};







class CIwUIEventSlider : public CIwUIEvent
{
public:
    CIwUIEventSlider(CIwUISlider* pSlider, int value);
    public: CIwUIEventSlider() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_SLIDER"); m_Hash = IWUI_EVENT_SLIDER ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_SLIDER };;

    int GetSliderValue() const { return m_SliderValue; }

    CIwUISlider* GetSlider() const;

private:
    int m_SliderValue;
};







class CIwUIEventSoftKey : public CIwUIEvent
{
public:
    CIwUIEventSoftKey(CIwUISoftKey* pSoftKey, bool down, bool clicked);
    public: CIwUIEventSoftKey() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_SOFTKEY"); m_Hash = IWUI_EVENT_SOFTKEY ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_SOFTKEY };;

    bool GetDown() const { return m_Down; }
    bool GetClicked() const { return m_Clicked; }

    CIwUISoftKey* GetSoftKey() const;

private:
    bool m_Clicked;
    bool m_Down;
};







class CIwUIEventSoftKeyboard : public CIwUIEvent
{
public:
    CIwUIEventSoftKeyboard(CIwUISoftKeyboard* pSoftKeyboard, bool visible,
        const CIwUIRect& area);
    public: CIwUIEventSoftKeyboard() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_SOFTKEYBOARD"); m_Hash = IWUI_EVENT_SOFTKEYBOARD ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_SOFTKEYBOARD };;

    bool GetVisible() const { return m_Visible; }
    const CIwUIRect& GetArea() const { return m_Area; }

    CIwUISoftKeyboard* GetSoftKeyboard() const;

private:
    bool m_Visible;
    CIwUIRect m_Area;
};







class CIwUIEventTextInput : public CIwUIEvent
{
public:

    enum ETextInput
    {
        eChanged,
        eAccepted,
        eCancelled,


        E_CHANGED = eChanged,
        E_ACCEPTED = eAccepted,
        E_CANCELLED = eCancelled,
    };

    CIwUIEventTextInput(ETextInput action, const char* pCaption,
        CIwUIElement* pInputElement = __null);
    CIwUIEventTextInput(ETextInput action, const CIwPropertyString& caption,
        CIwUIElement* pInputElement = __null);
    public: CIwUIEventTextInput() { Create(); } void Create() { CIwManaged::SetName("IWUI_EVENT_TEXT_INPUT"); m_Hash = IWUI_EVENT_TEXT_INPUT ; } void SetName(const char* pName) { ((void)0); } enum { ID = IWUI_EVENT_TEXT_INPUT };;


    ETextInput GetAction() const { return m_Action; }
    const char* GetText() const { return m_Caption.c_str(); }
    const CIwPropertyString& GetCaption() const { return m_Caption; }

    CIwUIElement* GetInputElement() const;

private:
    ETextInput m_Action;
    CIwPropertyString m_Caption;
};
# 56 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIEventHandlerSlot.h" 1
# 31 "c:/marmalade/6.2/modules/iwui/h/IwUIEventHandlerSlot.h"
template<typename Handler, typename Event>
class CIwUIEventHandlerSlot : public CIwUIElementEventHandler
{
public:
    typedef bool (Handler::*Member)(Event*);

    CIwUIEventHandlerSlot(Handler* pHandler, Member pMember, bool handleNotFilter) :
        m_Handler(pHandler),
        m_Member(pMember),
        m_HandleNotFilter(handleNotFilter)
    {
    }

    bool EquivalentTo(const CIwUIElementEventHandler* pEventHandler) const
    {
        if (pEventHandler &&
            !strcmp(GetClassName(), pEventHandler->GetClassName()))
        {
            const CIwUIEventHandlerSlot* pEventHandlerSlot =
                IwSafeCast<const CIwUIEventHandlerSlot*>(pEventHandler);

            return m_Handler == pEventHandlerSlot->m_Handler &&
                m_Member == pEventHandlerSlot->m_Member &&
                m_HandleNotFilter == pEventHandlerSlot->m_HandleNotFilter;
        }

        return false;
    }

private:

    virtual const char* GetClassName() const
    {
        return typeid(CIwUIEventHandlerSlot).name();
    }


    virtual bool FilterEvent(CIwEvent* pEvent)
    {
        return !m_HandleNotFilter ? ProcessEvent(pEvent) : false;
    }

    virtual bool HandleEvent(CIwEvent* pEvent)
    {
        return m_HandleNotFilter ? ProcessEvent(pEvent) : false;
    }


    virtual CIwUIElementEventHandler* Clone() const
    {
        return new CIwUIEventHandlerSlot(m_Handler, m_Member, m_HandleNotFilter);
    }


    bool ProcessEvent(CIwEvent* pEvent)
    {
        if (pEvent->GetID() == Event::ID)
        {
            return (this->m_Handler->*this->m_Member)(IwSafeCast<Event*>(pEvent));
        }
        return false;
    }


    Handler* m_Handler;
    Member m_Member;
    bool m_HandleNotFilter;
};
# 130 "c:/marmalade/6.2/modules/iwui/h/IwUIEventHandlerSlot.h"
template<typename Handler, typename Event>
CIwUIEventHandlerSlot<Handler, Event>* IwUIAttachEventHandlerSlot(
    CIwUIElement* pElement, Handler* pHandler,
    bool(Handler::*pMember)(Event*), bool handleNotFilter = true)
{
    ((void)0);


    if (pElement)
    {

        CIwUIEventHandlerSlot<Handler, Event>* pEventHandler =
            new CIwUIEventHandlerSlot<Handler, Event>(
            pHandler, pMember, handleNotFilter);

        pElement->AddEventHandler(pEventHandler);

        return pEventHandler;
    }

    return __null;
}

template<typename Handler, typename Event>
bool IwUIDetachEventHandlerSlot(CIwUIElement* pElement, Handler* pHandler,
    bool(Handler::*pMember)(Event*), bool handleNotFilter = true)
{
    ((void)0);


    if (pElement)
    {
        const CIwUIEventHandlerSlot<Handler, Event> eventHandler(
            pHandler, pMember, handleNotFilter);

        bool found = false;
        for (int i=0; i<pElement->GetNumEventHandlers();)
        {
            CIwUIElementEventHandler* pEventHandler =
                pElement->GetEventHandler(i);
            if (eventHandler.EquivalentTo(pEventHandler))
            {
                pElement->RemoveEventHandler(pEventHandler);
                found = true;
            }
            else
            {
                ++i;
            }
        }
        return found;
    }

    return false;
}
# 58 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandler.h" 1
# 38 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandler.h"
class CIwUIElement;
class CIwUIEventFocus;
# 56 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandler.h"
enum IwUIFocusMovement
{
    IW_UI_FOCUS_MOVE_LEFT,
    IW_UI_FOCUS_MOVE_RIGHT,
    IW_UI_FOCUS_MOVE_UP,
    IW_UI_FOCUS_MOVE_DOWN,
    IW_UI_FOCUS_MOVE_NONE
};






enum IwUIFocusWrapMode
{
    IW_UI_FOCUS_WRAP_NONE,
    IW_UI_FOCUS_WRAP_WRAP,
    IW_UI_FOCUS_WRAP_STOP,
    IW_UI_FOCUS_WRAP_JUMP
};
# 87 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandler.h"
class CIwUIFocusHandler : public CIwResource, public IIwDecomposable,
    private CIwUncopyable
{
public:
    typedef CIwArray<CIwUIFocusHandler*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }
# 107 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandler.h"
    virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeClose(CIwTextDecomposer* pDecomposer) const;
# 125 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandler.h"
    virtual CIwUIElement* FindWantsFocus(CIwUIElement* pParentElement) const;
# 135 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandler.h"
    virtual CIwUIElement* MoveFocus(CIwUIElement* pParentElement,
        CIwUIElement* pCurrentFocus, IwUIFocusMovement movement) const;
# 152 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandler.h"
    static IwUIFocusWrapMode GetWrapMode(CIwUIElement* pElement,
        IwUIFocusMovement movement);





    CIwUIFocusHandler* Clone() const;


protected:
# 172 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandler.h"
    virtual void Clone(CIwUIFocusHandler* pTarget) const;



    static const char* s_CloneExpectedClassName;

};



# 59 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandler2D.h" 1
# 25 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandler2D.h"
class CIwUIEventKey;
# 36 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandler2D.h"
class CIwUIFocusHandler2D : public CIwUIFocusHandler
{
public:
    typedef CIwArray<CIwUIFocusHandler2D*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;

protected:

    virtual CIwUIElement* MoveFocus(CIwUIElement* pParentElement,
        CIwUIElement* pCurrentFocus, IwUIFocusMovement movement) const;
    virtual void Clone(CIwUIFocusHandler* pTarget) const;
};
# 60 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandlerTab.h" 1
# 25 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandlerTab.h"
class CIwUIEventKey;
# 36 "c:/marmalade/6.2/modules/iwui/h/IwUIFocusHandlerTab.h"
class CIwUIFocusHandlerTab : public CIwUIFocusHandler
{
public:
    typedef CIwArray<CIwUIFocusHandlerTab*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;

protected:

    virtual CIwUIElement* MoveFocus(CIwUIElement* pParentElement,
        CIwUIElement* pCurrentFocus, IwUIFocusMovement movement) const;
    virtual void Clone(CIwUIFocusHandler* pTarget) const;
};
# 61 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIGraphics.h" 1
# 38 "c:/marmalade/6.2/modules/iwui/h/IwUIGraphics.h"
class CIwGxFont;
class CIwGxFontPreparedData;
class CIwUIPrimitiveDrawer;
class CIwUIRegion;
# 50 "c:/marmalade/6.2/modules/iwui/h/IwUIGraphics.h"
class CIwUIGraphics
{
public:
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }
# 62 "c:/marmalade/6.2/modules/iwui/h/IwUIGraphics.h"
    CIwUIGraphics(const CIwUIRect drawArea = CIwUIRect(0, 0,
        IwGxGetScreenWidth(), IwGxGetScreenHeight()),
        const CIwMat& viewMat = CIwMat::g_Identity,
        IwGxCoordSpace coordSpace = IW_GX_SCREENSPACE);


    CIwUIGraphics(const CIwUIGraphics& graphics);
    ~CIwUIGraphics();
# 86 "c:/marmalade/6.2/modules/iwui/h/IwUIGraphics.h"
    void DrawImage(CIwTexture* pTexture, CIwMaterial* pMaterial, const CIwUIRect& rect,
        const CIwSVec2& uv0, const CIwSVec2& uv1, const CIwUIColour& col,
        bool applyColour = true);
# 99 "c:/marmalade/6.2/modules/iwui/h/IwUIGraphics.h"
    void DrawText(const CIwGxFont* pFont, const CIwVec2& position,
        const CIwGxFontPreparedData* pData, const CIwUIColour& col,
        bool applyColour = false);







    void DebugDrawRect(const CIwUIRect& rect, const CIwUIColour& col,
        bool clip = true);







    void DebugDrawRectCorners(const CIwUIRect& rect, const CIwUIColour& col);





    void DrawFlush();
# 133 "c:/marmalade/6.2/modules/iwui/h/IwUIGraphics.h"
    void SetViewMat(const CIwMat& viewMat);


    CIwMat GetViewMat() const;


    IwGxCoordSpace GetCoordSpace() const;






    void IntersectFrame(const CIwUIRect& localFrame);


    CIwUIRect GetFrameBounds() const;


    void SetFrame(const CIwUIRect& frame);



    bool IsFrameEmpty() const;






    void ModulateColour(const CIwUIColour& colour);


    const CIwUIColour& GetModulateColour() const { return m_ModulateColour; }


    void SetModulateColour(const CIwUIColour& colour) { m_ModulateColour = colour; }


    const CIwUIColour& GetColour() const { return m_Colour; }


    void SetColour(const CIwUIColour& colour) { m_Colour = colour; }


    CIwUIColour GetDrawColour(const CIwUIColour& col, bool applyColour);





    void ComposeTransform(const CIwUIMat& transform);


    void TranslateTransform(const CIwVec2& translation);


    CIwUIMat GetTransform() const;


    void SetTransform(const CIwUIMat& transform);

private:




    void operator=(const CIwUIGraphics& graphics);


    void DebugCheck();




    int32 m_RenderMatId;
    CIwUIRegion* m_Frame;
    CIwUIMat m_Transform;
    CIwUIColour m_Colour;
    CIwUIColour m_ModulateColour;

    CIwUIPrimitiveDrawer* m_PrimitiveDrawer;
    bool m_OwnsDrawing;
};
# 63 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIImage.h" 1
# 21 "c:/marmalade/6.2/modules/iwui/h/IwUIImage.h"
class IIwUIDrawable;
class CIwMaterial;
# 92 "c:/marmalade/6.2/modules/iwui/h/IwUIImage.h"
class CIwUIImage : public CIwUIElement
{
public:
    typedef CIwArray<CIwUIImage*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;





    void SetMaterial(CIwMaterial * pMaterial);





    void SetTexture(CIwTexture * pTexture);





    CIwMaterial* GetMaterial() const;







    CIwTexture* GetTexture() const;

protected:

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual CIwUIRect GetElementBounds() const;
    virtual void OnPropertyChanged(uint32 hashName);
    virtual void OnSizeChanged();
    virtual CIwVec2 MeasureElement(const CIwVec2& availableSize) const;
    virtual void Animate(const CIwUIAnimData& animData);
    virtual void TraverseElement(IIwUIVisitor& visitor);


    IIwUIDrawable* GetImage() { return m_Image; }
    const IIwUIDrawable* GetImage() const { return m_Image; }

private:

    CIwUIHoldingPtr<IIwUIDrawable> m_Image;


    void _CreateDrawables();
    void _DestroyDrawables();
};
# 65 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUILayout.h" 1
# 17 "c:/marmalade/6.2/modules/iwui/h/IwUILayout.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutItemContainer.h" 1
# 106 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutItemContainer.h"
class CIwUILayoutItemContainer : public CIwUILayoutItem
{
public:
    typedef CIwArray<CIwUILayoutItemContainer*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUILayoutItemContainer();
    ~CIwUILayoutItemContainer();


    virtual void ParseCloseChild(CIwTextParserITX* pParser, CIwManaged* pChild);
    virtual void Serialise();
    virtual void Resolve();


    virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeClose(CIwTextDecomposer* pDecomposer) const;


    virtual void DebugRender(CIwUIDebugGraphics& debugGraphics);





    void SetItem(CIwUILayoutItem* pItem);


    CIwUILayoutItem* GetItem() const { return m_Item; }


    CIwVec2 Measure(const CIwVec2& availableSize) const;


    void Arrange(const CIwVec2& pos, const CIwVec2& area);


    CIwUILayoutItemContainer* Clone() const;


    IwUIAlignmentH GetAlignmentH() const;


    IwUIAlignmentV GetAlignmentV() const;


    CIwSVec2 GetBorder() const;


    void SetAlignment(IwUIAlignmentH alignH, IwUIAlignmentV alignV);


    void SetAlignmentFromPos(const CIwVec2& pos,
        const CIwVec2& rectPos, const CIwVec2& rectSize);


    void SetBorder(CIwSVec2 border);





    const CIwVec2& GetCachedArrangePos() const;


    const CIwVec2& GetCachedArrangeArea() const;



    void GetCachedItemPosAndSize(CIwVec2& itemPos, CIwVec2& itemSize) const;


    virtual void Attach();
    virtual void InvalidateLayout();
    virtual bool PopulateElement(CIwUIElement* pElement);
    virtual bool RemoveElement(CIwUIElement* pElement);
    virtual bool IsChildElement(CIwUIElement* pElement) const;
    virtual void Traverse(IIwUIVisitor& visitor);

protected:
    virtual CIwVec2 MeasureItem(const CIwVec2& availableSize) const;
    virtual void ArrangeItem(const CIwVec2& pos, const CIwVec2& size);
    virtual void RemoveChildItem(CIwUILayoutItem* pChild);
    virtual void Clone(CIwUILayoutItem* pTarget) const;

    virtual bool InsertItem(CIwUILayoutItem* pItem,
        const CIwVec2& insertPos, int16 tolerance,
        const CIwVec2& arrangePos, const CIwVec2& arrangeSize);

private:


    CIwVec2 CachedMeasureItem(const CIwVec2& availableSize) const;


    CIwVec2 Position(const CIwVec2& size, const CIwVec2& area) const;


    CIwVec2 ApplyBorder(const CIwVec2& size, bool addNotRemove) const;


    void GetItemPosAndSize(const CIwVec2& pos, const CIwVec2& area,
        CIwVec2& itemPos, CIwVec2& itemSize) const;


    bool DecomposeContainer() const;


    CIwUILayoutItem* m_Item;


    CIwUIPositionPolicy m_PositionPolicy;


    CIwSVec2 m_Border;


    friend class CIwUILayout;


    mutable CIwVec2 m_CachedAvailableSize;
    mutable CIwVec2 m_CachedRequiredSize;
    mutable CIwVec2 m_CachedArrangePos;
    mutable CIwVec2 m_CachedArrangeArea;
};
# 18 "c:/marmalade/6.2/modules/iwui/h/IwUILayout.h" 2
# 39 "c:/marmalade/6.2/modules/iwui/h/IwUILayout.h"
class CIwUIView;
# 79 "c:/marmalade/6.2/modules/iwui/h/IwUILayout.h"
class CIwUILayout : public CIwUILayoutItem
{
public:
    typedef CIwArray<CIwUILayout*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUILayout();
    ~CIwUILayout();


    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
    virtual void ParseClose(CIwTextParserITX* pParser);
    virtual void ParseCloseChild(CIwTextParserITX* pParser, CIwManaged* pChild);


    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const;


    virtual void Serialise();
    virtual void Resolve();


    virtual bool RemoveElement(CIwUIElement* pElement);
    virtual void Traverse(IIwUIVisitor& visitor);







    void Populate(const CIwManagedList& elements);





    void AddElement(CIwUIElement* pElement,
        IwUIAlignmentH alignH = IW_UI_ALIGN_CENTRE,
        IwUIAlignmentV alignV = IW_UI_ALIGN_MIDDLE,
        CIwSVec2 border = CIwSVec2::g_Zero);





    void AddElement(CIwUIElement* pElement, const CIwUIStyle& style);





    void AddLayoutItem(CIwUILayoutItem* pLayoutItem,
        IwUIAlignmentH alignH = IW_UI_ALIGN_CENTRE,
        IwUIAlignmentV alignV = IW_UI_ALIGN_MIDDLE,
        CIwSVec2 border = CIwSVec2::g_Zero);





    void AddLayoutItem(CIwUILayoutItem* pLayoutItem, const CIwUIStyle& style);
# 149 "c:/marmalade/6.2/modules/iwui/h/IwUILayout.h"
    bool InsertElement(CIwUIElement* pElement, const CIwVec2& pos, int16 tolerance);
# 161 "c:/marmalade/6.2/modules/iwui/h/IwUILayout.h"
    bool MoveElement(CIwUIElement* pElement, const CIwVec2& pos, int16 tolerance);




    void SetElement(CIwUIElement* pElement);




    CIwUIElement* GetElement() const { return m_Element; }




    CIwUILayout* Clone() const;




    bool IsLayoutInvalid() const { return m_LayoutInvalid; }




    bool IsAttached() const { return m_IsAttached; }





    void SetSizeToSpace(bool val);





    bool GetSizeToSpace() const;




    CIwUILayoutItemContainer* GetLayoutItem(CIwUIElement* pElement);

protected:





    virtual CIwUILayoutItemContainer* ContainerFactory();




    virtual bool InsertIntoContainer(
        CIwUILayoutItem* pInsertItem, const CIwVec2& insertPos, int16 tolerance,
        CIwUILayoutItemContainer* pContainer);






    virtual CIwUILayoutItemContainer* InsertOverContainer(
        CIwUILayoutItem* pInsertItem, const CIwVec2& insertPos,
        CIwUILayoutItemContainer* pContainer);
# 236 "c:/marmalade/6.2/modules/iwui/h/IwUILayout.h"
    virtual CIwUILayoutItemContainer* InsertIntoLayout(CIwUILayoutItem* pItem,
        const CIwVec2& insertPos, const CIwVec2& arrangePos,
        const CIwVec2& arrangeSize);






    static bool TestInsertPos(const CIwVec2& insertPos, int16 tolerance,
        const CIwVec2& rectPos, const CIwVec2& rectSize);


    int GetNumLayoutItems() const;


    CIwUILayoutItemContainer* GetLayoutItem(int i);
    const CIwUILayoutItemContainer* GetLayoutItem(int i) const;


    const CIwUILayoutItemContainer* GetLayoutItem(const char* pName) const;


    CIwUILayoutItemContainer* GetLayoutItem(CIwUILayoutItem* pItem);


    int GetLayoutItemIndex(CIwUILayoutItem* pItem, bool recursive = false) const;


    CIwManagedList& GetLayoutItems() { return m_LayoutItems; }
    const CIwManagedList& GetLayoutItems() const { return m_LayoutItems; }


    void SetLayoutInvalid(bool val) { m_LayoutInvalid = val; }


    virtual void Attach();
    virtual void InvalidateLayout();
    virtual bool PopulateElement(CIwUIElement* pElement);
    virtual bool IsChildElement(CIwUIElement* pElement) const;
    virtual CIwUIElement* GetParentElement() const;

    virtual CIwVec2 MeasureItem(const CIwVec2& availableSize) const;
    virtual void ArrangeItem(const CIwVec2& pos, const CIwVec2& size);
    virtual void RemoveChildItem(CIwUILayoutItem* pChild);

    virtual bool InsertItem(CIwUILayoutItem* pItem,
        const CIwVec2& insertPos, int16 tolerance,
        const CIwVec2& arrangePos, const CIwVec2& arrangeSize);
    virtual void Clone(CIwUILayoutItem* pTarget) const;

private:





    CIwUILayoutItemContainer* AddItem(CIwUILayoutItem* pItem);
    CIwUILayoutItemContainer* CreateContainer();
    void CheckAttachContainer(CIwUILayoutItemContainer* pContainer);


    void SetItemAlignmentAndBorder(CIwUILayoutItemContainer* pContainer,
        IwUIAlignmentH alignH, IwUIAlignmentV alignV, const CIwSVec2& border) const;


    void _SetIsAttached(bool val) { m_IsAttached = val; }


    bool _InsertItem(CIwUILayoutItem* pItem, const CIwVec2& pos, int16 tolerance);


    CIwUIElement* m_Element;


    CIwManagedList m_LayoutItems;


    bool m_LayoutInvalid;
    bool m_IsAttached;
    bool m_SizeToSpace;


    friend class CIwUIElement;
};


# 67 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutForm.h" 1
# 48 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutForm.h"
class CIwUILayoutForm: public CIwUILayout
{
public:
    typedef CIwArray<CIwUILayoutForm*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUILayoutForm();
    ~CIwUILayoutForm();


    enum TCoordinate
    {
        eDefault,
        eLeft,
        eTop,
        eRight,
        eBottom
    };


    class Dimension : private CIwParseable
    {
    public:
        Dimension();
        Dimension(int32 fixedValue, uint32 guideName = 0,
            const char* pDebugGuideName = __null,
            TCoordinate guideCoord = eDefault);


        void Parse(CIwTextParserITX* pParser);
        void Decompose(CIwTextDecomposer* pDecomposer) const;
        void Serialise();
        void Resolve() {}
        void Clone(const Dimension& src) { *this = src; }


        bool operator == (const Dimension& dimension) const;
        Dimension& operator = (const Dimension& dimension);


        int32 GetFixedValue() const { return m_FixedValue; }
        uint32 GetGuideName() const { return m_GuideName; }
        TCoordinate GetGuideCoordinate() const { return m_GuideCoordinate; }

    private:

        virtual void ParseOpen(CIwTextParserITX* pParser) {}
        virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
        virtual void ParseClose(CIwTextParserITX* pParser);


        int32 m_FixedValue;
        uint32 m_GuideName;
        TCoordinate m_GuideCoordinate;
    };






    void AddElement(CIwUIElement* pElement,
        const Dimension& left, const Dimension& top,
        const Dimension& right, const Dimension& bottom,
        IwUIAlignmentH alignH = IW_UI_ALIGN_CENTRE,
        IwUIAlignmentV alignV = IW_UI_ALIGN_MIDDLE,
        CIwSVec2 border = CIwSVec2::g_Zero);





    void AddElement(CIwUIElement* pElement, const CIwUIStyle& style,
        const Dimension& left, const Dimension& top,
        const Dimension& right, const Dimension& bottom);





    void AddLayoutItem(CIwUILayoutItem* pLayoutItem,
        const Dimension& left, const Dimension& top,
        const Dimension& right, const Dimension& bottom,
        IwUIAlignmentH alignH = IW_UI_ALIGN_CENTRE,
        IwUIAlignmentV alignV = IW_UI_ALIGN_MIDDLE,
        CIwSVec2 border = CIwSVec2::g_Zero);





    void AddLayoutItem(CIwUILayoutItem* pLayoutItem, const CIwUIStyle& style,
        const Dimension& left, const Dimension& top,
        const Dimension& right, const Dimension& bottom);




    CIwVec2 GetFormSize() const { return m_FormSize; }




    void SetFormSize(const CIwVec2& formSize);

private:
    class Item : public CIwUILayoutItemContainer
    {
    public:
        typedef CIwArray<Item*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
        Item();


        virtual void Attach();
        virtual void RemoveChildItem(CIwUILayoutItem* pChild);
        virtual void Clone(CIwUILayoutItem* pTarget) const;


        void ResetCacheValues() const;

        CIwVec2 MeasureFormItem(const CIwVec2& availableSize,
            const CIwVec2& formSize) const;
        const CIwUIRect& ArrangeFormItem(const CIwVec2& pos,
            const CIwVec2& size, const CIwVec2& formSize);


        const CIwUIRect& GetCachedRect() const;

        void SetItemCorners(const Dimension& left, const Dimension& top,
            const Dimension& right, const Dimension& bottom,
            const CIwManagedList* pItems);

        bool HasGuide(const Item* pItem) const;

    private:

        void AttachGuides(const CIwManagedList* pItems);
        void DetachGuides(const Item* pGuide);
        Item* LookupGuide(uint32 guideName, const CIwManagedList* guides) const;
        const CIwManagedList* GetSiblings() const;
        CIwVec2 GetFixedSize() const;
        int32 GetFixedValue(TCoordinate coordinate) const;
        int32 GetFixedValue(const Dimension& dimension, const Item* pGuide,
            TCoordinate defaultCoord) const;
        int32 GetGuideValue(const Dimension& dimension, const CIwUIRect& guideRect,
            TCoordinate defaultCoord) const;
        int32 ScaleDivide(int32 a, iwfixed b, iwfixed c) const;
        int32 ScaleDivideRounded(int32 a, iwfixed b, iwfixed c) const;


        Dimension m_Left;
        Dimension m_Top;
        Dimension m_Right;
        Dimension m_Bottom;

        Item* m_LeftGuide;
        Item* m_TopGuide;
        Item* m_RightGuide;
        Item* m_BottomGuide;

        mutable CIwUIRect m_CachedRect;

        static const Item* s_MeasureItem;
    };


    virtual CIwVec2 MeasureItem(const CIwVec2& availableSize) const;
    virtual void ArrangeItem(const CIwVec2& pos, const CIwVec2& size);
    virtual void Attach();
    virtual void Clone(CIwUILayoutItem* pTarget) const;


    virtual CIwUILayoutItemContainer* ContainerFactory() { return new Item; }
    virtual bool InsertIntoContainer(
        CIwUILayoutItem* pInsertItem, const CIwVec2& insertPos, int16 tolerance,
        CIwUILayoutItemContainer* pContainer);
    virtual CIwUILayoutItemContainer* InsertOverContainer(
        CIwUILayoutItem* pInsertItem, const CIwVec2& insertPos,
        CIwUILayoutItemContainer* pContainer);
    virtual CIwUILayoutItemContainer* InsertIntoLayout(CIwUILayoutItem* pItem,
        const CIwVec2& insertPos, const CIwVec2& arrangePos,
        const CIwVec2& arrangeSize);


    int GetNumItems() const { return GetNumLayoutItems(); }
    Item* GetItem(int i) { return (Item*) GetLayoutItem(i); }
    const Item* GetItem(int i) const { return (Item*) GetLayoutItem(i); }
    const Item* GetItem(const char* pName) const { return (Item*) GetLayoutItem(pName); }


    CIwVec2 GetFixedFormSize() const;
    void SetItemCorners(Item* pItem,
        const Dimension& left, const Dimension& top,
        const Dimension& right, const Dimension& bottom) const;
    void SetItemDimensionsAndAlignment(Item* pItem, const CIwVec2& itemPos,
        const CIwVec2& itemSize, const CIwVec2& layoutPos, const CIwVec2& layoutSize);
    bool SnapHoriztonal(Dimension& dimension, int32& posX, int32& dist, Item* pGuideItem) const;
    bool SnapVertical(Dimension& dimension, int32& posY, int32& dist, Item* pGuideItem) const;
    void ResetItemCacheValues() const;


    CIwVec2 m_FormSize;


    friend void* _CIwUILayoutFormItemFactory();
    friend uint32 _GetCIwUILayoutFormItemSize();
    friend class Item;
    friend class CIwPropertyDataType<Dimension>;
};


# 68 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutGrid.h" 1
# 51 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutGrid.h"
class CIwUILayoutGrid: public CIwUILayout
{
public:
    typedef CIwArray<CIwUILayoutGrid*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUILayoutGrid();
    ~CIwUILayoutGrid();


    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
    virtual void ParseCloseChild(CIwTextParserITX* pParser, CIwManaged* pChild);


    virtual void Serialise();
    virtual void Resolve();


    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const;






    void AddElement(CIwUIElement* pElement,
        int16 column, int16 row, int16 columnSpan = 1, int16 rowSpan = 1,
        IwUIAlignmentH alignH = IW_UI_ALIGN_CENTRE,
        IwUIAlignmentV alignV = IW_UI_ALIGN_MIDDLE,
        CIwSVec2 border = CIwSVec2::g_Zero);





    void AddElement(CIwUIElement* pElement, const CIwUIStyle& style,
        int16 column, int16 row, int16 columnSpan = 1, int16 rowSpan = 1);





    void AddLayoutItem(CIwUILayoutItem* pLayoutItem,
        int16 column, int16 row, int16 columnSpan = 1, int16 rowSpan = 1,
        IwUIAlignmentH alignH = IW_UI_ALIGN_CENTRE,
        IwUIAlignmentV alignV = IW_UI_ALIGN_MIDDLE,
        CIwSVec2 border = CIwSVec2::g_Zero);





    void AddLayoutItem(CIwUILayoutItem* pLayoutItem, const CIwUIStyle& style,
        int16 column, int16 row, int16 columnSpan = 1, int16 rowSpan = 1);





    void AddColumn(int32 minSize = 0, int32 maxSize = 0x7fffffffL);





    void AddRow(int32 minSize = 0, int32 maxSize = 0x7fffffffL);





    int GetNumColumns() const;




    int GetNumRows() const;


    void SetLayoutItemSpanFromPosSize(CIwUIElement* element);
private:

    class Item : public CIwUILayoutItemContainer
    {
    public:
        typedef CIwArray<Item*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
        Item();


        virtual void Attach();
        virtual void Clone(CIwUILayoutItem* pTarget) const;


        bool HasMultiSpan(bool columnNotRow, int16 numFiles) const;
        int16 GetPos(bool columnNotRow, int16 numFiles) const;
        int16 GetSpan(bool columnNotRow, int16 numFiles) const;


        int16 GetRow(int16 numRows) const;
        int16 GetColumn(int16 numColumns) const;
        int16 GetRowSpan(int16 numRows) const;
        int16 GetColumnSpan(int16 numColumns) const;

        void SetRow(int16 row);
        void SetColumn(int16 column);
        void SetRowSpan(int16 rowSpan);
        void SetColumnSpan(int16 columnSpan);

    private:

        int16 m_Column;
        int16 m_Row;
        int16 m_ColumnSpan;
        int16 m_RowSpan;
    };

    class File : public CIwUILayoutItem
    {
    public:
        typedef CIwArray<File*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
        File();


        virtual void Serialise();


        virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const;


        virtual void Attach();
        File* Clone() const;


        void ResetCacheValues() const;
        void BoundCacheMin(int32 minSize) const;
        void BoundCacheMax(int32 maxSize) const;
        void BoundCacheLimit(bool minNotMax, int32 limit) const;


        bool IsMaxLimited() const;
        int32 GetMinSlack() const;
        int32 GetMaxSlack() const;
        int32 GetSlack(bool minNotMax) const;


        int32 GetMinSize() const { return m_MinSize; }
        int32 GetMaxSize() const { return m_MaxSize; }
        bool GetCachedEmpty() const { return m_CachedEmpty; }
        int32 GetCachedMin() const { return m_CachedMin; }
        int32 GetCachedMax() const { return m_CachedMax; }
        int32 GetCachedSize() const;
        int32 GetCachedLimit(bool minNotMax) const;

        void SetColumnNotRow(bool columnNotRow) { m_ColumnNotRow = columnNotRow; }
        void SetMinSize(int32 minSize);
        void SetMaxSize(int32 maxSize);
        void SetCachedEmpty(bool isEmpty) const { m_CachedEmpty = isEmpty; }
        void SetCacheSize(int32 size) const;

    protected:

        virtual CIwVec2 MeasureItem(const CIwVec2& availableSize) const;
        virtual void ArrangeItem(const CIwVec2& pos, const CIwVec2& size);
        virtual void RemoveChildItem(CIwUILayoutItem* pChild);
        virtual void Clone(CIwUILayoutItem* pTarget) const;

    private:

        bool m_ColumnNotRow;
        int32 m_MinSize;
        int32 m_MaxSize;

        mutable bool m_CachedEmpty;
        mutable int32 m_CachedMin;
        mutable int32 m_CachedMax;
        mutable int32 m_CachedSize;
    };


    virtual CIwVec2 MeasureItem(const CIwVec2& availableSize) const;
    virtual void ArrangeItem(const CIwVec2& pos, const CIwVec2& size);
    virtual void Attach();
    virtual void InvalidateLayout();
    virtual void Clone(CIwUILayoutItem* pTarget) const;
    virtual void DebugRender(CIwUIDebugGraphics& debugGraphics);


    virtual CIwUILayoutItemContainer* ContainerFactory() { return new Item; }
    virtual CIwUILayoutItemContainer* InsertIntoLayout(CIwUILayoutItem* pItem,
        const CIwVec2& insertPos, const CIwVec2& arrangePos,
        const CIwVec2& arrangeSize);


    int GetNumItems() const { return GetNumLayoutItems(); }
    Item* GetItem(int i) { return (Item*) GetLayoutItem(i); }
    const Item* GetItem(int i) const { return (const Item*) GetLayoutItem(i); }

    File* GetColumnFile(int i) { return (File*) m_ColumnFiles[i]; }
    const File* GetColumnFile(int i) const { return (const File*) m_ColumnFiles[i]; }

    File* GetRowFile(int i) { return (File*) m_RowFiles[i]; }
    const File* GetRowFile(int i) const { return (const File*) m_RowFiles[i]; }


    void ResetFileCacheValues() const;
    void CalculateColumnWidthLimits() const;
    void CalculateColumnWidths(int32 availableWidth, bool sizeToSpace) const;
    void CalculateRowHeightLimits() const;
    void CalculateRowHeights(int32 availableHeight, bool sizeToSpace) const;
    CIwVec2 GetTotalRowAndColumnSize() const;

    void SetItemRowAndColumn(Item* pItem, int16 row, int16 column,
        int16 rowSpan, int16 columnSpan) const;


    static void CalculateFileLimits(const CIwManagedList& items, const CIwManagedList& files,
        const CIwManagedList& complementFiles, bool columnNotRow, bool multiNotSingleSpan);
    static void AllocateMultiSpanItemSpace(const Item* pItem, const CIwManagedList& files,
        bool columnNotRow, int32 itemSize, bool minNotMax);
    static void CalculateFileSize(const CIwManagedList& files, int32 availableSpace,
        bool sizeToSpace);


    CIwManagedList m_ColumnFiles;
    CIwManagedList m_RowFiles;

    mutable CIwVec2 m_CacheAvailableSize;
    mutable CIwVec2 m_CacheRequiredSize;


    friend void* _CIwUILayoutGridItemFactory();
    friend uint32 _GetCIwUILayoutGridItemSize();
    friend void* _CIwUILayoutGridFileFactory();
    friend uint32 _GetCIwUILayoutGridFileSize();
};
# 69 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutHorizontal.h" 1
# 46 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutHorizontal.h"
class CIwUILayoutHorizontal : public CIwUILayout
{
public:
    typedef CIwArray<CIwUILayoutHorizontal*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUILayoutHorizontal();
    ~CIwUILayoutHorizontal();






    void AddElement(CIwUIElement* pElement, int16 order = 0,
        IwUIAlignmentH alignH = IW_UI_ALIGN_CENTRE,
        IwUIAlignmentV alignV = IW_UI_ALIGN_MIDDLE,
        CIwSVec2 border = CIwSVec2::g_Zero);





    void AddElement(CIwUIElement* pElement, const CIwUIStyle& style,
        int16 order = 0);





    void AddLayoutItem(CIwUILayoutItem* pLayoutItem, int16 order = 0,
        IwUIAlignmentH alignH = IW_UI_ALIGN_CENTRE,
        IwUIAlignmentV alignV = IW_UI_ALIGN_MIDDLE,
        CIwSVec2 border = CIwSVec2::g_Zero);





    void AddLayoutItem(CIwUILayoutItem* pLayoutItem, const CIwUIStyle& style,
        int16 order = 0);


    void SetSpacing(int16 spacing);





    void SetOrder(CIwUIElement* pElement, int16 order);

private:

    class Item : public CIwUILayoutItemContainer
    {
    public:
        typedef CIwArray<Item*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
        Item() : m_Order(0) {}


        virtual void Attach();
        virtual void Clone(CIwUILayoutItem* pTarget) const;


        CIwVec2 GetItemSize(const CIwVec2& availableSize) const;
        CIwVec2 GetItemSizeToSpace(const CIwVec2& itemSize,
            CIwVec2& totalSize, CIwVec2& availableSize) const;


        void SetOrder(int16 order);
        int16 GetOrder() const { return m_Order; }

    private:
        int16 m_Order;
    };


    virtual CIwVec2 MeasureItem(const CIwVec2& availableSize) const;
    virtual void ArrangeItem(const CIwVec2& pos, const CIwVec2& size);
    virtual void Attach();
    virtual void Clone(CIwUILayoutItem* pTarget) const;


    virtual CIwUILayoutItemContainer* ContainerFactory() { return new Item; }
    virtual CIwUILayoutItemContainer* InsertOverContainer(
        CIwUILayoutItem* pInsertItem, const CIwVec2& insertPos,
        CIwUILayoutItemContainer* pContainer);


    void SetItemOrder(Item* pContainer, int16 order) const;
    void SortItemsByOrder();
    CIwVec2 GetTotalItemSize(const CIwVec2& availableSize, bool includeSpacing) const;


    int16 m_Spacing;


    friend void* _CIwUILayoutHorizontalItemFactory();
    friend uint32 _GetCIwUILayoutHorizontalItemSize();
};
# 70 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2



# 1 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutSpacer.h" 1
# 62 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutSpacer.h"
class CIwUILayoutSpacer : public CIwUILayoutItem
{
public:
    typedef CIwArray<CIwUILayoutSpacer*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUILayoutSpacer();
    ~CIwUILayoutSpacer();


    void SetAspectRatio(const CIwVec2& ratio);
    void SetHint(const CIwVec2& hint);
    void SetMin(const CIwVec2& min);
    void SetMax(const CIwVec2& max);

protected:

    virtual CIwVec2 MeasureItem(const CIwVec2& availableSize) const;
    virtual void ArrangeItem(const CIwVec2& pos, const CIwVec2& size);
    virtual void Attach();
    virtual void RemoveChildItem(CIwUILayoutItem* pChild);
    virtual void Clone(CIwUILayoutItem* pTarget) const;

private:

    CIwUISizePolicy m_SizePolicy;
};
# 74 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutVertical.h" 1
# 46 "c:/marmalade/6.2/modules/iwui/h/IwUILayoutVertical.h"
class CIwUILayoutVertical : public CIwUILayout
{
public:
    typedef CIwArray<CIwUILayoutVertical*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUILayoutVertical();
    ~CIwUILayoutVertical();






    void AddElement(CIwUIElement* pElement, int16 order = 0,
        IwUIAlignmentH alignH = IW_UI_ALIGN_CENTRE,
        IwUIAlignmentV alignV = IW_UI_ALIGN_MIDDLE,
        CIwSVec2 border = CIwSVec2::g_Zero);





    void AddElement(CIwUIElement* pElement, const CIwUIStyle& style,
        int16 order = 0);





    void AddLayoutItem(CIwUILayoutItem* pLayoutItem, int16 order = 0,
        IwUIAlignmentH alignH = IW_UI_ALIGN_CENTRE,
        IwUIAlignmentV alignV = IW_UI_ALIGN_MIDDLE,
        CIwSVec2 border = CIwSVec2::g_Zero);





    void AddLayoutItem(CIwUILayoutItem* pLayoutItem, const CIwUIStyle& style,
        int16 order = 0);


    void SetSpacing(int16 spacing);





    void SetOrder(CIwUIElement* pElement, int16 order);

private:

    class Item : public CIwUILayoutItemContainer
    {
    public:
        typedef CIwArray<Item*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
        Item() : m_Order(0) {}


        virtual void Attach();
        virtual void Clone(CIwUILayoutItem* pTarget) const;


        CIwVec2 GetItemSize(const CIwVec2& availableSize) const;
        CIwVec2 GetItemSizeToSpace(const CIwVec2& itemSize,
            CIwVec2& totalSize, CIwVec2& availableSize) const;


        void SetOrder(int16 order);
        int16 GetOrder() const { return m_Order; }

    private:
        int16 m_Order;
    };


    virtual CIwVec2 MeasureItem(const CIwVec2& availableSize) const;
    virtual void ArrangeItem(const CIwVec2& pos, const CIwVec2& size);
    virtual void Clone(CIwUILayoutItem* pTarget) const;
    virtual void Attach();


    virtual CIwUILayoutItemContainer* ContainerFactory() { return new Item; }
    virtual CIwUILayoutItemContainer* InsertOverContainer(
        CIwUILayoutItem* pInsertItem, const CIwVec2& insertPos,
        CIwUILayoutItemContainer* pContainer);


    void SetItemOrder(Item* pContainer, int16 order) const;
    void SortItemsByOrder();
    CIwVec2 GetTotalItemSize(const CIwVec2& availableSize, bool includeSpacing) const;


    int16 m_Spacing;


    friend void* _CIwUILayoutVerticalItemFactory();
    friend uint32 _GetCIwUILayoutVerticalItemSize();
};
# 75 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2


# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerView.h" 1
# 26 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerView.h"
class CIwUIEventPickerWheel;
class CIwUIPickerView;
class CIwUIPickerWheel;
class CIwUIPickerViewItemSource;
# 97 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerView.h"
class CIwUIPickerView : public CIwUIElement
{
public:
    typedef CIwArray<CIwUIPickerView*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUIPickerView();
    virtual ~CIwUIPickerView();


    virtual void ParseCloseChild(CIwTextParserITX* pParser, CIwManaged* pChild);


    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const;


    virtual void Serialise();
    virtual void Resolve();
# 123 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerView.h"
    void SetItemSource(CIwUIPickerViewItemSource* pItemSource);
# 132 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerView.h"
    void SetSelectedRowForColumn(int32 column, int32 row, bool scrollToRow = false);




    CIwUIPickerViewItemSource* GetItemSource();




    int32 GetSelectedRowForColumn(int32 column) const;





    void RecreateItemsFromSource();






    void RecreateItemsForColumnFromSource(int32 column);







    void AttachSelectionSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);







    void DetachSelectionSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);


protected:

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void OnPropertyChanged(uint32 hashName);
    virtual void OnSizeChanged();
    virtual CIwVec2 MeasureElement(const CIwVec2& availableSize) const;
    virtual void Render(const CIwUIGraphics& parentGraphics);
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual bool WantsFocus() const;
    virtual bool HandlesFocus() const;
    virtual CIwUIElement* FindWantsFocus();
    virtual bool HandleEvent(CIwEvent* pEvent);
    virtual bool HandleEventKey(CIwUIEventKey* pEventKey);
    virtual void Arrange(const CIwVec2& pos, const CIwVec2& size);
    virtual void OnChildRemove(CIwUIElement* pChild);
    virtual void Animate(const CIwUIAnimData& animData);
    virtual void TraverseElement(IIwUIVisitor& visitor);


    IIwUIDrawable* GetBackground() { return m_Background; }
    IIwUIDrawable* GetSpacer() { return m_Spacer; }
    IIwUIDrawable* GetIndicator() { return m_Indicator; }
    IIwUIDrawable* GetImageFocus() { return m_ImageFocus; }

    const IIwUIDrawable* GetBackground() const { return m_Background; }
    const IIwUIDrawable* GetSpacer() const { return m_Spacer; }
    const IIwUIDrawable* GetIndicator() const { return m_Indicator; }
    const IIwUIDrawable* GetImageFocus() const { return m_ImageFocus; }

    int32 GetNumWheels() const;
    CIwUIPickerWheel* GetWheel(int32 column) const;

private:

    IwUI<CIwUIElement*>::Array m_Wheels;
    CIwUIHoldingPtr<IIwUIDrawable> m_Background;
    CIwUIHoldingPtr<IIwUIDrawable> m_Spacer;
    CIwUIHoldingPtr<IIwUIDrawable> m_Indicator;
    CIwUIHoldingPtr<IIwUIDrawable> m_ImageFocus;
    CIwUIPickerViewItemSource* m_ItemSource;
    bool m_ItemSourceFromProperty;


    void _CreateItemSourceFromProperty();
    void _CreateDrawables();
    void _DestroyDrawables();
    void _CreateWheels();
    void _DestroyWheels();
    void _RenderOverlay(CIwUIGraphics& graphics);
    bool _HandleEventPickerWheel(CIwUIEventPickerWheel* pEventPickerWheel);
    void _ArrangeWheels(const CIwVec2& pos, const CIwVec2& size);

    CIwUIRect _GetSpacerRect(int32 index) const;
    CIwUIRect _GetIndicatorRect() const;
    CIwSVec2 _GetMargin() const;
    int16 _GetSpacing() const;
};
# 78 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerViewItemSource.h" 1
# 25 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerViewItemSource.h"
class CIwUIElement;
class CIwUIPickerView;
# 49 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerViewItemSource.h"
class CIwUIPickerViewItemSource : public CIwResource, public IIwDecomposable
{
public:
    typedef CIwArray<CIwUIPickerViewItemSource*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUIPickerViewItemSource() : m_PickerView(__null) {}
    virtual ~CIwUIPickerViewItemSource() {}


    virtual void ParseClose(CIwTextParserITX* pParser);


    virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeClose(CIwTextDecomposer* pDecomposer) const;
# 77 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerViewItemSource.h"
    CIwUIPickerViewItemSource* Clone() const;




    CIwUIPickerView* GetPickerView() { return m_PickerView; }
# 94 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerViewItemSource.h"
    virtual int32 GetNumColumns() const = 0;




    virtual int32 GetNumRowsForColumn(int32 column) const = 0;




    virtual CIwUIElement* CreateItem(int32 column, int32 row) = 0;




    virtual void ReleaseItem(CIwUIElement* pItem, int32 column, int32 row) = 0;




    virtual int32 GetColumnWidthHint(int32 column) const = 0;




    virtual int32 GetRowHeightForColumn(int32 column, int32 columnWidth) const = 0;


protected:
# 132 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerViewItemSource.h"
    virtual void Activate(bool val);




    virtual void Clone(CIwUIPickerViewItemSource* pTarget) const;



    static const char* s_CloneExpectedClassName;


private:

    void _SetPickerView(CIwUIPickerView* pOwner);


    CIwUIPickerView* m_PickerView;


    friend class CIwUIPickerView;
};


# 79 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerWheel.h" 1
# 31 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerWheel.h"
class CIwUIPickerView;
class CIwUIPointerMovement;
class CIwUIScrollAnimation;
class CIwUIPickerViewItemSource;
# 43 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerWheel.h"
class CIwUIPickerWheel : public CIwUIElement
{
public:
    typedef CIwArray<CIwUIPickerWheel*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUIPickerWheel();
    virtual ~CIwUIPickerWheel();
# 61 "c:/marmalade/6.2/modules/iwui/h/IwUIPickerWheel.h"
    void SetSelectedRow(int32 row, bool scrollToRow = false);





    int32 GetSelectedRow() const;




    void RecreateItems();


protected:

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void OnSizeChanged();
    virtual void UpdateElement(int32 deltaMS);
    virtual void Render(const CIwUIGraphics& parentGraphics);
    virtual CIwUIElement* Intersect(const CIwVec2& pos) const;
    virtual bool IntersectElement(const CIwVec2& pos) const;
    virtual bool WantsFocus() const;
    virtual bool HandleEventKey(CIwUIEventKey* pEventKey);
    virtual bool HandleEventFocus(CIwUIEventFocus* pEventFocus);
    virtual bool HandleEventClick(CIwUIEventClick* pEventClick);
    virtual bool HandleEventPointerMove(CIwUIEventPointerMove* pEventPointerMove);
    virtual bool HandleEventPointerLeave(CIwUIEventPointerLeave* pEventPointerLeave);
    virtual void Arrange(const CIwVec2& pos, const CIwVec2& size);
    virtual void OnChildRemove(CIwUIElement* pChild);

private:

    class ControlData
    {
    public:
        ControlData();
        void Clear();

        bool m_KeyPressed;
        bool m_KeyUpNotDown;
        bool m_KeyFreeSpin;
        int32 m_KeyPressTimer;
        int32 m_KeyRepeatTimer;
    };


    IwUI<CIwUIElement*>::Array m_Items;
    int32 m_FirstItemRow;

    CIwUIPickerView* m_View;
    int32 m_Column;
    int32 m_SelectedRow;
    int32 m_NumRows;
    int32 m_RowHeight;
    bool m_EnsureVisibleRows;
    bool m_GenerateEvent;

    bool m_Dragging;
    CIwVec2 m_ScrollPosition;
    ControlData m_ControlData;
    CIwUIPointerMovement* m_PointerMovement;
    CIwUIScrollAnimation* m_ScrollAnimation;


    CIwUIPickerViewItemSource* _GetItemSource(bool allowMissing = false);
    void _SetPickerViewAndColumn(CIwUIPickerView* pPickerView, int32 column);

    void _SetupFromItemSource();
    int32 _GetColumnWidth() const;
    void _UpdateRowHeight(int32 columnWidth);

    void _ClearActiveState();
    void _CreateItems();
    void _ReleaseItems();
    void _EnsureVisibleRows();
    CIwUIElement* _CreateItem(int32 row);
    void _ReleaseItem(CIwUIElement* pItem, int32 row);

    CIwUIRect _GetSelectionIndicatorRect() const;
    CIwVec2 _GetScrollPositionToRow(int32 row) const;

    int32 _ClampRow(int32 row) const;
    CIwVec2 _ClampScrollPosition(const CIwVec2& scrollPosition) const;

    void _SetScrollPositionFromSelectedRow();
    void _SetSelectedRowFromScrollPosition();
    void _SetScrollPosition(const CIwVec2& scrollPosition);
    void _GenerateEvent();

    void _ScrollAndReleasePointer();
    void _ScrollToSelectedRow();
    void _ApplyScrollDrag(int32 deltaMS);

    void _SelectedRowKeyMovement(bool keyPressed, bool upNotDown);
    void _UpdateSelectedRowKeyMovement(int32 deltaMS);
    void _MoveSelection(bool upNotDown);


    friend class CIwUIPickerView;
};
# 80 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIProgressBar.h" 1
# 89 "c:/marmalade/6.2/modules/iwui/h/IwUIProgressBar.h"
class CIwUIProgressBar : public CIwUIElement
{
public:
    typedef CIwArray<CIwUIProgressBar*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUIProgressBar();






    void SetProgress(iwfixed prop);





    iwfixed GetProgress() const;





    void SetMaterial(CIwMaterial * pMaterial);





    void SetTexture(CIwTexture * pTexture);





    CIwMaterial* GetMaterial() const;







    CIwTexture* GetTexture() const;

protected:

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual CIwUIRect GetElementBounds() const;
    virtual void OnPropertyChanged(uint32 hashName);
    virtual void OnSizeChanged();
    virtual CIwVec2 MeasureElement(const CIwVec2& availableSize) const;
    virtual void Animate(const CIwUIAnimData& animData);
    virtual void TraverseElement(IIwUIVisitor& visitor);


    IIwUIDrawable* GetBar() { return m_Bar; }
    IIwUIDrawable* GetBackground() { return m_Background; }

    const IIwUIDrawable* GetBar() const { return m_Bar; }
    const IIwUIDrawable* GetBackground() const { return m_Background; }

private:

    CIwUIHoldingPtr<IIwUIDrawable> m_Bar;
    CIwUIHoldingPtr<IIwUIDrawable> m_Background;


    void _CreateDrawables();
    void _DestroyDrawables();
    void _SetProgress(iwfixed prop);
    iwfixed _GetProgress() const;
    bool _GetScaleDontCrop() const;
    CIwSVec2 _GetMargin() const;
    CIwVec2 _GetBarPos(const CIwVec2& barSize) const;
    CIwVec2 _GetBarSize() const;
};
# 81 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIRadioButton.h" 1
# 58 "c:/marmalade/6.2/modules/iwui/h/IwUIRadioButton.h"
class CIwUIRadioButton : public CIwUIButton
{
public:
    typedef CIwArray<CIwUIRadioButton*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUIRadioButton();





    void SetSelected(bool val);





    bool GetSelected() const { return m_Selected; }







    void AttachSelectedSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);







    void DetachSelectedSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);

protected:

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual bool IntersectElement(const CIwVec2& pos) const;
    virtual CIwUIRect GetElementBounds() const;
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual void OnPropertyChanged(uint32 hashName);
    virtual void OnSizeChanged();
    virtual bool HandleEvent(CIwEvent* pEvent);
    virtual void Animate(const CIwUIAnimData& animData);


    IIwUIDrawable* GetImageSelected() { return m_ImageSelected; }
    const IIwUIDrawable* GetImageSelected() const { return m_ImageSelected; }

private:

    CIwUIHoldingPtr<IIwUIDrawable> m_ImageSelected;
    bool m_Selected;
    CIwUIColour m_CaptionColourDefault;
    CIwUIColour m_CaptionColourSelected;


    void _CreateDrawables();
    void _DestroyDrawables();
    void _SetSelected(bool val);
};
# 83 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIScrollableView.h" 1
# 21 "c:/marmalade/6.2/modules/iwui/h/IwUIScrollableView.h"
class CIwUIPointerMovement;
class CIwUIScrollAnimation;
# 69 "c:/marmalade/6.2/modules/iwui/h/IwUIScrollableView.h"
class CIwUIScrollableView : public CIwUIElement
{
public:
    typedef CIwArray<CIwUIScrollableView*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUIScrollableView();
    virtual ~CIwUIScrollableView();
# 87 "c:/marmalade/6.2/modules/iwui/h/IwUIScrollableView.h"
    void Scroll(const CIwVec2& initialVelocity);






    void ScrollToPosition(const CIwVec2& pos);




    void StopScroll();




    void SetScrollPosition(const CIwVec2& pos);




    const CIwVec2& GetScrollPosition() const;


protected:

    virtual void UpdateElement(int32 deltaMS);
    virtual CIwVec2 Measure(const CIwVec2& availableSize) const;
    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void OnPropertyChanged(uint32 hashName);
    virtual void SetupGraphics(CIwUIGraphics& graphics) const;
    virtual void Render(const CIwUIGraphics& parentGraphics);
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual void DebugRender(CIwUIDebugGraphics& debugGraphics);
    virtual CIwUIElement* Intersect(const CIwVec2& pos) const;
    virtual bool IntersectElement(const CIwVec2& pos) const;
    virtual CIwUIMat GetElementViewTransform() const;
    virtual bool HandleEventKey(CIwUIEventKey* pEventKey);
    virtual bool HandleEventFocus(CIwUIEventFocus* pEventFocus);
    virtual bool FilterEvent(CIwEvent* pEvent);
    virtual bool WantsFocus() const;
    virtual void OnSizeChanged();
    virtual void Animate(const CIwUIAnimData& animData);


    IIwUIDrawable* GetHorizontalScrollBar() { return m_HorizontalScrollBar; }
    IIwUIDrawable* GetVerticalScrollBar() { return m_VerticalScrollBar; }

    const IIwUIDrawable* GetHorizontalScrollBar() const { return m_HorizontalScrollBar; }
    const IIwUIDrawable* GetVerticalScrollBar() const { return m_VerticalScrollBar; }
# 150 "c:/marmalade/6.2/modules/iwui/h/IwUIScrollableView.h"
    virtual CIwUIRect GetContentRect() const;







    virtual CIwVec2 ClampScrollPosition(const CIwVec2& scrollPosition) const;






    virtual void OnScrollPositionChanged() { }


private:

    bool m_ScrollToFocus;
    CIwVec2 m_ScrollPosition;
    CIwEvent* m_GeneratedEvent;

    bool m_Tracking;
    int32 m_TrackingTimer;
    bool m_Dragging;
    bool m_CapturingClickEvents;
    CIwVec2 m_SentPointerPosition;

    CIwUIPointerMovement* m_PointerMovement;
    CIwUIScrollAnimation* m_ScrollAnimation;

    int32 m_ScrollBarTimer;
    CIwUIHoldingPtr<IIwUIDrawable> m_HorizontalScrollBar;
    CIwUIHoldingPtr<IIwUIDrawable> m_VerticalScrollBar;


    void ScrollUp(CIwUIElement* pUnused = __null);
    void ScrollDown(CIwUIElement* pUnused = __null);
    void ScrollLeft(CIwUIElement* pUnused = __null);
    void ScrollRight(CIwUIElement* pUnused = __null);


    void _ApplyScrollDrag(int32 deltaMS, iwfixed frictionConstant);
    void _ApplyScrollSprings(int32 deltaMS, iwfixed springConstant);


    void _SetupFromProperties();
    void _CreateDrawables();
    void _DestroyDrawables();


    void _SetScrollPosition(const CIwVec2& pos);


    void _StartTracking(const CIwVec2& pointerPos, bool restart);
    void _StopTracking();


    bool _SendClickEvent(bool pressed, const CIwVec2& pos);
    bool _SendPointerMoveEvent(const CIwVec2& pos);
    bool _SendGeneratedEvent(CIwEvent* pEvent);
    bool _IsGeneratedEvent(const CIwEvent* pEvent) const;
    bool _FilterEventClick(CIwUIEventClick* pEventClick);
    bool _FilterEventPointerMove(CIwUIEventPointerMove* pEventPointerMove);
    void _EnsureElementInView(CIwUIElement* pElement);


    CIwUIRect _GetContainerRect() const;
    CIwUIRect _GetScrollRect() const;
    void _GetScrollDirections(bool& horizontal, bool& vertical) const;


    CIwVec2 _GetScrollBarSize() const;
    CIwUIRect _GetScrollBarRect(bool horizontalNotVertical) const;
    void _DisplayScrollBars();
    void _UpdateScrollBars(int32 deltaMS);
};
# 85 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUISlider.h" 1
# 119 "c:/marmalade/6.2/modules/iwui/h/IwUISlider.h"
class CIwUISlider : public CIwUIElement
{
public:
    typedef CIwArray<CIwUISlider*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUISlider();






    void SetValue(int16 val);





    int16 GetValue() const;





    void SetProportion(iwfixed prop);





    iwfixed GetProportion() const;







    void AttachChangeSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);







    void DetachChangeSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);

protected:

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual bool IntersectElement(const CIwVec2& pos) const;
    virtual CIwUIRect GetElementBounds() const;
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual void OnPropertyChanged(uint32 hashName);
    virtual void OnSizeChanged();
    virtual CIwVec2 MeasureElement(const CIwVec2& availableSize) const;
    virtual bool FilterEvent(CIwEvent* pEvent);
    virtual bool HandleEventKey(CIwUIEventKey* pEventKey);
    virtual bool HandleEventClick(CIwUIEventClick* pEventClick);
    virtual bool HandleEventPointerMove(CIwUIEventPointerMove* pEventPointerMove);
    virtual void Animate(const CIwUIAnimData& animData);
    virtual void TraverseElement(IIwUIVisitor& visitor);
    virtual bool WantsFocus() const { return _IsEnabled(); }


    IIwUIDrawable* GetBar() { return m_Bar; }
    IIwUIDrawable* GetMarker() { return m_Marker; }
    IIwUIDrawable* GetBackground() { return m_Background; }
    IIwUIDrawable* GetImageFocus() { return m_ImageFocus; }

    const IIwUIDrawable* GetBar() const { return m_Bar; }
    const IIwUIDrawable* GetMarker() const { return m_Marker; }
    const IIwUIDrawable* GetBackground() const { return m_Background; }
    const IIwUIDrawable* GetImageFocus() const { return m_ImageFocus; }

private:

    CIwUIHoldingPtr<IIwUIDrawable> m_Bar;
    CIwUIHoldingPtr<IIwUIDrawable> m_Marker;
    CIwUIHoldingPtr<IIwUIDrawable> m_Background;
    CIwUIHoldingPtr<IIwUIDrawable> m_ImageFocus;

    bool m_Dragging;
    CIwVec2 m_StartPos;


    void _CreateDrawables();
    void _DestroyDrawables();
    bool _IsEnabled() const;
    void _SlideLeft();
    void _SlideRight();
    void _SetValue(int16 val);
    int16 _GetValue() const;
    CIwVec2 _SetProportionFromPointerPos(const CIwVec2& pos);
    CIwSVec2 _GetMargin() const;
    int16 _GetSliderStep() const;
    bool _GetMarkerOverlaps() const;
    CIwVec2 _GetMarkerRange(const CIwVec2& markerSize) const;
    CIwVec2 _GetMarkerPos(const CIwVec2& markerSize) const;
    CIwVec2 _GetMarkerSize() const;
    CIwVec2 _GetBarPos(const CIwVec2& barSize, const CIwVec2& markerSize) const;
    CIwVec2 _GetBarSize(const CIwVec2& markerSize) const;
    CIwVec2 _GetBackgroundPos(const CIwVec2& markerSize) const;
    CIwVec2 _GetBackgroundSize(const CIwVec2& markerSize) const;
    CIwSVec2 _GetSliderRange() const;
};
# 87 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUISoftKey.h" 1
# 22 "c:/marmalade/6.2/modules/iwui/h/IwUISoftKey.h"
class CIwUIEventTouchPress;
class CIwUIEventTouchMove;
class CIwUIEventTouchEnter;
class CIwUIEventTouchLeave;
# 84 "c:/marmalade/6.2/modules/iwui/h/IwUISoftKey.h"
class CIwUISoftKey : public CIwUIElement
{
public:
    typedef CIwArray<CIwUISoftKey*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUISoftKey();

    enum EKeyType
    {
        eCharacter,
        eString,
        eDelete,
        eCapsLock,
        eCapsLockOn,
        eCapsLockOff,
        eNumLock,
        eEnter,
        eClose,
        eAlphabetPage,
        eSymbolsPage,
        eNumbersPage,
        eAccept,

        eVoid
    };


    void SetEnabled(bool val);
    bool GetEnabled() const;

    EKeyType GetKeyType() const;
    const char* GetKeyCharacter() const;
    const char* GetKeyCharacterLower() const;
    const char* GetKeyGroup() const;
    CIwMaterial* GetKeyMaterial() const;
    bool IsDown() const;

protected:

    virtual bool HandleEvent(CIwEvent* pEvent);
    virtual bool HandleEventKey(CIwUIEventKey* pEventKey);
    virtual bool HandleEventFocus(CIwUIEventFocus* pEventFocus);
    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual void OnPropertyChanged(uint32 hashName);
    virtual void OnSizeChanged();
    virtual bool IntersectElement(const CIwVec2& pos) const;
    virtual CIwUIRect GetElementBounds() const;
    virtual void Animate(const CIwUIAnimData& animData);
    virtual bool WantsFocus() const;

private:

    CIwUIHoldingPtr<IIwUIDrawable> m_ImageUp;
    CIwUIHoldingPtr<IIwUIDrawable> m_ImageDown;
    CIwUIHoldingPtr<IIwUIDrawable> m_ImageFocus;

    bool m_Down;
    IwUI<IIwUIDrawable*>::Array m_KeyContent;

    EKeyType m_KeyType;
    CIwPropertyString m_KeyCharacter;
    CIwPropertyString m_KeyGroup;
    CIwMaterial* m_KeyMaterial;


    void _SetDown(bool val);
    void _HandlePress(bool pressed, bool clicked);
    void _CreateDrawables();
    void _DestroyDrawables();
    void _SetContentPositionAndSize();

    bool _HandleEventTouchClick(CIwUIEventTouchPress* pEventClick);
    bool _HandleEventTouchEnter(CIwUIEventTouchEnter* pEventPointerEnter);
    bool _HandleEventTouchLeave(CIwUIEventTouchLeave* pEventPointerLeave);

    CIwSVec2 _GetMargin() const;
    CIwColour _GetColourDisabled() const;
    CIwColour _GetCapsLockColour() const;
};


# 88 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUISoftKeyBalloon.h" 1
# 21 "c:/marmalade/6.2/modules/iwui/h/IwUISoftKeyBalloon.h"
class CIwUISoftKey;
# 112 "c:/marmalade/6.2/modules/iwui/h/IwUISoftKeyBalloon.h"
class CIwUISoftKeyBalloon : public CIwUIElement
{
public:
    typedef CIwArray<CIwUISoftKeyBalloon*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUISoftKeyBalloon();


    void ShowKey(const CIwUISoftKey* pSoftKey);
    void HideKey(bool immediatelyWithoutDelay);

protected:

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void UpdateElement(int32 deltaMS);
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual void OnPropertyChanged(uint32 hashName);
    virtual void OnSizeChanged();
    virtual void Animate(const CIwUIAnimData& animData);

private:

    void _CreateDrawables();
    void _DestroyDrawables();

    void _CreateContents(bool createImageNotText);
    void _SetBalloonPosition(const CIwUISoftKey* pSoftKey);

    void _ShowKey();
    void _HideKey();

    CIwVec2 _GetBalloonSize() const;
    CIwVec2 _GetPointerSize() const;

    CIwUIHoldingPtr<IIwUIDrawable> m_Contents;
    CIwUIHoldingPtr<IIwUIDrawable> m_Background;
    CIwUIHoldingPtr<IIwUIDrawable> m_BackgroundPointer;
    int32 m_DisplayLength;
    int32 m_DisplayTimer;
};
# 89 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUISoftKeyboard.h" 1
# 22 "c:/marmalade/6.2/modules/iwui/h/IwUISoftKeyboard.h"
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUITextInput.h" 1
# 41 "c:/marmalade/6.2/modules/iwui/h/IwUITextInput.h"
class CIwUIElement;
class CIwUISoftKeyboard;
# 52 "c:/marmalade/6.2/modules/iwui/h/IwUITextInput.h"
class CIwUITextInput : public IIwUIEventHandler
{
public:
    private: static CIwUITextInput* s_Singleton; public: static inline CIwUITextInput* GetSingleton() { return s_Singleton; }
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUITextInput();
    virtual ~CIwUITextInput();





    enum EditorMode
    {



        eSoftKeyboard,




        eSoftNumpad,




        eInlineKeyboard,




        eInlineNumpad,




        eOSReadString,


        EDITOR_KEYBOARD = eSoftKeyboard,
        EDITOR_NUMPAD = eSoftNumpad,
        EDITOR_INLINE_KEYBOARD = eInlineKeyboard,
        EDITOR_INLINE_NUMPAD = eInlineNumpad,
        EDITOR_OS = eOSReadString,
    };





    enum EKeyboardLayout
    {



        eDefault,




        eURL,




        eEmailAddress,
    };






    void CreateSoftKeyboard(const char* pElementName = "soft_keyboard");






    void SetSoftKeyboard(CIwUISoftKeyboard* pSoftKeyboard);





    CIwUISoftKeyboard* GetSoftKeyboard();
    const CIwUISoftKeyboard* GetSoftKeyboard() const;






    void SetEditorMode(EditorMode mode);





    EditorMode GetEditorMode() const;







    virtual void DoTextEntry(CIwUIElement* pTextField = __null,
        const char* pOriginalText = __null,
        EKeyboardLayout keyboardLayout = eDefault);






    virtual void EndTextEntry(bool acceptNotCancel);






    bool ShouldDisplayCursor(const CIwUIElement* pTextField) const;





    bool IsShiftDown() const;






    bool IsBeingEdited(const CIwUIElement* pTextField) const;






    bool ShouldAllowFocus(const CIwUIElement* pTextField) const;






    void SetCursorPosition(int32 cursorPosition);





    int32 GetCursorPosition() const;





    void SetCursorFlashPeriod(int32 periodMS);




    int32 GetCursorFlashPeriod() const;







    void SetCursorDelay(int32 delayMS);




    int32 GetCursorDelay() const;





    void SetOSReadStringPrompt(const char* pPromptText);




    const char* GetOSReadStringPrompt() const;






    virtual void Update(int32 deltaMS);

protected:






    virtual void SetSoftKeyboardModal(CIwUISoftKeyboard* pSoftkeyboard);
# 271 "c:/marmalade/6.2/modules/iwui/h/IwUITextInput.h"
    virtual void AddCharacter(CIwPropertyString& string, const char* pChar);
# 281 "c:/marmalade/6.2/modules/iwui/h/IwUITextInput.h"
    virtual void DeleteCharacter(CIwPropertyString& string, bool backspaceNotDelete);


    virtual bool HandleEvent(CIwEvent* pEvent);
    virtual bool FilterEvent(CIwEvent* pEvent);

private:

    enum ETextMode
    {
        eTextLowerAlpha,
        eTextUpperAlpha,
        eTextNumeric,
        eTextCapitilise,

        eNumTextModes,
        eTextVoid = eNumTextModes
    };


    bool _IsActive() const;
    bool _LastEditInProgress() const;
    bool _UsingInlineEditor() const;
    bool _IsOneLine() const;

    void _SetTextMode(ETextMode textMode);
    bool _BeginEditing(CIwUIElement* pTextField);
    void _FinishEditing(bool acceptNotCancel);
    bool _OSReadString(EKeyboardLayout keyboardLayout);

    void _TextingGroup(const char* pGroup);
    void _AddCharacter(const char* pChar);
    void _DeleteCharacter(bool backspaceNotDelete);
    void _UpdateInputString(const CIwPropertyString& string);

    void _UpdateInputElements();
    void _SendEventToInputElements(CIwEvent* pEvent);
    void _FocusInputElement();
    void _Reset();
    EditorMode _ChooseEditMode() const;

    bool _StartingSentance();
    bool _CapitiliseNextCharacter(int num);
    bool _GetCharacterAtCursor(char (&character)[5]);
    bool _CharacterInGroup(const char* pCharacter, const char* pGroup);
    void _CycleTextMode();
    void _ShowSymbolChooser();
    void _MoveCursor(int delta);

    bool _OnCursorKey(s3eKey key);
    bool _OnNumpadKey(s3eKey key);
    bool _OnNumpadNum(int num);
    bool _OnKeyboardKey(s3eKey key);
    bool _OnKeyboardChar(s3eWChar wChar);


    EditorMode m_EditorMode;
    bool m_Active;
    CIwUIElementPtr m_SoftKeyboard;
    CIwUIElementPtr m_InputElement;

    int32 m_CursorFlashPeriod;
    int32 m_CursorDelay;

    CIwPropertyString m_String;
    CIwPropertyString m_OriginalString;
    CIwPropertyString m_OSReadStringPrompt;
    int32 m_CursorPosition;
    int32 m_CursorTimer;
    ETextMode m_TextMode;
    bool m_CapitiliseNextChar;


    friend class CIwUITextField;
    friend class CIwUISoftKeyboard;
    friend class CIwUISoftKeyboardBuilder;
};


inline CIwUITextInput* IwGetUITextInput() { ((void)0); return CIwUITextInput::GetSingleton(); } inline bool IwUITextInputExists() { return CIwUITextInput::GetSingleton() != __null; };



# 23 "c:/marmalade/6.2/modules/iwui/h/IwUISoftKeyboard.h" 2


class CIwUIEventSoftKey;
class CIwUILabel;
class CIwUISoftKeyBalloon;
class CIwUISoftKeyboardBuilder;
class CIwUITextField;
# 64 "c:/marmalade/6.2/modules/iwui/h/IwUISoftKeyboard.h"
class CIwUISoftKeyboard : public CIwUIElement
{
public:
    typedef CIwArray<CIwUISoftKeyboard*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUISoftKeyboard();
    virtual ~CIwUISoftKeyboard();




    bool UsingInlineEditor() const;

protected:

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void OnSizeChanged();
    virtual void Arrange(const CIwVec2& pos, const CIwVec2& size);
    virtual bool HandleEvent(CIwEvent* pEvent);
    virtual bool HandleEventClick(CIwUIEventClick* pEventClick);
    virtual bool HandleEventKey(CIwUIEventKey* pEventKey);
    virtual void UpdateElement(int32 deltaMS);

private:

    enum EPanelGroups
    {
        eKeyboardDefault,
        eKeyboardURL,
        eKeyboardEmail,
        eNumpad,
        eInline,

        eNumPanelGroups,
        eVoidGroup = eNumPanelGroups
    };

    enum EPanelTypes
    {
        eLowerAlpha,
        eUpperAlpha,
        eNumbers,
        eSymbols,

        eNumPanelTypes,
        eVoidPanel = eNumPanelTypes
    };


    void _SetupFromProperties();
    void _FindElements();
    void _CreateElements();
    void _DestroyElements();

    bool _HandleSoftKey(CIwUIEventSoftKey* pEventSoftKey);
    void _OnCharacter(const char* pChar, const char* pGroup);
    bool _OnNumpadNum(int num);

    void _AddCharacter(const char* pChar, const char* pGroup = __null);
    void _DeleteCharacter();
    void _FinishEditing(bool acceptNotCancel);

    void _SetModeAndLayout(CIwUITextInput::EditorMode mode,
        CIwUITextInput::EKeyboardLayout layout);
    void _ShowEditor(const CIwPropertyString& originalString);
    void _HideEditor();

    void _ShowPanel(EPanelTypes panelTypes);
    void _CreatePanelGroup(EPanelGroups panelGroup);
    void _DestroyPanelGroup();

    void _ShowInlineEditor();
    void _SetVisible(bool val);
    void _SetModal(bool val);
    void _LeaveSymbols();
    void _HideElements();

    void _SetShiftDown(bool shiftDown);
    void _SetTextModeLabel(CIwUITextInput::ETextMode textMode);
    void _ShowKeyBalloon(const CIwUISoftKey* pSoftKey);
    void _HideKeyBalloon(const CIwUISoftKey* pSoftKey, bool immediately);
    void _UpdateTextBox(const CIwPropertyString& string);
    bool _SendEventToTextBox(CIwEvent* pEvent);
    void _SendSoftKeyboardEvent();

    CIwUIElement* _GetCurrentPanel();
    CIwUIElement* _GetPreviousPanel();
    bool _IsBeingEdited(const CIwUIElement* pTextField) const;
    bool _IsShiftDown() const;
    bool _IsShowingSymbolChooser();
    bool _IsOneLine() const;
    void _Reset();


    CIwUISoftKeyboardBuilder* m_Builder;
    CIwUITextField* m_TextBox;
    CIwUISoftKeyBalloon* m_KeyBalloon;

    CIwUIElement* m_InlineEditor;
    CIwUILabel* m_TextingModeLabel;
    CIwUIElement* m_Close;
    CIwUIElement* m_Background;
    CIwUIElement* m_BackgroundFade;

    CIwUITextInput::EditorMode m_EditorMode;
    CIwUITextInput::EKeyboardLayout m_KeyboardLayout;
    EPanelGroups m_ActiveGroup;
    CIwUIElement* m_ActivePanels[eNumPanelTypes];
    EPanelTypes m_CurrentPanel;
    EPanelTypes m_PreviousPanel;
    bool m_IsEditing;
    bool m_IsModal;
    bool m_SendSoftKeyboardEvent;

    bool m_ShiftHeldDown;
    bool m_LastCharWasSpace;
    bool m_LastCharWasSymbol;
    bool m_LastCharWithShift;
    bool m_LastCharWasNumber;
    int32 m_TimeSinceLastChar;
    bool m_DeleteHeldDown;
    int32 m_RepeatDeleteTimer;


    friend class CIwUITextInput;
    friend class CIwUISoftKeyboardBuilder;
};
# 90 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUISoftKeyPosition.h" 1
# 49 "c:/marmalade/6.2/modules/iwui/h/IwUISoftKeyPosition.h"
class CIwUISoftKeyPosition : public CIwUIElement
{
public:
    typedef CIwArray<CIwUISoftKeyPosition*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUISoftKeyPosition();

protected:

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void UpdateElement(int32 deltaMS);
    virtual void OnPropertyChanged(uint32 hashName);

private:

    void _SetupFromProperties();


    bool m_IsAdvanceKey;
};
# 91 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIStyleManager.h" 1
# 21 "c:/marmalade/6.2/modules/iwui/h/IwUIStyleManager.h"
class CIwPropertySet;
class CIwUIStyle;
class CIwUIStylesheet;
# 40 "c:/marmalade/6.2/modules/iwui/h/IwUIStyleManager.h"
class CIwUIStyleManager
{
public:
    private: static CIwUIStyleManager* s_Singleton; public: static inline CIwUIStyleManager* GetSingleton() { return s_Singleton; }
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUIStyleManager();
    ~CIwUIStyleManager();







    void SetStylesheet(const char* pStylesheetResName);
    void SetStylesheet(CIwUIStylesheet* pStylesheet);







    void QueueStylesheet(const char* pStylesheetResName);
    void QueueStylesheet(CIwUIStylesheet* pStylesheet);





    void SetQueuedStylesheet();




    const CIwUIStylesheet* GetStylesheet() const { return m_Stylesheet; }
# 86 "c:/marmalade/6.2/modules/iwui/h/IwUIStyleManager.h"
    const CIwPropertySet* GetPropertySet(const CIwUIStyle& style,
        bool allowMissing = false) const;
# 96 "c:/marmalade/6.2/modules/iwui/h/IwUIStyleManager.h"
    const CIwPropertySet* GetGlobalPropertySet(const CIwUIStyle& style,
        bool allowMissing = false) const;






    void BuildHierarchy();

private:

    CIwUIStylesheet* _GetStylesheet(const char* pStylesheetResName) const;


    CIwUIStylesheet* m_Stylesheet;
    CIwUIStylesheet* m_QueuedStylesheet;
};


inline CIwUIStyleManager* IwGetUIStyleManager() { ((void)0); return CIwUIStyleManager::GetSingleton(); } inline bool IwUIStyleManagerExists() { return CIwUIStyleManager::GetSingleton() != __null; };
# 93 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIStylesheet.h" 1
# 25 "c:/marmalade/6.2/modules/iwui/h/IwUIStylesheet.h"
class CIwPropertySet;
class CIwUIPropertySet;
class CIwUIStyle;
class CIwUIStylesheet;
# 67 "c:/marmalade/6.2/modules/iwui/h/IwUIStylesheet.h"
class CIwUIStylesheet : public CIwResource, private CIwUncopyable
{
public:
    typedef CIwArray<CIwUIStylesheet*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUIStylesheet();
    virtual ~CIwUIStylesheet();
# 87 "c:/marmalade/6.2/modules/iwui/h/IwUIStylesheet.h"
    void AddPropertySet(CIwUIPropertySet* pPropertySet);







    void SetParent(CIwUIStylesheet* pStyleSheet) { m_Parent = pStyleSheet; }





    void BuildPropertySetHierarchy();
# 112 "c:/marmalade/6.2/modules/iwui/h/IwUIStylesheet.h"
    bool IsCurrent() const;




    const CIwUIStylesheet* GetParent() const { return m_Parent; }
# 126 "c:/marmalade/6.2/modules/iwui/h/IwUIStylesheet.h"
    const CIwPropertySet* GetPropertySet(const CIwUIStyle& style,
        bool allowMissing = false) const;

private:

    CIwUIStylesheet* m_Parent;
    CIwManagedList m_PropertySets;


    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
    virtual void ParseClose(CIwTextParserITX* pParser);
    virtual void ParseCloseChild(CIwTextParserITX* pParser, CIwManaged* pChild);


    virtual void Serialise();
    virtual void Resolve();
};
# 94 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUITabBar.h" 1
# 26 "c:/marmalade/6.2/modules/iwui/h/IwUITabBar.h"
class CIwUIRadioButton;
# 79 "c:/marmalade/6.2/modules/iwui/h/IwUITabBar.h"
class CIwUITabBar : public CIwUIElement
{
public:
    typedef CIwArray<CIwUITabBar*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUITabBar();




    void SetRadioButtonStyle(int16 radioButtonIndex, const CIwUIStyle& buttonStyle);






    void SetRadioButtonCaption(int16 radioButtonIndex, const char* pString);
# 104 "c:/marmalade/6.2/modules/iwui/h/IwUITabBar.h"
    void SetSelected(int16 selectedIndex, bool sendEvent = true);







    void SetEnabled(bool val);






    int16 GetNumRadioButtons() const;





    int16 GetSelected() const;





    bool GetEnabled() const;







    void AttachSelectedSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);







    void DetachSelectedSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);

protected:

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void OnPropertyChanged(uint32 hashName);
    virtual bool HandlesFocus() const;
    virtual CIwUIElement* FindWantsFocus();
    virtual bool HandleEvent(CIwEvent* pEvent);
    virtual bool HandleEventKey(CIwUIEventKey* pEventKey);
    virtual void Animate(const CIwUIAnimData& animData);
    virtual void OnChildRemove(CIwUIElement* pChild);

    CIwUIRadioButton* GetRadioButton(int index) const;

private:

    IwUI<CIwUIElement*>::Array m_RadioButtons;


    bool _HandleRadioButtonSelected(CIwUIRadioButton* pButton);

    void _CreateDrawables();
    void _DestroyDrawables();

    void _CreateLayout();
    void _DestroyLayout();

    void _EnsureFocusHandler();
};
# 95 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUITableView.h" 1
# 20 "c:/marmalade/6.2/modules/iwui/h/IwUITableView.h"
class CIwUIEventTableViewItem;
class CIwUITableViewItemSource;
# 58 "c:/marmalade/6.2/modules/iwui/h/IwUITableView.h"
class CIwUITableView : public CIwUIScrollableView
{
public:
    typedef CIwArray<CIwUITableView*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUITableView();
    virtual ~CIwUITableView();


    virtual void ParseCloseChild(CIwTextParserITX* pParser, CIwManaged* pChild);


    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const;


    virtual void Serialise();
    virtual void Resolve();
# 84 "c:/marmalade/6.2/modules/iwui/h/IwUITableView.h"
    void SetItemSource(CIwUITableViewItemSource* pItemSource);




    void SetSelection(int32 row);






    void ScrollToRow(int32 row);





    void SetScrollToRow(int32 row);




    CIwUITableViewItemSource* GetItemSource();




    int32 GetSelection() const;





    void UpdateRow(int32 row);
# 127 "c:/marmalade/6.2/modules/iwui/h/IwUITableView.h"
    void InsertRow(int32 row);







    void DeleteRow(int32 row);





    void RecreateItemsFromSource();







    void AttachSelectionSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);







    void DetachSelectionSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);


protected:

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void OnPropertyChanged(uint32 hashName);
    virtual void OnSizeChanged();
    virtual void UpdateElement(int32 deltaMS);
    virtual bool WantsFocus() const;
    virtual bool HandlesFocus() const;
    virtual CIwUIElement* FindWantsFocus();
    virtual bool HandleEventKey(CIwUIEventKey* pEventKey);
    virtual bool HandleEvent(CIwEvent* pEvent);
    virtual void Arrange(const CIwVec2& pos, const CIwVec2& size);
    virtual void OnChildRemove(CIwUIElement* pChild);


    virtual CIwUIRect GetContentRect() const;
    virtual CIwVec2 ClampScrollPosition(const CIwVec2& scrollPosition) const;
    virtual void OnScrollPositionChanged();

private:

    int32 m_FirstItemRow;
    IwUI<CIwUIElement*>::Array m_Items;

    int32 m_Selection;

    int32 m_ColumnWidthForHeights;
    int32 m_FirstHeightOffset;
    int32 m_EndHeightOffset;
    int32 m_FirstHeightRow;
    IwUI<int32>::Array m_RowHeights;

    bool m_EnsureVisibleRows;

    CIwUITableViewItemSource* m_ItemSource;
    bool m_ItemSourceFromProperty;


    void _CreateItemSourceFromProperty();
    void _ClearActiveState();
    bool _Scroll(bool upNotDown);


    void _CreateItems();
    void _ReleaseItems();
    CIwUIElement* _CreateItem(int32 row);
    void _ReleaseItem(CIwUIElement* pItem, int32 row);
    void _DeleteRow(int32 row, bool updatingRow);
    void _SetSelected(CIwUIElement* pItem, bool selected);


    CIwUIElement* _GetItemForRow(int32 row) const;
    int32 _GetCachedRowPosition(int32 row, bool& havePosition) const;
    int32 _GetCachedRowHeight(int32 row, bool& haveHeight) const;
    int32 _GetTotalCachedRowHeight() const;


    void _MoveToRow(int32 row, bool scrollNotSet);
    int32 _ClampGetRowHeightAndPosition(int32 row,
        int32& rowHeight, int32& rowPosition) const;
    int32 _ClampToRowPosition(int32 row) const;
    int32 _ClampRow(int32 row) const;
    void _SetScrollPositionFromSelectedRow();


    bool _AddRowHeight(bool frontNotBack, int32 desiredStart, int32 desiredEnd,
        int32& lastPosition, int32& lastIndex);
    void _EnsureNearbyRowHeights(const CIwVec2& tableSize);
    void _EnsureVisibleRows();


    bool _HandleSelection(CIwUIEventTableViewItem* pEventTableViewItem);
};
# 96 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUITableViewItem.h" 1
# 85 "c:/marmalade/6.2/modules/iwui/h/IwUITableViewItem.h"
class CIwUITableViewItem : public CIwUIElement
{
public:
    typedef CIwArray<CIwUITableViewItem*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUITableViewItem();
    virtual ~CIwUITableViewItem();





    void SetSelected(bool val);







    void SetEnabled(bool val);





    bool GetSelected() const;





    bool GetEnabled() const;







    void AttachSelectedSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);







    void DetachSelectedSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);

protected:

    virtual bool HandleEventClick(CIwUIEventClick* pEventClick);
    virtual bool HandleEventKey(CIwUIEventKey* pEventKey);
    virtual bool HandleEventPointerEnter(CIwUIEventPointerEnter* pEventPointerEnter);
    virtual bool HandleEventPointerLeave(CIwUIEventPointerLeave* pEventPointerLeave);
    virtual bool HandleEventFocus(CIwUIEventFocus* pEventFocus);

    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual bool IntersectElement(const CIwVec2& pos) const;
    virtual CIwUIRect GetElementBounds() const;
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual void OnPropertyChanged(uint32 hashName);
    virtual void OnSizeChanged();
    virtual void Animate(const CIwUIAnimData& animData);
    virtual bool WantsFocus() const;


    bool IsDown() const { return m_Down; }

    IIwUIDrawable* GetBackground() { return m_Background; }
    IIwUIDrawable* GetImageDown() { return m_ImageDown; }
    IIwUIDrawable* GetImageSelected() { return m_ImageSelected; }
    IIwUIDrawable* GetImageFocus() { return m_ImageFocus; }

    const IIwUIDrawable* GetBackground() const { return m_Background; }
    const IIwUIDrawable* GetImageDown() const { return m_ImageDown; }
    const IIwUIDrawable* GetImageSelected() const { return m_ImageSelected; }
    const IIwUIDrawable* GetImageFocus() const { return m_ImageFocus; }

private:

    void _CreateDrawables();
    void _DestroyDrawables();

    void _SetDown(bool val);
    void _HandlePress(bool isPressed);

    CIwColour _GetColourDisabled() const;


    CIwUIHoldingPtr<IIwUIDrawable> m_Background;
    CIwUIHoldingPtr<IIwUIDrawable> m_ImageDown;
    CIwUIHoldingPtr<IIwUIDrawable> m_ImageSelected;
    CIwUIHoldingPtr<IIwUIDrawable> m_ImageFocus;
    bool m_Selected;
    bool m_Enabled;
    bool m_Down;
};
# 97 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUITableViewItemSource.h" 1
# 25 "c:/marmalade/6.2/modules/iwui/h/IwUITableViewItemSource.h"
class CIwUIElement;
class CIwUITableView;
# 49 "c:/marmalade/6.2/modules/iwui/h/IwUITableViewItemSource.h"
class CIwUITableViewItemSource : public CIwResource, public IIwDecomposable
{
public:
    typedef CIwArray<CIwUITableViewItemSource*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUITableViewItemSource() : m_TableView(__null) {}
    virtual ~CIwUITableViewItemSource() {}


    virtual void ParseClose(CIwTextParserITX* pParser);


    virtual void DecomposeOpen(CIwTextDecomposer* pDecomposer) const;
    virtual void DecomposeAttributes(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeChildren(CIwTextDecomposer* pDecomposer) const {}
    virtual void DecomposeClose(CIwTextDecomposer* pDecomposer) const;
# 77 "c:/marmalade/6.2/modules/iwui/h/IwUITableViewItemSource.h"
    CIwUITableViewItemSource* Clone() const;




    CIwUITableView* GetTableView() { return m_TableView; }
# 95 "c:/marmalade/6.2/modules/iwui/h/IwUITableViewItemSource.h"
    virtual bool IsRowAvailable(int32 row) const = 0;




    virtual CIwUIElement* CreateItem(int32 row) = 0;




    virtual void ReleaseItem(CIwUIElement* pItem, int32 row) = 0;




    virtual int32 GetRowHeight(int32 row, int32 columnWidth) const = 0;


protected:
# 123 "c:/marmalade/6.2/modules/iwui/h/IwUITableViewItemSource.h"
    virtual void Activate(bool val);




    virtual void Clone(CIwUITableViewItemSource* pTarget) const;



    static const char* s_CloneExpectedClassName;


private:

    void _SetTableView(CIwUITableView* pOwner);


    CIwUITableView* m_TableView;


    friend class CIwUITableView;
};


# 98 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 1 "c:/marmalade/6.2/modules/iwui/h/IwUITextField.h" 1
# 25 "c:/marmalade/6.2/modules/iwui/h/IwUITextField.h"
class CIwUIEventTextInput;
# 89 "c:/marmalade/6.2/modules/iwui/h/IwUITextField.h"
class CIwUITextField : public CIwUILabel
{
public:
    typedef CIwArray<CIwUITextField*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    CIwUITextField();







    void AttachCompleteSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);







    void DetachCompleteSlot(const char* pSlotName,
        const char* pSlotOwnerName = __null, bool classNotObjectName = false);

protected:

    virtual void OnPropertyChanged(uint32 hashName);
    virtual void Clone(CIwUIElement* pTarget) const;
    virtual void Activate(bool val);
    virtual void UpdateElement(int32 deltaMS);
    virtual void RenderElement(CIwUIGraphics& graphics);
    virtual bool HandleEvent(CIwEvent* pEvent);
    virtual bool HandleEventClick(CIwUIEventClick* pEventClick);
    virtual bool HandleEventKey(CIwUIEventKey* pEventKey);
    virtual bool HandleEventTextInput(CIwUIEventTextInput* pEvent);
    virtual bool HandleEventPointerLeave(CIwUIEventPointerLeave* pEventPointerLeave);
    virtual void OnSizeChanged();
    virtual bool IntersectElement(const CIwVec2& pos) const;
    virtual bool WantsFocus() const;





    virtual CIwVec2 GetCursorPosition(int32 c);


    IIwUIDrawable* GetCursor() { return m_Cursor; }
    IIwUIDrawable* GetImageFocus() { return m_ImageFocus; }

    const IIwUIDrawable* GetCursor() const { return m_Cursor; }
    const IIwUIDrawable* GetImageFocus() const { return m_ImageFocus; }

private:

    CIwUIHoldingPtr<IIwUIDrawable> m_Cursor;
    CIwUIHoldingPtr<IIwUIDrawable> m_ImageFocus;

    bool m_Down;
    CIwUIRect m_OriginalTextRect;
    CIwVec2 m_TextOffset;


    void _CreateDrawables();
    void _DestroyDrawables();
    void _HandlePress(bool is_pressed);
    bool _IsEnabled() const;
    void _StoreTextRect();
    CIwVec2 _GetCursorPosition();
};
# 99 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2

# 1 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h" 1
# 37 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h"
class IDelegateQuery;
# 48 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h"
class CIwUIView
{
public:
    private: static CIwUIView* s_Singleton; public: static inline CIwUIView* GetSingleton() { return s_Singleton; };
    void* operator new (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new[] (size_t size) { CIwAutoBucketSwitch iwbucketswitch(IwUIGetMemBucketID()); return s3eMalloc(size); } void* operator new (size_t, void* placement) { return placement; } void* operator new[] (size_t, void* placement) { return placement; }

    CIwUIView();
    virtual ~CIwUIView();
# 66 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h"
    virtual void Update(int32 deltaMS);






    virtual void Layout();







    virtual void Render();






    virtual void Reactivate();




    virtual CIwUIElement* Intersect(const CIwVec2& pos) const;
# 103 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h"
    void Intersect(CIwManagedList& contained, const CIwUIRect& rect) const;





    void AddElement(CIwUIElement* pElement);






    void AddElementToLayout(CIwUIElement* pElement,
        IwUIAlignmentH alignH = IW_UI_ALIGN_CENTRE,
        IwUIAlignmentV alignV = IW_UI_ALIGN_MIDDLE,
        CIwSVec2 border = CIwSVec2::g_Zero);





    void RemoveElement(CIwUIElement* pElement);




    void DestroyElements();
# 139 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h"
    void SetModal(CIwUIElement* pElement, bool setFocus = true);




    CIwUIElement* GetModal() const;






    void SetCoordSpace(IwGxCoordSpace coordSpace);




    IwGxCoordSpace GetCoordSpace() const;




    void Traverse(IIwUIVisitor& visitor);
# 178 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h"
    IDelegateQuery* LookupSlot(CIwUIElement* pContext,
        bool classNotObjectName, uint32 ownerName, uint32 slotName);
# 189 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h"
    void AddDelegate(uint32 className, uint32 objectName,
        IDelegateQuery* pDelegate);





    void RemoveDelegate(IDelegateQuery* pDelegate);







    void DestroyDelegates(void* pHandler);
# 214 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h"
    CIwUIElement* GetFocus() const;





    bool InFocusChain(CIwUIElement* pElement) const;
# 229 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h"
    bool ChooseFocus(CIwUIElement* pElement);
# 238 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h"
    bool MoveFocus(CIwUIElement* pElement, IwUIFocusMovement movement);






    void RequestFocus(CIwUIElement* pElement);






    bool IsFocusable(const CIwUIElement* pElement) const;
# 262 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h"
    int GetNumElements() const;




    CIwUIElement* GetElement(int index) const;
# 278 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h"
    CIwUIElement* GetChildNamed(const char* pName, bool permitNull = false) const;
# 289 "c:/marmalade/6.2/modules/iwui/h/IwUIView.h"
    CIwUIElement* GetChildHashed(uint32 hash, bool permitNull = false) const;

private:

    IwGxCoordSpace m_CoordSpace;


    bool m_ProcessingRoot;


    CIwUIElement m_Root;


    CIwUILayout* m_RootLayout;


    CIwUIElementPtr m_Modal;


    CIwUIAnimManager m_AnimManager;


    struct DelegateReference
    {
        bool operator == (const DelegateReference& other);

        uint32 m_ClassName;
        uint32 m_ObjectName;
        IDelegateQuery* m_Delegate;
    };
    IwUI<DelegateReference>::Array m_Delegates;


    IDelegateQuery* _GetDelegate(bool classNotObjectName, uint32 ownerName,
        uint32 slotName) const;


    int _GetDelegateIndex(IDelegateQuery* pDelegate) const;


    void _DestroyDelegates();


    void _SetProcessingRoot(bool val);


    CIwUIElement* _GetFocus(const CIwUIElement* pElement) const;


    CIwVec2 _GetDisplaySize() const;
};


inline CIwUIView* IwGetUIView() { ((void)0); return CIwUIView::GetSingleton(); } inline bool IwUIViewExists() { return CIwUIView::GetSingleton() != __null; };
# 101 "c:/marmalade/6.2/modules/iwui/h/IwUI.h" 2
# 18 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/game.cpp" 2
# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/game.h" 1
# 16 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/game.h"
class CGame
{
public:
    CGame();
    ~CGame();

 void waitTime(int ms);



    void Update();


    void Render();

private:
    CIwFVec2 m_Position;
    CIwSVec2 m_Size;
};

CIwRect createRect(char* stringToSize, bool LeftJustified, int y);
CIwRect createRect(char* stringToSize, bool LeftJustified, CIwRect pastRect);
# 19 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/game.cpp" 2
# 1 "c:/marmalade/6.2/s3e/h/std/time.h" 1
# 19 "c:/marmalade/6.2/s3e/h/std/time.h"
typedef long time_t;





typedef long clock_t;




struct tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
};



struct timespec
{
    time_t tv_sec;
    long int tv_nsec;
};

extern "C" {






time_t time(time_t *t);

void tzset(void);

char *asctime(const struct tm *tm);
char *asctime_r(const struct tm *tm, char *buf);

char *ctime(const time_t *timep);
char *ctime_r(const time_t *timep, char *buf);

struct tm *gmtime(const time_t *timep);
struct tm *gmtime_r(const time_t *timep, struct tm *result);

struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);

time_t mktime(struct tm *tm);

size_t strftime(char *s, size_t max, const char *format, const struct tm *tm);

clock_t clock(void);

double difftime(time_t time1, time_t time0);

int nanosleep(const struct timespec *req, struct timespec *rem);



    extern char *_tzname[2];
    extern int _daylight;
    extern long int _timezone;
# 101 "c:/marmalade/6.2/s3e/h/std/time.h"
typedef int clockid_t;

int clock_getres(clockid_t clk_id, struct timespec *res);

int clock_gettime(clockid_t clk_id, struct timespec *tp);

int clock_settime(clockid_t clk_id, const struct timespec *tp);

}

# 1 "c:/marmalade/6.2/s3e/h/std/sys/time.h" 1
# 16 "c:/marmalade/6.2/s3e/h/std/sys/time.h"
# 1 "c:/marmalade/6.2/s3e/h/std/time.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/sys/time.h" 2



extern "C" {

typedef long suseconds_t;
struct timeval
{
    time_t tv_sec;
    suseconds_t tv_usec;
};

struct _timezone
{
    int tz_minuteswest;
    int tz_dsttime;
};

int gettimeofday(struct timeval *tv, struct _timezone *tz);
int settimeofday(const struct timeval *tv , const struct _timezone *tz);

int utimes(const char *filename, const struct timeval times[2]);

}
# 112 "c:/marmalade/6.2/s3e/h/std/time.h" 2
# 20 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/game.cpp" 2

# 1 "c:/marmalade/6.2/s3e/h/std/c++/string" 1
# 24 "c:/marmalade/6.2/s3e/h/std/c++/string"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h" 1
# 16 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h" 2
# 25 "c:/marmalade/6.2/s3e/h/std/c++/string" 2



         
# 45 "c:/marmalade/6.2/s3e/h/std/c++/string"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 1
# 23 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/memory" 1
# 28 "c:/marmalade/6.2/s3e/h/std/c++/memory"
         



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 1
# 39 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/cstdlib" 1
# 27 "c:/marmalade/6.2/s3e/h/std/c++/cstdlib"
# 1 "c:/marmalade/6.2/s3e/h/ext/../std/stdlib.h" 1
# 28 "c:/marmalade/6.2/s3e/h/std/c++/cstdlib" 2
# 41 "c:/marmalade/6.2/s3e/h/std/c++/cstdlib"
namespace _STL {
using ::div_t;
using ::ldiv_t;
using ::size_t;


using ::abort;
using ::atexit;
using ::exit;
using ::getenv;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::atof;
using ::atoi;
using ::atol;
using ::mblen;
using ::mbstowcs;
using ::mbtowc;
using ::strtod;
using ::strtol;
using ::strtoul;
using ::system;


using ::wcstombs;
using ::wctomb;

using ::bsearch;
using ::qsort;




using ::div;
using ::labs;
using ::ldiv;
using ::rand;
using ::srand;

}


namespace _STL {



inline long abs(long __x) { return ::labs(__x); }


inline ldiv_t div(long __x, long __y) { return ::ldiv(__x, __y); }
# 103 "c:/marmalade/6.2/s3e/h/std/c++/cstdlib"
}
# 40 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/cstring" 1
# 27 "c:/marmalade/6.2/s3e/h/std/c++/cstring"
# 1 "c:/marmalade/6.2/s3e/h/ext/../std/string.h" 1
# 28 "c:/marmalade/6.2/s3e/h/std/c++/cstring" 2



namespace _STL {
# 1 "c:/marmalade/6.2/s3e/h/std/c++/using/cstring" 1
using ::size_t;
# 17 "c:/marmalade/6.2/s3e/h/std/c++/using/cstring"
 using ::memmove;
 using ::memcpy;




using ::memchr;
using ::strchr;
using ::strpbrk;
using ::strrchr;
using ::strstr;


using ::memcmp;
using ::memset;

using ::strcat;


using ::strcmp;


using ::strcoll;

using ::strcpy;

using ::strcspn;
using ::strerror;
using ::strlen;
using ::strncat;
using ::strncmp;

using ::strncpy;
using ::strspn;

using ::strtok;
using ::strxfrm;
# 33 "c:/marmalade/6.2/s3e/h/std/c++/cstring" 2
}
# 43 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 2





# 1 "c:/marmalade/6.2/s3e/h/std/c++/cstdio" 1
# 35 "c:/marmalade/6.2/s3e/h/std/c++/cstdio"
# 1 "c:/marmalade/6.2/s3e/h/ext/../std/stdio.h" 1
# 36 "c:/marmalade/6.2/s3e/h/std/c++/cstdio" 2
# 58 "c:/marmalade/6.2/s3e/h/std/c++/cstdio"
namespace _STL {
using ::FILE;
using ::fpos_t;
using ::size_t;
# 72 "c:/marmalade/6.2/s3e/h/std/c++/cstdio"
using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;


 using ::getc;
 using ::getchar;
 using ::putc;
 using ::putchar;


using ::gets;
using ::perror;
using ::printf;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;
using ::tmpnam;
using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;





}
# 49 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 2
# 64 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h" 1
# 57 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
  typedef size_t __stl_atomic_t;
# 280 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
namespace _STL {




template <int __inst>
struct _STLP_mutex_spin {
  enum { __low_max = 30, __high_max = 1000 };

  static unsigned __max;
  static unsigned __last;
  static void _M_do_lock(volatile __stl_atomic_t* __lock);
  static void _S_nsec_sleep(int __log_nsec);
};
# 311 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
struct _STLP_mutex_base
{
# 441 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
  inline void _M_initialize() {}
  inline void _M_destroy() {}
  inline void _M_acquire_lock() {}
  inline void _M_release_lock() {}

};
# 458 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
typedef _STLP_mutex_base _STLP_mutex_nodemand;





class _STLP_mutex : public _STLP_mutex_nodemand {
  public:
    inline _STLP_mutex () { _M_initialize(); }
    inline ~_STLP_mutex () { _M_destroy(); }
  private:
    _STLP_mutex(const _STLP_mutex&);
    void operator=(const _STLP_mutex&);
};
# 569 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
struct _Refcount_Base
{

  volatile __stl_atomic_t _M_ref_count;


  _STLP_mutex _M_mutex;



  _Refcount_Base(__stl_atomic_t __n) : _M_ref_count(__n) {}
# 597 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
  void _M_incr() { ++_M_ref_count; }
  void _M_decr() { --_M_ref_count; }

};
# 632 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
static inline __stl_atomic_t
_Atomic_swap(volatile __stl_atomic_t * __p, __stl_atomic_t __q) {
  __stl_atomic_t __result = *__p;
  *__p = __q;
  return __result;
}






struct _STLP_auto_lock
{
  _STLP_mutex_base& _M_lock;

  _STLP_auto_lock(_STLP_mutex_base& __lock) : _M_lock(__lock)
    { _M_lock._M_acquire_lock(); }
  ~_STLP_auto_lock() { _M_lock._M_release_lock(); }

private:
  void operator=(const _STLP_auto_lock&);
  _STLP_auto_lock(const _STLP_auto_lock&);
};

typedef _STLP_auto_lock _STLP_mutex_lock;
# 710 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
}


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.c" 1
# 714 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h" 2
# 65 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h" 1
# 43 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h" 1
# 44 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h" 1
# 62 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h"
namespace _STL {

struct __true_type {};
struct __false_type {};


template <int _Is> struct __bool2type {
  typedef __false_type _Ret;
};

template<>
struct __bool2type<1> { typedef __true_type _Ret; };

template<>
struct __bool2type<0> { typedef __false_type _Ret; };


template <class _P1, class _P2, class _P3>
struct _Land3 {
  typedef __false_type _Ret;
};

template<>
struct _Land3<__true_type, __true_type, __true_type> {
  typedef __true_type _Ret;
};



template <class _Tp> struct __type_traits;
template <int _IsPOD> struct __type_traits_aux {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<0> {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<1> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};
# 188 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h"
template <class _Tp>
struct __type_traits {
   typedef __true_type this_dummy_member_must_be_first;
# 206 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h"
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};


template <class _Tp> struct _IsPtr { enum { _Ret = 0 }; };
template <class _Tp> struct _IsPtrType {
  static __false_type _Ret() { return __false_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType {
  static __false_type _Ret() { return __false_type();}
};

template <class _Tp1, class _Tp2>
struct _IsSame { enum { _Ret = 0 }; };





template <class _Tp> struct _IsPtr<_Tp*> { enum { _Ret = 1 }; };
template <class _Tp> struct _IsPtrType<_Tp*> {
  static __true_type _Ret() { return __true_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType<_Tp1*, _Tp2*> {
  static __true_type _Ret() { return __true_type();}
};
template <class _Tp>
struct _IsSame<_Tp, _Tp> { enum { _Ret = 1 }; };
# 246 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h"
template<> struct __type_traits<bool> : __type_traits_aux<1> {};

template<> struct __type_traits<char> : __type_traits_aux<1> {};

template<> struct __type_traits<signed char> : __type_traits_aux<1> {};

template<> struct __type_traits<unsigned char> : __type_traits_aux<1> {};




template<> struct __type_traits<short> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned short> : __type_traits_aux<1> {};
template<> struct __type_traits<int> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned int> : __type_traits_aux<1> {};
template<> struct __type_traits<long> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned long> : __type_traits_aux<1> {};


template<> struct __type_traits<long long> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned long long> : __type_traits_aux<1> {};


template<> struct __type_traits<float> : __type_traits_aux<1> {};
template<> struct __type_traits<double> : __type_traits_aux<1> {};


template<> struct __type_traits<long double> : __type_traits_aux<1> {};



template <class _Tp> struct __type_traits<_Tp*> : __type_traits_aux<1> {};





template <class _Tp> struct _Is_integer {
  typedef __false_type _Integral;
};



template<> struct _Is_integer<bool> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<char> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<signed char> {
  typedef __true_type _Integral;
};


template<> struct _Is_integer<unsigned char> {
  typedef __true_type _Integral;
};
# 318 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h"
template<> struct _Is_integer<short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<long long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long long> {
  typedef __true_type _Integral;
};



template <class _Tp1, class _Tp2>
struct _OKToMemCpy {
  enum { _Same = _IsSame<_Tp1,_Tp2>::_Ret } ;
  typedef typename __type_traits<_Tp1>::has_trivial_assignment_operator _Tr1;
  typedef typename __type_traits<_Tp2>::has_trivial_assignment_operator _Tr2;
  typedef typename __bool2type< _Same >::_Ret _Tr3;
  typedef typename _Land3<_Tr1, _Tr2, _Tr3>::_Ret _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp1, class _Tp2>
inline _OKToMemCpy<_Tp1, _Tp2> _IsOKToMemCpy(_Tp1*, _Tp2*) {
  return _OKToMemCpy<_Tp1, _Tp2>();
}

template <class _Tp>
struct _IsPOD {
  typedef typename __type_traits<_Tp>::is_POD_type _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp>
inline _IsPOD<_Tp> _Is_POD (_Tp*) { return _IsPOD<_Tp>(); }
# 411 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h"
}
# 45 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h" 2


namespace _STL {

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};


template <class _Category, class _Tp, class _Distance = ptrdiff_t,
          class _Pointer = _Tp*, class _Reference = _Tp& >
struct iterator {
  typedef _Category iterator_category;
  typedef _Tp value_type;
  typedef _Distance difference_type;
  typedef _Pointer pointer;
  typedef _Reference reference;
};
template<>
struct iterator<output_iterator_tag, void, void, void, void> {
  typedef output_iterator_tag iterator_category;

  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

};
# 96 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Iterator>
struct iterator_traits {
  typedef typename _Iterator::iterator_category iterator_category;
  typedef typename _Iterator::value_type value_type;
  typedef typename _Iterator::difference_type difference_type;
  typedef typename _Iterator::pointer pointer;
  typedef typename _Iterator::reference reference;
};
# 115 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef const _Tp* pointer;
  typedef const _Tp& reference;
};

template <class _Tp>
struct iterator_traits<_Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp* pointer;
  typedef _Tp& reference;
};
# 164 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Iter>
inline typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter&) {
  typedef typename iterator_traits<_Iter>::iterator_category _Category;
  return _Category();
}

template <class _Iter>
inline typename iterator_traits<_Iter>::difference_type* __distance_type(const _Iter&) {
  typedef typename iterator_traits<_Iter>::difference_type _diff_type;
  return static_cast<_diff_type*>(0);
}

template <class _Iter>
inline typename iterator_traits<_Iter>::value_type* __value_type(const _Iter&) {
  typedef typename iterator_traits<_Iter>::value_type _value_type;
  return static_cast<_value_type*>(0);
}
# 236 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Tp, class _Distance> struct input_iterator :
  public iterator <input_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
struct output_iterator : public iterator <output_iterator_tag, void, void, void, void> {};
template <class _Tp, class _Distance> struct forward_iterator :
  public iterator<forward_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct bidirectional_iterator :
  public iterator<bidirectional_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct random_access_iterator :
  public iterator<random_access_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
# 281 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _InputIterator, class _Distance>
inline void __distance(const _InputIterator& __first, const _InputIterator& __last,
      _Distance& __n, const input_iterator_tag &) {
  _InputIterator __it(__first);
  while (__it != __last) { ++__it; ++__n; }
}
# 305 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _RandomAccessIterator, class _Distance>
inline void __distance(const _RandomAccessIterator& __first,
      const _RandomAccessIterator& __last,
      _Distance& __n, const random_access_iterator_tag &) {
  __n += __last - __first;
}


template <class _InputIterator, class _Distance>
inline void distance(const _InputIterator& __first,
    const _InputIterator& __last, _Distance& __n) {
  __distance(__first, __last, __n, typename iterator_traits< _InputIterator >::iterator_category());
}


template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
__distance(const _InputIterator& __first, const _InputIterator& __last, const input_iterator_tag &) {
  typename iterator_traits<_InputIterator>::difference_type __n = 0;
  _InputIterator __it(__first);
  while (__it != __last) {
    ++__it; ++__n;
  }
  return __n;
}
# 359 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _RandomAccessIterator>
inline typename iterator_traits<_RandomAccessIterator>::difference_type
__distance(const _RandomAccessIterator& __first, const _RandomAccessIterator& __last,
           const random_access_iterator_tag &) {
  return __last - __first;
}

template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
distance(const _InputIterator& __first, const _InputIterator& __last) {
  return __distance(__first, __last, typename iterator_traits< _InputIterator >::iterator_category());
}



template <class _Tp>
struct _Nonconst_traits;

template <class _Tp>
struct _Const_traits {
  typedef _Tp value_type;
  typedef const _Tp& reference;
  typedef const _Tp* pointer;
  typedef _Nonconst_traits<_Tp> _Non_const_traits;
};

template <class _Tp>
struct _Nonconst_traits {
  typedef _Tp value_type;
  typedef _Tp& reference;
  typedef _Tp* pointer;
  typedef _Nonconst_traits<_Tp> _Non_const_traits;
};
# 414 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, const input_iterator_tag &) {
  while (__n--) ++__i;
}


template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, const output_iterator_tag &) {
  while (__n--) ++__i;
}
# 432 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _BidirectionalIterator, class _Distance>
inline void __advance(_BidirectionalIterator& __i, _Distance __n,
                      const bidirectional_iterator_tag &) {
  if (__n > 0)
    while (__n--) ++__i;
  else
    while (__n++) --__i;
}

template <class _RandomAccessIterator, class _Distance>
inline void __advance(_RandomAccessIterator& __i, _Distance __n,
                      const random_access_iterator_tag &) {
  __i += __n;
}

template <class _InputIterator, class _Distance>
inline void advance(_InputIterator& __i, _Distance __n) {
  __advance(__i, __n, typename iterator_traits< _InputIterator >::iterator_category());
}

}
# 44 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h" 2


namespace _STL {
# 55 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h"
template <class _Tp>
inline void _Destroy(_Tp* __pointer) {
# 67 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h"
    __pointer->~_Tp();





}
# 92 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h"
template <class _T1, class _T2>
inline void _Construct(_T1* __p, const _T2& __val) {



    new (__p) _T1(__val);
}

template <class _T1>
inline void _Construct(_T1* __p) {







  new (__p) _T1();

}
# 120 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h"
template <class _ForwardIterator>
inline void
__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, const __false_type&) {
  for ( ; __first != __last; ++__first)
    _STL::_Destroy(&*__first);
}

template <class _ForwardIterator>
inline void __destroy_aux(_ForwardIterator, _ForwardIterator, const __true_type&) {}

template <class _ForwardIterator, class _Tp>
inline void
__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*) {
  typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
  __destroy_aux(__first, __last, _Trivial_destructor());
}

template <class _ForwardIterator>
inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
  __destroy(__first, __last, (typename iterator_traits< _ForwardIterator >::value_type*)0);
}

inline void _Destroy(char*, char*) {}

inline void _Destroy(wchar_t*, wchar_t*) {}
inline void _Destroy(const wchar_t*, const wchar_t*) {}






template <class _T1, class _T2>
inline void construct(_T1* __p, const _T2& __val) {_Construct(__p, __val); }
template <class _T1>
inline void construct(_T1* __p) { _Construct(__p); }
template <class _Tp>
inline void destroy(_Tp* __pointer) { _STL::_Destroy(__pointer); }
template <class _ForwardIterator>
inline void destroy(_ForwardIterator __first, _ForwardIterator __last) { _STL::_Destroy(__first, __last); }

}
# 69 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 2
# 85 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
namespace _STL {
# 94 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
typedef void (* __oom_handler_type)();

template <int __inst>
class __malloc_alloc {
private:
  static void* _S_oom_malloc(size_t);
  static __oom_handler_type __oom_handler;
public:

  typedef char value_type;





  static void* allocate(size_t __n) {
    void* __result = malloc(__n);
    if (0 == __result) __result = _S_oom_malloc(__n);
    return __result;
  }
  static void deallocate(void* __p, size_t ) { free((char*)__p); }
  static __oom_handler_type set_malloc_handler(__oom_handler_type __f) {
    __oom_handler_type __old = __oom_handler;
    __oom_handler = __f;
    return(__old);
  }
};




class __new_alloc {
public:

  typedef char value_type;





  static void* allocate(size_t __n) { return __stl_new(__n); }
  static void deallocate(void* __p, size_t) { __stl_delete(__p); }
};
# 146 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Alloc>
class __debug_alloc : public _Alloc {
public:
  typedef _Alloc __allocator_type;
  typedef typename _Alloc::value_type value_type;
private:
  struct __alloc_header {
    size_t __magic: 16;
    size_t __type_size:16;
    unsigned long _M_size;
  };

  enum { __pad=8, __magic=0xdeba, __deleted_magic = 0xdebd,
  __shred_byte= 0xA3
  };

  enum { __extra_before = 16, __extra_after = 8 };



  static size_t __extra_before_chunk() {
    return (long)__extra_before/sizeof(value_type)+
      (size_t)((long)__extra_before%sizeof(value_type)>0);
  }
  static size_t __extra_after_chunk() {
    return (long)__extra_after/sizeof(value_type)+
      (size_t)((long)__extra_after%sizeof(value_type)>0);
  }
public:





  __debug_alloc() {}
  ~__debug_alloc() {}
  static void * allocate(size_t);
  static void deallocate(void *, size_t);
};
# 214 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
enum {_ALIGN = 8, _ALIGN_SHIFT=3, _MAX_BYTES = 128};



class _Node_alloc_obj {
public:
    _Node_alloc_obj * _M_free_list_link;
};

template <bool __threads, int __inst>
class __node_alloc {
  public:
  static inline size_t _S_round_up(size_t __bytes) { return (((__bytes) + (size_t)_ALIGN-1) & ~((size_t)_ALIGN - 1)); }
  typedef _Node_alloc_obj _Obj;
private:

  static void* _S_refill(size_t __n);


  static char* _S_chunk_alloc(size_t __p_size, int& __nobjs);

  static _Node_alloc_obj * _S_free_list[16];
  static char* _S_start_free;
  static char* _S_end_free;
  static size_t _S_heap_size;
  static void * _M_allocate(size_t __n);

  static void _M_deallocate(void *__p, size_t __n);
public:

  typedef char value_type;






  static void * allocate(size_t __n) { return (__n > (size_t)_MAX_BYTES) ? __stl_new(__n) : _M_allocate(__n); }

  static void deallocate(void *__p, size_t __n) { if (__n > (size_t)_MAX_BYTES) __stl_delete(__p); else _M_deallocate(__p, __n); }
};





typedef __node_alloc<false, 0> _Node_alloc;
# 301 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
typedef __malloc_alloc<0> __sgi_alloc;


typedef __malloc_alloc<0> __single_client_alloc;
typedef __malloc_alloc<0> __multithreaded_alloc;
# 329 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp>
class allocator {
public:

  typedef _Tp value_type;
  typedef value_type * pointer;
  typedef const _Tp* const_pointer;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() {}

  template <class _Tp1> allocator(const allocator<_Tp1>&) {}

  allocator(const allocator<_Tp>&) {}
  ~allocator() {}
  pointer address(reference __x) const { return &__x; }
  const_pointer address(const_reference __x) const { return &__x; }

  _Tp* allocate(size_type __n, const void* = 0) {
    return __n != 0 ? reinterpret_cast<value_type*>(__sgi_alloc::allocate(__n * sizeof(value_type))) : 0;
  }

  void deallocate(pointer __p, size_type __n) {
   
      if (__p != 0) __sgi_alloc::deallocate((void*)__p, __n * sizeof(value_type));
  }

  void deallocate(pointer __p) const { if (__p != 0) __sgi_alloc::deallocate((void*)__p, sizeof(value_type)); }
  size_type max_size() const { return size_t(-1) / sizeof(value_type); }
  void construct(pointer __p, const _Tp& __val) { _STL::_Construct(__p, __val); }
  void destroy(pointer __p) { _STL::_Destroy(__p); }




};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;

  typedef void value_type;


  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };





};


template <class _T1, class _T2> inline bool operator==(const allocator<_T1>&, const allocator<_T2>&) { return true; }
template <class _T1, class _T2> inline bool operator!=(const allocator<_T1>&, const allocator<_T2>&) { return false; }
# 411 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp, class _Allocator>
struct _Alloc_traits
{
  typedef _Allocator _Orig;

  typedef typename _Allocator::template rebind<_Tp> _Rebind_type;
  typedef typename _Rebind_type::other allocator_type;
  static allocator_type create_allocator(const _Orig& __a) { return allocator_type(__a); }





};
# 457 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp, class _Alloc>
inline typename _Alloc_traits<_Tp, _Alloc>::allocator_type
__stl_alloc_create(const _Alloc& __a, const _Tp*) {
  typedef typename _Alloc::template rebind<_Tp>::other _Rebound_type;
  return _Rebound_type(__a);
}
# 480 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Value, class _Tp, class _MaybeReboundAlloc>
class _STLP_alloc_proxy : public _MaybeReboundAlloc {
private:
  typedef _MaybeReboundAlloc _Base;
  typedef _STLP_alloc_proxy<_Value, _Tp, _MaybeReboundAlloc> _Self;
public:
  _Value _M_data;
  inline _STLP_alloc_proxy(const _MaybeReboundAlloc& __a, _Value __p) : _MaybeReboundAlloc(__a), _M_data(__p) {}
# 509 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
};
# 520 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
}
# 33 "c:/marmalade/6.2/s3e/h/std/c++/memory" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.h" 1
# 34 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/climits" 1
# 32 "c:/marmalade/6.2/s3e/h/std/c++/climits"
# 1 "c:/marmalade/6.2/s3e/h/std/limits.h" 1
# 33 "c:/marmalade/6.2/s3e/h/std/c++/climits" 2
# 35 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.h" 2





# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_uninitialized.h" 1
# 38 "c:/marmalade/6.2/s3e/h/std/c++/stl/_uninitialized.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h" 1
# 51 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_pair.h" 1
# 34 "c:/marmalade/6.2/s3e/h/std/c++/stl/_pair.h"
namespace _STL {

template <class _T1, class _T2>
struct pair {
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;



  pair() : first(_T1()), second(_T2()) {}

  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}


  template <class _U1, class _U2>
  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}

  pair(const pair<_T1,_T2>& __o) : first(__o.first), second(__o.second) {}

 
};

template <class _T1, class _T2>
inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first < __y.first ||
         (!(__y.first < __x.first) && __x.second < __y.second);
}



template <class _T1, class _T2>
inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x == __y);
}

template <class _T1, class _T2>
inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return __y < __x;
}

template <class _T1, class _T2>
inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__y < __x);
}

template <class _T1, class _T2>
inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x < __y);
}





template <class _T1, class _T2, int _Sz>
inline pair<_T1, _T2 const*> make_pair(_T1 const& __x,
                                       _T2 const (&__y)[_Sz])
{
  return pair<_T1, _T2 const*>(__x, static_cast<_T2 const*>(__y));
}

template <class _T1, class _T2, int _Sz>
inline pair<_T1 const*, _T2> make_pair(_T1 const (&__x)[_Sz],
                                       _T2 const& __y)
{
  return pair<_T1 const*, _T2>(static_cast<_T1 const*>(__x), __y);
}

template <class _T1, class _T2, int _Sz1, int _Sz2>
inline pair<_T1 const*, _T2 const*> make_pair(_T1 const (&__x)[_Sz1],
                                              _T2 const (&__y)[_Sz2])
{
  return pair<_T1 const*, _T2 const*>(static_cast<_T1 const*>(__x),
                                      static_cast<_T2 const*>(__y));
}


template <class _T1, class _T2>
inline pair<_T1, _T2> make_pair(const _T1& __x, const _T2& __y)
{
  return pair<_T1, _T2>(__x, __y);
}


}


namespace _STL { namespace rel_ops {

template <class _Tp>
inline bool operator!=(const _Tp& __x, const _Tp& __y) {
  return !(__x == __y);
}

template <class _Tp>
inline bool operator>(const _Tp& __x, const _Tp& __y) {
  return __y < __x;
}

template <class _Tp>
inline bool operator<=(const _Tp& __x, const _Tp& __y) {
  return !(__y < __x);
}

template <class _Tp>
inline bool operator>=(const _Tp& __x, const _Tp& __y) {
  return !(__x < __y);
}

} }
# 52 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h" 2






namespace _STL {

template <class _Tp>
inline void swap(_Tp& __a, _Tp& __b) {
  _Tp __tmp = __a;
  __a = __b;
  __b = __tmp;
}

template <class _ForwardIter1, class _ForwardIter2>
inline void iter_swap(_ForwardIter1 __i1, _ForwardIter2 __i2) {
  swap(*__i1, *__i2);
}





template <class _Tp>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b) { return __b < __a ? __b : __a; }
template <class _Tp>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b) { return __a < __b ? __b : __a; }







template <class _Tp, class _Compare>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__b, __a) ? __b : __a;
}

template <class _Tp, class _Compare>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__a, __b) ? __b : __a;
}
# 106 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h"
template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __copy(_InputIter __first, _InputIter __last,
                          _OutputIter __result,
                          const input_iterator_tag &, _Distance*) {
  for ( ; __first != __last; ++__result, ++__first)
    *__result = *__first;
  return __result;
}
# 134 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h"
template <class _RandomAccessIter, class _OutputIter, class _Distance>
inline _OutputIter
__copy(_RandomAccessIter __first, _RandomAccessIter __last,
       _OutputIter __result, const random_access_iterator_tag &, _Distance*) {
  for (_Distance __n = __last - __first; __n > 0; --__n) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return __result;
}

inline void*
__copy_trivial(const void* __first, const void* __last, void* __result) {
  return (__last == __first) ? __result :
    ((char*)memmove(__result, __first, ((const char*)__last - (const char*)__first))) +
    ((const char*)__last - (const char*)__first);
}




template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _Distance>
inline _BidirectionalIter2 __copy_backward(_BidirectionalIter1 __first,
                                           _BidirectionalIter1 __last,
                                           _BidirectionalIter2 __result,
                                           const bidirectional_iterator_tag &,
                                           _Distance*)
{
  while (__first != __last)
    *--__result = *--__last;
  return __result;
}

template <class _RandomAccessIter, class _BidirectionalIter, class _Distance>
inline _BidirectionalIter __copy_backward(_RandomAccessIter __first,
                                          _RandomAccessIter __last,
                                          _BidirectionalIter __result,
                                          const random_access_iterator_tag &,
                                          _Distance*)
{
  for (_Distance __n = __last - __first; __n > 0; --__n)
    *--__result = *--__last;
  return __result;
}

inline void*
__copy_trivial_backward(const void* __first, const void* __last, void* __result) {
  const ptrdiff_t _Num = (const char*)__last - (const char*)__first;
  return (_Num > 0) ? memmove((char*)__result - _Num, __first, _Num) : __result ;
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy(__first, __last, __result,
                typename iterator_traits< _InputIter >::iterator_category(),
                (typename iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {


  return (_OutputIter)__copy_trivial(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return __copy_ptrs(__first, __last, __result,
                     _IsOKToMemCpy((typename iterator_traits< _InputIter >::value_type*)0,
                                   (typename iterator_traits< _OutputIter >::value_type*)0)._Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy(__first, __last, __result,
  typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
    return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return (_OutputIter)__copy_trivial_backward(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return __copy_backward_ptrs(__first, __last, __result,
                              _IsOKToMemCpy((typename iterator_traits< _InputIter >::value_type*)0,
                                            (typename iterator_traits< _OutputIter >::value_type*)0)._Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy_backward(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
    return __copy_backward_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret() );
}
# 282 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h"
template <class _InputIter, class _Size, class _OutputIter>
inline
pair<_InputIter, _OutputIter> __copy_n(_InputIter __first, _Size __count,
                                       _OutputIter __result,
                                       const input_iterator_tag &) {
  for ( ; __count > 0; --__count) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return pair<_InputIter, _OutputIter>(__first, __result);
}

template <class _RAIter, class _Size, class _OutputIter>
inline pair<_RAIter, _OutputIter>
__copy_n(_RAIter __first, _Size __count,
         _OutputIter __result,
         const random_access_iterator_tag &) {
  _RAIter __last = __first + __count;
  return pair<_RAIter, _OutputIter>(__last, copy(__first, __last, __result));
}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
__copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 
  return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 
  return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}





template <class _ForwardIter, class _Tp>
inline
void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
 
  for ( ; __first != __last; ++__first)
    *__first = __val;
}

template <class _OutputIter, class _Size, class _Tp>
inline
_OutputIter fill_n(_OutputIter __first, _Size __n, const _Tp& __val) {
 
  for ( ; __n > 0; --__n, ++__first)
    *__first = __val;
  return __first;
}




inline void fill(unsigned char* __first, unsigned char* __last,
                 const unsigned char& __val) {
  unsigned char __tmp = __val;
  memset(__first, __tmp, __last - __first);
}

inline void fill(signed char* __first, signed char* __last,
                 const signed char& __val) {
  signed char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}

inline void fill(char* __first, char* __last, const char& __val) {
  char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}



template <class _Size>
inline unsigned char* fill_n(unsigned char* __first, _Size __n,
                             const unsigned char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline signed char* fill_n(char* __first, _Size __n,
                           const signed char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline char* fill_n(char* __first, _Size __n, const char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}







template <class _InputIter1, class _InputIter2>
inline
pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                        _InputIter1 __last1,
                                        _InputIter2 __first2) {
 
 
  while (__first1 != __last1 && *__first1 == *__first2) {
    ++__first1;
    ++__first2;
  }
  return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                        _InputIter1 __last1,
                                        _InputIter2 __first2,
                                        _BinaryPredicate __binary_pred) {
 
 
  while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
    ++__first1;
    ++__first2;
  }
  return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!(*__first1 == *__first2))
      return false;
  return true;
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _BinaryPredicate __binary_pred) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!__binary_pred(*__first1, *__first2))
      return false;
  return true;
}





template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2);

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp);

inline bool
lexicographical_compare(const unsigned char* __first1,
                        const unsigned char* __last1,
                        const unsigned char* __first2,
                        const unsigned char* __last2)
{
  const size_t __len1 = __last1 - __first1;
  const size_t __len2 = __last2 - __first2;
 
 

  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? (__result < 0) : (__len1 < __len2);
}



inline bool lexicographical_compare(const char* __first1, const char* __last1,
                                    const char* __first2, const char* __last2)
{
 
 

  return lexicographical_compare((const unsigned char*) __first1,
                                 (const unsigned char*) __last1,
                                 (const unsigned char*) __first2,
                                 (const unsigned char*) __last2);
}


template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2);

inline int
__lexicographical_compare_3way(const unsigned char* __first1,
                               const unsigned char* __last1,
                               const unsigned char* __first2,
                               const unsigned char* __last2)
{
  const ptrdiff_t __len1 = __last1 - __first1;
  const ptrdiff_t __len2 = __last2 - __first2;
  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? __result
                       : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));
}



inline int
__lexicographical_compare_3way(const char* __first1, const char* __last1,
                               const char* __first2, const char* __last2)
{
  return __lexicographical_compare_3way((const unsigned char*) __first1,
                                        (const unsigned char*) __last1,
                                        (const unsigned char*) __first2,
                                        (const unsigned char*) __last2);
}




template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2);




template <class _InputIter, class _Tp>
inline typename iterator_traits<_InputIter>::difference_type
count(_InputIter __first, _InputIter __last, const _Tp& __val) {
 
  typename iterator_traits<_InputIter>::difference_type __n = 0;
  for ( ; __first != __last; ++__first)
    if (*__first == __val)
      ++__n;
  return __n;
}


template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val);
template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last, _Predicate __pred);


template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2, _BinaryPred __predicate);


template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp);

template <class _ForwardIter1, class _ForwardIter2,
          class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp);


template <class _ForwardIter, class _Tp>
inline void
replace(_ForwardIter __first, _ForwardIter __last,
        const _Tp& __old_value, const _Tp& __new_value) {
 
  for ( ; __first != __last; ++__first)
    if (*__first == __old_value)
      *__first = __new_value;
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
                              const _Tp& __val, const _Compare& __comp, _Distance*);

}


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.c" 1
# 32 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.c"
namespace _STL {

template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2) {
 
   
    for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2) {
      if (*__first1 < *__first2)
 return true;
      if (*__first2 < *__first1)
 return false;
    }
  return __first1 == __last1 && __first2 != __last2;
}

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp) {
 
   
    for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2) {
      if (__comp(*__first1, *__first2))
 return true;
      if (__comp(*__first2, *__first1))
 return false;
    }
  return __first1 == __last1 && __first2 != __last2;
}



template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2)
{
  while (__first1 != __last1 && __first2 != __last2) {
    if (*__first1 < *__first2)
      return -1;
    if (*__first2 < *__first1)
      return 1;
    ++__first1;
    ++__first2;
  }
  if (__first2 == __last2) {
    return !(__first1 == __last1);
  }
  else {
    return -1;
  }
}


template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2)
{
 
   
    return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);
}


template <class _RandomAccessIter, class _Tp>
inline _RandomAccessIter __find(_RandomAccessIter __first, _RandomAccessIter __last,
                                           const _Tp& __val,
                                           const random_access_iterator_tag &)
{
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (*__first == __val) return __first;
    ++__first;
  case 2:
    if (*__first == __val) return __first;
    ++__first;
  case 1:
    if (*__first == __val) return __first;
    ++__first;
  case 0:
  default:
    return __last;
  }
}

template <class _RandomAccessIter, class _Predicate>
inline _RandomAccessIter __find_if(_RandomAccessIter __first, _RandomAccessIter __last,
                                              _Predicate __pred,
                                              const random_access_iterator_tag &)
{
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (__pred(*__first)) return __first;
    ++__first;
  case 2:
    if (__pred(*__first)) return __first;
    ++__first;
  case 1:
    if (__pred(*__first)) return __first;

  case 0:
  default:
    return __last;
  }
}

template <class _InputIter, class _Tp>
inline _InputIter __find(_InputIter __first, _InputIter __last,
    const _Tp& __val,
    const input_iterator_tag &)
{
  while (__first != __last && !(*__first == __val))
    ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
inline _InputIter __find_if(_InputIter __first, _InputIter __last,
                            _Predicate __pred,
                            const input_iterator_tag &)
{
  while (__first != __last && !__pred(*__first))
    ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last,
                   _Predicate __pred) {
 
    return __find_if(__first, __last, __pred, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val)
{
 
    return __find(__first, __last, __val, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2,
                     _BinaryPred __predicate)
{
 
   

    if (__first1 == __last1 || __first2 == __last2)
      return __first1;


  _ForwardIter2 __tmp(__first2);
  ++__tmp;
  if (__tmp == __last2) {
    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
      ++__first1;
    return __first1;
  }



  _ForwardIter2 __p1, __p;

  __p1 = __first2; ++__p1;



  while (__first1 != __last1) {
    while (__first1 != __last1) {
      if (__predicate(*__first1, *__first2))
        break;
      ++__first1;
    }
    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
      ++__first1;
    if (__first1 == __last1)
      return __last1;

    __p = __p1;
    _ForwardIter1 __current = __first1;
    if (++__current == __last1) return __last1;

    while (__predicate(*__current, *__p)) {
      if (++__p == __last2)
        return __first1;
      if (++__current == __last1)
        return __last1;
    }

    ++__first1;
  }
  return __first1;
}



template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp) {
  for ( ; __first1 != __last1; ++__first1)
    for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
      if (__comp(*__first1, *__iter))
        return __first1;
  return __last1;
}
# 282 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.c"
template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1 __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
                         _ForwardIter2 __first2, _ForwardIter2 __last2,
                         const forward_iterator_tag &, const forward_iterator_tag &,
                         _BinaryPredicate __comp)
{
  if (__first2 == __last2)
    return __last1;
  else {
    _ForwardIter1 __result = __last1;
    while (1) {
      _ForwardIter1 __new_result
        = search(__first1, __last1, __first2, __last2, __comp);
      if (__new_result == __last1)
        return __result;
      else {
        __result = __new_result;
        __first1 = __new_result;
        ++__first1;
      }
    }
  }
}





}
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator.h" 1
# 37 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator.h"
namespace _STL {
# 46 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator.h"
template <class _Iterator>
class reverse_iterator :
  public iterator<typename iterator_traits<_Iterator>::iterator_category,
                  typename iterator_traits<_Iterator>::value_type,
                  typename iterator_traits<_Iterator>::difference_type,
                  typename iterator_traits<_Iterator>::pointer,
                  typename iterator_traits<_Iterator>::reference>
{
protected:
  _Iterator current;
  typedef reverse_iterator<_Iterator> _Self;
public:
  typedef typename iterator_traits<_Iterator>::iterator_category iterator_category;
  typedef typename iterator_traits<_Iterator>::value_type value_type;
  typedef typename iterator_traits<_Iterator>::difference_type difference_type;
  typedef typename iterator_traits<_Iterator>::pointer pointer;
  typedef typename iterator_traits<_Iterator>::reference reference;
  typedef _Iterator iterator_type;
public:
  reverse_iterator() {}
  explicit reverse_iterator(iterator_type __x) : current(__x) {}
  reverse_iterator(const _Self& __x) : current(__x.current) {}
  _Self& operator = (const _Self& __x) { current = __x.base(); return *this; }

  template <class _Iter>
  reverse_iterator(const reverse_iterator<_Iter>& __x) : current(__x.base()) {}
  template <class _Iter>
  _Self& operator = (const reverse_iterator<_Iter>& __x) { current = __x.base(); return *this; }


  iterator_type base() const { return current; }
  reference operator*() const {
    _Iterator __tmp = current;
    return *--__tmp;
  }
  pointer operator->() const { return &(operator*()); }
  _Self& operator++() {
    --current;
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    --current;
    return __tmp;
  }
  _Self& operator--() {
    ++current;
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    ++current;
    return __tmp;
  }

  _Self operator+(difference_type __n) const {
    return _Self(current - __n);
  }
  _Self& operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  _Self operator-(difference_type __n) const {
    return _Self(current + __n);
  }
  _Self& operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  reference operator[](difference_type __n) const { return *(*this + __n); }
};

template <class _Iterator>
inline bool operator==(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return __x.base() == __y.base();
}

template <class _Iterator>
inline bool operator<(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return __y.base() < __x.base();
}



template <class _Iterator>
inline bool operator!=(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return !(__x == __y);
}

template <class _Iterator>
inline bool operator>(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return __y < __x;
}

template <class _Iterator>
inline bool operator<=(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return !(__y < __x);
}

template <class _Iterator>
inline bool operator>=(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return !(__x < __y);
}



template <class _Iterator>



inline typename reverse_iterator<_Iterator>::difference_type

operator-(const reverse_iterator<_Iterator>& __x,
          const reverse_iterator<_Iterator>& __y) {
  return __y.base() - __x.base();
}

template <class _Iterator, class _DifferenceType>
inline reverse_iterator<_Iterator>
operator+(_DifferenceType n,const reverse_iterator<_Iterator>& x) {
  return x.operator+(n);
}



template <class _Container>
class back_insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;

  explicit back_insert_iterator(_Container& __x) : container(&__x) {}
  back_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    container->push_back(__val);
    return *this;
  }
  back_insert_iterator<_Container>& operator*() { return *this; }
  back_insert_iterator<_Container>& operator++() { return *this; }
  back_insert_iterator<_Container> operator++(int) { return *this; }
};

template <class _Container>
inline back_insert_iterator<_Container> back_inserter(_Container& __x) {
  return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class front_insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  explicit front_insert_iterator(_Container& __x) : container(&__x) {}
  front_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    container->push_front(__val);
    return *this;
  }
  front_insert_iterator<_Container>& operator*() { return *this; }
  front_insert_iterator<_Container>& operator++() { return *this; }
  front_insert_iterator<_Container>& operator++(int) { return *this; }
};

template <class _Container>
inline front_insert_iterator<_Container> front_inserter(_Container& __x) {
  return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
  typename _Container::iterator iter;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  insert_iterator(_Container& __x, typename _Container::iterator __i)
    : container(&__x), iter(__i) {}
  insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    iter = container->insert(iter, __val);
    ++iter;
    return *this;
  }
  insert_iterator<_Container>& operator*() { return *this; }
  insert_iterator<_Container>& operator++() { return *this; }
  insert_iterator<_Container>& operator++(int) { return *this; }
};

template <class _Container, class _Iterator>
inline insert_iterator<_Container>
inserter(_Container& __x, _Iterator __i)
{
  typedef typename _Container::iterator __iter;
  return insert_iterator<_Container>(__x, __iter(__i));
}

}
# 313 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.c" 2
namespace _STL {


template <class _BidirectionalIter1, class _BidirectionalIter2,
  class _BinaryPredicate>
_BidirectionalIter1
__find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
           _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
           const bidirectional_iterator_tag &, const bidirectional_iterator_tag &,
           _BinaryPredicate __comp)
{
  typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
  typedef reverse_iterator<_BidirectionalIter2> _RevIter2;

  _RevIter1 __rlast1(__first1);
  _RevIter2 __rlast2(__first2);
  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
                               _RevIter2(__last2), __rlast2,
                               __comp);

  if (__rresult == __rlast1)
    return __last1;
  else {
    _BidirectionalIter1 __result = __rresult.base();
    advance(__result, -distance(__first2, __last2));
    return __result;
  }
}


template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp)
{
 
   
    return __find_end(__first1, __last1, __first2, __last2,

        typename iterator_traits< _ForwardIter1 >::iterator_category(),
        typename iterator_traits< _ForwardIter2 >::iterator_category(),




        __comp);
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
      const _Tp& __val, const _Compare& __comp, _Distance*)
{
  _Distance __len = distance(__first, __last);
  _Distance __half;
  _ForwardIter __middle;

  while (__len > 0) {
    __half = __len >> 1;
    __middle = __first;
    advance(__middle, __half);
    if (__comp(*__middle, __val)) {
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
    else
      __len = __half;
  }
  return __first;
}

}
# 576 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h" 2
# 39 "c:/marmalade/6.2/s3e/h/std/c++/stl/_uninitialized.h" 2






namespace _STL {





template <class _InputIter, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     const __true_type&) {
  return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter> :: _Ret());
}

template <class _InputIter, class _ForwardIter>
inline
_ForwardIter
__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     const __false_type&)
{
  _ForwardIter __cur = __result;
  {
    for ( ; __first != __last; ++__first, ++__cur)
      _Construct(&*__cur, *__first);
    return __cur;
  }
  ;



}

template <class _InputIter, class _ForwardIter>
inline _ForwardIter
uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result) {
  return __uninitialized_copy(__first, __last, __result, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}

inline char*
uninitialized_copy(const char* __first, const char* __last, char* __result) {
  return (char*)__copy_trivial (__first, __last, __result);
}


inline wchar_t*
uninitialized_copy(const wchar_t* __first, const wchar_t* __last, wchar_t* __result) {
  return (wchar_t*)__copy_trivial (__first, __last, __result);
}





template <class _InputIter, class _Size, class _ForwardIter>
inline
pair<_InputIter, _ForwardIter>
__uninitialized_copy_n(_InputIter __first, _Size __count,
                       _ForwardIter __result,
                       const input_iterator_tag &)
{
  _ForwardIter __cur = __result;
  {
    for ( ; __count > 0 ; --__count, ++__first, ++__cur)
      _Construct(&*__cur, *__first);
    return pair<_InputIter, _ForwardIter>(__first, __cur);
  }
  ;



}
# 135 "c:/marmalade/6.2/s3e/h/std/c++/stl/_uninitialized.h"
template <class _RandomAccessIter, class _Size, class _ForwardIter>
inline pair<_RandomAccessIter, _ForwardIter>
__uninitialized_copy_n(_RandomAccessIter __first, _Size __count, _ForwardIter __result, const random_access_iterator_tag &) {
  _RandomAccessIter __last = __first + __count;
  return pair<_RandomAccessIter, _ForwardIter>( __last, __uninitialized_copy(__first, __last, __result,
                                                                             typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type()));
}


template <class _InputIter, class _Size, class _ForwardIter>
inline pair<_InputIter, _ForwardIter>
uninitialized_copy_n(_InputIter __first, _Size __count,
                     _ForwardIter __result) {
  return __uninitialized_copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}




template <class _ForwardIter, class _Tp>
inline void
__uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
                     const _Tp& __x, const __true_type&) {
  _STL::fill(__first, __last, __x);
}

template <class _ForwardIter, class _Tp>
inline void
__uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
                     const _Tp& __x, const __false_type&)
{
  _ForwardIter __cur = __first;
  {
    for ( ; __cur != __last; ++__cur)
      _Construct(&*__cur, __x);
  }
  ;
}

template <class _ForwardIter, class _Tp>
inline void uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __x) {
  __uninitialized_fill(__first, __last, __x, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}



template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
__uninitialized_fill_n(_ForwardIter __first, _Size __n,
                       const _Tp& __x, const __true_type&) {
  return _STL::fill_n(__first, __n, __x);
}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
__uninitialized_fill_n(_ForwardIter __first, _Size __n,
                       const _Tp& __x, const __false_type&)
{
  _ForwardIter __cur = __first;
  {
    for ( ; __n > 0; --__n, ++__cur)
      _Construct(&*__cur, __x);
    return __cur;
  }
  ;



}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x) {
  return __uninitialized_fill_n(__first, __n, __x, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}
# 219 "c:/marmalade/6.2/s3e/h/std/c++/stl/_uninitialized.h"
template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                          _InputIter2 __first2, _InputIter2 __last2,
                          _ForwardIter __result, __true_type)
{
  return __uninitialized_copy(__first2, __last2,
                              __uninitialized_copy(__first1, __last1, __result, __true_type()), __true_type());
}

template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                          _InputIter2 __first2, _InputIter2 __last2,
                          _ForwardIter __result, __false_type)
{
  _ForwardIter __mid = __uninitialized_copy(__first1, __last1, __result, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
  {
    return __uninitialized_copy(__first2, __last2, __mid , typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
  }
  ;



}




template <class _ForwardIter, class _Tp, class _InputIter>
inline _ForwardIter
__uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid, const _Tp& __x,
                          _InputIter __first, _InputIter __last)
{
  typedef typename __type_traits<_Tp>::is_POD_type _I_POD;
  __uninitialized_fill(__result, __mid, __x, _I_POD());
  {
    return __uninitialized_copy(__first, __last, __mid, _I_POD());
  }
  ;



}




template <class _InputIter, class _ForwardIter, class _Tp>
inline void
__uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,
                          _ForwardIter __first2, _ForwardIter __last2,
                          const _Tp& __x)
{
  typedef typename __type_traits<_Tp>::is_POD_type _I_POD;
  _ForwardIter __mid2 = __uninitialized_copy(__first1, __last1, __first2, _I_POD());
  {
    __uninitialized_fill(__mid2, __last2, __x, _I_POD());
  }
  ;
}

}
# 41 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.h" 2


namespace _STL {

template <class _Tp>
pair<_Tp*, ptrdiff_t>
__get_temporary_buffer(ptrdiff_t __len, _Tp*);



template <class _Tp>
inline pair<_Tp*, ptrdiff_t> get_temporary_buffer(ptrdiff_t __len) {
  return __get_temporary_buffer(__len, (_Tp*) 0);
}







template <class _Tp>
inline pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __len, _Tp*) {
  return __get_temporary_buffer(__len, (_Tp*) 0);
}



template <class _Tp>
inline void return_temporary_buffer(_Tp* __p) {

  free((char*)__p);
}

template <class _ForwardIterator, class _Tp>
class _Temporary_buffer {
private:
  ptrdiff_t _M_original_len;
  ptrdiff_t _M_len;
  _Tp* _M_buffer;

  void _M_allocate_buffer() {
    _M_original_len = _M_len;
    _M_buffer = 0;

    if (_M_len > (ptrdiff_t)(0x7fffffffL / sizeof(_Tp)))
      _M_len = 0x7fffffffL / sizeof(_Tp);

    while (_M_len > 0) {
      _M_buffer = (_Tp*) malloc(_M_len * sizeof(_Tp));
      if (_M_buffer)
        break;
      _M_len /= 2;
    }
  }

  void _M_initialize_buffer(const _Tp&, const __true_type&) {}
  void _M_initialize_buffer(const _Tp& val, const __false_type&) {
    uninitialized_fill_n(_M_buffer, _M_len, val);
  }

public:
  ptrdiff_t size() const { return _M_len; }
  ptrdiff_t requested_size() const { return _M_original_len; }
  _Tp* begin() { return _M_buffer; }
  _Tp* end() { return _M_buffer + _M_len; }

  _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) {




     typedef typename __type_traits<_Tp>::has_trivial_default_constructor _Trivial;

    {
      _M_len = distance(__first, __last);
      _M_allocate_buffer();
      if (_M_len > 0)
        _M_initialize_buffer(*__first, _Trivial());
    }
    ;
  }

  ~_Temporary_buffer() {
    _STL::_Destroy(_M_buffer, _M_buffer + _M_len);
    free(_M_buffer);
  }

private:

  _Temporary_buffer(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
  void operator=(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
};





template <class _ForwardIterator,
          class _Tp

                    = typename iterator_traits<_ForwardIterator>::value_type

         >
struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>
{
  temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _Temporary_buffer<_ForwardIterator, _Tp>(__first, __last) {}
  ~temporary_buffer() {}
};



}


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.c" 1
# 33 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.c"
namespace _STL {

template <class _Tp>
pair<_Tp*, ptrdiff_t>
__get_temporary_buffer(ptrdiff_t __len, _Tp*)
{
  if (__len > ptrdiff_t(0x7fffffffL / sizeof(_Tp)))
    __len = 0x7fffffffL / sizeof(_Tp);

  while (__len > 0) {
    _Tp* __tmp = (_Tp*) malloc((size_t)__len * sizeof(_Tp));
    if (__tmp != 0)
      return pair<_Tp*, ptrdiff_t>(__tmp, __len);
    __len /= 2;
  }

  return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);
}
}
# 159 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.h" 2
# 37 "c:/marmalade/6.2/s3e/h/std/c++/memory" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_raw_storage_iter.h" 1
# 37 "c:/marmalade/6.2/s3e/h/std/c++/stl/_raw_storage_iter.h"
namespace _STL {

template <class _ForwardIterator, class _Tp>
class raw_storage_iterator



{
protected:
  _ForwardIterator _M_iter;
public:
  typedef output_iterator_tag iterator_category;

  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

  explicit raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}
  raw_storage_iterator<_ForwardIterator, _Tp>& operator*() { return *this; }
  raw_storage_iterator<_ForwardIterator, _Tp>& operator=(const _Tp& __element) {
    _Construct(&*_M_iter, __element);
    return *this;
  }
  raw_storage_iterator<_ForwardIterator, _Tp>& operator++() {
    ++_M_iter;
    return *this;
  }
  raw_storage_iterator<_ForwardIterator, _Tp> operator++(int) {
    raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
    ++_M_iter;
    return __tmp;
  }
};





}
# 41 "c:/marmalade/6.2/s3e/h/std/c++/memory" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_auto_ptr.h" 1
# 22 "c:/marmalade/6.2/s3e/h/std/c++/stl/_auto_ptr.h"
namespace _STL {

class __ptr_base {
public:
  void* _M_p;
  void __set(const void* p) { _M_p = const_cast<void*>(p); }
  void __set(void* p) { _M_p = p; }
};

template <class _Tp> class auto_ptr_ref {
public:
  __ptr_base& _M_r;
  _Tp* const _M_p;

  auto_ptr_ref(__ptr_base& __r, _Tp* __p) : _M_r(__r), _M_p(__p) { }

  _Tp* release() const { _M_r.__set((void*)0); return _M_p; }

};

template<class _Tp> class auto_ptr : public __ptr_base {
public:
  typedef _Tp element_type;
  typedef auto_ptr<_Tp> _Self;

  _Tp* release() {
    _Tp* __px = this->get();
    this->_M_p = 0;
    return __px;
  }

  void reset(_Tp* __px=0) {
    _Tp* __pt = this->get();
    if (__px != __pt)
      delete __pt;
    this->__set(__px);
  }

  _Tp* get() const { return reinterpret_cast<_Tp*>(const_cast<void*>(_M_p)); }


  _Tp* operator->() const {
   
    return get();
  }

  _Tp& operator*() const {
   
    return *get();
  }

  auto_ptr() { this->_M_p = 0; }

  explicit auto_ptr(_Tp* __px) { this->__set(__px); }



  template<class _Tp1> auto_ptr(auto_ptr<_Tp1>& __r) {
    _Tp* __conversionCheck = __r.release();
    this->__set(__conversionCheck);
  }

  template<class _Tp1> auto_ptr<_Tp>& operator=(auto_ptr<_Tp1>& __r) {
    _Tp* __conversionCheck = __r.release();
    reset(__conversionCheck);
    return *this;
  }


  auto_ptr(_Self& __r) { this->__set(__r.release()); }

  _Self& operator=(_Self& __r) {
    reset(__r.release());
    return *this;
  }

  ~auto_ptr() { delete this->get(); }

  auto_ptr(auto_ptr_ref<_Tp> __r) {
    this->__set(__r.release());
  }

  _Self& operator=(auto_ptr_ref<_Tp> __r) {
    reset(__r.release());
    return *this;
  }


  template<class _Tp1> operator auto_ptr_ref<_Tp1>() {
    return auto_ptr_ref<_Tp1>(*this, this->get());
  }
  template<class _Tp1> operator auto_ptr<_Tp1>() {
    return auto_ptr<_Tp1>(release());
  }





};
}
# 44 "c:/marmalade/6.2/s3e/h/std/c++/memory" 2
# 24 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/cctype" 1
# 30 "c:/marmalade/6.2/s3e/h/std/c++/cctype"
# 1 "c:/marmalade/6.2/s3e/h/std/ctype.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/ctype.h"
extern "C" {
# 31 "c:/marmalade/6.2/s3e/h/std/ctype.h"
int toupper(int c);
int tolower(int c);
int isalnum(int c);
int isalpha(int c);

int isblank(int c);
int iscntrl(int c);
int isdigit(int c);
int isgraph(int c);
int islower(int c);
int isprint(int c);
int ispunct(int c);
int isspace(int c);
int isupper(int c);
int isxdigit(int c);

}
# 31 "c:/marmalade/6.2/s3e/h/std/c++/cctype" 2
# 51 "c:/marmalade/6.2/s3e/h/std/c++/cctype"
namespace _STL {
using ::isalnum;
using ::isalpha;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;
}
# 28 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_fwd.h" 1
# 23 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_fwd.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/iosfwd" 1
# 28 "c:/marmalade/6.2/s3e/h/std/c++/iosfwd"
         





# 1 "c:/marmalade/6.2/s3e/h/std/c++/cwchar" 1
# 49 "c:/marmalade/6.2/s3e/h/std/c++/cwchar"
# 1 "c:/marmalade/6.2/s3e/h/ext/../std/wchar.h" 1
# 18 "c:/marmalade/6.2/s3e/h/ext/../std/wchar.h"
# 1 "c:/marmalade/6.2/s3e/h/std/wctype.h" 1
# 18 "c:/marmalade/6.2/s3e/h/std/wctype.h"
extern "C" {

typedef const int32* wctrans_t;

wctype_t wctype(const char *name);
wctrans_t wctrans(const char *name);
int iswctype(wint_t wc, wctype_t desc);
wint_t towctrans(wint_t wc, wctrans_t desc);

int towupper(int c);
int towlower(int c);
int iswalnum(int c);
int iswalpha(int c);
int iswascii(int c);
int iswblank(int c);
int iswcntrl(int c);
int iswdigit(int c);
int iswgraph(int c);
int iswlower(int c);
int iswprint(int c);
int iswpunct(int c);
int iswspace(int c);
int iswupper(int c);
int iswxdigit(int c);

}
# 19 "c:/marmalade/6.2/s3e/h/ext/../std/wchar.h" 2


extern "C" {



typedef int mbstate_t;

wchar_t fgetwc(FILE *stream);
wchar_t *fgetws(wchar_t *ws, int n, FILE *stream);
wchar_t fputwc(wchar_t wc, FILE *stream);
wchar_t putwc(wchar_t wc, FILE *stream);
wchar_t getwc(FILE *stream);
wchar_t getwchar(void);
wchar_t ungetwc(wchar_t wc, FILE *stream);

int fputws(const wchar_t *ws, FILE *stream);
int fwide(FILE *stream, int mode);

int mbsinit(const mbstate_t *ps);
wchar_t btowc(int c);
size_t mbrlen(const char *s, size_t n, mbstate_t *ps);
size_t mbsrtowcs(wchar_t *dest, const char **src, size_t len, mbstate_t *ps);
size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *ps);
wchar_t putwchar(wchar_t wc);
wchar_t *wmemset(wchar_t *wcs, wchar_t wc, size_t n);
wchar_t *wcspbrk(const wchar_t *wcs, const wchar_t *accept);
wchar_t *wcsrchr(const wchar_t *wcs, wchar_t wc);
wchar_t *wmemchr(const wchar_t *s, wchar_t c, size_t n);
int wmemcmp(const wchar_t *s1, const wchar_t *s2, size_t n);
size_t wcslen(const wchar_t *s);
size_t wcsnlen(const wchar_t *s, size_t n);
size_t wcsrtombs(char *dest, const wchar_t **src, size_t len, mbstate_t *ps);
wchar_t *wmemmove(wchar_t *dest, const wchar_t *src, size_t n);
wchar_t *wmemcpy(wchar_t *dest, const wchar_t *src, size_t n);
wchar_t *wcsstr(const wchar_t *haystack, const wchar_t *needle);
wchar_t *wcschr(const wchar_t *wcs, wchar_t wc);
size_t wcsspn(const wchar_t *wcs, const wchar_t *accept);
wchar_t *wcstok(wchar_t *wcs, const wchar_t *delim, wchar_t **ptr);
wchar_t *wcsncpy(wchar_t *dest, const wchar_t *src, size_t n);
wchar_t *wcscat(wchar_t *dest, const wchar_t *src);
wchar_t *wcscpy(wchar_t *dest, const wchar_t *src);
size_t wcsxfrm (wchar_t *s1, const wchar_t *s2, size_t n);
float wcstof(const wchar_t *nptr, wchar_t **endptr);

int wcscoll (const wchar_t *s1, const wchar_t *s2);

int wprintf(const wchar_t *format, ...);
int fwprintf(FILE *stream, const wchar_t *format, ...);
int swprintf(wchar_t *wcs, size_t maxlen, const wchar_t *format, ...);

int wscanf(const wchar_t *format, ...);
int fwscanf(FILE *stream, const wchar_t *format, ...);
int swscanf(const wchar_t *str, const wchar_t *format, ...);

size_t wcrtomb(char *s, wchar_t wc, mbstate_t *ps);
int wcscmp(const wchar_t *s1, const wchar_t *s2);
int wcsncmp(const wchar_t *s1, const wchar_t *s2, size_t n);
size_t wcsftime(wchar_t *s, size_t maxsize, const wchar_t *format, const struct tm *tp);
int wctob(wint_t c);
size_t wcscspn(const wchar_t *wcs, const wchar_t *reject);
wchar_t *wcsncat(wchar_t *dest, const wchar_t *src, size_t n);

int64 wcstoll(wchar_t *nptr, wchar_t **endptr, int base);
uint64 wcstoull(wchar_t *nptr, wchar_t **endptr, int base);
long int wcstol(const wchar_t *nptr, wchar_t **endptr, int base);
unsigned long int wcstoul(const wchar_t *nptr, wchar_t **endptr, int base);
double wcstod(const wchar_t *nptr, wchar_t **endptr);
long double wcstold(wchar_t *nptr, wchar_t **endptr);

int vwprintf(const wchar_t *format, va_list args);
int vfwprintf(FILE *stream, const wchar_t *format, va_list args);
int vswprintf(wchar_t *wcs, size_t maxlen, const wchar_t *format, va_list args);

int vfwscanf(FILE *s, const wchar_t *format, va_list arg);
int vswscanf(wchar_t *s, wchar_t *format, va_list arg);
int vwscanf(wchar_t *format, va_list arg);






}
# 50 "c:/marmalade/6.2/s3e/h/std/c++/cwchar" 2
# 98 "c:/marmalade/6.2/s3e/h/std/c++/cwchar"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_cwchar.h" 1
# 21 "c:/marmalade/6.2/s3e/h/std/c++/stl/_cwchar.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/cwchar" 1
# 22 "c:/marmalade/6.2/s3e/h/std/c++/stl/_cwchar.h" 2
# 99 "c:/marmalade/6.2/s3e/h/std/c++/cwchar" 2
# 107 "c:/marmalade/6.2/s3e/h/std/c++/cwchar"
namespace _STL {





using ::wint_t;






using ::size_t;


using ::mbstate_t;
# 147 "c:/marmalade/6.2/s3e/h/std/c++/cwchar"
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;





using ::fwide;

using ::fwprintf;
using ::fwscanf;
using ::getwchar;



using ::getwc;
using ::ungetwc;

using ::putwc;
using ::putwchar;




using ::swprintf;
using ::swscanf;
using ::vfwprintf;
using ::vwprintf;
using ::vswprintf;


using ::wcsftime;

using ::wcstok;




using ::wcscat;
using ::wcsrchr;
using ::wcscmp;
using ::wcscoll;

using ::wcscpy;
using ::wcscspn;

using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcspbrk;
using ::wcschr;

using ::wcsspn;
using ::wcsxfrm;





using ::wcstod;
using ::wcstol;





using ::wcsstr;
using ::wmemchr;




using ::wctob;
using ::wmemcmp;

using ::wmemmove;
using ::wprintf;
using ::wscanf;



using ::wmemcpy;
using ::wmemset;



}
# 35 "c:/marmalade/6.2/s3e/h/std/c++/iosfwd" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iosfwd.h" 1
# 22 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iosfwd.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/char_traits.h" 1
# 53 "c:/marmalade/6.2/s3e/h/std/c++/stl/char_traits.h"
namespace _STL {



template <class _Tp> class allocator;
# 67 "c:/marmalade/6.2/s3e/h/std/c++/stl/char_traits.h"
typedef long streamoff;


typedef ptrdiff_t streamsize;




template <class _StateT> class fpos
{
public:
  fpos(streamoff __pos) : _M_pos(__pos), _M_st(_StateT()) {}
  fpos() : _M_pos(0), _M_st(_StateT()) {}

  operator streamoff() const { return _M_pos; }

  bool operator==(const fpos<_StateT>& __y) const
    { return _M_pos == __y._M_pos; }
  bool operator!=(const fpos<_StateT>& __y) const
    { return _M_pos != __y._M_pos; }

  fpos<_StateT>& operator+=(streamoff __off) {
    _M_pos += __off;
    return *this;
  }
  fpos<_StateT>& operator-=(streamoff __off) {
    _M_pos -= __off;
    return *this;
  }

  fpos<_StateT> operator+(streamoff __off) {
    fpos<_StateT> __tmp(*this);
    __tmp += __off;
    return __tmp;
  }
  fpos<_StateT> operator-(streamoff __off) {
    fpos<_StateT> __tmp(*this);
    __tmp -= __off;
    return __tmp;
  }

public:
  _StateT state() const { return _M_st; }
  void state(_StateT __st) { _M_st = __st; }
private:
  streamoff _M_pos;
  _StateT _M_st;
};

typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;




template <class _CharT, class _IntT> class __char_traits_base {
public:
  typedef _CharT char_type;
  typedef _IntT int_type;

  typedef streamoff off_type;
  typedef streampos pos_type;



  typedef mbstate_t state_type;



  static void assign(char_type& __c1, const char_type& __c2) { __c1 = __c2; }
  static bool eq(const _CharT& __c1, const _CharT& __c2)
    { return __c1 == __c2; }
  static bool lt(const _CharT& __c1, const _CharT& __c2)
    { return __c1 < __c2; }

  static int compare(const _CharT* __s1, const _CharT* __s2, size_t __n) {
    for (size_t __i = 0; __i < __n; ++__i)
      if (!eq(__s1[__i], __s2[__i]))
        return __s1[__i] < __s2[__i] ? -1 : 1;
    return 0;
  }

  static size_t length(const _CharT* __s) {
    const _CharT _NullChar = _CharT();
    size_t __i;
    for (__i = 0; !eq(__s[__i], _NullChar); ++__i)
      {}
    return __i;
  }

  static const _CharT* find(const _CharT* __s, size_t __n, const _CharT& __c) {
    for ( ; __n > 0 ; ++__s, --__n)
      if (eq(*__s, __c))
        return __s;
    return 0;
  }


  static _CharT* move(_CharT* __s1, const _CharT* __s2, size_t _Sz) {
    return (_Sz == 0 ? __s1 : (_CharT*)memmove(__s1, __s2, _Sz * sizeof(_CharT)));
  }

  static _CharT* copy(_CharT* __s1, const _CharT* __s2, size_t __n) {
    return (__n == 0 ? __s1 :
     (_CharT*)memcpy(__s1, __s2, __n * sizeof(_CharT)));
    }

  static _CharT* assign(_CharT* __s, size_t __n, _CharT __c) {
    for (size_t __i = 0; __i < __n; ++__i)
      __s[__i] = __c;
    return __s;
  }

  static int_type not_eof(const int_type& __c) {
    return !eq_int_type(__c, eof()) ? __c : static_cast<int_type>(0);
  }

  static char_type to_char_type(const int_type& __c) {
    return (char_type)__c;
  }

  static int_type to_int_type(const char_type& __c) {
    return (int_type)__c;
  }

  static bool eq_int_type(const int_type& __c1, const int_type& __c2) {
    return __c1 == __c2;
  }

  static int_type eof() {
    return (int_type)-1;

  }
};






template <class _CharT> class char_traits
  : public __char_traits_base<_CharT, _CharT>
{};



template<> class char_traits<char>
  : public __char_traits_base<char, int>
{
public:
  typedef char char_type;
  typedef int int_type;

  typedef streamoff off_type;

  typedef streampos pos_type;
  typedef mbstate_t state_type;



  static char to_char_type(const int& __c) {
    return (char)(unsigned char)__c;
  }

  static int to_int_type(const char& __c) {
    return (unsigned char)__c;
  }

  static int compare(const char* __s1, const char* __s2, size_t __n)
    { return memcmp(__s1, __s2, __n); }

  static size_t length(const char* __s) { return strlen(__s); }

  static void assign(char& __c1, const char& __c2) { __c1 = __c2; }

  static char* assign(char* __s, size_t __n, char __c)
    { memset(__s, __c, __n); return __s; }
};



template<> class char_traits<wchar_t>
  : public __char_traits_base<wchar_t, wint_t>
{};


}
# 23 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iosfwd.h" 2


namespace _STL {

class ios_base;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_streambuf;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_istream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ostream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_stringbuf;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_istringstream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_ostringstream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_filebuf;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ifstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ofstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class istreambuf_iterator;

template <class _CharT, class _Traits = char_traits<_CharT> >
class ostreambuf_iterator;

typedef basic_ios<char, char_traits<char> > ios;


typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;



class locale;
# 95 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iosfwd.h"
template <class _Facet> inline const _Facet& use_facet(const locale&);


template <class _CharT> class ctype;
template <class _CharT> class ctype_byname;
template <class _CharT> class collate;
template <class _CharT> class collate_byname;

template<> class ctype<char>;
template<> class ctype_byname<char>;
template<> class collate<char>;
template<> class collate_byname<char>;


template<> class ctype<wchar_t>;
template<> class ctype_byname<wchar_t>;
template<> class collate<wchar_t>;
template<> class collate_byname<wchar_t>;







typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_streambuf<char,char_traits<char> > streambuf;

typedef basic_stringbuf<char, char_traits<char>, allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>, allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>, allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>, allocator<char> > stringstream;

typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;



typedef basic_streambuf<wchar_t, char_traits<wchar_t> > wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;

typedef basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstringstream;

typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;


}
# 38 "c:/marmalade/6.2/s3e/h/std/c++/iosfwd" 2
# 24 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_fwd.h" 2


namespace _STL {


template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Alloc = allocator<_CharT> >
class basic_string;







typedef basic_string<char, char_traits<char>, allocator<char> > string;


typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;



 const char*
__get_c_string(const string& __str);






}
# 32 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function.h" 1
# 34 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_base.h" 1
# 37 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_base.h"
namespace _STL {

template <class _Arg, class _Result>
struct unary_function {
  typedef _Arg argument_type;
  typedef _Result result_type;
};

template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
};

template <class _Tp>
struct equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }
};

template <class _Tp>
struct not_equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }
};

template <class _Tp>
struct greater : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }
};

template <class _Tp>
struct less : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }
};

template <class _Tp>
struct greater_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }
};

template <class _Tp>
struct less_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }
};

template <class _Tp>
less<_Tp> __less(_Tp* ) { return less<_Tp>(); }

template <class _Tp>
equal_to<_Tp> __equal_to(_Tp* ) { return equal_to<_Tp>(); }

template <class _Tp>
struct plus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }
};

template <class _Tp>
struct minus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }
};

template <class _Tp>
plus<_Tp> __plus(_Tp* ) { return plus<_Tp>(); }

template <class _Tp>
minus<_Tp> __minus(_Tp* ) { return minus<_Tp>(); }

template <class _Tp>
struct multiplies : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }
};

template <class _Tp>
struct divides : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }
};

template <class _Tp>
struct modulus : public binary_function<_Tp,_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }
};

template <class _Tp>
struct negate : public unary_function<_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x) const { return -__x; }
};

template <class _Tp>
struct logical_and : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }
};

template <class _Tp>
struct logical_or : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }
};

template <class _Tp>
struct logical_not : public unary_function<_Tp,bool>
{
  bool operator()(const _Tp& __x) const { return !__x; }
};

template <class _Pair>
struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
  const typename _Pair::first_type& operator()(const _Pair& __x) const {
    return __x.first;
  }
};

template <class _Pair>
struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type>
{
  const typename _Pair::second_type& operator()(const _Pair& __x) const {
    return __x.second;
  }
};


template <class _Arg1, class _Arg2>
struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {
  _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }
};

template <class _Arg1, class _Arg2>
struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {
  _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }
};
# 188 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_base.h"
template <class _Tp>
struct _Identity : public unary_function<_Tp,_Tp> {
  const _Tp& operator()(const _Tp& __x) const { return __x; }
};

template <class _Result, class _Argument>
struct _Constant_unary_fun {
  typedef _Argument argument_type;
  typedef _Result result_type;
  result_type _M_val;

  _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()(const _Argument&) const { return _M_val; }
};

template <class _Result, class _Arg1, class _Arg2>
struct _Constant_binary_fun {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
  _Result _M_val;

  _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}
  const result_type& operator()(const _Arg1&, const _Arg2&) const {
    return _M_val;
  }
};


template <class _Tp> inline _Tp __identity_element(plus<_Tp>) { return _Tp(0); }
template <class _Tp> inline _Tp __identity_element(multiplies<_Tp>) { return _Tp(1); }

}
# 35 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function.h" 2


namespace _STL {



template <class _Tp> inline _Tp identity_element(plus<_Tp>) { return _Tp(0); }
template <class _Tp> inline _Tp identity_element(multiplies<_Tp>) { return _Tp(1); }
# 84 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function.h"
template <class _Predicate>
class unary_negate :
    public unary_function<typename _Predicate::argument_type, bool> {
protected:
  _Predicate _M_pred;
public:
  explicit unary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(const typename _Predicate::argument_type& __x) const {
    return !_M_pred(__x);
  }
};

template <class _Predicate>
inline unary_negate<_Predicate>
not1(const _Predicate& __pred)
{
  return unary_negate<_Predicate>(__pred);
}

template <class _Predicate>
class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type,
                             bool> {
protected:
  _Predicate _M_pred;
public:
  explicit binary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(const typename _Predicate::first_argument_type& __x,
                  const typename _Predicate::second_argument_type& __y) const
  {
    return !_M_pred(__x, __y);
  }
};

template <class _Predicate>
inline binary_negate<_Predicate>
not2(const _Predicate& __pred)
{
  return binary_negate<_Predicate>(__pred);
}

template <class _Operation>
class binder1st :
    public unary_function<typename _Operation::second_argument_type,
                          typename _Operation::result_type > {
protected:
  _Operation _M_op;
  typename _Operation::first_argument_type _M_value;
public:
  binder1st(const _Operation& __x,
            const typename _Operation::first_argument_type& __y)
      : _M_op(__x), _M_value(__y) {}

  typename _Operation::result_type
  operator()(const typename _Operation::second_argument_type& __x) const {
    return _M_op(_M_value, __x);
  }

  typename _Operation::result_type
  operator()(typename _Operation::second_argument_type& __x) const {
    return _M_op(_M_value, __x);
  }
};

template <class _Operation, class _Tp>
inline binder1st<_Operation>
bind1st(const _Operation& __fn, const _Tp& __x)
{
  typedef typename _Operation::first_argument_type _Arg1_type;
  return binder1st<_Operation>(__fn, _Arg1_type(__x));
}

template <class _Operation>
class binder2nd
  : public unary_function<typename _Operation::first_argument_type,
                          typename _Operation::result_type> {
protected:
  _Operation _M_op;
  typename _Operation::second_argument_type value;
public:
  binder2nd(const _Operation& __x,
            const typename _Operation::second_argument_type& __y)
      : _M_op(__x), value(__y) {}

  typename _Operation::result_type
  operator()(const typename _Operation::first_argument_type& __x) const {
    return _M_op(__x, value);
  }

  typename _Operation::result_type
  operator()(typename _Operation::first_argument_type& __x) const {
    return _M_op(__x, value);
  }
};

template <class _Operation, class _Tp>
inline binder2nd<_Operation>
bind2nd(const _Operation& __fn, const _Tp& __x)
{
  typedef typename _Operation::second_argument_type _Arg2_type;
  return binder2nd<_Operation>(__fn, _Arg2_type(__x));
}




template <class _Operation1, class _Operation2>
class unary_compose :
  public unary_function<typename _Operation2::argument_type,
                        typename _Operation1::result_type> {
protected:
  _Operation1 _M_fn1;
  _Operation2 _M_fn2;
public:
  unary_compose(const _Operation1& __x, const _Operation2& __y)
    : _M_fn1(__x), _M_fn2(__y) {}

  typename _Operation1::result_type
  operator()(const typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x));
  }

  typename _Operation1::result_type
  operator()(typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x));
  }
};

template <class _Operation1, class _Operation2>
inline unary_compose<_Operation1,_Operation2>
compose1(const _Operation1& __fn1, const _Operation2& __fn2)
{
  return unary_compose<_Operation1,_Operation2>(__fn1, __fn2);
}

template <class _Operation1, class _Operation2, class _Operation3>
class binary_compose :
    public unary_function<typename _Operation2::argument_type,
                          typename _Operation1::result_type> {
protected:
  _Operation1 _M_fn1;
  _Operation2 _M_fn2;
  _Operation3 _M_fn3;
public:
  binary_compose(const _Operation1& __x, const _Operation2& __y,
                 const _Operation3& __z)
    : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) { }

  typename _Operation1::result_type
  operator()(const typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x), _M_fn3(__x));
  }

  typename _Operation1::result_type
  operator()(typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x), _M_fn3(__x));
  }
};

template <class _Operation1, class _Operation2, class _Operation3>
inline binary_compose<_Operation1, _Operation2, _Operation3>
compose2(const _Operation1& __fn1, const _Operation2& __fn2,
         const _Operation3& __fn3)
{
  return binary_compose<_Operation1,_Operation2,_Operation3>
    (__fn1, __fn2, __fn3);
}






template <class _Tp> struct identity : public _Identity<_Tp> {};

template <class _Pair> struct select1st : public _Select1st<_Pair> {};
template <class _Pair> struct select2nd : public _Select2nd<_Pair> {};

template <class _Arg1, class _Arg2>
struct project1st : public _Project1st<_Arg1, _Arg2> {};

template <class _Arg1, class _Arg2>
struct project2nd : public _Project2nd<_Arg1, _Arg2> {};






template <class _Result>
struct _Constant_void_fun {
  typedef _Result result_type;
  result_type _M_val;

  _Constant_void_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()() const { return _M_val; }
};


template <class _Result>
struct constant_void_fun : public _Constant_void_fun<_Result> {
  constant_void_fun(const _Result& __v) : _Constant_void_fun<_Result>(__v) {}
};

template <class _Result, class _Argument = _Result >
struct constant_unary_fun : public _Constant_unary_fun<_Result, _Argument>
{
  constant_unary_fun(const _Result& __v)
    : _Constant_unary_fun<_Result, _Argument>(__v) {}
};

template <class _Result, class _Arg1 = _Result, class _Arg2 = _Arg1 >
struct constant_binary_fun
  : public _Constant_binary_fun<_Result, _Arg1, _Arg2>
{
  constant_binary_fun(const _Result& __v)
    : _Constant_binary_fun<_Result, _Arg1, _Arg2>(__v) {}
};

template <class _Result>
inline constant_void_fun<_Result> constant0(const _Result& __val)
{
  return constant_void_fun<_Result>(__val);
}

template <class _Result>
inline constant_unary_fun<_Result,_Result> constant1(const _Result& __val)
{
  return constant_unary_fun<_Result,_Result>(__val);
}

template <class _Result>
inline constant_binary_fun<_Result,_Result,_Result>
constant2(const _Result& __val)
{
  return constant_binary_fun<_Result,_Result,_Result>(__val);
}



class subtractive_rng : public unary_function<unsigned long, unsigned long> {
private:
  unsigned long _M_table[55];
  unsigned long _M_index1;
  unsigned long _M_index2;
public:
  unsigned long operator()(unsigned long __limit) {
    _M_index1 = (_M_index1 + 1) % 55;
    _M_index2 = (_M_index2 + 1) % 55;
    _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];
    return _M_table[_M_index1] % __limit;
  }

  void _M_initialize(unsigned long __seed)
  {
    unsigned long __k = 1;
    _M_table[54] = __seed;
    unsigned long __i;
    for (__i = 0; __i < 54; __i++) {
        unsigned long __ii = (21 * (__i + 1) % 55) - 1;
        _M_table[__ii] = __k;
        __k = __seed - __k;
        __seed = _M_table[__ii];
    }
    for (int __loop = 0; __loop < 4; __loop++) {
        for (__i = 0; __i < 55; __i++)
            _M_table[__i] = _M_table[__i] - _M_table[(1 + __i + 30) % 55];
    }
    _M_index1 = 0;
    _M_index2 = 31;
  }

  subtractive_rng(unsigned int __seed) { _M_initialize(__seed); }
  subtractive_rng() { _M_initialize(161803398ul); }
};



}

# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_adaptors.h" 1
# 58 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_adaptors.h"
namespace _STL {
# 411 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_adaptors.h"
template <class _Ret, class _Tp>
class mem_fun_t : public unary_function<_Tp*,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void);
public:
  explicit mem_fun_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p) const { return (__p->*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp>
class const_mem_fun_t : public unary_function<const _Tp*,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void) const;
public:
  explicit const_mem_fun_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p) const { return (__p->*_M_f)(); }
private:
  __fun_type _M_f;
};


template <class _Ret, class _Tp>
class mem_fun_ref_t : public unary_function<_Tp,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void);
public:
  explicit mem_fun_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r) const { return (__r.*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp>
class const_mem_fun_ref_t : public unary_function<_Tp,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void) const;
public:
  explicit const_mem_fun_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r) const { return (__r.*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class mem_fun1_t : public binary_function<_Tp*,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg);
public:
  explicit mem_fun1_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p, _Arg __x) const { return (__p->*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_t : public binary_function<const _Tp*,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg) const;
public:
  explicit const_mem_fun1_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p, _Arg __x) const
    { return (__p->*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg);
public:
  explicit mem_fun1_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg) const;
public:
  explicit const_mem_fun1_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Arg, class _Result>
class pointer_to_unary_function : public unary_function<_Arg, _Result> {
protected:
  _Result (*_M_ptr)(_Arg);
public:
  pointer_to_unary_function() {}
  explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}
  _Result operator()(_Arg __x) const { return _M_ptr(__x); }
};

template <class _Arg1, class _Arg2, class _Result>
class pointer_to_binary_function :
  public binary_function<_Arg1,_Arg2,_Result> {
protected:
    _Result (*_M_ptr)(_Arg1, _Arg2);
public:
    pointer_to_binary_function() {}
    explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}
    _Result operator()(_Arg1 __x, _Arg2 __y) const {
      return _M_ptr(__x, __y);
    }
};
# 737 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_adaptors.h"
template <class _Result, class _Tp>
inline mem_fun_t<_Result,_Tp>
mem_fun(_Result (_Tp::*__f)()) { return mem_fun_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline const_mem_fun_t<_Result,_Tp>
mem_fun(_Result (_Tp::*__f)() const) { return const_mem_fun_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline mem_fun_ref_t<_Result,_Tp>
mem_fun_ref(_Result (_Tp::*__f)()) { return mem_fun_ref_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline const_mem_fun_ref_t<_Result,_Tp>
mem_fun_ref(_Result (_Tp::*__f)() const) { return const_mem_fun_ref_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_t<_Result,_Tp,_Arg>
mem_fun(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_t<_Result,_Tp,_Arg>
mem_fun(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun_ref(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun_ref(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }




template <class _Result, class _Tp, class _Arg>
inline mem_fun1_t<_Result,_Tp,_Arg>
mem_fun1(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_t<_Result,_Tp,_Arg>
mem_fun1(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun1_ref(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun1_ref(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }





template <class _Arg, class _Result>
inline pointer_to_unary_function<_Arg, _Result>
ptr_fun(_Result (*__f)(_Arg))
{ return pointer_to_unary_function<_Arg, _Result>(__f); }

template <class _Arg1, class _Arg2, class _Result>
inline pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1, _Arg2))
{ return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f); }

}
# 366 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function.h" 2
# 36 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctraits_fns.h" 1
# 28 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctraits_fns.h"
namespace _STL {

template <class _Traits>
struct _Eq_traits
  : public binary_function<typename _Traits::char_type,
                           typename _Traits::char_type,
                           bool>
{
  bool operator()(const typename _Traits::char_type& __x,
                  const typename _Traits::char_type& __y) const
    { return _Traits::eq(__x, __y); }
};

template <class _Traits>
struct _Eq_char_bound
  : public unary_function<typename _Traits::char_type, bool>
{
  typename _Traits::char_type __val;
  _Eq_char_bound(typename _Traits::char_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
    { return _Traits::eq(__x, __val); }
};

template <class _Traits>
struct _Neq_char_bound
  : public unary_function<typename _Traits::char_type, bool>
{
  typename _Traits::char_type __val;
  _Neq_char_bound(typename _Traits::char_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
    { return !_Traits::eq(__x, __val); }
};

template <class _Traits>
struct _Eq_int_bound
  : public unary_function<typename _Traits::char_type, bool>
{
  typename _Traits::int_type __val;

  _Eq_int_bound(typename _Traits::int_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
    { return _Traits::eq_int_type(_Traits::to_int_type(__x), __val); }
};
# 85 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctraits_fns.h"
}
# 39 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2
# 79 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
namespace _STL {







template <class _Traits> struct _Not_within_traits
  : public unary_function<typename _Traits::char_type, bool> {
  typedef typename _Traits::char_type _CharT;
  const _CharT* _M_first;
  const _CharT* _M_last;

  _Not_within_traits(const typename _Traits::char_type* __f,
       const typename _Traits::char_type* __l)
    : _M_first(__f), _M_last(__l) {}

  bool operator()(const typename _Traits::char_type& __x) const {
    return find_if(_M_first, _M_last,
                   _Eq_char_bound<_Traits>(__x)) == _M_last;
  }
};
# 114 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
template <class _Tp, class _Alloc> class _String_base {
public:
 
  typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;
  _Tp* _M_start;
  _Tp* _M_finish;
  _STLP_alloc_proxy<_Tp*, _Tp, allocator_type> _M_end_of_storage;

  void _M_allocate_block(size_t);
  void _M_deallocate_block()
    { _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start); }

  size_t max_size() const { return (size_t(-1) / sizeof(_Tp)) - 1; }

  _String_base(const allocator_type& __a)
    : _M_start(0), _M_finish(0), _M_end_of_storage(__a, (_Tp*)0) {}

  _String_base(const allocator_type& __a, size_t __n)
    : _M_start(0), _M_finish(0), _M_end_of_storage(__a, (_Tp*)0)
    { _M_allocate_block(__n); }

  ~_String_base() { _M_deallocate_block(); }

  void _M_throw_length_error() const;
  void _M_throw_out_of_range() const;
};
# 164 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
struct _String_reserve_t {};

template <class _CharT, class _Traits, class _Alloc> class basic_string : protected _String_base<_CharT,_Alloc> {
private:
  typedef _String_base<_CharT,_Alloc> _Base;
  typedef basic_string<_CharT, _Traits, _Alloc> _Self;


  typedef typename _Is_integer<_CharT>::_Integral _Char_Is_Integral;
public:
  typedef _CharT value_type;
  typedef _Traits traits_type;

  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef random_access_iterator_tag _Iterator_category;

  typedef const value_type* const_iterator;
  typedef value_type* iterator;

  typedef _STL::reverse_iterator<const_iterator> const_reverse_iterator; typedef _STL::reverse_iterator<iterator> reverse_iterator;







  static const size_t npos = ~(size_t)0;


  typedef _String_reserve_t _Reserve_t;
# 212 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
public:
  typedef typename _String_base<_CharT,_Alloc>::allocator_type allocator_type;

  allocator_type get_allocator() const {
    return (const allocator_type&)this->_M_end_of_storage;
  }

  basic_string();

  explicit basic_string(const allocator_type& __a)
    : _String_base<_CharT,_Alloc>(__a, 8) {
    _M_terminate_string();
  }

  basic_string(_Reserve_t, size_t __n,
               const allocator_type& __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a, __n + 1) {
    _M_terminate_string();
  }

  basic_string(const basic_string<_CharT, _Traits, _Alloc>&);

  basic_string(const _Self& __s, size_type __pos, size_type __n = npos,
               const allocator_type& __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a) {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    else
      _M_range_initialize(__s._M_start + __pos,
                          __s._M_start + __pos + (min) (__n, __s.size() - __pos));
  }

  basic_string(const _CharT* __s, size_type __n,
               const allocator_type& __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a)
    {
     
      _M_range_initialize(__s, __s + __n);
    }

  basic_string(const _CharT* __s,
               const allocator_type& __a = allocator_type());

  basic_string(size_type __n, _CharT __c,
               const allocator_type& __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a, __n + 1)
  {
    this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __c);
    _M_terminate_string();
  }
# 274 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
  template <class _InputIterator> basic_string(_InputIterator __f, _InputIterator __l,
               const allocator_type & __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a)
  {
    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
    _M_initialize_dispatch(__f, __l, _Integral());
  }
# 305 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
  ~basic_string() { _STL::_Destroy(this->_M_start, this->_M_finish + 1); }

  _Self& operator=(const _Self& __s) {
    if (&__s != this)
      assign(__s._M_start, __s._M_finish);
    return *this;
  }

  _Self& operator=(const _CharT* __s) {
   
    return assign(__s, __s + traits_type::length(__s));
  }

  _Self& operator=(_CharT __c)
    { return assign(static_cast<size_type>(1), __c); }

  static _CharT _M_null() {
    return _CharT();
  }

private:


  void _M_construct_null_aux(_CharT* __p, const __false_type&) {
    _Construct(__p);
  }
  void _M_construct_null_aux(_CharT* __p, const __true_type&) {
    *__p = 0;
  }

  void _M_construct_null(_CharT* __p) {
    _M_construct_null_aux(__p, _Char_Is_Integral());
  }

private:



  void _M_terminate_string_aux(const __false_type&) {
    {
      _M_construct_null(this->_M_finish);
    }
    ;
  }

  void _M_terminate_string_aux(const __true_type&) {
    *(this->_M_finish)=0;
  }

  void _M_terminate_string() {
    _M_terminate_string_aux(_Char_Is_Integral());
  }






  template <class _InputIter>
  bool _M_inside(_InputIter __i) const {
    const _CharT* __s = static_cast<const _CharT*>(&(*__i));
    return (__s >= this->_M_start) && (__s < this->_M_finish);
  }




  template <class _InputIter> void _M_range_initialize(_InputIter __f, _InputIter __l,
                           const input_iterator_tag &) {
    this->_M_allocate_block(8);
    _M_construct_null(this->_M_finish);
    {
      append(__f, __l);
    }
    ;
  }

  template <class _ForwardIter> void _M_range_initialize(_ForwardIter __f, _ForwardIter __l,
                           const forward_iterator_tag &) {
    difference_type __n = distance(__f, __l);
    this->_M_allocate_block(__n + 1);
    this->_M_finish = uninitialized_copy(__f, __l, this->_M_start);
    _M_terminate_string();
  }

  template <class _InputIter> void _M_range_initialize(_InputIter __f, _InputIter __l) {
    _M_range_initialize(__f, __l, typename iterator_traits< _InputIter >::iterator_category());
  }

  template <class _Integer> void _M_initialize_dispatch(_Integer __n, _Integer __x, const __true_type&) {
    this->_M_allocate_block(__n + 1);
    this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __x);
    _M_terminate_string();
  }

  template <class _InputIter> void _M_initialize_dispatch(_InputIter __f, _InputIter __l, const __false_type&) {
     _M_range_initialize(__f, __l);
  }
# 415 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
public:
  iterator begin() { return this->_M_start; }
  iterator end() { return this->_M_finish; }
  const_iterator begin() const { return this->_M_start; }
  const_iterator end() const { return this->_M_finish; }

  reverse_iterator rbegin()
    { return reverse_iterator(this->_M_finish); }
  reverse_iterator rend()
    { return reverse_iterator(this->_M_start); }
  const_reverse_iterator rbegin() const
    { return const_reverse_iterator(this->_M_finish); }
  const_reverse_iterator rend() const
    { return const_reverse_iterator(this->_M_start); }

public:
  size_type size() const { return this->_M_finish - this->_M_start; }
  size_type length() const { return size(); }

  size_t max_size() const { return _Base::max_size(); }


  void resize(size_type __n, _CharT __c) {
    if (__n <= size())
      erase(begin() + __n, end());
    else
      append(__n - size(), __c);
  }
  void resize(size_type __n) { resize(__n, _M_null()); }

  void reserve(size_type = 0);

  size_type capacity() const { return (this->_M_end_of_storage._M_data - this->_M_start) - 1; }

  void clear() {
    if (!empty()) {
      _Traits::assign(*(this->_M_start), _M_null());
      _STL::_Destroy(this->_M_start+1, this->_M_finish+1);
      this->_M_finish = this->_M_start;
    }
  }

  bool empty() const { return this->_M_start == this->_M_finish; }

public:

  const_reference operator[](size_type __n) const
    { return *(this->_M_start + __n); }
  reference operator[](size_type __n)
    { return *(this->_M_start + __n); }

  const_reference at(size_type __n) const {
    if (__n >= size())
      this->_M_throw_out_of_range();
    return *(this->_M_start + __n);
  }

  reference at(size_type __n) {
    if (__n >= size())
      this->_M_throw_out_of_range();
    return *(this->_M_start + __n);
  }

public:

  _Self& operator+=(const _Self& __s) { return append(__s); }
  _Self& operator+=(const _CharT* __s) { return append(__s); }
  _Self& operator+=(_CharT __c) { push_back(__c); return *this; }

  _Self& append(const _Self& __s)
    { return append(__s._M_start, __s._M_finish); }

  _Self& append(const _Self& __s,
                       size_type __pos, size_type __n)
  {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    return append(__s._M_start + __pos,
                  __s._M_start + __pos + (min) (__n, __s.size() - __pos));
  }

  _Self& append(const _CharT* __s, size_type __n)
    { return append(__s, __s+__n); }
  _Self& append(const _CharT* __s)
    { return append(__s, __s + traits_type::length(__s)); }
  _Self& append(size_type __n, _CharT __c);





  template <class _InputIter> _Self& append(_InputIter __first, _InputIter __last) {
    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
    return _M_append_dispatch(__first, __last, _Integral());
  }







  void push_back(_CharT __c) {
    if (this->_M_finish + 1 == this->_M_end_of_storage._M_data)
      reserve(size() + (max)(size(), static_cast<size_type>(1)));
    _M_construct_null(this->_M_finish + 1);
    _Traits::assign(*(this->_M_finish), __c);
    ++this->_M_finish;
  }

  void pop_back() {
    _Traits::assign(*(this->_M_finish - 1), _M_null());
    _STL::_Destroy(this->_M_finish);
    --this->_M_finish;
  }

private:



  template <class _InputIter> _Self& append(_InputIter __first, _InputIter __last, const input_iterator_tag &)
  {
   for ( ; __first != __last ; ++__first)
     push_back(*__first);
   return *this;
 }

  template <class _ForwardIter> _Self& append(_ForwardIter __first, _ForwardIter __last,
                       const forward_iterator_tag &) {
    if (__first != __last) {
     const size_type __old_size = size();
     difference_type __n = distance(__first, __last);
     if (static_cast<size_type>(__n) > max_size() || __old_size > max_size() - static_cast<size_type>(__n))
       this->_M_throw_length_error();
     if (__old_size + __n > capacity()) {
       const size_type __len = __old_size +
                             (max)(__old_size, static_cast<size_type>(__n)) + 1;
       pointer __new_start = this->_M_end_of_storage.allocate(__len);
       pointer __new_finish = __new_start;
       {
         __new_finish = uninitialized_copy(this->_M_start, this->_M_finish, __new_start);
         __new_finish = uninitialized_copy(__first, __last, __new_finish);
         _M_construct_null(__new_finish);
       }
       ;

       _STL::_Destroy(this->_M_start, this->_M_finish + 1);
       this->_M_deallocate_block();
       this->_M_start = __new_start;
       this->_M_finish = __new_finish;
       this->_M_end_of_storage._M_data = __new_start + __len;
     }
     else {
       _ForwardIter __f1 = __first;
       ++__f1;
       uninitialized_copy(__f1, __last, this->_M_finish + 1);
       {
         _M_construct_null(this->_M_finish + __n);
       }
       ;
       _Traits::assign(*end(), *__first);
       this->_M_finish += __n;
     }
   }
   return *this;
 }

  template <class _Integer> _Self& _M_append_dispatch(_Integer __n, _Integer __x, const __true_type&) {
    return append((size_type) __n, (_CharT) __x);
  }

  template <class _InputIter> _Self& _M_append_dispatch(_InputIter __f, _InputIter __l,
                                   const __false_type&) {
    return append(__f, __l, typename iterator_traits< _InputIter >::iterator_category());
  }



public:

  _Self& assign(const _Self& __s)
    { return assign(__s._M_start, __s._M_finish); }

  _Self& assign(const _Self& __s,
                       size_type __pos, size_type __n) {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    return assign(__s._M_start + __pos,
                  __s._M_start + __pos + (min) (__n, __s.size() - __pos));
  }

  _Self& assign(const _CharT* __s, size_type __n)
    { return assign(__s, __s + __n); }

  _Self& assign(const _CharT* __s)
    { return assign(__s, __s + _Traits::length(__s)); }

  _Self& assign(size_type __n, _CharT __c);



private:

  template <class _Integer>
  _Self& _M_assign_dispatch(_Integer __n, _Integer __x, const __true_type&) {
    return assign((size_type) __n, (_CharT) __x);
  }

  template <class _InputIter>
  _Self& _M_assign_dispatch(_InputIter __f, _InputIter __l,
       const __false_type&) {
    pointer __cur = this->_M_start;
    while (__f != __l && __cur != this->_M_finish) {
      _Traits::assign(*__cur, *__f);
      ++__f;
      ++__cur;
    }
    if (__f == __l)
      erase(__cur, end());
    else
      append(__f, __l);
    return *this;
  }

public:


  template <class _InputIter> _Self& assign(_InputIter __first, _InputIter __last) {
    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
    return _M_assign_dispatch(__first, __last, _Integral());
  }



  _Self& assign(const _CharT* __f, const _CharT* __l)
  {
    ptrdiff_t __n = __l - __f;
    if (static_cast<size_type>(__n) <= size()) {
      _Traits::copy(this->_M_start, __f, __n);
      erase(begin() + __n, end());
    }
    else {
      _Traits::copy(this->_M_start, __f, size());
      append(__f + size(), __l);
    }
    return *this;
  }

public:

  _Self& insert(size_type __pos, const _Self& __s) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (size() > max_size() - __s.size())
      this->_M_throw_length_error();
    insert(begin() + __pos, __s._M_start, __s._M_finish);
    return *this;
  }

  _Self& insert(size_type __pos, const _Self& __s,
                       size_type __beg, size_type __n) {
    if (__pos > size() || __beg > __s.size())
      this->_M_throw_out_of_range();
    size_type __len = (min) (__n, __s.size() - __beg);
    if (size() > max_size() - __len)
      this->_M_throw_length_error();
    insert(begin() + __pos,
           __s._M_start + __beg, __s._M_start + __beg + __len);
    return *this;
  }

  _Self& insert(size_type __pos, const _CharT* __s, size_type __n) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (size() > max_size() - __n)
      this->_M_throw_length_error();
    insert(begin() + __pos, __s, __s + __n);
    return *this;
  }

  _Self& insert(size_type __pos, const _CharT* __s) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    size_type __len = _Traits::length(__s);
    if (size() > max_size() - __len)
      this->_M_throw_length_error();
    insert(this->_M_start + __pos, __s, __s + __len);
    return *this;
  }

  _Self& insert(size_type __pos, size_type __n, _CharT __c) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (size() > max_size() - __n)
      this->_M_throw_length_error();
    insert(begin() + __pos, __n, __c);
    return *this;
  }

  iterator insert(iterator __p, _CharT __c) {
   
    if (__p == end()) {
      push_back(__c);
      return this->_M_finish - 1;
    }
    else
      return _M_insert_aux(__p, __c);
  }

  void insert(iterator __p, size_t __n, _CharT __c);





  template <class _InputIter> void insert(iterator __p, _InputIter __first, _InputIter __last) {
    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
    _M_insert_dispatch(__p, __first, __last, _Integral());
  }







private:



  template <class _InputIter> void insert(iterator __p, _InputIter __first, _InputIter __last,
       const input_iterator_tag &)
  {
   for ( ; __first != __last; ++__first) {
     __p = insert(__p, *__first);
     ++__p;
   }
 }

  template <class _ForwardIter>
  void insert(iterator __position, _ForwardIter __first, _ForwardIter __last,
       const forward_iterator_tag &) {
    if (__first != __last) {
      difference_type __n = distance(__first, __last);
      if (this->_M_end_of_storage._M_data - this->_M_finish >= __n + 1) {
 const difference_type __elems_after = this->_M_finish - __position;
 pointer __old_finish = this->_M_finish;
 if (__elems_after >= __n) {
   uninitialized_copy((this->_M_finish - __n) + 1, this->_M_finish + 1,
        this->_M_finish + 1);
   this->_M_finish += __n;
   _Traits::move(__position + __n,
   __position, (__elems_after - __n) + 1);
   _M_move(__first, __last, __position);
       }
 else {
   _ForwardIter __mid = __first;
   advance(__mid, __elems_after + 1);
   uninitialized_copy(__mid, __last, this->_M_finish + 1);
   this->_M_finish += __n - __elems_after;
         {
           uninitialized_copy(__position, __old_finish + 1, this->_M_finish);
           this->_M_finish += __elems_after;
         }
         ;

         _M_move(__first, __mid, __position);
 }
      }
      else {
 const size_type __old_size = size();
 const size_type __len
   = __old_size + (max)(__old_size, static_cast<size_type>(__n)) + 1;
       pointer __new_start = this->_M_end_of_storage.allocate(__len);
       pointer __new_finish = __new_start;
       {
         __new_finish = uninitialized_copy(this->_M_start, __position, __new_start);
         __new_finish = uninitialized_copy(__first, __last, __new_finish);
         __new_finish
           = uninitialized_copy(__position, this->_M_finish, __new_finish);
         _M_construct_null(__new_finish);
       }
       ;

       _STL::_Destroy(this->_M_start, this->_M_finish + 1);
       this->_M_deallocate_block();
       this->_M_start = __new_start;
       this->_M_finish = __new_finish;
       this->_M_end_of_storage._M_data = __new_start + __len;
     }
    }
  }

  template <class _Integer> void _M_insert_dispatch(iterator __p, _Integer __n, _Integer __x,
                          const __true_type&) {
    insert(__p, (size_type) __n, (_CharT) __x);
  }

  template <class _InputIter> void _M_insert_dispatch(iterator __p, _InputIter __first, _InputIter __last,
                          const __false_type&) {
    insert(__p, __first, __last, typename iterator_traits< _InputIter >::iterator_category());
  }

  template <class _InputIterator> void
  _M_copy(_InputIterator __first, _InputIterator __last, pointer __result) {
    for ( ; __first != __last; ++__first, ++__result)
      _Traits::assign(*__result, *__first);
  }

  template <class _InputIterator>
  void _M_move(_InputIterator __first, _InputIterator __last, pointer __result) {

    for ( ; __first != __last; ++__first, ++__result)
      _Traits::assign(*__result, *__first);
  }



  pointer _M_insert_aux(pointer, _CharT);

  void
  _M_copy(const _CharT* __first, const _CharT* __last, _CharT* __result) {
    _Traits::copy(__result, __first, __last - __first);
  }
  void _M_move(const _CharT* __first, const _CharT* __last, _CharT* __result) {
    _Traits::move(__result, __first, __last - __first);
  }

public:

  _Self& erase(size_type __pos = 0, size_type __n = npos) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    erase(begin() + __pos, begin() + __pos + (min) (__n, size() - __pos));
    return *this;
  }

  iterator erase(iterator __position) {

    _Traits::move(__position, __position + 1, this->_M_finish - __position);
    _STL::_Destroy(this->_M_finish);
    --this->_M_finish;
    return __position;
  }

  iterator erase(iterator __first, iterator __last) {
    if (__first != __last) {

      traits_type::move(__first, __last, (this->_M_finish - __last) + 1);
      pointer __new_finish = this->_M_finish - (__last - __first);
      _STL::_Destroy(__new_finish + 1, this->_M_finish + 1);
      this->_M_finish = __new_finish;
    }
    return __first;
  }

public:

  _Self& replace(size_type __pos, size_type __n,
                        const _Self& __s) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n, size() - __pos);
    if (size() - __len >= max_size() - __s.size())
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len,
                   __s._M_start, __s._M_finish);
  }

  _Self& replace(size_type __pos1, size_type __n1,
                        const _Self& __s,
                        size_type __pos2, size_type __n2) {
    if (__pos1 > size() || __pos2 > __s.size())
      this->_M_throw_out_of_range();
    const size_type __len1 = (min) (__n1, size() - __pos1);
    const size_type __len2 = (min) (__n2, __s.size() - __pos2);
    if (size() - __len1 >= max_size() - __len2)
      this->_M_throw_length_error();
    return replace(begin() + __pos1, begin() + __pos1 + __len1,
                   __s._M_start + __pos2, __s._M_start + __pos2 + __len2);
  }

  _Self& replace(size_type __pos, size_type __n1,
                        const _CharT* __s, size_type __n2) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n1, size() - __pos);
    if (__n2 > max_size() || size() - __len >= max_size() - __n2)
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len,
                   __s, __s + __n2);
  }

  _Self& replace(size_type __pos, size_type __n1,
                        const _CharT* __s) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n1, size() - __pos);
    const size_type __n2 = _Traits::length(__s);
    if (__n2 > max_size() || size() - __len >= max_size() - __n2)
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len,
                   __s, __s + _Traits::length(__s));
  }

  _Self& replace(size_type __pos, size_type __n1,
                        size_type __n2, _CharT __c) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n1, size() - __pos);
    if (__n2 > max_size() || size() - __len >= max_size() - __n2)
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len, __n2, __c);
  }

  _Self& replace(iterator __first, iterator __last,
                        const _Self& __s)
    { return replace(__first, __last, __s._M_start, __s._M_finish); }

  _Self& replace(iterator __first, iterator __last,
                        const _CharT* __s, size_type __n)
    { return replace(__first, __last, __s, __s + __n); }

  _Self& replace(iterator __first, iterator __last,
                        const _CharT* __s) {
   
    return replace(__first, __last, __s, __s + _Traits::length(__s));
  }

  _Self& replace(iterator __first, iterator __last,
                        size_type __n, _CharT __c);




  template <class _InputIter> _Self& replace(iterator __first, iterator __last,
                        _InputIter __f, _InputIter __l) {
    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
    return _M_replace_dispatch(__first, __last, __f, __l, _Integral());
  }





private:



  template <class _Integer> _Self& _M_replace_dispatch(iterator __first, iterator __last,
                                    _Integer __n, _Integer __x,
                                    const __true_type&) {
    return replace(__first, __last, (size_type) __n, (_CharT) __x);
  }

  template <class _InputIter> _Self& _M_replace_dispatch(iterator __first, iterator __last,
                                    _InputIter __f, _InputIter __l,
                                    const __false_type&) {
    return replace(__first, __last, __f, __l, typename iterator_traits< _InputIter >::iterator_category());
  }

  template <class _InputIter> _Self& replace(iterator __first, iterator __last,
                        _InputIter __f, _InputIter __l, const input_iterator_tag &) {
   for ( ; __first != __last && __f != __l; ++__first, ++__f)
     _Traits::assign(*__first, *__f);

   if (__f == __l)
     erase(__first, __last);
   else
     insert(__last, __f, __l);
   return *this;
 }

  template <class _InputIter>
  _Self& replace(iterator __first, iterator __last,
                 _InputIter __f, _InputIter __l, const random_access_iterator_tag &) {

    if (_M_inside(__f)) {
      difference_type __n = __l - __f;
      const difference_type __len = __last - __first;
      if (__len >= __n) {
        _M_move(__f, __l, __first);
        erase(__first + __n, __last);
      }
      else {
        _InputIter __m = __f + __len;
        if ((__l <= __first) || (__f >= __last)) {

          _M_copy(__f, __m, __first);
          insert(__last, __m, __l);
        }
        else {

      const difference_type __off_dest = __first - this->begin();
      const difference_type __off_src = __f - this->begin();
      insert(__last, __m, __l);
      _Traits::move(begin() + __off_dest, begin() + __off_src, __n);
        }
      }
      return *this;
    }
   else {
    return replace(__first, __last, __f, __l, forward_iterator_tag());
   }
  }


  template <class _ForwardIter> _Self& replace(iterator __first, iterator __last,
                        _ForwardIter __f, _ForwardIter __l,
                        const forward_iterator_tag &) {
   difference_type __n = distance(__f, __l);
   const difference_type __len = __last - __first;
   if (__len >= __n) {
     _M_copy(__f, __l, __first);
     erase(__first + __n, __last);
   }
   else {
     _ForwardIter __m = __f;
     advance(__m, __len);
     _M_copy(__f, __m, __first);
     insert(__last, __m, __l);
   }
   return *this;
 }



public:

  size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n, size() - __pos);
    _Traits::copy(__s, this->_M_start + __pos, __len);
    return __len;
  }

  void swap(_Self& __s) {
    _STL::swap(this->_M_start, __s._M_start);
    _STL::swap(this->_M_finish, __s._M_finish);
    _STL::swap(this->_M_end_of_storage, __s._M_end_of_storage);
  }

public:

  const _CharT* c_str() const { return this->_M_start; }
  const _CharT* data() const { return this->_M_start; }

public:

  size_type find(const _Self& __s, size_type __pos = 0) const
    { return find(__s._M_start, __pos, __s.size()); }

  size_type find(const _CharT* __s, size_type __pos = 0) const
    { return find(__s, __pos, _Traits::length(__s)); }

  size_type find(const _CharT* __s, size_type __pos, size_type __n) const;


  size_type find(_CharT __c) const
    { return find(__c, 0) ; }
  size_type find(_CharT __c, size_type __pos ) const;

public:

  size_type rfind(const _Self& __s, size_type __pos = npos) const
    { return rfind(__s._M_start, __pos, __s.size()); }

  size_type rfind(const _CharT* __s, size_type __pos = npos) const
    { return rfind(__s, __pos, _Traits::length(__s)); }

  size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const;
  size_type rfind(_CharT __c, size_type __pos = npos) const;

public:

  size_type find_first_of(const _Self& __s, size_type __pos = 0) const
    { return find_first_of(__s._M_start, __pos, __s.size()); }

  size_type find_first_of(const _CharT* __s, size_type __pos = 0) const
    { return find_first_of(__s, __pos, _Traits::length(__s)); }

  size_type find_first_of(const _CharT* __s, size_type __pos,
                          size_type __n) const;

  size_type find_first_of(_CharT __c, size_type __pos = 0) const
    { return find(__c, __pos); }

public:

  size_type find_last_of(const _Self& __s,
                         size_type __pos = npos) const
    { return find_last_of(__s._M_start, __pos, __s.size()); }

  size_type find_last_of(const _CharT* __s, size_type __pos = npos) const
    { return find_last_of(__s, __pos, _Traits::length(__s)); }

  size_type find_last_of(const _CharT* __s, size_type __pos,
                         size_type __n) const;

  size_type find_last_of(_CharT __c, size_type __pos = npos) const {
    return rfind(__c, __pos);
  }

public:

  size_type find_first_not_of(const _Self& __s,
                              size_type __pos = 0) const
    { return find_first_not_of(__s._M_start, __pos, __s.size()); }

  size_type find_first_not_of(const _CharT* __s, size_type __pos = 0) const
    { return find_first_not_of(__s, __pos, _Traits::length(__s)); }

  size_type find_first_not_of(const _CharT* __s, size_type __pos,
                              size_type __n) const;

  size_type find_first_not_of(_CharT __c, size_type __pos = 0) const;

public:

  size_type find_last_not_of(const _Self& __s,
                             size_type __pos = npos) const
    { return find_last_not_of(__s._M_start, __pos, __s.size()); }

  size_type find_last_not_of(const _CharT* __s, size_type __pos = npos) const
    { return find_last_not_of(__s, __pos, _Traits::length(__s)); }

  size_type find_last_not_of(const _CharT* __s, size_type __pos,
                             size_type __n) const;

  size_type find_last_not_of(_CharT __c, size_type __pos = npos) const;

public:

  _Self substr(size_type __pos = 0, size_type __n = npos) const {
    if (__pos > size())
      this->_M_throw_out_of_range();
    return _Self(this->_M_start + __pos,
                        this->_M_start + __pos + (min) (__n, size() - __pos));
  }

public:

  int compare(const _Self& __s) const
    { return _M_compare(this->_M_start, this->_M_finish, __s._M_start, __s._M_finish); }

  int compare(size_type __pos1, size_type __n1,
              const _Self& __s) const {
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_start + __pos1,
                      this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
                      __s._M_start, __s._M_finish);
  }

  int compare(size_type __pos1, size_type __n1,
              const _Self& __s,
              size_type __pos2, size_type __n2) const {
    if (__pos1 > size() || __pos2 > __s.size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_start + __pos1,
                      this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
                      __s._M_start + __pos2,
                      __s._M_start + __pos2 + (min) (__n2, __s.size() - __pos2));
  }

  int compare(const _CharT* __s) const {
   
      return _M_compare(this->_M_start, this->_M_finish, __s, __s + _Traits::length(__s));
  }

  int compare(size_type __pos1, size_type __n1, const _CharT* __s) const {
   
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_start + __pos1,
                      this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
                      __s, __s + _Traits::length(__s));
  }

  int compare(size_type __pos1, size_type __n1, const _CharT* __s,
              size_type __n2) const {
   
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_start + __pos1,
                      this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
                      __s, __s + __n2);
  }

public:

  static int _M_compare(const _CharT* __f1, const _CharT* __l1,
                        const _CharT* __f2, const _CharT* __l2) {
    const ptrdiff_t __n1 = __l1 - __f1;
    const ptrdiff_t __n2 = __l2 - __f2;
    const int cmp = _Traits::compare(__f1, __f2, (min) (__n1, __n2));
    return cmp != 0 ? cmp : (__n1 < __n2 ? -1 : (__n1 > __n2 ? 1 : 0));
  }
};
# 1237 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y)
{
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;


  _Str __result = _Str(_Reserve_t(),__s.size() + __y.size());



  __result.append(__s);
  __result.append(__y);
  return __result;
}





template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;
  const size_t __n = _Traits::length(__s);

  _Str __result = _Str(_Reserve_t(), __n + __y.size());



  __result.append(__s, __s + __n);
  __result.append(__y);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(_CharT __c,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;

  _Str __result = _Str(_Reserve_t(), 1 + __y.size());



  __result.push_back(__c);
  __result.append(__y);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
 
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;
  const size_t __n = _Traits::length(__s);

  _Str __result = _Str(_Reserve_t(), __x.size() + __n, __x.get_allocator());



  __result.append(__x);
  __result.append(__s, __s + __n);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT __c) {
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;

  _Str __result = _Str(_Reserve_t(), __x.size() + 1, __x.get_allocator());



  __result.append(__x);
  __result.push_back(__c);
  return __result;
}





template <class _CharT, class _Traits, class _Alloc> inline bool
operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return __x.size() == __y.size() && _Traits::compare(__x.data(), __y.data(), __x.size()) == 0;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator==(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  size_t __n = _Traits::length(__s);
  return __n == __y.size() && _Traits::compare(__s, __y.data(), __n) == 0;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  size_t __n = _Traits::length(__s);
  return __x.size() == __n && _Traits::compare(__x.data(), __s, __n) == 0;
}



template <class _CharT, class _Traits, class _Alloc> inline bool
operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__x.begin(), __x.end(),
   __y.begin(), __y.end()) < 0;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  size_t __n = _Traits::length(__s);
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__s, __s + __n, __y.begin(), __y.end()) < 0;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
 
  size_t __n = _Traits::length(__s);
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__x.begin(), __x.end(), __s, __s + __n) < 0;
}



template <class _CharT, class _Traits, class _Alloc> inline bool
operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return !(__x == __y);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return __y < __x;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return !(__y < __x);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return !(__x < __y);
}



template <class _CharT, class _Traits, class _Alloc> inline bool
operator!=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return !(__s == __y);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  return !(__x == __s);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return __y < __s;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
 
  return __s < __x;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return !(__y < __s);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  return !(__s < __x);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return !(__s < __y);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  return !(__x < __s);
}






template <class _CharT, class _Traits, class _Alloc> inline void
swap(basic_string<_CharT,_Traits,_Alloc>& __x,
     basic_string<_CharT,_Traits,_Alloc>& __y) {
  __x.swap(__y);
}



template <class _CharT, class _Traits, class _Alloc> void _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,
                    _CharT* __buf,
                    size_t __n);
# 1483 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
}






# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c" 1
# 47 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c"
namespace _STL {
# 57 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c"
template <class _CharT, class _Traits, class _Alloc> void basic_string<_CharT,_Traits,_Alloc>::reserve(size_type __res_arg) {

  if (__res_arg >= capacity())
    {
      if (__res_arg > max_size())
 this->_M_throw_length_error();

      size_type __n = __res_arg + 1;
      pointer __new_start = this->_M_end_of_storage.allocate(__n);
      pointer __new_finish = __new_start;

      {
 __new_finish = uninitialized_copy(this->_M_start, this->_M_finish, __new_start);
 _M_construct_null(__new_finish);
      }
      ;


      _STL::_Destroy(this->_M_start, this->_M_finish + 1);
      this->_M_deallocate_block();
      this->_M_start = __new_start;
      this->_M_finish = __new_finish;
      this->_M_end_of_storage._M_data = __new_start + __n;
    }
}

template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT,_Traits,_Alloc>& basic_string<_CharT,_Traits,_Alloc>::append(size_type __n, _CharT __c) {
  if (__n > max_size() || size() > max_size() - __n)
    this->_M_throw_length_error();
  if (size() + __n > capacity())
    reserve(size() + (max)(size(), __n));
  if (__n > 0) {
    uninitialized_fill_n(this->_M_finish + 1, __n - 1, __c);
    {
      _M_construct_null(this->_M_finish + __n);
    }
    ;
    _Traits::assign(*end(), __c);
    this->_M_finish += __n;
  }
  return *this;
}
# 144 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c"
template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc>::assign(size_type __n, _CharT __c) {
  if (__n <= size()) {
    _Traits::assign(this->_M_start, __n, __c);
    erase(begin() + __n, end());
  }
  else {
    _Traits::assign(this->_M_start, size(), __c);
    append(__n - size(), __c);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc> _CharT*
basic_string<_CharT,_Traits,_Alloc> ::_M_insert_aux(_CharT* __p,
                  _CharT __c)
{
  pointer __new_pos = __p;
  if (this->_M_finish + 1 < this->_M_end_of_storage._M_data) {
    _M_construct_null(this->_M_finish + 1);
    _Traits::move(__p + 1, __p, this->_M_finish - __p);
    _Traits::assign(*__p, __c);
    ++this->_M_finish;
  }
  else {
    const size_type __old_len = size();
    const size_type __len = __old_len +
                            (max)(__old_len, static_cast<size_type>(1)) + 1;
    pointer __new_start = this->_M_end_of_storage.allocate(__len);
    pointer __new_finish = __new_start;
    {
      __new_pos = uninitialized_copy(this->_M_start, __p, __new_start);
      _Construct(__new_pos, __c);
      __new_finish = __new_pos + 1;
      __new_finish = uninitialized_copy(__p, this->_M_finish, __new_finish);
      _M_construct_null(__new_finish);
    }
    ;

    _STL::_Destroy(this->_M_start, this->_M_finish + 1);
    this->_M_deallocate_block();
    this->_M_start = __new_start;
    this->_M_finish = __new_finish;
    this->_M_end_of_storage._M_data = __new_start + __len;
  }
  return __new_pos;
}

template <class _CharT, class _Traits, class _Alloc> void basic_string<_CharT,_Traits,_Alloc>::insert(iterator __position,
           size_t __n, _CharT __c)
{
  if (__n != 0) {
    if (size_type(this->_M_end_of_storage._M_data - this->_M_finish) >= __n + 1) {
      const size_type __elems_after = this->_M_finish - __position;
      pointer __old_finish = this->_M_finish;
      if (__elems_after >= __n) {
        uninitialized_copy((this->_M_finish - __n) + 1, this->_M_finish + 1,
                           this->_M_finish + 1);
        this->_M_finish += __n;
        _Traits::move(__position + __n,
                      __position, (__elems_after - __n) + 1);
        _Traits::assign(__position, __n, __c);
      }
      else {
        uninitialized_fill_n(this->_M_finish + 1, __n - __elems_after - 1, __c);
        this->_M_finish += __n - __elems_after;
        {
          uninitialized_copy(__position, __old_finish + 1, this->_M_finish);
          this->_M_finish += __elems_after;
        }
        ;

        _Traits::assign(__position, __elems_after + 1, __c);
      }
    }
    else {
      const size_type __old_size = size();
      const size_type __len = __old_size + (max)(__old_size, __n) + 1;
      pointer __new_start = this->_M_end_of_storage.allocate(__len);
      pointer __new_finish = __new_start;
      {
        __new_finish = uninitialized_copy(this->_M_start, __position, __new_start);
        __new_finish = uninitialized_fill_n(__new_finish, __n, __c);
        __new_finish = uninitialized_copy(__position, this->_M_finish,
                                          __new_finish);
        _M_construct_null(__new_finish);
      }
      ;

      _STL::_Destroy(this->_M_start, this->_M_finish + 1);
      this->_M_deallocate_block();
      this->_M_start = __new_start;
      this->_M_finish = __new_finish;
      this->_M_end_of_storage._M_data = __new_start + __len;
    }
  }
}
# 303 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c"
template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT,_Traits,_Alloc>& basic_string<_CharT,_Traits,_Alloc> ::replace(iterator __first, iterator __last, size_type __n, _CharT __c)
{
  size_type __len = (size_type)(__last - __first);

  if (__len >= __n) {
    _Traits::assign(__first, __n, __c);
    erase(__first + __n, __last);
  }
  else {
    _Traits::assign(__first, __len, __c);
    insert(__last, __n - __len, __c);
  }
  return *this;
}
# 340 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c"
template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find(const _CharT* __s, size_type __pos, size_type __n) const
{
  if (__pos + __n > size())
    return npos;
  else {
    const const_pointer __result =
      _STL::search((const _CharT*)this->_M_start + __pos, (const _CharT*)this->_M_finish,
   __s, __s + __n, _Eq_traits<_Traits>());
    return __result != this->_M_finish ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find(_CharT __c, size_type __pos) const
{
  if (__pos >= size())
    return npos;
  else {
    const const_pointer __result =
      _STL::find_if((const _CharT*)this->_M_start + __pos, (const _CharT*)this->_M_finish,
    _Eq_char_bound<_Traits>(__c));
    return __result != this->_M_finish ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::rfind(const _CharT* __s, size_type __pos, size_type __n) const
{
  const size_t __len = size();

  if (__n > __len)
    return npos;
  else if (__n == 0)
    return (min) (__len, __pos);
  else {
    const_pointer __last = this->_M_start + (min) (__len - __n, __pos) + __n;
    const_pointer __result = _STL::find_end((const_pointer)this->_M_start, __last,
       __s, __s + __n,
       _Eq_traits<_Traits>());
    return __result != __last ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::rfind(_CharT __c, size_type __pos) const
{
  const size_type __len = size();

  if (__len < 1)
    return npos;
  else {
    const const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
    const_reverse_iterator __rresult =
      _STL::find_if(const_reverse_iterator(__last), rend(),
              _Eq_char_bound<_Traits>(__c));
    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  if (__pos >= size())
    return npos;
  else {
    const_iterator __result = __find_first_of(begin() + __pos, end(),
                                              __s, __s + __n,
                                              _Eq_traits<_Traits>());
    return __result != end() ? __result - begin() : npos;
  }
}


template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  const size_type __len = size();

  if (__len < 1)
    return npos;
  else {
    const const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
    const const_reverse_iterator __rresult =
      __find_first_of(const_reverse_iterator(__last), rend(),
                      __s, __s + __n,
                      _Eq_traits<_Traits>());
    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
  }
}


template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  typedef typename _Traits::char_type _CharType;
  if (__pos > size())
    return npos;
  else {
    const_pointer __result = _STL::find_if((const _CharT*)this->_M_start + __pos,
          (const _CharT*)this->_M_finish,
                                _Not_within_traits<_Traits>((const _CharType*)__s,
           (const _CharType*)__s + __n));
    return __result != this->_M_finish ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_not_of(_CharT __c, size_type __pos) const
{
  if (__pos > size())
    return npos;
  else {
    const_pointer __result = _STL::find_if((const _CharT*)this->_M_start + __pos, (const _CharT*)this->_M_finish,
      _Neq_char_bound<_Traits>(__c));
    return __result != this->_M_finish ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  typedef typename _Traits::char_type _CharType;
  const size_type __len = size();

  if (__len < 1)
    return npos;
  else {
    const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
    const_reverse_iterator __rlast = const_reverse_iterator(__last);
    const_reverse_iterator __rresult =
      _STL::find_if(__rlast, rend(),
    _Not_within_traits<_Traits>((const _CharType*)__s,
           (const _CharType*)__s + __n));
    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc> ::find_last_not_of(_CharT __c, size_type __pos) const
{
  const size_type __len = size();

  if (__len < 1)
    return npos;
  else {
    const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
    const_reverse_iterator __rlast = const_reverse_iterator(__last);
    const_reverse_iterator __rresult =
      _STL::find_if(__rlast, rend(),
    _Neq_char_bound<_Traits>(__c));
    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> void _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,
                    _CharT* __buf,
                    size_t __n)
{
  if (__n > 0) {
    __n = (min) (__n - 1, __s.size());
    _STL::copy(__s.begin(), __s.begin() + __n, __buf);
    __buf[__n] = _CharT();
  }
}
}





# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_fwd.c" 1
# 512 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c" 2






# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_range_errors.h" 1
# 36 "c:/marmalade/6.2/s3e/h/std/c++/stl/_range_errors.h"
namespace _STL {
void __stl_throw_range_error(const char* __msg);
void __stl_throw_out_of_range(const char* __msg);
void __stl_throw_length_error(const char* __msg);
void __stl_throw_invalid_argument(const char* __msg);
void __stl_throw_overflow_error(const char* __msg);
}
# 519 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c" 2
namespace _STL {


template <class _Tp, class _Alloc> void _String_base<_Tp,_Alloc>::_M_throw_length_error() const {
    __stl_throw_length_error("basic_string");
}

template <class _Tp, class _Alloc> void _String_base<_Tp, _Alloc>::_M_throw_out_of_range() const {
    __stl_throw_out_of_range("basic_string");
}

template <class _Tp, class _Alloc> void _String_base<_Tp, _Alloc>::_M_allocate_block(size_t __n) {
  if ((__n <= (max_size()+1)) && (__n>0)){
    _M_start = _M_end_of_storage.allocate(__n);
    _M_finish = _M_start;
    _M_end_of_storage._M_data = _M_start + __n;
  }
    else
      _M_throw_length_error();
}

template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT, _Traits, _Alloc>::basic_string()
  : _String_base<_CharT,_Alloc>(allocator_type()) {
  this->_M_start = this->_M_end_of_storage.allocate(8);
  this->_M_finish = this->_M_start;
  this->_M_end_of_storage._M_data = this->_M_start + 8;
  _M_terminate_string();
}


template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT* __s,
          const allocator_type& __a)
  : _String_base<_CharT,_Alloc>(__a)
{
 
    _M_range_initialize(__s, __s + traits_type::length(__s));
}


template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT, _Traits, _Alloc>::basic_string(const basic_string<_CharT, _Traits, _Alloc> & __s)
  : _String_base<_CharT,_Alloc>(__s.get_allocator())
{
  _M_range_initialize(__s._M_start, __s._M_finish);
}





}
# 1491 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.h" 1
# 36 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.h"
namespace _STL {



template <class _CharT, class _Traits, class _Alloc>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT,_Traits,_Alloc>& __s);

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT,_Traits,_Alloc>& __s);

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s,
        _CharT __delim);



template <class _CharT, class _Traits, class _Alloc>
inline basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s)
{
  return getline(__is, __s, __is.widen('\n'));
}


template <class _CharT, class _Traits>
bool
__stlp_string_fill(basic_ostream<_CharT, _Traits>& __os,
                  basic_streambuf<_CharT, _Traits>* __buf,
                  size_t __n);
# 114 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.h"
}




# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.c" 1
# 9 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.c"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctype.h" 1
# 26 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctype.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/c_locale.h" 1
# 109 "c:/marmalade/6.2/s3e/h/std/c++/stl/c_locale.h"
struct _Locale_ctype;
struct _Locale_numeric;
struct _Locale_time;
struct _Locale_collate;
struct _Locale_monetary;
struct _Locale_messages;
# 27 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctype.h" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_locale.h" 1
# 46 "c:/marmalade/6.2/s3e/h/std/c++/stl/_locale.h"
namespace _STL {

class _Locale_impl;
class _Locale;
class locale;
class ios_base;


template <class _CharT>
bool
__locale_do_operator_call (const locale* __that,
                           const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >& __x,
                           const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >& __y);



class locale {
public:


  class facet : private _Refcount_Base {
  protected:
    explicit facet(size_t __no_del = 0) : _Refcount_Base(1), _M_delete(__no_del == 0) {}
    virtual ~facet();
    friend class locale;
    friend class _Locale_impl;
    friend class _Locale;

  private:
    facet(const facet& __f) : _Refcount_Base(1), _M_delete(__f._M_delete == 0) {};
    void operator=(const facet&);

  private:
    const bool _M_delete;
  };




  class

  id {
    friend class locale;
    friend class _Locale_impl;
  public:
    size_t _M_index;
    static size_t _S_max;
  };

  typedef int category;



  static const category

    none = 0x000,
    collate = 0x010,
    ctype = 0x020,
    monetary = 0x040,
    numeric = 0x100,
    time = 0x200,
    messages = 0x400,
    all = collate | ctype | monetary | numeric | time | messages



  ;


  locale();
  locale(const locale&) ;
  explicit locale(const char *);
  locale(const locale&, const char*, category);


  locale(_Locale_impl*);
  locale(_Locale_impl*, bool);

public:


  template <class _Facet>
  locale(const locale& __loc, _Facet* __f) : _M_impl(0)
    {

      new(this) locale(__loc._M_impl, __f != 0);
      if (__f != 0)
        this->_M_insert(__f, _Facet::id);
    }


  locale(const locale&, const locale&, category);
  ~locale() ;
  const locale& operator=(const locale&) ;


  template <class _Facet> locale combine(const locale& __loc) {
    locale __result(__loc._M_impl, true);
    if (facet* __f = __loc._M_get_facet(_Facet::id)) {
      __result._M_insert(__f, _Facet::id);
      __f->_M_incr();
    }
    else
      _M_throw_runtime_error();
    return __result;
  }


  string name() const;

  bool operator==(const locale&) const;
  bool operator!=(const locale&) const;







  template <class _CharT, class _Traits, class _Alloc>
  bool operator()(const basic_string<_CharT, _Traits, _Alloc>& __x,
                  const basic_string<_CharT, _Traits, _Alloc>& __y) const {
    return __locale_do_operator_call(this, __x, __y);
  }



  static locale global(const locale&);
  static const locale& classic();

public:
  facet* _M_get_facet(const id&) const;

  facet* _M_use_facet(const id&) const;
  static void _M_throw_runtime_error(const char* = 0);
  static void _S_initialize();
  static void _S_uninitialize();

private:

  void _M_insert(facet* __f, id& __id);


  friend class _Locale_impl;
  friend class _Locale;
  friend class ios_base;

private:
  _Locale_impl* _M_impl;
};
# 205 "c:/marmalade/6.2/s3e/h/std/c++/stl/_locale.h"
template <class _Facet> inline const _Facet& use_facet(const locale& __loc)

{
  return *static_cast<const _Facet*>(__loc._M_use_facet(_Facet::id));
}
# 219 "c:/marmalade/6.2/s3e/h/std/c++/stl/_locale.h"
template <class _Facet> inline bool has_facet(const locale& __loc)

{
  return (__loc._M_get_facet(_Facet::id) != 0);
}






}
# 30 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctype.h" 2





namespace _STL {

class ctype_base {
public:
  enum mask {
    space = 0x8,
    print = ((0x0100|0x1|0x2) | 0x4 | 0x40 | 0x10),
    cntrl = 0x20,
    upper = 0x1,
    lower = 0x2,
    alpha = ( (0x0100|0x1|0x2) & ~ (0x1 | 0x2 )),
    digit = 0x4,
    punct = 0x10,
    xdigit = 0x80,
    alnum = alpha | digit,
    graph = alnum | punct
  };
};



template <class charT> class ctype {};
template <class charT> class ctype_byname {};



template<>
class ctype<char> : public locale::facet, public ctype_base
{






    friend class ctype<wchar_t>;


  friend class _Locale;
public:

  typedef char char_type;

  explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);
  bool is(mask __m, char __c) const
    { return ((*(_M_ctype_table+(unsigned char)__c)) & __m) != 0; }

  const char* is(const char* __low, const char* __high, mask* __vec) const {
    for (const char* __p = __low;__p != __high; ++__p, ++__vec) {
      *__vec = _M_ctype_table[(unsigned char)*__p];
    }
    return __high;
  }

  const char* scan_is(mask __m, const char* __low, const char* __high) const;
  const char* scan_not(mask __m, const char* __low, const char* __high) const;

  char (toupper)(char __c) const { return do_toupper(__c); }
  const char* (toupper)(char* __low, const char* __high) const {
    return do_toupper(__low, __high);
  }

  char (tolower)(char __c) const { return do_tolower(__c); }
  const char* (tolower)(char* __low, const char* __high) const {
    return do_tolower(__low, __high);
  }

  char widen(char __c) const { return do_widen(__c); }
  const char* widen(const char* __low, const char* __high, char* __to) const {
    return do_widen(__low, __high, __to);
  }

  char narrow(char __c, char __dfault) const {
    return do_narrow(__c, __dfault);
  }
  const char* narrow(const char* __low, const char* __high,
                     char __dfault, char* __to) const {
    return do_narrow(__low, __high, __dfault, __to);
  }

  static locale::id id;



  static const size_t table_size = 256;


protected:
  const mask* table() const {return _M_ctype_table;}
  static const mask* classic_table() { return & _S_classic_table [1]; }

  ~ctype();

  virtual char do_toupper(char __c) const;
  virtual char do_tolower(char __c) const;
  virtual const char* do_toupper(char* __low, const char* __high) const;
  virtual const char* do_tolower(char* __low, const char* __high) const;
  virtual char do_widen(char __c) const;
  virtual const char* do_widen(const char* __low, const char* __high,
                               char* __to) const;
  virtual char do_narrow(char __c, char ) const;
  virtual const char* do_narrow(const char* __low, const char* __high,
                                char , char* __to) const;
private:
  struct _Is_mask {
    mask __m;
    _Is_mask(mask __x): __m(__x) {}
   bool operator()(char __c) {return (__m & (unsigned char) __c) != 0;}
  };

  static const mask _S_classic_table[257 ];
  const mask* _M_ctype_table;
  bool _M_delete;

  static const unsigned char _S_upper[256 ];
  static const unsigned char _S_lower[256 ];
};

template<>
class ctype_byname<char>: public ctype<char> {
public:
  explicit ctype_byname(const char*, size_t = 0);
  ~ctype_byname();

  virtual char do_toupper(char __c) const;
  virtual char do_tolower(char __c) const;

  virtual const char* do_toupper(char*, const char*) const;
  virtual const char* do_tolower(char*, const char*) const;

private:
  mask _M_byname_table[table_size + 1];
  _Locale_ctype* _M_ctype;
};



template<>
class ctype<wchar_t> : public locale::facet, public ctype_base
{
  friend class _Locale;
public:
  typedef wchar_t char_type;

  explicit ctype(size_t __refs = 0) : locale::facet(__refs) {}

  bool is(mask __m, wchar_t __c) const
    { return do_is(__m, __c); }

  const wchar_t* is(const wchar_t* __low, const wchar_t* __high,
                    mask* __vec) const
    { return do_is(__low, __high, __vec); }

  const wchar_t* scan_is(mask __m,
                         const wchar_t* __low, const wchar_t* __high) const
    { return do_scan_is(__m, __low, __high); }

  const wchar_t* scan_not (mask __m,
                           const wchar_t* __low, const wchar_t* __high) const
    { return do_scan_not(__m, __low, __high); }

  wchar_t (toupper)(wchar_t __c) const { return do_toupper(__c); }
  const wchar_t* (toupper)(wchar_t* __low, const wchar_t* __high) const
    { return do_toupper(__low, __high); }

  wchar_t (tolower)(wchar_t __c) const { return do_tolower(__c); }
  const wchar_t* (tolower)(wchar_t* __low, const wchar_t* __high) const
    { return do_tolower(__low, __high); }

  wchar_t widen(char __c) const { return do_widen(__c); }
  const char* widen(const char* __low, const char* __high,
                    wchar_t* __to) const
    { return do_widen(__low, __high, __to); }

  char narrow(wchar_t __c, char __dfault) const
    { return do_narrow(__c, __dfault); }
  const wchar_t* narrow(const wchar_t* __low, const wchar_t* __high,
                        char __dfault, char* __to) const
    { return do_narrow(__low, __high, __dfault, __to); }

  static locale::id id;

protected:
  ~ctype();

  virtual bool do_is(mask __m, wchar_t __c) const;
  virtual const wchar_t* do_is(const wchar_t*, const wchar_t*, mask*) const;
  virtual const wchar_t* do_scan_is(mask,
                                    const wchar_t*, const wchar_t*) const;
  virtual const wchar_t* do_scan_not(mask,
                                     const wchar_t*, const wchar_t*) const;
  virtual wchar_t do_toupper(wchar_t __c) const;
  virtual const wchar_t* do_toupper(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_tolower(wchar_t c) const;
  virtual const wchar_t* do_tolower(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_widen(char c) const;
  virtual const char* do_widen(const char*, const char*, wchar_t*) const;
  virtual char do_narrow(wchar_t __c, char __dfault) const;
  virtual const wchar_t* do_narrow(const wchar_t*, const wchar_t*,
                                   char, char*) const;
};

template<>
class ctype_byname<wchar_t>: public ctype<wchar_t> {
public:
  explicit ctype_byname(const char* __name, size_t __refs = 0);

protected:
  ~ctype_byname();

  virtual bool do_is(mask __m, wchar_t __c) const;
  virtual const wchar_t* do_is(const wchar_t*, const wchar_t*, mask*) const;
  virtual const wchar_t* do_scan_is(mask,
                                    const wchar_t*, const wchar_t*) const;
  virtual const wchar_t* do_scan_not(mask,
                                     const wchar_t*, const wchar_t*) const;
  virtual wchar_t do_toupper(wchar_t __c) const;
  virtual const wchar_t* do_toupper(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_tolower(wchar_t c) const;
  virtual const wchar_t* do_tolower(wchar_t*, const wchar_t*) const;

private:
  _Locale_ctype* _M_ctype;
};



}
# 10 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.c" 2






namespace _STL {
# 26 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.c"
template <class _CharT, class _Traits>
bool
__stlp_string_fill(basic_ostream<_CharT, _Traits>& __os,
                  basic_streambuf<_CharT, _Traits>* __buf,
                  size_t __n)
{
  _CharT __f = __os.fill();
  size_t __i;
  bool __ok = true;

  for (__i = 0; __i < __n; ++__i)
    __ok = __ok && !_Traits::eq_int_type(__buf->sputc(__f), _Traits::eof());
  return __ok;
}

template <class _CharT, class _Traits, class _Alloc>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT,_Traits,_Alloc>& __s)
{

 
  typedef basic_ostream<_CharT, _Traits> __ostream;
  typename __ostream::sentry __sentry(__os);
  bool __ok = false;

  if (__sentry) {
    __ok = true;
    size_t __n = __s.size();
    size_t __pad_len = 0;
    const bool __left = (__os.flags() & __ostream::left) != 0;
    const size_t __w = __os.width(0);
    basic_streambuf<_CharT, _Traits>* __buf = __os.rdbuf();

    if (__n < __w) {
      __pad_len = __w - __n;
    }

    if (!__left)
      __ok = __stlp_string_fill(__os, __buf, __pad_len);

    __ok = __ok && (__buf->sputn(__s.data(), streamsize(__n)) == streamsize(__n));

    if (__left)
      __ok = __ok && __stlp_string_fill(__os, __buf, __pad_len);
  }

  if (!__ok)
    __os.setstate(__ostream::failbit);

  return __os;
}

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT,_Traits, _Alloc>& __s)
{
 
  typedef basic_istream<_CharT, _Traits> __istream;
  typename __istream::sentry __sentry(__is);

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
    typedef ctype<_CharT> _C_type;



    const _C_type& _Ctype = *(const _C_type*)__is._M_ctype_facet();
# 107 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.c"
    __s.clear();
    size_t __n = __is.width(0);
    if (__n == 0)
      __n = static_cast<size_t>(-1);
    else
      __s.reserve(__n);


    while (__n-- > 0) {
      typename _Traits::int_type __c1 = __buf->sbumpc();
      if (_Traits::eq_int_type(__c1, _Traits::eof())) {
        __is.setstate(__istream::eofbit);
        break;
      }
      else {
        _CharT __c = _Traits::to_char_type(__c1);

        if (_Ctype.is(_C_type::space, __c)) {
          if (_Traits::eq_int_type(__buf->sputbackc(__c), _Traits::eof()))
            __is.setstate(__istream::failbit);
          break;
        }
        else
          __s.push_back(__c);
      }
    }


    if (__s.size() == 0)
      __is.setstate(__istream::failbit);
  }
  else
    __is.setstate(__istream::failbit);

  return __is;
}

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s,
        _CharT __delim)
{
 
  typedef basic_istream<_CharT, _Traits> __istream;
  size_t __nread = 0;
  typename basic_istream<_CharT, _Traits>::sentry __sentry(__is, true);
  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
    __s.clear();

    while (__nread < __s.max_size()) {
      int __c1 = __buf->sbumpc();
      if (_Traits::eq_int_type(__c1, _Traits::eof())) {
        __is.setstate(__istream::eofbit);
        break;
      }
      else {
        ++__nread;
        _CharT __c = _Traits::to_char_type(__c1);
        if (!_Traits::eq(__c, __delim))
          __s.push_back(__c);
        else
          break;
      }
    }
  }
  if (__nread == 0 || __nread >= __s.max_size())
    __is.setstate(__istream::failbit);

  return __is;
}
# 329 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.c"
}
# 120 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.h" 2
# 1494 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_hash.h" 1
# 23 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_hash.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_hash_fun.h" 1
# 38 "c:/marmalade/6.2/s3e/h/std/c++/stl/_hash_fun.h"
namespace _STL {

template <class _Key> struct hash { };

inline size_t __stl_hash_string(const char* __s)
{
 
  unsigned long __h = 0;
  for ( ; *__s; ++__s)
    __h = 5*__h + *__s;

  return size_t(__h);
}

template<> struct hash<char*>
{
  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
};

template<> struct hash<const char*>
{
  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
};

template<> struct hash<char> {
  size_t operator()(char __x) const { return __x; }
};
template<> struct hash<unsigned char> {
  size_t operator()(unsigned char __x) const { return __x; }
};

template<> struct hash<signed char> {
  size_t operator()(unsigned char __x) const { return __x; }
};

template<> struct hash<short> {
  size_t operator()(short __x) const { return __x; }
};
template<> struct hash<unsigned short> {
  size_t operator()(unsigned short __x) const { return __x; }
};
template<> struct hash<int> {
  size_t operator()(int __x) const { return __x; }
};
template<> struct hash<unsigned int> {
  size_t operator()(unsigned int __x) const { return __x; }
};
template<> struct hash<long> {
  size_t operator()(long __x) const { return __x; }
};
template<> struct hash<unsigned long> {
  size_t operator()(unsigned long __x) const { return __x; }
};


template<> struct hash<long long> {
  size_t operator()(long x) const { return x; }
};
template<> struct hash<unsigned long long> {
  size_t operator()(unsigned long x) const { return x; }
};


}
# 24 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_hash.h" 2






namespace _STL {

template <class _CharT, class _Traits, class _Alloc>
inline size_t
__stl_string_hash(const basic_string<_CharT,_Traits,_Alloc>& __s) {
  unsigned long __h = 0;
  typedef typename basic_string<_CharT,_Traits,_Alloc>::const_pointer const_ptr;
  size_t __len = __s.size();
  const _CharT* __data = __s.data();
  for ( size_t __i = 0; __i < __len; ++__i)
    __h = 5*__h + __data[__i];
  return size_t(__h);
}



template <class _CharT, class _Traits, class _Alloc>
struct hash<basic_string<_CharT,_Traits,_Alloc> > {
  size_t operator()(const basic_string<_CharT,_Traits,_Alloc>& __s) const
    { return __stl_string_hash(__s); }
};
# 68 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_hash.h"
}
# 1495 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2
# 46 "c:/marmalade/6.2/s3e/h/std/c++/string" 2







# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 2
# 54 "c:/marmalade/6.2/s3e/h/std/c++/string" 2
# 22 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/game.cpp" 2

# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/xmlloader.h" 1



# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h" 1
# 38 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
# 1 "c:/marmalade/6.2/s3e/h/std/assert.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/assert.h"
extern "C" {
# 43 "c:/marmalade/6.2/s3e/h/std/assert.h"
}
# 39 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h" 2
# 52 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinystr.h" 1
# 56 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinystr.h"
class TiXmlString
{
  public :

   typedef size_t size_type;


 static const size_type npos;



 TiXmlString () : rep_(&nullrep_)
 {
 }


 TiXmlString ( const TiXmlString & copy) : rep_(0)
 {
  init(copy.length());
  memcpy(start(), copy.data(), length());
 }


 explicit TiXmlString ( const char * copy) : rep_(0)
 {
  init( static_cast<size_type>( strlen(copy) ));
  memcpy(start(), copy, length());
 }


 explicit TiXmlString ( const char * str, size_type len) : rep_(0)
 {
  init(len);
  memcpy(start(), str, len);
 }


 ~TiXmlString ()
 {
  quit();
 }

 TiXmlString& operator = (const char * copy)
 {
  return assign( copy, (size_type)strlen(copy));
 }

 TiXmlString& operator = (const TiXmlString & copy)
 {
  return assign(copy.start(), copy.length());
 }



 TiXmlString& operator += (const char * suffix)
 {
  return append(suffix, static_cast<size_type>( strlen(suffix) ));
 }


 TiXmlString& operator += (char single)
 {
  return append(&single, 1);
 }


 TiXmlString& operator += (const TiXmlString & suffix)
 {
  return append(suffix.data(), suffix.length());
 }



 const char * c_str () const { return rep_->str; }


 const char * data () const { return rep_->str; }


 size_type length () const { return rep_->size; }


 size_type size () const { return rep_->size; }


 bool empty () const { return rep_->size == 0; }


 size_type capacity () const { return rep_->capacity; }



 const char& at (size_type index) const
 {
  ((void)0);
  return rep_->str[ index ];
 }


 char& operator [] (size_type index) const
 {
  ((void)0);
  return rep_->str[ index ];
 }


 size_type find (char lookup) const
 {
  return find(lookup, 0);
 }


 size_type find (char tofind, size_type offset) const
 {
  if (offset >= length()) return npos;

  for (const char* p = c_str() + offset; *p != '\0'; ++p)
  {
     if (*p == tofind) return static_cast< size_type >( p - c_str() );
  }
  return npos;
 }

 void clear ()
 {




  quit();
  init(0,0);
 }




 void reserve (size_type cap);

 TiXmlString& assign (const char* str, size_type len);

 TiXmlString& append (const char* str, size_type len);

 void swap (TiXmlString& other)
 {
  Rep* r = rep_;
  rep_ = other.rep_;
  other.rep_ = r;
 }

  private:

 void init(size_type sz) { init(sz, sz); }
 void set_size(size_type sz) { rep_->str[ rep_->size = sz ] = '\0'; }
 char* start() const { return rep_->str; }
 char* finish() const { return rep_->str + rep_->size; }

 struct Rep
 {
  size_type size, capacity;
  char str[1];
 };

 void init(size_type sz, size_type cap)
 {
  if (cap)
  {





   const size_type bytesNeeded = sizeof(Rep) + cap;
   const size_type intsNeeded = ( bytesNeeded + sizeof(int) - 1 ) / sizeof( int );
   rep_ = reinterpret_cast<Rep*>( new int[ intsNeeded ] );

   rep_->str[ rep_->size = sz ] = '\0';
   rep_->capacity = cap;
  }
  else
  {
   rep_ = &nullrep_;
  }
 }

 void quit()
 {
  if (rep_ != &nullrep_)
  {


   delete [] ( reinterpret_cast<int*>( rep_ ) );
  }
 }

 Rep * rep_;
 static Rep nullrep_;

} ;


inline bool operator == (const TiXmlString & a, const TiXmlString & b)
{
 return ( a.length() == b.length() )
        && ( strcmp(a.c_str(), b.c_str()) == 0 );
}
inline bool operator < (const TiXmlString & a, const TiXmlString & b)
{
 return strcmp(a.c_str(), b.c_str()) < 0;
}

inline bool operator != (const TiXmlString & a, const TiXmlString & b) { return !(a == b); }
inline bool operator > (const TiXmlString & a, const TiXmlString & b) { return b < a; }
inline bool operator <= (const TiXmlString & a, const TiXmlString & b) { return !(b < a); }
inline bool operator >= (const TiXmlString & a, const TiXmlString & b) { return !(a < b); }

inline bool operator == (const TiXmlString & a, const char* b) { return strcmp(a.c_str(), b) == 0; }
inline bool operator == (const char* a, const TiXmlString & b) { return b == a; }
inline bool operator != (const TiXmlString & a, const char* b) { return !(a == b); }
inline bool operator != (const char* a, const TiXmlString & b) { return !(b == a); }

TiXmlString operator + (const TiXmlString & a, const TiXmlString & b);
TiXmlString operator + (const TiXmlString & a, const char* b);
TiXmlString operator + (const char* a, const TiXmlString & b);






class TiXmlOutStream : public TiXmlString
{
public :


 TiXmlOutStream & operator << (const TiXmlString & in)
 {
  *this += in;
  return *this;
 }


 TiXmlOutStream & operator << (const char * in)
 {
  *this += in;
  return *this;
 }

} ;
# 53 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h" 2
# 83 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlDocument;
class TiXmlElement;
class TiXmlComment;
class TiXmlUnknown;
class TiXmlAttribute;
class TiXmlText;
class TiXmlDeclaration;
class TiXmlParsingData;

const int TIXML_MAJOR_VERSION = 2;
const int TIXML_MINOR_VERSION = 6;
const int TIXML_PATCH_VERSION = 2;




struct TiXmlCursor
{
 TiXmlCursor() { Clear(); }
 void Clear() { row = col = -1; }

 int row;
 int col;
};
# 128 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlVisitor
{
public:
 virtual ~TiXmlVisitor() {}


 virtual bool VisitEnter( const TiXmlDocument& ) { return true; }

 virtual bool VisitExit( const TiXmlDocument& ) { return true; }


 virtual bool VisitEnter( const TiXmlElement& , const TiXmlAttribute* ) { return true; }

 virtual bool VisitExit( const TiXmlElement& ) { return true; }


 virtual bool Visit( const TiXmlDeclaration& ) { return true; }

 virtual bool Visit( const TiXmlText& ) { return true; }

 virtual bool Visit( const TiXmlComment& ) { return true; }

 virtual bool Visit( const TiXmlUnknown& ) { return true; }
};


enum
{
 TIXML_SUCCESS,
 TIXML_NO_ATTRIBUTE,
 TIXML_WRONG_TYPE
};



enum TiXmlEncoding
{
 TIXML_ENCODING_UNKNOWN,
 TIXML_ENCODING_UTF8,
 TIXML_ENCODING_LEGACY
};

const TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;
# 194 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlBase
{
 friend class TiXmlNode;
 friend class TiXmlElement;
 friend class TiXmlDocument;

public:
 TiXmlBase() : userData(0) {}
 virtual ~TiXmlBase() {}
# 213 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 virtual void Print( FILE* cfile, int depth ) const = 0;







 static void SetCondenseWhiteSpace( bool condense ) { condenseWhiteSpace = condense; }


 static bool IsWhiteSpaceCondensed() { return condenseWhiteSpace; }
# 244 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 int Row() const { return location.row + 1; }
 int Column() const { return location.col + 1; }

 void SetUserData( void* user ) { userData = user; }
 void* GetUserData() { return userData; }
 const void* GetUserData() const { return userData; }



 static const int utf8ByteTable[256];

 virtual const char* Parse( const char* p,
        TiXmlParsingData* data,
        TiXmlEncoding encoding ) = 0;




 static void EncodeString( const TiXmlString& str, TiXmlString* out );

 enum
 {
  TIXML_NO_ERROR = 0,
  TIXML_ERROR,
  TIXML_ERROR_OPENING_FILE,
  TIXML_ERROR_PARSING_ELEMENT,
  TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
  TIXML_ERROR_READING_ELEMENT_VALUE,
  TIXML_ERROR_READING_ATTRIBUTES,
  TIXML_ERROR_PARSING_EMPTY,
  TIXML_ERROR_READING_END_TAG,
  TIXML_ERROR_PARSING_UNKNOWN,
  TIXML_ERROR_PARSING_COMMENT,
  TIXML_ERROR_PARSING_DECLARATION,
  TIXML_ERROR_DOCUMENT_EMPTY,
  TIXML_ERROR_EMBEDDED_NULL,
  TIXML_ERROR_PARSING_CDATA,
  TIXML_ERROR_DOCUMENT_TOP_ONLY,

  TIXML_ERROR_STRING_COUNT
 };

protected:

 static const char* SkipWhiteSpace( const char*, TiXmlEncoding encoding );

 inline static bool IsWhiteSpace( char c )
 {
  return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' );
 }
 inline static bool IsWhiteSpace( int c )
 {
  if ( c < 256 )
   return IsWhiteSpace( (char) c );
  return false;
 }
# 310 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 static const char* ReadName( const char* p, TiXmlString* name, TiXmlEncoding encoding );




 static const char* ReadText( const char* in,
         TiXmlString* text,
         bool ignoreWhiteSpace,
         const char* endTag,
         bool ignoreCase,
         TiXmlEncoding encoding );


 static const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );



 inline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )
 {
  ((void)0);
  if ( encoding == TIXML_ENCODING_UTF8 )
  {
   *length = utf8ByteTable[ *((const unsigned char*)p) ];
   ((void)0);
  }
  else
  {
   *length = 1;
  }

  if ( *length == 1 )
  {
   if ( *p == '&' )
    return GetEntity( p, _value, length, encoding );
   *_value = *p;
   return p+1;
  }
  else if ( *length )
  {


   for( int i=0; p[i] && i<*length; ++i ) {
    _value[i] = p[i];
   }
   return p + (*length);
  }
  else
  {

   return 0;
  }
 }




 static bool StringEqual( const char* p,
        const char* endTag,
        bool ignoreCase,
        TiXmlEncoding encoding );

 static const char* errorString[ TIXML_ERROR_STRING_COUNT ];

 TiXmlCursor location;


 void* userData;



 static int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );
 static int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );
 inline static int ToLower( int v, TiXmlEncoding encoding )
 {
  if ( encoding == TIXML_ENCODING_UTF8 )
  {
   if ( v < 128 ) return tolower( v );
   return v;
  }
  else
  {
   return tolower( v );
  }
 }
 static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );

private:
 TiXmlBase( const TiXmlBase& );
 void operator=( const TiXmlBase& base );

 struct Entity
 {
  const char* str;
  unsigned int strLength;
  char chr;
 };
 enum
 {
  NUM_ENTITY = 5,
  MAX_ENTITY_LENGTH = 6

 };
 static Entity entity[ NUM_ENTITY ];
 static bool condenseWhiteSpace;
};
# 423 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlNode : public TiXmlBase
{
 friend class TiXmlDocument;
 friend class TiXmlElement;

public:
# 462 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 enum NodeType
 {
  TINYXML_DOCUMENT,
  TINYXML_ELEMENT,
  TINYXML_COMMENT,
  TINYXML_UNKNOWN,
  TINYXML_TEXT,
  TINYXML_DECLARATION,
  TINYXML_TYPECOUNT
 };

 virtual ~TiXmlNode();
# 487 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const char *Value() const { return value.c_str (); }
# 497 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const TiXmlString& ValueTStr() const { return value; }
# 508 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 void SetValue(const char * _value) { value = _value;}







 void Clear();


 TiXmlNode* Parent() { return parent; }
 const TiXmlNode* Parent() const { return parent; }

 const TiXmlNode* FirstChild() const { return firstChild; }
 TiXmlNode* FirstChild() { return firstChild; }
 const TiXmlNode* FirstChild( const char * value ) const;

 TiXmlNode* FirstChild( const char * _value ) {


  return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->FirstChild( _value ));
 }
 const TiXmlNode* LastChild() const { return lastChild; }
 TiXmlNode* LastChild() { return lastChild; }

 const TiXmlNode* LastChild( const char * value ) const;
 TiXmlNode* LastChild( const char * _value ) {
  return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->LastChild( _value ));
 }
# 562 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const TiXmlNode* IterateChildren( const TiXmlNode* previous ) const;
 TiXmlNode* IterateChildren( const TiXmlNode* previous ) {
  return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( previous ) );
 }


 const TiXmlNode* IterateChildren( const char * value, const TiXmlNode* previous ) const;
 TiXmlNode* IterateChildren( const char * _value, const TiXmlNode* previous ) {
  return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( _value, previous ) );
 }
# 581 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 TiXmlNode* InsertEndChild( const TiXmlNode& addThis );
# 593 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 TiXmlNode* LinkEndChild( TiXmlNode* addThis );




 TiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );




 TiXmlNode* InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis );




 TiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );


 bool RemoveChild( TiXmlNode* removeThis );


 const TiXmlNode* PreviousSibling() const { return prev; }
 TiXmlNode* PreviousSibling() { return prev; }


 const TiXmlNode* PreviousSibling( const char * ) const;
 TiXmlNode* PreviousSibling( const char *_prev ) {
  return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->PreviousSibling( _prev ) );
 }
# 631 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const TiXmlNode* NextSibling() const { return next; }
 TiXmlNode* NextSibling() { return next; }


 const TiXmlNode* NextSibling( const char * ) const;
 TiXmlNode* NextSibling( const char* _next ) {
  return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->NextSibling( _next ) );
 }





 const TiXmlElement* NextSiblingElement() const;
 TiXmlElement* NextSiblingElement() {
  return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement() );
 }





 const TiXmlElement* NextSiblingElement( const char * ) const;
 TiXmlElement* NextSiblingElement( const char *_next ) {
  return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement( _next ) );
 }







 const TiXmlElement* FirstChildElement() const;
 TiXmlElement* FirstChildElement() {
  return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement() );
 }


 const TiXmlElement* FirstChildElement( const char * _value ) const;
 TiXmlElement* FirstChildElement( const char * _value ) {
  return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement( _value ) );
 }
# 684 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 int Type() const { return type; }




 const TiXmlDocument* GetDocument() const;
 TiXmlDocument* GetDocument() {
  return const_cast< TiXmlDocument* >( (const_cast< const TiXmlNode* >(this))->GetDocument() );
 }


 bool NoChildren() const { return !firstChild; }

 virtual const TiXmlDocument* ToDocument() const { return 0; }
 virtual const TiXmlElement* ToElement() const { return 0; }
 virtual const TiXmlComment* ToComment() const { return 0; }
 virtual const TiXmlUnknown* ToUnknown() const { return 0; }
 virtual const TiXmlText* ToText() const { return 0; }
 virtual const TiXmlDeclaration* ToDeclaration() const { return 0; }

 virtual TiXmlDocument* ToDocument() { return 0; }
 virtual TiXmlElement* ToElement() { return 0; }
 virtual TiXmlComment* ToComment() { return 0; }
 virtual TiXmlUnknown* ToUnknown() { return 0; }
 virtual TiXmlText* ToText() { return 0; }
 virtual TiXmlDeclaration* ToDeclaration() { return 0; }




 virtual TiXmlNode* Clone() const = 0;
# 738 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 virtual bool Accept( TiXmlVisitor* visitor ) const = 0;

protected:
 TiXmlNode( NodeType _type );



 void CopyTo( TiXmlNode* target ) const;







 TiXmlNode* Identify( const char* start, TiXmlEncoding encoding );

 TiXmlNode* parent;
 NodeType type;

 TiXmlNode* firstChild;
 TiXmlNode* lastChild;

 TiXmlString value;

 TiXmlNode* prev;
 TiXmlNode* next;

private:
 TiXmlNode( const TiXmlNode& );
 void operator=( const TiXmlNode& base );
};
# 779 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlAttribute : public TiXmlBase
{
 friend class TiXmlAttributeSet;

public:

 TiXmlAttribute() : TiXmlBase()
 {
  document = 0;
  prev = next = 0;
 }
# 803 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 TiXmlAttribute( const char * _name, const char * _value )
 {
  name = _name;
  value = _value;
  document = 0;
  prev = next = 0;
 }

 const char* Name() const { return name.c_str(); }
 const char* Value() const { return value.c_str(); }



 int IntValue() const;
 double DoubleValue() const;


 const TiXmlString& NameTStr() const { return name; }
# 831 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 int QueryIntValue( int* _value ) const;

 int QueryDoubleValue( double* _value ) const;

 void SetName( const char* _name ) { name = _name; }
 void SetValue( const char* _value ) { value = _value; }

 void SetIntValue( int _value );
 void SetDoubleValue( double _value );
# 849 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const TiXmlAttribute* Next() const;
 TiXmlAttribute* Next() {
  return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Next() );
 }


 const TiXmlAttribute* Previous() const;
 TiXmlAttribute* Previous() {
  return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Previous() );
 }

 bool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }
 bool operator<( const TiXmlAttribute& rhs ) const { return name < rhs.name; }
 bool operator>( const TiXmlAttribute& rhs ) const { return name > rhs.name; }




 virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );


 virtual void Print( FILE* cfile, int depth ) const {
  Print( cfile, depth, 0 );
 }
 void Print( FILE* cfile, int depth, TiXmlString* str ) const;



 void SetDocument( TiXmlDocument* doc ) { document = doc; }

private:
 TiXmlAttribute( const TiXmlAttribute& );
 void operator=( const TiXmlAttribute& base );

 TiXmlDocument* document;
 TiXmlString name;
 TiXmlString value;
 TiXmlAttribute* prev;
 TiXmlAttribute* next;
};
# 903 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlAttributeSet
{
public:
 TiXmlAttributeSet();
 ~TiXmlAttributeSet();

 void Add( TiXmlAttribute* attribute );
 void Remove( TiXmlAttribute* attribute );

 const TiXmlAttribute* First() const { return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
 TiXmlAttribute* First() { return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
 const TiXmlAttribute* Last() const { return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
 TiXmlAttribute* Last() { return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }

 TiXmlAttribute* Find( const char* _name ) const;
 TiXmlAttribute* FindOrCreate( const char* _name );







private:


 TiXmlAttributeSet( const TiXmlAttributeSet& );
 void operator=( const TiXmlAttributeSet& );

 TiXmlAttribute sentinel;
};






class TiXmlElement : public TiXmlNode
{
public:

 TiXmlElement (const char * in_value);






 TiXmlElement( const TiXmlElement& );

 TiXmlElement& operator=( const TiXmlElement& base );

 virtual ~TiXmlElement();




 const char* Attribute( const char* name ) const;







 const char* Attribute( const char* name, int* i ) const;







 const char* Attribute( const char* name, double* d ) const;
# 985 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 int QueryIntAttribute( const char* name, int* _value ) const;

 int QueryUnsignedAttribute( const char* name, unsigned* _value ) const;




 int QueryBoolAttribute( const char* name, bool* _value ) const;

 int QueryDoubleAttribute( const char* name, double* _value ) const;

 int QueryFloatAttribute( const char* name, float* _value ) const {
  double d;
  int result = QueryDoubleAttribute( name, &d );
  if ( result == TIXML_SUCCESS ) {
   *_value = (float)d;
  }
  return result;
 }
# 1050 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 void SetAttribute( const char* name, const char * _value );
# 1070 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 void SetAttribute( const char * name, int value );




 void SetDoubleAttribute( const char * name, double value );



 void RemoveAttribute( const char * name );




 const TiXmlAttribute* FirstAttribute() const { return attributeSet.First(); }
 TiXmlAttribute* FirstAttribute() { return attributeSet.First(); }
 const TiXmlAttribute* LastAttribute() const { return attributeSet.Last(); }
 TiXmlAttribute* LastAttribute() { return attributeSet.Last(); }
# 1121 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const char* GetText() const;


 virtual TiXmlNode* Clone() const;

 virtual void Print( FILE* cfile, int depth ) const;




 virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

 virtual const TiXmlElement* ToElement() const { return this; }
 virtual TiXmlElement* ToElement() { return this; }



 virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:

 void CopyTo( TiXmlElement* target ) const;
 void ClearThis();
# 1153 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );

private:
 TiXmlAttributeSet attributeSet;
};




class TiXmlComment : public TiXmlNode
{
public:

 TiXmlComment() : TiXmlNode( TiXmlNode::TINYXML_COMMENT ) {}

 TiXmlComment( const char* _value ) : TiXmlNode( TiXmlNode::TINYXML_COMMENT ) {
  SetValue( _value );
 }
 TiXmlComment( const TiXmlComment& );
 TiXmlComment& operator=( const TiXmlComment& base );

 virtual ~TiXmlComment() {}


 virtual TiXmlNode* Clone() const;

 virtual void Print( FILE* cfile, int depth ) const;




 virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

 virtual const TiXmlComment* ToComment() const { return this; }
 virtual TiXmlComment* ToComment() { return this; }



 virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:
 void CopyTo( TiXmlComment* target ) const;







private:

};







class TiXmlText : public TiXmlNode
{
 friend class TiXmlElement;
public:




 TiXmlText (const char * initValue ) : TiXmlNode (TiXmlNode::TINYXML_TEXT)
 {
  SetValue( initValue );
  cdata = false;
 }
 virtual ~TiXmlText() {}
# 1236 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 TiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TINYXML_TEXT ) { copy.CopyTo( this ); }
 TiXmlText& operator=( const TiXmlText& base ) { base.CopyTo( this ); return *this; }


 virtual void Print( FILE* cfile, int depth ) const;


 bool CDATA() const { return cdata; }

 void SetCDATA( bool _cdata ) { cdata = _cdata; }

 virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

 virtual const TiXmlText* ToText() const { return this; }
 virtual TiXmlText* ToText() { return this; }



 virtual bool Accept( TiXmlVisitor* content ) const;

protected :

 virtual TiXmlNode* Clone() const;
 void CopyTo( TiXmlText* target ) const;

 bool Blank() const;





private:
 bool cdata;
};
# 1285 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlDeclaration : public TiXmlNode
{
public:

 TiXmlDeclaration() : TiXmlNode( TiXmlNode::TINYXML_DECLARATION ) {}
# 1299 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 TiXmlDeclaration( const char* _version,
      const char* _encoding,
      const char* _standalone );

 TiXmlDeclaration( const TiXmlDeclaration& copy );
 TiXmlDeclaration& operator=( const TiXmlDeclaration& copy );

 virtual ~TiXmlDeclaration() {}


 const char *Version() const { return version.c_str (); }

 const char *Encoding() const { return encoding.c_str (); }

 const char *Standalone() const { return standalone.c_str (); }


 virtual TiXmlNode* Clone() const;

 virtual void Print( FILE* cfile, int depth, TiXmlString* str ) const;
 virtual void Print( FILE* cfile, int depth ) const {
  Print( cfile, depth, 0 );
 }

 virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

 virtual const TiXmlDeclaration* ToDeclaration() const { return this; }
 virtual TiXmlDeclaration* ToDeclaration() { return this; }



 virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:
 void CopyTo( TiXmlDeclaration* target ) const;





private:

 TiXmlString version;
 TiXmlString encoding;
 TiXmlString standalone;
};
# 1354 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlUnknown : public TiXmlNode
{
public:
 TiXmlUnknown() : TiXmlNode( TiXmlNode::TINYXML_UNKNOWN ) {}
 virtual ~TiXmlUnknown() {}

 TiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::TINYXML_UNKNOWN ) { copy.CopyTo( this ); }
 TiXmlUnknown& operator=( const TiXmlUnknown& copy ) { copy.CopyTo( this ); return *this; }


 virtual TiXmlNode* Clone() const;

 virtual void Print( FILE* cfile, int depth ) const;

 virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

 virtual const TiXmlUnknown* ToUnknown() const { return this; }
 virtual TiXmlUnknown* ToUnknown() { return this; }



 virtual bool Accept( TiXmlVisitor* content ) const;

protected:
 void CopyTo( TiXmlUnknown* target ) const;





private:

};






class TiXmlDocument : public TiXmlNode
{
public:

 TiXmlDocument();

 TiXmlDocument( const char * documentName );






 TiXmlDocument( const TiXmlDocument& copy );
 TiXmlDocument& operator=( const TiXmlDocument& copy );

 virtual ~TiXmlDocument() {}





 bool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );

 bool SaveFile() const;

 bool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );

 bool SaveFile( const char * filename ) const;





 bool LoadFile( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );

 bool SaveFile( FILE* ) const;
# 1446 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 virtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );





 const TiXmlElement* RootElement() const { return FirstChildElement(); }
 TiXmlElement* RootElement() { return FirstChildElement(); }






 bool Error() const { return error; }


 const char * ErrorDesc() const { return errorDesc.c_str (); }




 int ErrorId() const { return errorId; }
# 1477 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 int ErrorRow() const { return errorLocation.row+1; }
 int ErrorCol() const { return errorLocation.col+1; }
# 1504 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 void SetTabSize( int _tabsize ) { tabsize = _tabsize; }

 int TabSize() const { return tabsize; }




 void ClearError() { error = false;
            errorId = 0;
            errorDesc = "";
            errorLocation.row = errorLocation.col = 0;

           }


 void Print() const { Print( (__aeabi_stdout), 0 ); }
# 1528 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 virtual void Print( FILE* cfile, int depth = 0 ) const;

 void SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );

 virtual const TiXmlDocument* ToDocument() const { return this; }
 virtual TiXmlDocument* ToDocument() { return this; }



 virtual bool Accept( TiXmlVisitor* content ) const;

protected :

 virtual TiXmlNode* Clone() const;




private:
 void CopyTo( TiXmlDocument* target ) const;

 bool error;
 int errorId;
 TiXmlString errorDesc;
 int tabsize;
 TiXmlCursor errorLocation;
 bool useMicrosoftBOM;
};
# 1638 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlHandle
{
public:

 TiXmlHandle( TiXmlNode* _node ) { this->node = _node; }

 TiXmlHandle( const TiXmlHandle& ref ) { this->node = ref.node; }
 TiXmlHandle operator=( const TiXmlHandle& ref ) { if ( &ref != this ) this->node = ref.node; return *this; }


 TiXmlHandle FirstChild() const;

 TiXmlHandle FirstChild( const char * value ) const;

 TiXmlHandle FirstChildElement() const;

 TiXmlHandle FirstChildElement( const char * value ) const;




 TiXmlHandle Child( const char* value, int index ) const;



 TiXmlHandle Child( int index ) const;




 TiXmlHandle ChildElement( const char* value, int index ) const;




 TiXmlHandle ChildElement( int index ) const;
# 1685 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 TiXmlNode* ToNode() const { return node; }


 TiXmlElement* ToElement() const { return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }


 TiXmlText* ToText() const { return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }


 TiXmlUnknown* ToUnknown() const { return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }




 TiXmlNode* Node() const { return ToNode(); }



 TiXmlElement* Element() const { return ToElement(); }



 TiXmlText* Text() const { return ToText(); }



 TiXmlUnknown* Unknown() const { return ToUnknown(); }

private:
 TiXmlNode* node;
};
# 1737 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlPrinter : public TiXmlVisitor
{
public:
 TiXmlPrinter() : depth( 0 ), simpleTextPrint( false ),
      buffer(), indent( "    " ), lineBreak( "\n" ) {}

 virtual bool VisitEnter( const TiXmlDocument& doc );
 virtual bool VisitExit( const TiXmlDocument& doc );

 virtual bool VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute );
 virtual bool VisitExit( const TiXmlElement& element );

 virtual bool Visit( const TiXmlDeclaration& declaration );
 virtual bool Visit( const TiXmlText& text );
 virtual bool Visit( const TiXmlComment& comment );
 virtual bool Visit( const TiXmlUnknown& unknown );




 void SetIndent( const char* _indent ) { indent = _indent ? _indent : "" ; }

 const char* Indent() { return indent.c_str(); }




 void SetLineBreak( const char* _lineBreak ) { lineBreak = _lineBreak ? _lineBreak : ""; }

 const char* LineBreak() { return lineBreak.c_str(); }




 void SetStreamPrinting() { indent = "";
               lineBreak = "";
             }

 const char* CStr() { return buffer.c_str(); }

 size_t Size() { return buffer.size(); }






private:
 void DoIndent() {
  for( int i=0; i<depth; ++i )
   buffer += indent;
 }
 void DoLineBreak() {
  buffer += lineBreak;
 }

 int depth;
 bool simpleTextPrint;
 TiXmlString buffer;
 TiXmlString indent;
 TiXmlString lineBreak;
};
# 5 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/xmlloader.h" 2

class CXmlLoader
{
public:

 CXmlLoader(const char* filename);

    ~CXmlLoader();

 char** getNextRowArray();

 TiXmlElement* elem;
 char** rowCurr;

};
# 24 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/game.cpp" 2
# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/npc.h" 1



# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/dialogueManager.h" 1


# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/dialogueRow.h" 1




class CDialogueRow
{
public:

 CDialogueRow();

    ~CDialogueRow();

 void assignValues(char nt[250], char oA, char oB, char oC, char oD,
 char rA[250], char rB[250], char rC[250], char rD[250], int pA, int pB, int pC, int pD);

 char* npcText;
 char replyOptionA;
 char replyOptionB;
 char replyOptionC;
 char replyOptionD;
 char* playerReplyA;
 char* playerReplyB;
 char* playerReplyC;
 char* playerReplyD;
 int pointerA;
 int pointerB;
 int pointerC;
 int pointerD;

};
# 4 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/dialogueManager.h" 2

class CDialogueManager
{
public:

 CDialogueManager(const char* filename);

    ~CDialogueManager();

 CDialogueRow* dialogueArray;

};
# 5 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/npc.h" 2
# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/ReplyArray.h" 1





class CReplyArray
{
public:

 static TiXmlDocument replyDoc;
 static TiXmlElement* elem1;
 static char** replies;
 static bool loaded;

 static void initReplies();
 static void clearReplies();

 static char* getReplyByChar(char val);
};
# 6 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/npc.h" 2
# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/history.h" 1





class CHistory
{
public:
 CHistory(char* filename);

 ~CHistory();

 char** histArray;
 int size;
 int location;
 TiXmlDocument histDoc;
 TiXmlElement* histElem;
 bool playerTurn;
 char* histFilename;

 bool addNpcTextToHist(int id, char text[250]);
 bool addPlayerTextToHist(int id, char text[250]);
 void clearAndCreateHist();
};
# 7 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/npc.h" 2

class CNpc
{
public:

 CNpc(char* npcName);

    ~CNpc();

 CDialogueManager* dialMan;
 CReplyArray* replyArray;
 int index;
 bool pTurn;

 CHistory* hist;

 void printArray();

 char* getText();
 char* getReplyA();
 char* getReplyB();
 char* getReplyC();
 char* getReplyD();
 bool chooseReply(int option);
 char* sendText();

 char* getHist(int id);
 int getHistSize();

 static int activeNpcs;

 bool getPlayerTurn();
};
# 25 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/game.cpp" 2
using _STL::string;

int checkBox = 0;
bool flag = true;
bool flag2 = true;
CIwGxFont* Font;
CIw2DImage* txtButt;
CXmlLoader* g_cXml;
int whereAt;
int txtState;
int textsPrinted;
int scaleFactor;
int selectionMade;
int timeStart;
int timeMS;
bool timeFlag;
bool reply;
bool playerTop;
 char tempP[250];
 char tempR[250];
 char tempR2[250];
 char tempOp1[50];
 char tempOp2[50];
 char tempOp3[50];
 char tempOp4[50];
CNpc* rick;
CGame::CGame()
{
 rick= new CNpc("rick");
 scaleFactor=1;
 whereAt=0;
 txtState=0;
 textsPrinted=0;
 selectionMade=4;
 reply=false;
 timeStart = 0;
 timeFlag = false;
 timeMS = 0;
 playerTop=false;

 IwGxInit();
 Iw2DInit();
    IwGetResManager()->LoadGroup("IwUIBasicLabelCode.group");


    CIwGxFont* pFont = (CIwGxFont*)IwGetResManager()->GetResNamed("times", "CIwGxFont");


    IwGxSetColClear(0x55, 0x55, 0xff, 0xff);
    IwResManagerInit();
 IwGxFontInit();




    IwGetResManager()->LoadGroup("fonts.group");
 txtButt=Iw2DCreateImage("txtButton_small.png");

    Font = (CIwGxFont*)IwGetResManager()->GetResNamed("font","CIwGxFont");
    IwGxSetColClear(0x55, 0x55, 0xff, 0xff);



}


CGame::~CGame()
{
 delete txtButt;
 delete Font;
 IwResManagerTerminate();
 IwGxFontTerminate();
 Iw2DTerminate();
 IwGxTerminate();

 delete rick;
}


void CGame::Update()
{
 if(s3ePointerGetState(S3E_POINTER_BUTTON_SELECT)&&whereAt==0)
 { if(s3ePointerGetX()>(IwGxGetScreenWidth()/6)&&s3ePointerGetX()<((IwGxGetScreenWidth()/6)+txtButt->GetWidth())&&s3ePointerGetY()>(IwGxGetScreenHeight()/2)&&s3ePointerGetY()<((IwGxGetScreenHeight()/2)+txtButt->GetHeight()))
   whereAt=1;
 }
 else if(s3ePointerGetState(S3E_POINTER_BUTTON_SELECT)==S3E_POINTER_STATE_DOWN&&whereAt==1)
 {
  if(s3ePointerGetX()>(IwGxGetScreenWidth()*0.0f)&&s3ePointerGetX()<(IwGxGetScreenWidth()*1.0f)&&s3ePointerGetY()>(IwGxGetScreenHeight()*0.0f)&&s3ePointerGetY()<(IwGxGetScreenHeight()*0.075f))
   whereAt=0;
  else if(s3ePointerGetX()>(IwGxGetScreenWidth()*0.0f)&&s3ePointerGetX()<(IwGxGetScreenWidth()*1.0f)&&s3ePointerGetY()>(IwGxGetScreenHeight()*0.125f)&&s3ePointerGetY()<(IwGxGetScreenHeight()*0.2f))
   whereAt=2;
 }
 else if(s3ePointerGetState(S3E_POINTER_BUTTON_SELECT)==S3E_POINTER_STATE_DOWN&&whereAt==2)
 {
  if(s3ePointerGetX()>(IwGxGetScreenWidth()*0.0f)&&s3ePointerGetX()<(IwGxGetScreenWidth()*1.0f)&&s3ePointerGetY()>(IwGxGetScreenHeight()*0.0f)&&s3ePointerGetY()<(IwGxGetScreenHeight()*0.075f))
  {
   whereAt=1;
   txtState=0;
   selectionMade=0;
   reply=false;
   timeStart = 0;
   timeFlag = false;
   timeMS = 0;
  }

 }
  else if(txtState==0&&selectionMade==4&&s3ePointerGetState(S3E_POINTER_BUTTON_SELECT)==S3E_POINTER_STATE_RELEASED&&whereAt==2){
   if(s3ePointerGetX()>(IwGxGetScreenWidth()*0.0f)&&s3ePointerGetX()<(IwGxGetScreenWidth()*0.5f)&&s3ePointerGetY()>(IwGxGetScreenHeight()*0.85f)&&s3ePointerGetY()<(IwGxGetScreenHeight()*0.925f))
    selectionMade = 0;
   else if(s3ePointerGetX()>(IwGxGetScreenWidth()*0.5f)&&s3ePointerGetX()<(IwGxGetScreenWidth()*1.0f)&&s3ePointerGetY()>(IwGxGetScreenHeight()*0.85f)&&s3ePointerGetY()<(IwGxGetScreenHeight()*0.925f))
    selectionMade = 1;
   else if(s3ePointerGetX()>(IwGxGetScreenWidth()*0.0f)&&s3ePointerGetX()<(IwGxGetScreenWidth()*0.5f)&&s3ePointerGetY()>(IwGxGetScreenHeight()*0.925f)&&s3ePointerGetY()<(IwGxGetScreenHeight()*1.0f))
    selectionMade = 2;
   else if(s3ePointerGetX()>(IwGxGetScreenWidth()*0.5f)&&s3ePointerGetX()<(IwGxGetScreenWidth()*1.0f)&&s3ePointerGetY()>(IwGxGetScreenHeight()*0.925f)&&s3ePointerGetY()<(IwGxGetScreenHeight()*1.0f))
    selectionMade = 3;
   if(selectionMade!=4)
   {

   }
 }
}


void CGame::Render()
{


    IwGxClear();

 IwGxFontSetScale(((iwfixed)((0.6f) * (1 << 12))));

 if(timeFlag==true)
 {
  if((selectionMade>0&&selectionMade<5))
  {
   if(s3eTimerGetMs()>timeStart+timeMS)
   {
    txtState=selectionMade;
    selectionMade=5;
    timeStart=0;
    timeMS=0;
    timeFlag=false;
    waitTime(4000);
   }
  }
  else if(selectionMade==5)
  {
   if(s3eTimerGetMs()>timeStart+timeMS)
   {
    reply=true;
    selectionMade=0;
    timeStart=0;
    timeMS=0;
    timeFlag=false;
   }
  }
 }

 switch(whereAt){


 case 0:
  {
     Iw2DSurfaceClear(0xff000000);
  IwGxSetColClear(0,0,0,0);
  time_t now = time(__null);
  struct tm* local_tm = localtime(&now);
  char time[100];
  strftime (time, 100, "%I:%M%p",local_tm );
  IwGxFontSetFont(Font);
  IwGxLightingOn();
  IwGxLightingEmissive(true);
  IwGxFontSetRect(CIwRect(IwGxGetScreenWidth()/7.5,IwGxGetScreenHeight()/5,(int16)IwGxGetScreenWidth()-10,(int16)IwGxGetScreenHeight()-50));
  scaleFactor=(IwGxGetScreenHeight()*5)+(IwGxGetScreenWidth()*5);
  IwGxFontSetScale(scaleFactor);
  IwGxFontDrawText(time);
  Iw2DDrawImage(txtButt, CIwSVec2(IwGxGetScreenWidth()/6,IwGxGetScreenHeight()/2));
  IwGxFlush();Iw2DSurfaceShow();
  IwGxSwapBuffers();
  s3eDeviceYield(0);
  break;}
 case 1:
  {IwGxSetColClear(20,20,20,0);

  IwGxFontSetFont(Font);
  IwGxLightingOn();
  IwGxLightingEmissive(true);

  CIwRect rectA = CIwRect(IwGxGetScreenWidth()*0.0f,IwGxGetScreenHeight()*0.0f,IwGxGetScreenWidth()*1.0f,IwGxGetScreenHeight()*0.075f);

  Iw2DSetColour(0xff222222);
  Iw2DFillRect(CIwSVec2(rectA.x,rectA.y),CIwSVec2(rectA.w,rectA.h));
  IwGxFlush();
  Iw2DSetColour(0xff444444);
  Iw2DDrawRect(CIwSVec2(rectA.x,rectA.y),CIwSVec2(rectA.w,rectA.h));
  IwGxFlush();
  Iw2DSetColour(0xffffffff);

  rectA.x += IwGxGetScreenWidth()*0.3f;

  IwGxFontSetRect(rectA);
  IwGxFontDrawText("GO BACK");
  IwGxFlush();

  CIwRect rectB = CIwRect(IwGxGetScreenWidth()*0.0f,IwGxGetScreenHeight()*0.125f,IwGxGetScreenWidth()*1.0f,IwGxGetScreenHeight()*0.075f);

  Iw2DSetColour(0xff332222);
  Iw2DFillRect(CIwSVec2(rectB.x,rectB.y),CIwSVec2(rectB.w,rectB.h));
  IwGxFlush();
  Iw2DSetColour(0xff444444);
  Iw2DDrawRect(CIwSVec2(rectB.x,rectB.y),CIwSVec2(rectB.w,rectB.h));
  IwGxFlush();
  Iw2DSetColour(0xffffffff);

  rectB.x += IwGxGetScreenWidth()*0.1f;

  IwGxFontSetRect(rectB);

  IwGxFontDrawText("NEW TEXT - RYAN");
  IwGxFlush();

  IwGxSwapBuffers();
  s3eDeviceYield(0);
  break;}
 case 2:
  {
   if(rick->getPlayerTurn())
   {
    if(selectionMade<4)
    {
     rick->chooseReply(selectionMade);
     strcpy(tempP,rick->sendText());
     textsPrinted++;
     selectionMade=4;
    }

    strcpy(tempOp1,rick->getReplyA());
    strcpy(tempOp2,rick->getReplyB());
    strcpy(tempOp3,rick->getReplyC());
    strcpy(tempOp4,rick->getReplyD());

   }
   if(!rick->getPlayerTurn())
   {
    textsPrinted++;

    if(textsPrinted>=2)
    {

    strcpy(tempR2,rick->getText());
    if(textsPrinted>3&&selectionMade!=4)
     textsPrinted=1;
    }
    else
     strcpy(tempR,rick->getText());
   }

   selectionMade=4;
   if(textsPrinted<2)
   strcpy(tempR,rick->getHist(rick->getHistSize()-1));
   if(textsPrinted<2)
   CIwRect rectTest = createRect(tempR,true, IwGxGetScreenHeight()*0.01f);
   if(textsPrinted>1)
   {
   CIwRect rectTest2 = createRect(tempP,false, IwGxGetScreenHeight()*0.01f);
    if(textsPrinted>=2)
    {
    CIwRect rectTest3 = createRect(tempR2,true, rectTest2);
    }

   }

     CIwRect rectD = CIwRect(IwGxGetScreenWidth()*0.0f,IwGxGetScreenHeight()*0.85f,IwGxGetScreenWidth()*0.495f,IwGxGetScreenHeight()*0.075f);

   Iw2DSetColour(0xff222222);
   Iw2DFillRect(CIwSVec2(rectD.x,rectD.y),CIwSVec2(rectD.w,rectD.h));
   IwGxFlush();
   Iw2DSetColour(0xff444444);
   Iw2DDrawRect(CIwSVec2(rectD.x,rectD.y),CIwSVec2(rectD.w,rectD.h));
   IwGxFlush();
   Iw2DSetColour(0xffffffff);

   rectD.x += IwGxGetScreenWidth()*0.025f;
   rectD.w -= IwGxGetScreenWidth()*0.025f;


   IwGxFontSetRect(rectD);
   IwGxFontDrawText(tempOp1);
   IwGxFlush();


   rectD.x -= IwGxGetScreenWidth()*0.025f;
   rectD.w += IwGxGetScreenWidth()*0.025f;

   rectD.x += IwGxGetScreenWidth()*0.5f;

   Iw2DSetColour(0xff222222);
   Iw2DFillRect(CIwSVec2(rectD.x,rectD.y),CIwSVec2(rectD.w,rectD.h));
   IwGxFlush();
   Iw2DSetColour(0xff444444);
   Iw2DDrawRect(CIwSVec2(rectD.x,rectD.y),CIwSVec2(rectD.w,rectD.h));
   IwGxFlush();
   Iw2DSetColour(0xffffffff);

   rectD.x += IwGxGetScreenWidth()*0.025f;
   rectD.w -= IwGxGetScreenWidth()*0.025f;


   IwGxFontSetRect(rectD);
   IwGxFontDrawText(tempOp2);
   IwGxFlush();


   rectD.x -= IwGxGetScreenWidth()*0.025f;
   rectD.w += IwGxGetScreenWidth()*0.035f;

   rectD.x -= IwGxGetScreenWidth()*0.5f;
   rectD.y += IwGxGetScreenHeight()*0.075f;

   Iw2DSetColour(0xff222222);
   Iw2DFillRect(CIwSVec2(rectD.x,rectD.y),CIwSVec2(rectD.w,rectD.h));
   IwGxFlush();
   Iw2DSetColour(0xff444444);
   Iw2DDrawRect(CIwSVec2(rectD.x,rectD.y),CIwSVec2(rectD.w,rectD.h));
   IwGxFlush();
   Iw2DSetColour(0xffffffff);

   rectD.x += IwGxGetScreenWidth()*0.025f;
   rectD.w -= IwGxGetScreenWidth()*0.025f;


   IwGxFontSetRect(rectD);
   IwGxFontDrawText(tempOp3);
   IwGxFlush();


   rectD.x -= IwGxGetScreenWidth()*0.025f;
   rectD.w += IwGxGetScreenWidth()*0.0225f;

   rectD.x += IwGxGetScreenWidth()*0.505f;

   Iw2DSetColour(0xff222222);
   Iw2DFillRect(CIwSVec2(rectD.x,rectD.y),CIwSVec2(rectD.w,rectD.h));
   IwGxFlush();
   Iw2DSetColour(0xff444444);
   Iw2DDrawRect(CIwSVec2(rectD.x,rectD.y),CIwSVec2(rectD.w,rectD.h));
   IwGxFlush();
   Iw2DSetColour(0xffffffff);

   rectD.x += IwGxGetScreenWidth()*0.025f;
   rectD.w -= IwGxGetScreenWidth()*0.025f;


   IwGxFontSetRect(rectD);
   IwGxFontDrawText(tempOp4);
   IwGxFlush();

  IwGxFlush();Iw2DSurfaceShow();
  IwGxSwapBuffers();
  s3eDeviceYield(0);
  break;
  }
 default:
   break;
 }

}

void CGame::waitTime(int ms){
 timeStart = s3eTimerGetMs();
 timeFlag = true;
 timeMS = ms;
}
CIwRect createRect(char* stringToSize, bool LeftJustified, CIwRect pastRect)
{
 CIwRect tempRec;
 if(LeftJustified){
  tempRec=CIwRect(IwGxGetScreenWidth()*0.0f,((pastRect.h + pastRect.y) + IwGxGetScreenHeight()*0.05f),IwGxGetScreenWidth()*.45,((strlen(stringToSize)+(Font->GetHeight()/2.1))/(Font->GetHeight()/2.1))*IwGxGetScreenHeight()*0.084f);

  Iw2DSetColour(0xff006633);
  Iw2DFillRect(CIwSVec2(tempRec.x,tempRec.y),CIwSVec2(tempRec.w,tempRec.h));
  IwGxFlush();
  Iw2DSetColour(0xff444444);
  Iw2DDrawRect(CIwSVec2(tempRec.x,tempRec.y),CIwSVec2(tempRec.w,tempRec.h));
  IwGxFlush();
  Iw2DSetColour(0xffffffff);
  IwGxFontSetFont(Font);
  IwGxLightingOn();
  IwGxLightingEmissive(true);
  IwGxFontSetRect(tempRec);
  IwGxFontSetScale(.375*scaleFactor);
  IwGxFontDrawText((IwChar*)stringToSize);
  IwGxFlush();

 }
 else
 {
  tempRec=CIwRect((IwGxGetScreenWidth()*.55f),((pastRect.h + pastRect.y) + IwGxGetScreenHeight()*0.05f),IwGxGetScreenWidth()*.45,((strlen(stringToSize)+(Font->GetHeight()/2.1))/(Font->GetHeight()/2.1))*IwGxGetScreenHeight()*0.084f);

  Iw2DSetColour(0xff332222);
  Iw2DFillRect(CIwSVec2(tempRec.x,tempRec.y),CIwSVec2(tempRec.w,tempRec.h));
  IwGxFlush();
  Iw2DSetColour(0xff444444);
  Iw2DDrawRect(CIwSVec2(tempRec.x,tempRec.y),CIwSVec2(tempRec.w,tempRec.h));
  IwGxFlush();
  Iw2DSetColour(0xffffffff);
  IwGxFontSetFont(Font);
  IwGxLightingOn();
  IwGxLightingEmissive(true);
  IwGxFontSetRect(tempRec);
  IwGxFontSetScale(.375*scaleFactor);
  IwGxFontDrawText((IwChar*)stringToSize);
  IwGxFlush();

 }
 return tempRec;
}


CIwRect createRect(char* stringToSize, bool LeftJustified, int y)
{
 CIwRect tempRec;
 if(LeftJustified){
  tempRec=CIwRect(IwGxGetScreenWidth()*0.0f,y,IwGxGetScreenWidth()*.45,((strlen(stringToSize)+(Font->GetHeight()/2.1))/(Font->GetHeight()/2.1))*IwGxGetScreenHeight()*0.084f);

  Iw2DSetColour(0xff006633);
  Iw2DFillRect(CIwSVec2(tempRec.x,tempRec.y),CIwSVec2(tempRec.w,tempRec.h));
  IwGxFlush();
  Iw2DSetColour(0xff444444);
  Iw2DDrawRect(CIwSVec2(tempRec.x,tempRec.y),CIwSVec2(tempRec.w,tempRec.h));
  IwGxFlush();
  Iw2DSetColour(0xffffffff);
  IwGxFontSetFont(Font);
  IwGxLightingOn();
  IwGxLightingEmissive(true);
  IwGxFontSetRect(tempRec);
  IwGxFontSetScale(.375*scaleFactor);
  IwGxFontDrawText((IwChar*)stringToSize);
  IwGxFlush();

 }
 else
 {
  tempRec=CIwRect((IwGxGetScreenWidth()*.55f),y,IwGxGetScreenWidth()*.45,((strlen(stringToSize)+(Font->GetHeight()/2.1))/(Font->GetHeight()/2.1))*IwGxGetScreenHeight()*0.084f);

  Iw2DSetColour(0xff332222);
  Iw2DFillRect(CIwSVec2(tempRec.x,tempRec.y),CIwSVec2(tempRec.w,tempRec.h));
  IwGxFlush();
  Iw2DSetColour(0xff444444);
  Iw2DDrawRect(CIwSVec2(tempRec.x,tempRec.y),CIwSVec2(tempRec.w,tempRec.h));
  IwGxFlush();
  Iw2DSetColour(0xffffffff);
  IwGxFontSetFont(Font);
  IwGxLightingOn();
  IwGxLightingEmissive(true);
  IwGxFontSetRect(tempRec);
  IwGxFontSetScale(.375*scaleFactor);
  IwGxFontDrawText((IwChar*)stringToSize);
  IwGxFlush();

 }
 return tempRec;
}
