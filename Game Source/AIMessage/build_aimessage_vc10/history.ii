# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/history.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/build_aimessage_vc10/temp_defines_release.h" 1
# 1 "<command-line>" 2
# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/history.cpp"
# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/history.h" 1


# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h" 1
# 35 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
# 1 "c:/marmalade/6.2/s3e/h/std/ctype.h" 1
# 15 "c:/marmalade/6.2/s3e/h/std/ctype.h"
# 1 "c:/marmalade/6.2/s3e/h/std/sys/types.h" 1
# 15 "c:/marmalade/6.2/s3e/h/std/sys/types.h"
# 1 "c:/marmalade/6.2/s3e/h/s3eTypes.h" 1
# 35 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
typedef unsigned char s3e_uint8_t;
typedef signed char s3e_int8_t;
typedef unsigned short int s3e_uint16_t;
typedef signed short int s3e_int16_t;
typedef unsigned int s3e_uint32_t;
typedef signed int s3e_int32_t;
# 49 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
  typedef signed long long s3e_int64_t;
  typedef unsigned long long s3e_uint64_t;
# 72 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
typedef s3e_uint64_t uint64_t;
typedef s3e_int64_t int64_t;
typedef s3e_uint32_t uint32_t;
typedef s3e_int32_t int32_t;
typedef s3e_uint16_t uint16_t;
typedef s3e_int16_t int16_t;
typedef s3e_uint8_t uint8_t;
typedef s3e_int8_t int8_t;
# 94 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
    typedef int intptr_t;
    typedef unsigned int uintptr_t;
# 106 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
typedef unsigned int uint;
typedef unsigned short int ushort;
typedef unsigned long int ulong;
typedef unsigned char uint8;
typedef signed char int8;







typedef int64_t int64;
typedef uint64_t uint64;





typedef unsigned int uint32;






typedef signed int int32;






typedef uint16_t uint16;




typedef int16_t int16;
# 224 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
typedef enum s3eResult
{
    S3E_RESULT_SUCCESS = 0,
    S3E_RESULT_ERROR = 1
} s3eResult;




typedef uint8 s3eBool;
# 242 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
typedef wchar_t s3eWChar;
# 254 "c:/marmalade/6.2/s3e/h/s3eTypes.h"
typedef int32 (*s3eCallback) (void* systemData, void* userData);
# 16 "c:/marmalade/6.2/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/stddef.h" 1
# 15 "c:/marmalade/6.2/s3e/h/std/stddef.h"
typedef signed int ptrdiff_t;


    typedef unsigned int wint_t;
    typedef unsigned long int wctype_t;







typedef unsigned int size_t;
# 17 "c:/marmalade/6.2/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/stdint.h" 1
# 19 "c:/marmalade/6.2/s3e/h/std/stdint.h"
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef long int_least32_t;
typedef int64_t int_least64_t;

typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned long uint_least32_t;
typedef uint64_t uint_least64_t;

typedef signed char int_fast8_t;
typedef short int_fast16_t;
typedef long int_fast32_t;
typedef int64_t int_fast64_t;

typedef unsigned char uint_fast8_t;
typedef unsigned short uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef uint64_t uint_fast64_t;

typedef int64_t intmax_t;
typedef uint64_t uintmax_t;
# 18 "c:/marmalade/6.2/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/sys/select.h" 1
# 24 "c:/marmalade/6.2/s3e/h/std/sys/select.h"
struct timeval;

typedef struct fd_set
{
    char fds_bits[256/8];
} fd_set;
# 39 "c:/marmalade/6.2/s3e/h/std/sys/select.h"
extern "C" {

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

}
# 19 "c:/marmalade/6.2/s3e/h/std/sys/types.h" 2



typedef long off_t;

typedef int64_t off64_t;


namespace std
{
typedef ::size_t size_t;
}


typedef uint u_int;
typedef uint8_t u_int8_t;
typedef uint16_t u_int16_t;
typedef uint32_t u_int32_t;
typedef uint64_t u_int64_t;

typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;

typedef int ssize_t;
typedef int pid_t;
typedef short uid_t;
typedef short gid_t;
typedef int idtype_t;
typedef int id_t;
typedef uint32 mode_t;
typedef short dev_t;
typedef short ino_t;
typedef int key_t;
typedef void* caddr_t;
# 16 "c:/marmalade/6.2/s3e/h/std/ctype.h" 2

extern "C" {
# 31 "c:/marmalade/6.2/s3e/h/std/ctype.h"
int toupper(int c);
int tolower(int c);
int isalnum(int c);
int isalpha(int c);

int isblank(int c);
int iscntrl(int c);
int isdigit(int c);
int isgraph(int c);
int islower(int c);
int isprint(int c);
int ispunct(int c);
int isspace(int c);
int isupper(int c);
int isxdigit(int c);

}
# 36 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/stdio.h" 1
# 19 "c:/marmalade/6.2/s3e/h/std/stdio.h"
struct __XXFILE;
typedef struct __XXFILE FILE;

typedef uint32 fpos_t;
# 38 "c:/marmalade/6.2/s3e/h/std/stdio.h"
extern "C" {
# 54 "c:/marmalade/6.2/s3e/h/std/stdio.h"
extern FILE *__aeabi_stdin;
extern FILE *__aeabi_stdout;
extern FILE *__aeabi_stderr;
# 66 "c:/marmalade/6.2/s3e/h/std/stdio.h"
FILE *fopen(const char *path, const char *mode);
int fclose(FILE *fp);
int fcloseall();
int fflush(FILE *stream);

FILE *fopen(const char *path, const char *mode);
FILE *fdopen(int fildes, const char *mode);
FILE *freopen(const char *path, const char *mode, FILE *stream);

size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

int fputc(int c, FILE *stream);
int fputs(const char *s, FILE *stream);
int putc(int c, FILE *stream);
int putchar(int c);
int puts(const char *s);

int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
char *gets(char *s);
int ungetc(int c, FILE *stream);

int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, fpos_t *pos);

void flockfile(FILE *filehandle);
int ftrylockfile(FILE *filehandle);
void funlockfile(FILE *filehandle);

int getc_unlocked(FILE *stream);
int getchar_unlocked(void);
int putc_unlocked(int c, FILE *stream);
int putchar_unlocked(int c);

FILE *popen(const char *command, const char *type);
int pclose(FILE *stream);

char *tempnam(const char *dir, const char *pfx);




int printf(const char *format, ...) __attribute__((format(printf, 1, 2)));



int fprintf(FILE *stream, const char* format, ...) __attribute__((format(printf, 2, 3)));



int sprintf(char *str, const char* format, ...) __attribute__((format(printf, 2, 3)));



int snprintf(char *str, size_t size, const char *format, ...) __attribute__((format(printf, 3, 4)));




int scanf(const char *format, ...);



int fscanf(FILE *stream, const char *format, ...);



int sscanf(const char *str, const char *format, ...);

void clearerr(FILE *stream);
int feof(FILE *stream);
int ferror(FILE *stream);
int fileno(FILE *stream);

int remove(const char *pathname);
int rename(const char *oldpath, const char *newpath);

void perror(const char *s);



FILE *tmpfile(void);
char *tmpnam(char *s);

void setbuf(FILE *stream, char *buf);
void setbuffer(FILE *stream, char *buf, size_t size);
void setlinebuf(FILE *stream);
int setvbuf(FILE *stream, char *buf, int mode , size_t size);

# 1 "c:/marmalade/6.2/s3e/h/std/stdarg.h" 1
# 54 "c:/marmalade/6.2/s3e/h/std/stdarg.h"
typedef __builtin_va_list va_list;
# 162 "c:/marmalade/6.2/s3e/h/std/stdio.h" 2

int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);
int vprintf(const char *format, va_list ap);
int asprintf(char **strp, const char *fmt, ...);
int vasprintf(char **strp, const char *fmt, va_list ap);

int vscanf(const char *format, va_list ap);
int vsscanf(const char *str, const char *format, va_list ap);
int vfscanf(FILE *stream, const char *format, va_list ap);

}
# 37 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/string.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/string.h"
extern "C" {

void *memcpy(void *dest, const void *src, size_t n);
void *memset(void *s, int c, size_t n);
int memcmp(const void *s1, const void *s2, size_t n);
void *memmove(void *dest, const void *src, size_t n);
void *memchr(const void *s, int c, size_t n);
void *memrchr(const void *s, int c, size_t n);







int strcmp(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t n);
char *strsep(char **stringp, const char *delim);
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);
char *strchr(const char *s, int c);
char *strstr(const char *haystack, const char *needle);
char *strrchr(const char *s, int c);
char *strdup(const char *s);
char *strtok(char *str, const char *delim);
char *strtok_r(char *str, const char *delim, char **saveptr);
char *strcat(char *dest, const char *src);
char *strncat(char *dest, const char *src, size_t n);
size_t strlen(const char *s);
size_t strnlen(const char *s, size_t n);
int strcasecmp(const char *s1, const char *s2);
int strncasecmp(const char *s1, const char *s2, size_t n);
size_t strspn(const char *s, const char *accept);
size_t strcspn(const char *s, const char *reject);
char *strpbrk(const char *s, const char *accept);
int strcoll(const char *s1, const char *s2);
char *strerror(int errnum);
size_t strxfrm(char *dest, const char *src, size_t n);

int strerror_r(int errnum, char *buf, size_t buflen);





size_t strlcpy(char* dest, const char* src, size_t len);
size_t strlcat(char* dest, const char* src, size_t len);

}
# 38 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/assert.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/assert.h"
extern "C" {
# 43 "c:/marmalade/6.2/s3e/h/std/assert.h"
}
# 39 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/stdlib.h" 1
# 16 "c:/marmalade/6.2/s3e/h/std/stdlib.h"
# 1 "c:/marmalade/6.2/s3e/h/std/malloc.h" 1
# 16 "c:/marmalade/6.2/s3e/h/std/malloc.h"
# 1 "c:/marmalade/6.2/s3e/h/std/alloca.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/alloca.h"
extern "C" {


    extern void *alloca(size_t __size);
# 35 "c:/marmalade/6.2/s3e/h/std/alloca.h"
}
# 17 "c:/marmalade/6.2/s3e/h/std/malloc.h" 2

extern "C" {

void *calloc(size_t nmemb, size_t size);
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);

}
# 17 "c:/marmalade/6.2/s3e/h/std/stdlib.h" 2
# 28 "c:/marmalade/6.2/s3e/h/std/stdlib.h"
extern "C" {

double atof(const char* string);
int atoi(const char *nptr);
long atol(const char *nptr);
int64_t atoll(const char *nptr);
int64_t atoq(const char *nptr);
int abs(int j);
long int labs(long int j);
int64_t llabs(int64_t j);
void qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *));
void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
void abort(void);
int putenv(char *string);
char *getenv(const char *name);
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);
void exit(int status) __attribute__ ((noreturn));
void _exit(int status) __attribute__ ((noreturn));
void _Exit(int status) __attribute__ ((noreturn));
unsigned long int strtoul(const char *nptr, char **endptr, int base);
uint64_t strtoull(const char *nptr, char **endptr, int base);
long int strtol(const char *nptr, char **endptr, int base);
int64_t strtoll(const char *nptr, char **endptr, int base);
double strtod(const char *nptr, char **endptr);
float strtof(const char *nptr, char **endptr);
long double strtold(const char *nptr, char **endptr);
int atexit(void (*function)(void));
int system(const char *command);
int posix_memalign(void **memptr, size_t alignment, size_t size);
char *mktemp(char *templ);
int mkstemp(char *templ);



int rand(void);
void srand(unsigned int seed);

long int random(void);
void srandom(unsigned int seed);

size_t __ctype_get_mb_cur_max();


int mblen(const char *s, size_t n);
int mbtowc(wchar_t *pwc, const char *s, size_t n);
int wctomb(char *s, wchar_t wc);
size_t mbstowcs(wchar_t *dest, const char *src, size_t n);
size_t wcstombs(char *dest, const wchar_t *src, size_t n);

typedef struct
{
    int quot;
    int rem;
} div_t;

typedef struct
{
    int quot;
    int rem;
} ldiv_t;

typedef struct
{
    int64_t quot;
    int64_t rem;
} lldiv_t;

div_t div(int numerator, int denominator);
ldiv_t ldiv(long numerator, long denominator);
lldiv_t lldiv(int64_t numerator, int64_t denominator);
# 112 "c:/marmalade/6.2/s3e/h/std/stdlib.h"
}
# 40 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h" 2
# 52 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinystr.h" 1
# 56 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinystr.h"
class TiXmlString
{
  public :

   typedef size_t size_type;


 static const size_type npos;



 TiXmlString () : rep_(&nullrep_)
 {
 }


 TiXmlString ( const TiXmlString & copy) : rep_(0)
 {
  init(copy.length());
  memcpy(start(), copy.data(), length());
 }


 explicit TiXmlString ( const char * copy) : rep_(0)
 {
  init( static_cast<size_type>( strlen(copy) ));
  memcpy(start(), copy, length());
 }


 explicit TiXmlString ( const char * str, size_type len) : rep_(0)
 {
  init(len);
  memcpy(start(), str, len);
 }


 ~TiXmlString ()
 {
  quit();
 }

 TiXmlString& operator = (const char * copy)
 {
  return assign( copy, (size_type)strlen(copy));
 }

 TiXmlString& operator = (const TiXmlString & copy)
 {
  return assign(copy.start(), copy.length());
 }



 TiXmlString& operator += (const char * suffix)
 {
  return append(suffix, static_cast<size_type>( strlen(suffix) ));
 }


 TiXmlString& operator += (char single)
 {
  return append(&single, 1);
 }


 TiXmlString& operator += (const TiXmlString & suffix)
 {
  return append(suffix.data(), suffix.length());
 }



 const char * c_str () const { return rep_->str; }


 const char * data () const { return rep_->str; }


 size_type length () const { return rep_->size; }


 size_type size () const { return rep_->size; }


 bool empty () const { return rep_->size == 0; }


 size_type capacity () const { return rep_->capacity; }



 const char& at (size_type index) const
 {
  ((void)0);
  return rep_->str[ index ];
 }


 char& operator [] (size_type index) const
 {
  ((void)0);
  return rep_->str[ index ];
 }


 size_type find (char lookup) const
 {
  return find(lookup, 0);
 }


 size_type find (char tofind, size_type offset) const
 {
  if (offset >= length()) return npos;

  for (const char* p = c_str() + offset; *p != '\0'; ++p)
  {
     if (*p == tofind) return static_cast< size_type >( p - c_str() );
  }
  return npos;
 }

 void clear ()
 {




  quit();
  init(0,0);
 }




 void reserve (size_type cap);

 TiXmlString& assign (const char* str, size_type len);

 TiXmlString& append (const char* str, size_type len);

 void swap (TiXmlString& other)
 {
  Rep* r = rep_;
  rep_ = other.rep_;
  other.rep_ = r;
 }

  private:

 void init(size_type sz) { init(sz, sz); }
 void set_size(size_type sz) { rep_->str[ rep_->size = sz ] = '\0'; }
 char* start() const { return rep_->str; }
 char* finish() const { return rep_->str + rep_->size; }

 struct Rep
 {
  size_type size, capacity;
  char str[1];
 };

 void init(size_type sz, size_type cap)
 {
  if (cap)
  {





   const size_type bytesNeeded = sizeof(Rep) + cap;
   const size_type intsNeeded = ( bytesNeeded + sizeof(int) - 1 ) / sizeof( int );
   rep_ = reinterpret_cast<Rep*>( new int[ intsNeeded ] );

   rep_->str[ rep_->size = sz ] = '\0';
   rep_->capacity = cap;
  }
  else
  {
   rep_ = &nullrep_;
  }
 }

 void quit()
 {
  if (rep_ != &nullrep_)
  {


   delete [] ( reinterpret_cast<int*>( rep_ ) );
  }
 }

 Rep * rep_;
 static Rep nullrep_;

} ;


inline bool operator == (const TiXmlString & a, const TiXmlString & b)
{
 return ( a.length() == b.length() )
        && ( strcmp(a.c_str(), b.c_str()) == 0 );
}
inline bool operator < (const TiXmlString & a, const TiXmlString & b)
{
 return strcmp(a.c_str(), b.c_str()) < 0;
}

inline bool operator != (const TiXmlString & a, const TiXmlString & b) { return !(a == b); }
inline bool operator > (const TiXmlString & a, const TiXmlString & b) { return b < a; }
inline bool operator <= (const TiXmlString & a, const TiXmlString & b) { return !(b < a); }
inline bool operator >= (const TiXmlString & a, const TiXmlString & b) { return !(a < b); }

inline bool operator == (const TiXmlString & a, const char* b) { return strcmp(a.c_str(), b) == 0; }
inline bool operator == (const char* a, const TiXmlString & b) { return b == a; }
inline bool operator != (const TiXmlString & a, const char* b) { return !(a == b); }
inline bool operator != (const char* a, const TiXmlString & b) { return !(b == a); }

TiXmlString operator + (const TiXmlString & a, const TiXmlString & b);
TiXmlString operator + (const TiXmlString & a, const char* b);
TiXmlString operator + (const char* a, const TiXmlString & b);






class TiXmlOutStream : public TiXmlString
{
public :


 TiXmlOutStream & operator << (const TiXmlString & in)
 {
  *this += in;
  return *this;
 }


 TiXmlOutStream & operator << (const char * in)
 {
  *this += in;
  return *this;
 }

} ;
# 53 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h" 2
# 83 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlDocument;
class TiXmlElement;
class TiXmlComment;
class TiXmlUnknown;
class TiXmlAttribute;
class TiXmlText;
class TiXmlDeclaration;
class TiXmlParsingData;

const int TIXML_MAJOR_VERSION = 2;
const int TIXML_MINOR_VERSION = 6;
const int TIXML_PATCH_VERSION = 2;




struct TiXmlCursor
{
 TiXmlCursor() { Clear(); }
 void Clear() { row = col = -1; }

 int row;
 int col;
};
# 128 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlVisitor
{
public:
 virtual ~TiXmlVisitor() {}


 virtual bool VisitEnter( const TiXmlDocument& ) { return true; }

 virtual bool VisitExit( const TiXmlDocument& ) { return true; }


 virtual bool VisitEnter( const TiXmlElement& , const TiXmlAttribute* ) { return true; }

 virtual bool VisitExit( const TiXmlElement& ) { return true; }


 virtual bool Visit( const TiXmlDeclaration& ) { return true; }

 virtual bool Visit( const TiXmlText& ) { return true; }

 virtual bool Visit( const TiXmlComment& ) { return true; }

 virtual bool Visit( const TiXmlUnknown& ) { return true; }
};


enum
{
 TIXML_SUCCESS,
 TIXML_NO_ATTRIBUTE,
 TIXML_WRONG_TYPE
};



enum TiXmlEncoding
{
 TIXML_ENCODING_UNKNOWN,
 TIXML_ENCODING_UTF8,
 TIXML_ENCODING_LEGACY
};

const TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;
# 194 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlBase
{
 friend class TiXmlNode;
 friend class TiXmlElement;
 friend class TiXmlDocument;

public:
 TiXmlBase() : userData(0) {}
 virtual ~TiXmlBase() {}
# 213 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 virtual void Print( FILE* cfile, int depth ) const = 0;







 static void SetCondenseWhiteSpace( bool condense ) { condenseWhiteSpace = condense; }


 static bool IsWhiteSpaceCondensed() { return condenseWhiteSpace; }
# 244 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 int Row() const { return location.row + 1; }
 int Column() const { return location.col + 1; }

 void SetUserData( void* user ) { userData = user; }
 void* GetUserData() { return userData; }
 const void* GetUserData() const { return userData; }



 static const int utf8ByteTable[256];

 virtual const char* Parse( const char* p,
        TiXmlParsingData* data,
        TiXmlEncoding encoding ) = 0;




 static void EncodeString( const TiXmlString& str, TiXmlString* out );

 enum
 {
  TIXML_NO_ERROR = 0,
  TIXML_ERROR,
  TIXML_ERROR_OPENING_FILE,
  TIXML_ERROR_PARSING_ELEMENT,
  TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
  TIXML_ERROR_READING_ELEMENT_VALUE,
  TIXML_ERROR_READING_ATTRIBUTES,
  TIXML_ERROR_PARSING_EMPTY,
  TIXML_ERROR_READING_END_TAG,
  TIXML_ERROR_PARSING_UNKNOWN,
  TIXML_ERROR_PARSING_COMMENT,
  TIXML_ERROR_PARSING_DECLARATION,
  TIXML_ERROR_DOCUMENT_EMPTY,
  TIXML_ERROR_EMBEDDED_NULL,
  TIXML_ERROR_PARSING_CDATA,
  TIXML_ERROR_DOCUMENT_TOP_ONLY,

  TIXML_ERROR_STRING_COUNT
 };

protected:

 static const char* SkipWhiteSpace( const char*, TiXmlEncoding encoding );

 inline static bool IsWhiteSpace( char c )
 {
  return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' );
 }
 inline static bool IsWhiteSpace( int c )
 {
  if ( c < 256 )
   return IsWhiteSpace( (char) c );
  return false;
 }
# 310 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 static const char* ReadName( const char* p, TiXmlString* name, TiXmlEncoding encoding );




 static const char* ReadText( const char* in,
         TiXmlString* text,
         bool ignoreWhiteSpace,
         const char* endTag,
         bool ignoreCase,
         TiXmlEncoding encoding );


 static const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );



 inline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )
 {
  ((void)0);
  if ( encoding == TIXML_ENCODING_UTF8 )
  {
   *length = utf8ByteTable[ *((const unsigned char*)p) ];
   ((void)0);
  }
  else
  {
   *length = 1;
  }

  if ( *length == 1 )
  {
   if ( *p == '&' )
    return GetEntity( p, _value, length, encoding );
   *_value = *p;
   return p+1;
  }
  else if ( *length )
  {


   for( int i=0; p[i] && i<*length; ++i ) {
    _value[i] = p[i];
   }
   return p + (*length);
  }
  else
  {

   return 0;
  }
 }




 static bool StringEqual( const char* p,
        const char* endTag,
        bool ignoreCase,
        TiXmlEncoding encoding );

 static const char* errorString[ TIXML_ERROR_STRING_COUNT ];

 TiXmlCursor location;


 void* userData;



 static int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );
 static int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );
 inline static int ToLower( int v, TiXmlEncoding encoding )
 {
  if ( encoding == TIXML_ENCODING_UTF8 )
  {
   if ( v < 128 ) return tolower( v );
   return v;
  }
  else
  {
   return tolower( v );
  }
 }
 static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );

private:
 TiXmlBase( const TiXmlBase& );
 void operator=( const TiXmlBase& base );

 struct Entity
 {
  const char* str;
  unsigned int strLength;
  char chr;
 };
 enum
 {
  NUM_ENTITY = 5,
  MAX_ENTITY_LENGTH = 6

 };
 static Entity entity[ NUM_ENTITY ];
 static bool condenseWhiteSpace;
};
# 423 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlNode : public TiXmlBase
{
 friend class TiXmlDocument;
 friend class TiXmlElement;

public:
# 462 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 enum NodeType
 {
  TINYXML_DOCUMENT,
  TINYXML_ELEMENT,
  TINYXML_COMMENT,
  TINYXML_UNKNOWN,
  TINYXML_TEXT,
  TINYXML_DECLARATION,
  TINYXML_TYPECOUNT
 };

 virtual ~TiXmlNode();
# 487 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const char *Value() const { return value.c_str (); }
# 497 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const TiXmlString& ValueTStr() const { return value; }
# 508 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 void SetValue(const char * _value) { value = _value;}







 void Clear();


 TiXmlNode* Parent() { return parent; }
 const TiXmlNode* Parent() const { return parent; }

 const TiXmlNode* FirstChild() const { return firstChild; }
 TiXmlNode* FirstChild() { return firstChild; }
 const TiXmlNode* FirstChild( const char * value ) const;

 TiXmlNode* FirstChild( const char * _value ) {


  return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->FirstChild( _value ));
 }
 const TiXmlNode* LastChild() const { return lastChild; }
 TiXmlNode* LastChild() { return lastChild; }

 const TiXmlNode* LastChild( const char * value ) const;
 TiXmlNode* LastChild( const char * _value ) {
  return const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->LastChild( _value ));
 }
# 562 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const TiXmlNode* IterateChildren( const TiXmlNode* previous ) const;
 TiXmlNode* IterateChildren( const TiXmlNode* previous ) {
  return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( previous ) );
 }


 const TiXmlNode* IterateChildren( const char * value, const TiXmlNode* previous ) const;
 TiXmlNode* IterateChildren( const char * _value, const TiXmlNode* previous ) {
  return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( _value, previous ) );
 }
# 581 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 TiXmlNode* InsertEndChild( const TiXmlNode& addThis );
# 593 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 TiXmlNode* LinkEndChild( TiXmlNode* addThis );




 TiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );




 TiXmlNode* InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis );




 TiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );


 bool RemoveChild( TiXmlNode* removeThis );


 const TiXmlNode* PreviousSibling() const { return prev; }
 TiXmlNode* PreviousSibling() { return prev; }


 const TiXmlNode* PreviousSibling( const char * ) const;
 TiXmlNode* PreviousSibling( const char *_prev ) {
  return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->PreviousSibling( _prev ) );
 }
# 631 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const TiXmlNode* NextSibling() const { return next; }
 TiXmlNode* NextSibling() { return next; }


 const TiXmlNode* NextSibling( const char * ) const;
 TiXmlNode* NextSibling( const char* _next ) {
  return const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->NextSibling( _next ) );
 }





 const TiXmlElement* NextSiblingElement() const;
 TiXmlElement* NextSiblingElement() {
  return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement() );
 }





 const TiXmlElement* NextSiblingElement( const char * ) const;
 TiXmlElement* NextSiblingElement( const char *_next ) {
  return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement( _next ) );
 }







 const TiXmlElement* FirstChildElement() const;
 TiXmlElement* FirstChildElement() {
  return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement() );
 }


 const TiXmlElement* FirstChildElement( const char * _value ) const;
 TiXmlElement* FirstChildElement( const char * _value ) {
  return const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement( _value ) );
 }
# 684 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 int Type() const { return type; }




 const TiXmlDocument* GetDocument() const;
 TiXmlDocument* GetDocument() {
  return const_cast< TiXmlDocument* >( (const_cast< const TiXmlNode* >(this))->GetDocument() );
 }


 bool NoChildren() const { return !firstChild; }

 virtual const TiXmlDocument* ToDocument() const { return 0; }
 virtual const TiXmlElement* ToElement() const { return 0; }
 virtual const TiXmlComment* ToComment() const { return 0; }
 virtual const TiXmlUnknown* ToUnknown() const { return 0; }
 virtual const TiXmlText* ToText() const { return 0; }
 virtual const TiXmlDeclaration* ToDeclaration() const { return 0; }

 virtual TiXmlDocument* ToDocument() { return 0; }
 virtual TiXmlElement* ToElement() { return 0; }
 virtual TiXmlComment* ToComment() { return 0; }
 virtual TiXmlUnknown* ToUnknown() { return 0; }
 virtual TiXmlText* ToText() { return 0; }
 virtual TiXmlDeclaration* ToDeclaration() { return 0; }




 virtual TiXmlNode* Clone() const = 0;
# 738 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 virtual bool Accept( TiXmlVisitor* visitor ) const = 0;

protected:
 TiXmlNode( NodeType _type );



 void CopyTo( TiXmlNode* target ) const;







 TiXmlNode* Identify( const char* start, TiXmlEncoding encoding );

 TiXmlNode* parent;
 NodeType type;

 TiXmlNode* firstChild;
 TiXmlNode* lastChild;

 TiXmlString value;

 TiXmlNode* prev;
 TiXmlNode* next;

private:
 TiXmlNode( const TiXmlNode& );
 void operator=( const TiXmlNode& base );
};
# 779 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlAttribute : public TiXmlBase
{
 friend class TiXmlAttributeSet;

public:

 TiXmlAttribute() : TiXmlBase()
 {
  document = 0;
  prev = next = 0;
 }
# 803 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 TiXmlAttribute( const char * _name, const char * _value )
 {
  name = _name;
  value = _value;
  document = 0;
  prev = next = 0;
 }

 const char* Name() const { return name.c_str(); }
 const char* Value() const { return value.c_str(); }



 int IntValue() const;
 double DoubleValue() const;


 const TiXmlString& NameTStr() const { return name; }
# 831 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 int QueryIntValue( int* _value ) const;

 int QueryDoubleValue( double* _value ) const;

 void SetName( const char* _name ) { name = _name; }
 void SetValue( const char* _value ) { value = _value; }

 void SetIntValue( int _value );
 void SetDoubleValue( double _value );
# 849 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const TiXmlAttribute* Next() const;
 TiXmlAttribute* Next() {
  return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Next() );
 }


 const TiXmlAttribute* Previous() const;
 TiXmlAttribute* Previous() {
  return const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Previous() );
 }

 bool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }
 bool operator<( const TiXmlAttribute& rhs ) const { return name < rhs.name; }
 bool operator>( const TiXmlAttribute& rhs ) const { return name > rhs.name; }




 virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );


 virtual void Print( FILE* cfile, int depth ) const {
  Print( cfile, depth, 0 );
 }
 void Print( FILE* cfile, int depth, TiXmlString* str ) const;



 void SetDocument( TiXmlDocument* doc ) { document = doc; }

private:
 TiXmlAttribute( const TiXmlAttribute& );
 void operator=( const TiXmlAttribute& base );

 TiXmlDocument* document;
 TiXmlString name;
 TiXmlString value;
 TiXmlAttribute* prev;
 TiXmlAttribute* next;
};
# 903 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlAttributeSet
{
public:
 TiXmlAttributeSet();
 ~TiXmlAttributeSet();

 void Add( TiXmlAttribute* attribute );
 void Remove( TiXmlAttribute* attribute );

 const TiXmlAttribute* First() const { return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
 TiXmlAttribute* First() { return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
 const TiXmlAttribute* Last() const { return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
 TiXmlAttribute* Last() { return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }

 TiXmlAttribute* Find( const char* _name ) const;
 TiXmlAttribute* FindOrCreate( const char* _name );







private:


 TiXmlAttributeSet( const TiXmlAttributeSet& );
 void operator=( const TiXmlAttributeSet& );

 TiXmlAttribute sentinel;
};






class TiXmlElement : public TiXmlNode
{
public:

 TiXmlElement (const char * in_value);






 TiXmlElement( const TiXmlElement& );

 TiXmlElement& operator=( const TiXmlElement& base );

 virtual ~TiXmlElement();




 const char* Attribute( const char* name ) const;







 const char* Attribute( const char* name, int* i ) const;







 const char* Attribute( const char* name, double* d ) const;
# 985 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 int QueryIntAttribute( const char* name, int* _value ) const;

 int QueryUnsignedAttribute( const char* name, unsigned* _value ) const;




 int QueryBoolAttribute( const char* name, bool* _value ) const;

 int QueryDoubleAttribute( const char* name, double* _value ) const;

 int QueryFloatAttribute( const char* name, float* _value ) const {
  double d;
  int result = QueryDoubleAttribute( name, &d );
  if ( result == TIXML_SUCCESS ) {
   *_value = (float)d;
  }
  return result;
 }
# 1050 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 void SetAttribute( const char* name, const char * _value );
# 1070 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 void SetAttribute( const char * name, int value );




 void SetDoubleAttribute( const char * name, double value );



 void RemoveAttribute( const char * name );




 const TiXmlAttribute* FirstAttribute() const { return attributeSet.First(); }
 TiXmlAttribute* FirstAttribute() { return attributeSet.First(); }
 const TiXmlAttribute* LastAttribute() const { return attributeSet.Last(); }
 TiXmlAttribute* LastAttribute() { return attributeSet.Last(); }
# 1121 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const char* GetText() const;


 virtual TiXmlNode* Clone() const;

 virtual void Print( FILE* cfile, int depth ) const;




 virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

 virtual const TiXmlElement* ToElement() const { return this; }
 virtual TiXmlElement* ToElement() { return this; }



 virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:

 void CopyTo( TiXmlElement* target ) const;
 void ClearThis();
# 1153 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 const char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );

private:
 TiXmlAttributeSet attributeSet;
};




class TiXmlComment : public TiXmlNode
{
public:

 TiXmlComment() : TiXmlNode( TiXmlNode::TINYXML_COMMENT ) {}

 TiXmlComment( const char* _value ) : TiXmlNode( TiXmlNode::TINYXML_COMMENT ) {
  SetValue( _value );
 }
 TiXmlComment( const TiXmlComment& );
 TiXmlComment& operator=( const TiXmlComment& base );

 virtual ~TiXmlComment() {}


 virtual TiXmlNode* Clone() const;

 virtual void Print( FILE* cfile, int depth ) const;




 virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

 virtual const TiXmlComment* ToComment() const { return this; }
 virtual TiXmlComment* ToComment() { return this; }



 virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:
 void CopyTo( TiXmlComment* target ) const;







private:

};







class TiXmlText : public TiXmlNode
{
 friend class TiXmlElement;
public:




 TiXmlText (const char * initValue ) : TiXmlNode (TiXmlNode::TINYXML_TEXT)
 {
  SetValue( initValue );
  cdata = false;
 }
 virtual ~TiXmlText() {}
# 1236 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 TiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TINYXML_TEXT ) { copy.CopyTo( this ); }
 TiXmlText& operator=( const TiXmlText& base ) { base.CopyTo( this ); return *this; }


 virtual void Print( FILE* cfile, int depth ) const;


 bool CDATA() const { return cdata; }

 void SetCDATA( bool _cdata ) { cdata = _cdata; }

 virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

 virtual const TiXmlText* ToText() const { return this; }
 virtual TiXmlText* ToText() { return this; }



 virtual bool Accept( TiXmlVisitor* content ) const;

protected :

 virtual TiXmlNode* Clone() const;
 void CopyTo( TiXmlText* target ) const;

 bool Blank() const;





private:
 bool cdata;
};
# 1285 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlDeclaration : public TiXmlNode
{
public:

 TiXmlDeclaration() : TiXmlNode( TiXmlNode::TINYXML_DECLARATION ) {}
# 1299 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 TiXmlDeclaration( const char* _version,
      const char* _encoding,
      const char* _standalone );

 TiXmlDeclaration( const TiXmlDeclaration& copy );
 TiXmlDeclaration& operator=( const TiXmlDeclaration& copy );

 virtual ~TiXmlDeclaration() {}


 const char *Version() const { return version.c_str (); }

 const char *Encoding() const { return encoding.c_str (); }

 const char *Standalone() const { return standalone.c_str (); }


 virtual TiXmlNode* Clone() const;

 virtual void Print( FILE* cfile, int depth, TiXmlString* str ) const;
 virtual void Print( FILE* cfile, int depth ) const {
  Print( cfile, depth, 0 );
 }

 virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

 virtual const TiXmlDeclaration* ToDeclaration() const { return this; }
 virtual TiXmlDeclaration* ToDeclaration() { return this; }



 virtual bool Accept( TiXmlVisitor* visitor ) const;

protected:
 void CopyTo( TiXmlDeclaration* target ) const;





private:

 TiXmlString version;
 TiXmlString encoding;
 TiXmlString standalone;
};
# 1354 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlUnknown : public TiXmlNode
{
public:
 TiXmlUnknown() : TiXmlNode( TiXmlNode::TINYXML_UNKNOWN ) {}
 virtual ~TiXmlUnknown() {}

 TiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::TINYXML_UNKNOWN ) { copy.CopyTo( this ); }
 TiXmlUnknown& operator=( const TiXmlUnknown& copy ) { copy.CopyTo( this ); return *this; }


 virtual TiXmlNode* Clone() const;

 virtual void Print( FILE* cfile, int depth ) const;

 virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );

 virtual const TiXmlUnknown* ToUnknown() const { return this; }
 virtual TiXmlUnknown* ToUnknown() { return this; }



 virtual bool Accept( TiXmlVisitor* content ) const;

protected:
 void CopyTo( TiXmlUnknown* target ) const;





private:

};






class TiXmlDocument : public TiXmlNode
{
public:

 TiXmlDocument();

 TiXmlDocument( const char * documentName );






 TiXmlDocument( const TiXmlDocument& copy );
 TiXmlDocument& operator=( const TiXmlDocument& copy );

 virtual ~TiXmlDocument() {}





 bool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );

 bool SaveFile() const;

 bool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );

 bool SaveFile( const char * filename ) const;





 bool LoadFile( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );

 bool SaveFile( FILE* ) const;
# 1446 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 virtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );





 const TiXmlElement* RootElement() const { return FirstChildElement(); }
 TiXmlElement* RootElement() { return FirstChildElement(); }






 bool Error() const { return error; }


 const char * ErrorDesc() const { return errorDesc.c_str (); }




 int ErrorId() const { return errorId; }
# 1477 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 int ErrorRow() const { return errorLocation.row+1; }
 int ErrorCol() const { return errorLocation.col+1; }
# 1504 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 void SetTabSize( int _tabsize ) { tabsize = _tabsize; }

 int TabSize() const { return tabsize; }




 void ClearError() { error = false;
            errorId = 0;
            errorDesc = "";
            errorLocation.row = errorLocation.col = 0;

           }


 void Print() const { Print( (__aeabi_stdout), 0 ); }
# 1528 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 virtual void Print( FILE* cfile, int depth = 0 ) const;

 void SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );

 virtual const TiXmlDocument* ToDocument() const { return this; }
 virtual TiXmlDocument* ToDocument() { return this; }



 virtual bool Accept( TiXmlVisitor* content ) const;

protected :

 virtual TiXmlNode* Clone() const;




private:
 void CopyTo( TiXmlDocument* target ) const;

 bool error;
 int errorId;
 TiXmlString errorDesc;
 int tabsize;
 TiXmlCursor errorLocation;
 bool useMicrosoftBOM;
};
# 1638 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlHandle
{
public:

 TiXmlHandle( TiXmlNode* _node ) { this->node = _node; }

 TiXmlHandle( const TiXmlHandle& ref ) { this->node = ref.node; }
 TiXmlHandle operator=( const TiXmlHandle& ref ) { if ( &ref != this ) this->node = ref.node; return *this; }


 TiXmlHandle FirstChild() const;

 TiXmlHandle FirstChild( const char * value ) const;

 TiXmlHandle FirstChildElement() const;

 TiXmlHandle FirstChildElement( const char * value ) const;




 TiXmlHandle Child( const char* value, int index ) const;



 TiXmlHandle Child( int index ) const;




 TiXmlHandle ChildElement( const char* value, int index ) const;




 TiXmlHandle ChildElement( int index ) const;
# 1685 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
 TiXmlNode* ToNode() const { return node; }


 TiXmlElement* ToElement() const { return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }


 TiXmlText* ToText() const { return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }


 TiXmlUnknown* ToUnknown() const { return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }




 TiXmlNode* Node() const { return ToNode(); }



 TiXmlElement* Element() const { return ToElement(); }



 TiXmlText* Text() const { return ToText(); }



 TiXmlUnknown* Unknown() const { return ToUnknown(); }

private:
 TiXmlNode* node;
};
# 1737 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h"
class TiXmlPrinter : public TiXmlVisitor
{
public:
 TiXmlPrinter() : depth( 0 ), simpleTextPrint( false ),
      buffer(), indent( "    " ), lineBreak( "\n" ) {}

 virtual bool VisitEnter( const TiXmlDocument& doc );
 virtual bool VisitExit( const TiXmlDocument& doc );

 virtual bool VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute );
 virtual bool VisitExit( const TiXmlElement& element );

 virtual bool Visit( const TiXmlDeclaration& declaration );
 virtual bool Visit( const TiXmlText& text );
 virtual bool Visit( const TiXmlComment& comment );
 virtual bool Visit( const TiXmlUnknown& unknown );




 void SetIndent( const char* _indent ) { indent = _indent ? _indent : "" ; }

 const char* Indent() { return indent.c_str(); }




 void SetLineBreak( const char* _lineBreak ) { lineBreak = _lineBreak ? _lineBreak : ""; }

 const char* LineBreak() { return lineBreak.c_str(); }




 void SetStreamPrinting() { indent = "";
               lineBreak = "";
             }

 const char* CStr() { return buffer.c_str(); }

 size_t Size() { return buffer.size(); }






private:
 void DoIndent() {
  for( int i=0; i<depth; ++i )
   buffer += indent;
 }
 void DoLineBreak() {
  buffer += lineBreak;
 }

 int depth;
 bool simpleTextPrint;
 TiXmlString buffer;
 TiXmlString indent;
 TiXmlString lineBreak;
};
# 4 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/history.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/c++/string" 1
# 24 "c:/marmalade/6.2/s3e/h/std/c++/string"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h" 1
# 10 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h" 1
# 62 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl_user_config.h" 1
# 63 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h" 2




# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config_compat.h" 1
# 68 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_site_config.h" 1
# 72 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/stlcomp.h" 1
# 54 "c:/marmalade/6.2/s3e/h/std/c++/config/stlcomp.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/stl_gcc_s3e.h" 1
# 67 "c:/marmalade/6.2/s3e/h/std/c++/config/stl_gcc_s3e.h"
     typedef char __stl_char;
# 55 "c:/marmalade/6.2/s3e/h/std/c++/config/stlcomp.h" 2
# 75 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h" 2
# 83 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/stl_confix.h" 1
# 84 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h" 2
# 488 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h"
namespace std { }
namespace __std_alias = std;
# 546 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config.h"
namespace _STL { }

namespace stlport = _STL;
# 11 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h" 2





# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h" 2
# 25 "c:/marmalade/6.2/s3e/h/std/c++/string" 2



         
# 45 "c:/marmalade/6.2/s3e/h/std/c++/string"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 1
# 23 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/memory" 1
# 28 "c:/marmalade/6.2/s3e/h/std/c++/memory"
         



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 1
# 31 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/cstddef" 1
# 37 "c:/marmalade/6.2/s3e/h/std/c++/cstddef"
# 1 "c:/marmalade/6.2/s3e/h/ext/../std/stddef.h" 1
# 38 "c:/marmalade/6.2/s3e/h/std/c++/cstddef" 2



namespace _STL {
using ::ptrdiff_t;
using ::size_t;
}
# 32 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 2







# 1 "c:/marmalade/6.2/s3e/h/std/c++/cstdlib" 1
# 27 "c:/marmalade/6.2/s3e/h/std/c++/cstdlib"
# 1 "c:/marmalade/6.2/s3e/h/ext/../std/stdlib.h" 1
# 28 "c:/marmalade/6.2/s3e/h/std/c++/cstdlib" 2
# 41 "c:/marmalade/6.2/s3e/h/std/c++/cstdlib"
namespace _STL {
using ::div_t;
using ::ldiv_t;
using ::size_t;


using ::abort;
using ::atexit;
using ::exit;
using ::getenv;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::atof;
using ::atoi;
using ::atol;
using ::mblen;
using ::mbstowcs;
using ::mbtowc;
using ::strtod;
using ::strtol;
using ::strtoul;
using ::system;


using ::wcstombs;
using ::wctomb;

using ::bsearch;
using ::qsort;




using ::div;
using ::labs;
using ::ldiv;
using ::rand;
using ::srand;

}


namespace _STL {



inline long abs(long __x) { return ::labs(__x); }


inline ldiv_t div(long __x, long __y) { return ::ldiv(__x, __y); }
# 103 "c:/marmalade/6.2/s3e/h/std/c++/cstdlib"
}
# 40 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/cstring" 1
# 27 "c:/marmalade/6.2/s3e/h/std/c++/cstring"
# 1 "c:/marmalade/6.2/s3e/h/ext/../std/string.h" 1
# 28 "c:/marmalade/6.2/s3e/h/std/c++/cstring" 2



namespace _STL {
# 1 "c:/marmalade/6.2/s3e/h/std/c++/using/cstring" 1
using ::size_t;
# 17 "c:/marmalade/6.2/s3e/h/std/c++/using/cstring"
 using ::memmove;
 using ::memcpy;




using ::memchr;
using ::strchr;
using ::strpbrk;
using ::strrchr;
using ::strstr;


using ::memcmp;
using ::memset;

using ::strcat;


using ::strcmp;


using ::strcoll;

using ::strcpy;

using ::strcspn;
using ::strerror;
using ::strlen;
using ::strncat;
using ::strncmp;

using ::strncpy;
using ::strspn;

using ::strtok;
using ::strxfrm;
# 33 "c:/marmalade/6.2/s3e/h/std/c++/cstring" 2
}
# 43 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 2





# 1 "c:/marmalade/6.2/s3e/h/std/c++/cstdio" 1
# 35 "c:/marmalade/6.2/s3e/h/std/c++/cstdio"
# 1 "c:/marmalade/6.2/s3e/h/ext/../std/stdio.h" 1
# 36 "c:/marmalade/6.2/s3e/h/std/c++/cstdio" 2
# 58 "c:/marmalade/6.2/s3e/h/std/c++/cstdio"
namespace _STL {
using ::FILE;
using ::fpos_t;
using ::size_t;
# 72 "c:/marmalade/6.2/s3e/h/std/c++/cstdio"
using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;


 using ::getc;
 using ::getchar;
 using ::putc;
 using ::putchar;


using ::gets;
using ::perror;
using ::printf;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;
using ::tmpnam;
using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;





}
# 49 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 2
# 60 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_new.h" 1
# 11 "c:/marmalade/6.2/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/exception" 1
# 58 "c:/marmalade/6.2/s3e/h/std/c++/exception"
# 1 "c:/marmalade/6.2/s3e/h/ext/../std/c++/exception.h" 1
# 18 "c:/marmalade/6.2/s3e/h/ext/../std/c++/exception.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/exception_gcc" 1
# 41 "c:/marmalade/6.2/s3e/h/std/c++/exception_gcc"
#pragma GCC visibility push(default)


extern "C++" {

namespace std
{
# 56 "c:/marmalade/6.2/s3e/h/std/c++/exception_gcc"
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 104 "c:/marmalade/6.2/s3e/h/std/c++/exception_gcc"
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 119 "c:/marmalade/6.2/s3e/h/std/c++/exception_gcc"
  void __verbose_terminate_handler ();
}

}


#pragma GCC visibility pop
# 19 "c:/marmalade/6.2/s3e/h/ext/../std/c++/exception.h" 2
# 59 "c:/marmalade/6.2/s3e/h/std/c++/exception" 2
# 75 "c:/marmalade/6.2/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/6.2/s3e/h/std/c++/exception"
}
# 12 "c:/marmalade/6.2/s3e/h/std/c++/stl/_new.h" 2

namespace _STL {

struct nothrow_t {};


extern const nothrow_t nothrow;




class bad_alloc : public exception {
public:
  bad_alloc () throw() { }
  bad_alloc(const bad_alloc&) throw() { }
  bad_alloc& operator=(const bad_alloc&) throw() {return *this;}
  ~bad_alloc () throw() { }
  const char* what() const throw() { return "bad alloc"; }
};

}
# 50 "c:/marmalade/6.2/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/new" 1
# 38 "c:/marmalade/6.2/s3e/h/std/c++/new"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/new.h" 1
# 52 "c:/marmalade/6.2/s3e/h/std/c++/new.h"
inline void* operator new(size_t, void* p) { return p;};
inline void* operator new[](size_t, void* p) { return p;};
inline void operator delete(void*, void*) {};
inline void operator delete[](void*, void*) {};
# 39 "c:/marmalade/6.2/s3e/h/std/c++/new" 2
# 51 "c:/marmalade/6.2/s3e/h/std/c++/stl/_new.h" 2
# 80 "c:/marmalade/6.2/s3e/h/std/c++/stl/_new.h"
namespace _STL {





inline void* __stl_new(size_t __n) { void* __y = ::operator new(__n);if (__y == 0){;}return __y; }
inline void __stl_delete(void* __p) { ::operator delete(__p); }

}
# 61 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h" 1
# 57 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
  typedef size_t __stl_atomic_t;
# 280 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
namespace _STL {




template <int __inst>
struct _STLP_mutex_spin {
  enum { __low_max = 30, __high_max = 1000 };

  static unsigned __max;
  static unsigned __last;
  static void _M_do_lock(volatile __stl_atomic_t* __lock);
  static void _S_nsec_sleep(int __log_nsec);
};
# 311 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
struct _STLP_mutex_base
{
# 441 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
  inline void _M_initialize() {}
  inline void _M_destroy() {}
  inline void _M_acquire_lock() {}
  inline void _M_release_lock() {}

};
# 458 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
typedef _STLP_mutex_base _STLP_mutex_nodemand;





class _STLP_mutex : public _STLP_mutex_nodemand {
  public:
    inline _STLP_mutex () { _M_initialize(); }
    inline ~_STLP_mutex () { _M_destroy(); }
  private:
    _STLP_mutex(const _STLP_mutex&);
    void operator=(const _STLP_mutex&);
};
# 569 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
struct _Refcount_Base
{

  volatile __stl_atomic_t _M_ref_count;


  _STLP_mutex _M_mutex;



  _Refcount_Base(__stl_atomic_t __n) : _M_ref_count(__n) {}
# 597 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
  void _M_incr() { ++_M_ref_count; }
  void _M_decr() { --_M_ref_count; }

};
# 632 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
static inline __stl_atomic_t
_Atomic_swap(volatile __stl_atomic_t * __p, __stl_atomic_t __q) {
  __stl_atomic_t __result = *__p;
  *__p = __q;
  return __result;
}






struct _STLP_auto_lock
{
  _STLP_mutex_base& _M_lock;

  _STLP_auto_lock(_STLP_mutex_base& __lock) : _M_lock(__lock)
    { _M_lock._M_acquire_lock(); }
  ~_STLP_auto_lock() { _M_lock._M_release_lock(); }

private:
  void operator=(const _STLP_auto_lock&);
  _STLP_auto_lock(const _STLP_auto_lock&);
};

typedef _STLP_auto_lock _STLP_mutex_lock;
# 710 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h"
}


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.c" 1
# 714 "c:/marmalade/6.2/s3e/h/std/c++/stl/_threads.h" 2
# 65 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h" 1
# 43 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h" 1
# 44 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h" 1
# 62 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h"
namespace _STL {

struct __true_type {};
struct __false_type {};


template <int _Is> struct __bool2type {
  typedef __false_type _Ret;
};

template<>
struct __bool2type<1> { typedef __true_type _Ret; };

template<>
struct __bool2type<0> { typedef __false_type _Ret; };


template <class _P1, class _P2, class _P3>
struct _Land3 {
  typedef __false_type _Ret;
};

template<>
struct _Land3<__true_type, __true_type, __true_type> {
  typedef __true_type _Ret;
};



template <class _Tp> struct __type_traits;
template <int _IsPOD> struct __type_traits_aux {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<0> {
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};

template<>
struct __type_traits_aux<1> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};
# 188 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h"
template <class _Tp>
struct __type_traits {
   typedef __true_type this_dummy_member_must_be_first;
# 206 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h"
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};


template <class _Tp> struct _IsPtr { enum { _Ret = 0 }; };
template <class _Tp> struct _IsPtrType {
  static __false_type _Ret() { return __false_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType {
  static __false_type _Ret() { return __false_type();}
};

template <class _Tp1, class _Tp2>
struct _IsSame { enum { _Ret = 0 }; };





template <class _Tp> struct _IsPtr<_Tp*> { enum { _Ret = 1 }; };
template <class _Tp> struct _IsPtrType<_Tp*> {
  static __true_type _Ret() { return __true_type();}
};
template <class _Tp1, class _Tp2> struct _BothPtrType<_Tp1*, _Tp2*> {
  static __true_type _Ret() { return __true_type();}
};
template <class _Tp>
struct _IsSame<_Tp, _Tp> { enum { _Ret = 1 }; };
# 246 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h"
template<> struct __type_traits<bool> : __type_traits_aux<1> {};

template<> struct __type_traits<char> : __type_traits_aux<1> {};

template<> struct __type_traits<signed char> : __type_traits_aux<1> {};

template<> struct __type_traits<unsigned char> : __type_traits_aux<1> {};




template<> struct __type_traits<short> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned short> : __type_traits_aux<1> {};
template<> struct __type_traits<int> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned int> : __type_traits_aux<1> {};
template<> struct __type_traits<long> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned long> : __type_traits_aux<1> {};


template<> struct __type_traits<long long> : __type_traits_aux<1> {};
template<> struct __type_traits<unsigned long long> : __type_traits_aux<1> {};


template<> struct __type_traits<float> : __type_traits_aux<1> {};
template<> struct __type_traits<double> : __type_traits_aux<1> {};


template<> struct __type_traits<long double> : __type_traits_aux<1> {};



template <class _Tp> struct __type_traits<_Tp*> : __type_traits_aux<1> {};





template <class _Tp> struct _Is_integer {
  typedef __false_type _Integral;
};



template<> struct _Is_integer<bool> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<char> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<signed char> {
  typedef __true_type _Integral;
};


template<> struct _Is_integer<unsigned char> {
  typedef __true_type _Integral;
};
# 318 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h"
template<> struct _Is_integer<short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long> {
  typedef __true_type _Integral;
};



template<> struct _Is_integer<long long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long long> {
  typedef __true_type _Integral;
};



template <class _Tp1, class _Tp2>
struct _OKToMemCpy {
  enum { _Same = _IsSame<_Tp1,_Tp2>::_Ret } ;
  typedef typename __type_traits<_Tp1>::has_trivial_assignment_operator _Tr1;
  typedef typename __type_traits<_Tp2>::has_trivial_assignment_operator _Tr2;
  typedef typename __bool2type< _Same >::_Ret _Tr3;
  typedef typename _Land3<_Tr1, _Tr2, _Tr3>::_Ret _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp1, class _Tp2>
inline _OKToMemCpy<_Tp1, _Tp2> _IsOKToMemCpy(_Tp1*, _Tp2*) {
  return _OKToMemCpy<_Tp1, _Tp2>();
}

template <class _Tp>
struct _IsPOD {
  typedef typename __type_traits<_Tp>::is_POD_type _Type;
  static _Type _Ret() { return _Type(); }
};

template <class _Tp>
inline _IsPOD<_Tp> _Is_POD (_Tp*) { return _IsPOD<_Tp>(); }
# 411 "c:/marmalade/6.2/s3e/h/std/c++/stl/type_traits.h"
}
# 45 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h" 2


namespace _STL {

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};


template <class _Category, class _Tp, class _Distance = ptrdiff_t,
          class _Pointer = _Tp*, class _Reference = _Tp& >
struct iterator {
  typedef _Category iterator_category;
  typedef _Tp value_type;
  typedef _Distance difference_type;
  typedef _Pointer pointer;
  typedef _Reference reference;
};
template<>
struct iterator<output_iterator_tag, void, void, void, void> {
  typedef output_iterator_tag iterator_category;

  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

};
# 96 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Iterator>
struct iterator_traits {
  typedef typename _Iterator::iterator_category iterator_category;
  typedef typename _Iterator::value_type value_type;
  typedef typename _Iterator::difference_type difference_type;
  typedef typename _Iterator::pointer pointer;
  typedef typename _Iterator::reference reference;
};
# 115 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Tp>
struct iterator_traits<const _Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef const _Tp* pointer;
  typedef const _Tp& reference;
};

template <class _Tp>
struct iterator_traits<_Tp*> {
  typedef random_access_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp* pointer;
  typedef _Tp& reference;
};
# 164 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Iter>
inline typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter&) {
  typedef typename iterator_traits<_Iter>::iterator_category _Category;
  return _Category();
}

template <class _Iter>
inline typename iterator_traits<_Iter>::difference_type* __distance_type(const _Iter&) {
  typedef typename iterator_traits<_Iter>::difference_type _diff_type;
  return static_cast<_diff_type*>(0);
}

template <class _Iter>
inline typename iterator_traits<_Iter>::value_type* __value_type(const _Iter&) {
  typedef typename iterator_traits<_Iter>::value_type _value_type;
  return static_cast<_value_type*>(0);
}
# 236 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _Tp, class _Distance> struct input_iterator :
  public iterator <input_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
struct output_iterator : public iterator <output_iterator_tag, void, void, void, void> {};
template <class _Tp, class _Distance> struct forward_iterator :
  public iterator<forward_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct bidirectional_iterator :
  public iterator<bidirectional_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
template <class _Tp, class _Distance> struct random_access_iterator :
  public iterator<random_access_iterator_tag, _Tp, _Distance, _Tp*, _Tp&> {};
# 281 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _InputIterator, class _Distance>
inline void __distance(const _InputIterator& __first, const _InputIterator& __last,
      _Distance& __n, const input_iterator_tag &) {
  _InputIterator __it(__first);
  while (__it != __last) { ++__it; ++__n; }
}
# 305 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _RandomAccessIterator, class _Distance>
inline void __distance(const _RandomAccessIterator& __first,
      const _RandomAccessIterator& __last,
      _Distance& __n, const random_access_iterator_tag &) {
  __n += __last - __first;
}


template <class _InputIterator, class _Distance>
inline void distance(const _InputIterator& __first,
    const _InputIterator& __last, _Distance& __n) {
  __distance(__first, __last, __n, typename iterator_traits< _InputIterator >::iterator_category());
}


template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
__distance(const _InputIterator& __first, const _InputIterator& __last, const input_iterator_tag &) {
  typename iterator_traits<_InputIterator>::difference_type __n = 0;
  _InputIterator __it(__first);
  while (__it != __last) {
    ++__it; ++__n;
  }
  return __n;
}
# 359 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _RandomAccessIterator>
inline typename iterator_traits<_RandomAccessIterator>::difference_type
__distance(const _RandomAccessIterator& __first, const _RandomAccessIterator& __last,
           const random_access_iterator_tag &) {
  return __last - __first;
}

template <class _InputIterator>
inline typename iterator_traits<_InputIterator>::difference_type
distance(const _InputIterator& __first, const _InputIterator& __last) {
  return __distance(__first, __last, typename iterator_traits< _InputIterator >::iterator_category());
}



template <class _Tp>
struct _Nonconst_traits;

template <class _Tp>
struct _Const_traits {
  typedef _Tp value_type;
  typedef const _Tp& reference;
  typedef const _Tp* pointer;
  typedef _Nonconst_traits<_Tp> _Non_const_traits;
};

template <class _Tp>
struct _Nonconst_traits {
  typedef _Tp value_type;
  typedef _Tp& reference;
  typedef _Tp* pointer;
  typedef _Nonconst_traits<_Tp> _Non_const_traits;
};
# 414 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, const input_iterator_tag &) {
  while (__n--) ++__i;
}


template <class _InputIter, class _Distance>
inline void __advance(_InputIter& __i, _Distance __n, const output_iterator_tag &) {
  while (__n--) ++__i;
}
# 432 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator_base.h"
template <class _BidirectionalIterator, class _Distance>
inline void __advance(_BidirectionalIterator& __i, _Distance __n,
                      const bidirectional_iterator_tag &) {
  if (__n > 0)
    while (__n--) ++__i;
  else
    while (__n++) --__i;
}

template <class _RandomAccessIterator, class _Distance>
inline void __advance(_RandomAccessIterator& __i, _Distance __n,
                      const random_access_iterator_tag &) {
  __i += __n;
}

template <class _InputIterator, class _Distance>
inline void advance(_InputIterator& __i, _Distance __n) {
  __advance(__i, __n, typename iterator_traits< _InputIterator >::iterator_category());
}

}
# 44 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h" 2


namespace _STL {
# 55 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h"
template <class _Tp>
inline void _Destroy(_Tp* __pointer) {
# 67 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h"
    __pointer->~_Tp();





}
# 92 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h"
template <class _T1, class _T2>
inline void _Construct(_T1* __p, const _T2& __val) {



    new (__p) _T1(__val);
}

template <class _T1>
inline void _Construct(_T1* __p) {







  new (__p) _T1();

}
# 120 "c:/marmalade/6.2/s3e/h/std/c++/stl/_construct.h"
template <class _ForwardIterator>
inline void
__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, const __false_type&) {
  for ( ; __first != __last; ++__first)
    _STL::_Destroy(&*__first);
}

template <class _ForwardIterator>
inline void __destroy_aux(_ForwardIterator, _ForwardIterator, const __true_type&) {}

template <class _ForwardIterator, class _Tp>
inline void
__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*) {
  typedef typename __type_traits<_Tp>::has_trivial_destructor _Trivial_destructor;
  __destroy_aux(__first, __last, _Trivial_destructor());
}

template <class _ForwardIterator>
inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
  __destroy(__first, __last, (typename iterator_traits< _ForwardIterator >::value_type*)0);
}

inline void _Destroy(char*, char*) {}

inline void _Destroy(wchar_t*, wchar_t*) {}
inline void _Destroy(const wchar_t*, const wchar_t*) {}






template <class _T1, class _T2>
inline void construct(_T1* __p, const _T2& __val) {_Construct(__p, __val); }
template <class _T1>
inline void construct(_T1* __p) { _Construct(__p); }
template <class _Tp>
inline void destroy(_Tp* __pointer) { _STL::_Destroy(__pointer); }
template <class _ForwardIterator>
inline void destroy(_ForwardIterator __first, _ForwardIterator __last) { _STL::_Destroy(__first, __last); }

}
# 69 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h" 2
# 85 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
namespace _STL {
# 94 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
typedef void (* __oom_handler_type)();

template <int __inst>
class __malloc_alloc {
private:
  static void* _S_oom_malloc(size_t);
  static __oom_handler_type __oom_handler;
public:

  typedef char value_type;





  static void* allocate(size_t __n) {
    void* __result = malloc(__n);
    if (0 == __result) __result = _S_oom_malloc(__n);
    return __result;
  }
  static void deallocate(void* __p, size_t ) { free((char*)__p); }
  static __oom_handler_type set_malloc_handler(__oom_handler_type __f) {
    __oom_handler_type __old = __oom_handler;
    __oom_handler = __f;
    return(__old);
  }
};




class __new_alloc {
public:

  typedef char value_type;





  static void* allocate(size_t __n) { return __stl_new(__n); }
  static void deallocate(void* __p, size_t) { __stl_delete(__p); }
};
# 146 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Alloc>
class __debug_alloc : public _Alloc {
public:
  typedef _Alloc __allocator_type;
  typedef typename _Alloc::value_type value_type;
private:
  struct __alloc_header {
    size_t __magic: 16;
    size_t __type_size:16;
    unsigned long _M_size;
  };

  enum { __pad=8, __magic=0xdeba, __deleted_magic = 0xdebd,
  __shred_byte= 0xA3
  };

  enum { __extra_before = 16, __extra_after = 8 };



  static size_t __extra_before_chunk() {
    return (long)__extra_before/sizeof(value_type)+
      (size_t)((long)__extra_before%sizeof(value_type)>0);
  }
  static size_t __extra_after_chunk() {
    return (long)__extra_after/sizeof(value_type)+
      (size_t)((long)__extra_after%sizeof(value_type)>0);
  }
public:





  __debug_alloc() {}
  ~__debug_alloc() {}
  static void * allocate(size_t);
  static void deallocate(void *, size_t);
};
# 214 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
enum {_ALIGN = 8, _ALIGN_SHIFT=3, _MAX_BYTES = 128};



class _Node_alloc_obj {
public:
    _Node_alloc_obj * _M_free_list_link;
};

template <bool __threads, int __inst>
class __node_alloc {
  public:
  static inline size_t _S_round_up(size_t __bytes) { return (((__bytes) + (size_t)_ALIGN-1) & ~((size_t)_ALIGN - 1)); }
  typedef _Node_alloc_obj _Obj;
private:

  static void* _S_refill(size_t __n);


  static char* _S_chunk_alloc(size_t __p_size, int& __nobjs);

  static _Node_alloc_obj * _S_free_list[16];
  static char* _S_start_free;
  static char* _S_end_free;
  static size_t _S_heap_size;
  static void * _M_allocate(size_t __n);

  static void _M_deallocate(void *__p, size_t __n);
public:

  typedef char value_type;






  static void * allocate(size_t __n) { return (__n > (size_t)_MAX_BYTES) ? __stl_new(__n) : _M_allocate(__n); }

  static void deallocate(void *__p, size_t __n) { if (__n > (size_t)_MAX_BYTES) __stl_delete(__p); else _M_deallocate(__p, __n); }
};





typedef __node_alloc<false, 0> _Node_alloc;
# 301 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
typedef __malloc_alloc<0> __sgi_alloc;


typedef __malloc_alloc<0> __single_client_alloc;
typedef __malloc_alloc<0> __multithreaded_alloc;
# 329 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp>
class allocator {
public:

  typedef _Tp value_type;
  typedef value_type * pointer;
  typedef const _Tp* const_pointer;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() {}

  template <class _Tp1> allocator(const allocator<_Tp1>&) {}

  allocator(const allocator<_Tp>&) {}
  ~allocator() {}
  pointer address(reference __x) const { return &__x; }
  const_pointer address(const_reference __x) const { return &__x; }

  _Tp* allocate(size_type __n, const void* = 0) {
    return __n != 0 ? reinterpret_cast<value_type*>(__sgi_alloc::allocate(__n * sizeof(value_type))) : 0;
  }

  void deallocate(pointer __p, size_type __n) {
   
      if (__p != 0) __sgi_alloc::deallocate((void*)__p, __n * sizeof(value_type));
  }

  void deallocate(pointer __p) const { if (__p != 0) __sgi_alloc::deallocate((void*)__p, sizeof(value_type)); }
  size_type max_size() const { return size_t(-1) / sizeof(value_type); }
  void construct(pointer __p, const _Tp& __val) { _STL::_Construct(__p, __val); }
  void destroy(pointer __p) { _STL::_Destroy(__p); }




};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;

  typedef void value_type;


  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };





};


template <class _T1, class _T2> inline bool operator==(const allocator<_T1>&, const allocator<_T2>&) { return true; }
template <class _T1, class _T2> inline bool operator!=(const allocator<_T1>&, const allocator<_T2>&) { return false; }
# 411 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp, class _Allocator>
struct _Alloc_traits
{
  typedef _Allocator _Orig;

  typedef typename _Allocator::template rebind<_Tp> _Rebind_type;
  typedef typename _Rebind_type::other allocator_type;
  static allocator_type create_allocator(const _Orig& __a) { return allocator_type(__a); }





};
# 457 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Tp, class _Alloc>
inline typename _Alloc_traits<_Tp, _Alloc>::allocator_type
__stl_alloc_create(const _Alloc& __a, const _Tp*) {
  typedef typename _Alloc::template rebind<_Tp>::other _Rebound_type;
  return _Rebound_type(__a);
}
# 480 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
template <class _Value, class _Tp, class _MaybeReboundAlloc>
class _STLP_alloc_proxy : public _MaybeReboundAlloc {
private:
  typedef _MaybeReboundAlloc _Base;
  typedef _STLP_alloc_proxy<_Value, _Tp, _MaybeReboundAlloc> _Self;
public:
  _Value _M_data;
  inline _STLP_alloc_proxy(const _MaybeReboundAlloc& __a, _Value __p) : _MaybeReboundAlloc(__a), _M_data(__p) {}
# 509 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
};
# 520 "c:/marmalade/6.2/s3e/h/std/c++/stl/_alloc.h"
}
# 33 "c:/marmalade/6.2/s3e/h/std/c++/memory" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.h" 1
# 34 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/climits" 1
# 32 "c:/marmalade/6.2/s3e/h/std/c++/climits"
# 1 "c:/marmalade/6.2/s3e/h/std/limits.h" 1
# 33 "c:/marmalade/6.2/s3e/h/std/c++/climits" 2
# 35 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.h" 2





# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_uninitialized.h" 1
# 38 "c:/marmalade/6.2/s3e/h/std/c++/stl/_uninitialized.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h" 1
# 51 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_pair.h" 1
# 34 "c:/marmalade/6.2/s3e/h/std/c++/stl/_pair.h"
namespace _STL {

template <class _T1, class _T2>
struct pair {
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;



  pair() : first(_T1()), second(_T2()) {}

  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}


  template <class _U1, class _U2>
  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}

  pair(const pair<_T1,_T2>& __o) : first(__o.first), second(__o.second) {}

 
};

template <class _T1, class _T2>
inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first < __y.first ||
         (!(__y.first < __x.first) && __x.second < __y.second);
}



template <class _T1, class _T2>
inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x == __y);
}

template <class _T1, class _T2>
inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return __y < __x;
}

template <class _T1, class _T2>
inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__y < __x);
}

template <class _T1, class _T2>
inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x < __y);
}





template <class _T1, class _T2, int _Sz>
inline pair<_T1, _T2 const*> make_pair(_T1 const& __x,
                                       _T2 const (&__y)[_Sz])
{
  return pair<_T1, _T2 const*>(__x, static_cast<_T2 const*>(__y));
}

template <class _T1, class _T2, int _Sz>
inline pair<_T1 const*, _T2> make_pair(_T1 const (&__x)[_Sz],
                                       _T2 const& __y)
{
  return pair<_T1 const*, _T2>(static_cast<_T1 const*>(__x), __y);
}

template <class _T1, class _T2, int _Sz1, int _Sz2>
inline pair<_T1 const*, _T2 const*> make_pair(_T1 const (&__x)[_Sz1],
                                              _T2 const (&__y)[_Sz2])
{
  return pair<_T1 const*, _T2 const*>(static_cast<_T1 const*>(__x),
                                      static_cast<_T2 const*>(__y));
}


template <class _T1, class _T2>
inline pair<_T1, _T2> make_pair(const _T1& __x, const _T2& __y)
{
  return pair<_T1, _T2>(__x, __y);
}


}


namespace _STL { namespace rel_ops {

template <class _Tp>
inline bool operator!=(const _Tp& __x, const _Tp& __y) {
  return !(__x == __y);
}

template <class _Tp>
inline bool operator>(const _Tp& __x, const _Tp& __y) {
  return __y < __x;
}

template <class _Tp>
inline bool operator<=(const _Tp& __x, const _Tp& __y) {
  return !(__y < __x);
}

template <class _Tp>
inline bool operator>=(const _Tp& __x, const _Tp& __y) {
  return !(__x < __y);
}

} }
# 52 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h" 2






namespace _STL {

template <class _Tp>
inline void swap(_Tp& __a, _Tp& __b) {
  _Tp __tmp = __a;
  __a = __b;
  __b = __tmp;
}

template <class _ForwardIter1, class _ForwardIter2>
inline void iter_swap(_ForwardIter1 __i1, _ForwardIter2 __i2) {
  swap(*__i1, *__i2);
}





template <class _Tp>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b) { return __b < __a ? __b : __a; }
template <class _Tp>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b) { return __a < __b ? __b : __a; }







template <class _Tp, class _Compare>
inline const _Tp& (min)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__b, __a) ? __b : __a;
}

template <class _Tp, class _Compare>
inline const _Tp& (max)(const _Tp& __a, const _Tp& __b, _Compare __comp) {
  return __comp(__a, __b) ? __b : __a;
}
# 106 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h"
template <class _InputIter, class _OutputIter, class _Distance>
inline _OutputIter __copy(_InputIter __first, _InputIter __last,
                          _OutputIter __result,
                          const input_iterator_tag &, _Distance*) {
  for ( ; __first != __last; ++__result, ++__first)
    *__result = *__first;
  return __result;
}
# 134 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h"
template <class _RandomAccessIter, class _OutputIter, class _Distance>
inline _OutputIter
__copy(_RandomAccessIter __first, _RandomAccessIter __last,
       _OutputIter __result, const random_access_iterator_tag &, _Distance*) {
  for (_Distance __n = __last - __first; __n > 0; --__n) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return __result;
}

inline void*
__copy_trivial(const void* __first, const void* __last, void* __result) {
  return (__last == __first) ? __result :
    ((char*)memmove(__result, __first, ((const char*)__last - (const char*)__first))) +
    ((const char*)__last - (const char*)__first);
}




template <class _BidirectionalIter1, class _BidirectionalIter2,
          class _Distance>
inline _BidirectionalIter2 __copy_backward(_BidirectionalIter1 __first,
                                           _BidirectionalIter1 __last,
                                           _BidirectionalIter2 __result,
                                           const bidirectional_iterator_tag &,
                                           _Distance*)
{
  while (__first != __last)
    *--__result = *--__last;
  return __result;
}

template <class _RandomAccessIter, class _BidirectionalIter, class _Distance>
inline _BidirectionalIter __copy_backward(_RandomAccessIter __first,
                                          _RandomAccessIter __last,
                                          _BidirectionalIter __result,
                                          const random_access_iterator_tag &,
                                          _Distance*)
{
  for (_Distance __n = __last - __first; __n > 0; --__n)
    *--__result = *--__last;
  return __result;
}

inline void*
__copy_trivial_backward(const void* __first, const void* __last, void* __result) {
  const ptrdiff_t _Num = (const char*)__last - (const char*)__first;
  return (_Num > 0) ? memmove((char*)__result - _Num, __first, _Num) : __result ;
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy(__first, __last, __result,
                typename iterator_traits< _InputIter >::iterator_category(),
                (typename iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {


  return (_OutputIter)__copy_trivial(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return __copy_ptrs(__first, __last, __result,
                     _IsOKToMemCpy((typename iterator_traits< _InputIter >::value_type*)0,
                                   (typename iterator_traits< _OutputIter >::value_type*)0)._Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy(__first, __last, __result,
  typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
    return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}
template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_ptrs(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return (_OutputIter)__copy_trivial_backward(__first, __last, __result);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __false_type&) {
  return __copy_backward(__first, __last, __result, typename iterator_traits< _InputIter >::iterator_category(), (typename iterator_traits< _InputIter >::difference_type*)0);
}

template <class _InputIter, class _OutputIter>
inline _OutputIter __copy_backward_aux(_InputIter __first, _InputIter __last, _OutputIter __result, const __true_type&) {
  return __copy_backward_ptrs(__first, __last, __result,
                              _IsOKToMemCpy((typename iterator_traits< _InputIter >::value_type*)0,
                                            (typename iterator_traits< _OutputIter >::value_type*)0)._Ret());
}

template <class _InputIter, class _OutputIter>
inline _OutputIter copy_backward(_InputIter __first, _InputIter __last, _OutputIter __result) {
 
    return __copy_backward_aux(__first, __last, __result, _BothPtrType< _InputIter, _OutputIter> :: _Ret() );
}
# 282 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h"
template <class _InputIter, class _Size, class _OutputIter>
inline
pair<_InputIter, _OutputIter> __copy_n(_InputIter __first, _Size __count,
                                       _OutputIter __result,
                                       const input_iterator_tag &) {
  for ( ; __count > 0; --__count) {
    *__result = *__first;
    ++__first;
    ++__result;
  }
  return pair<_InputIter, _OutputIter>(__first, __result);
}

template <class _RAIter, class _Size, class _OutputIter>
inline pair<_RAIter, _OutputIter>
__copy_n(_RAIter __first, _Size __count,
         _OutputIter __result,
         const random_access_iterator_tag &) {
  _RAIter __last = __first + __count;
  return pair<_RAIter, _OutputIter>(__last, copy(__first, __last, __result));
}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
__copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 
  return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Size, class _OutputIter>
inline pair<_InputIter, _OutputIter>
copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
 
  return __copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}





template <class _ForwardIter, class _Tp>
inline
void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
 
  for ( ; __first != __last; ++__first)
    *__first = __val;
}

template <class _OutputIter, class _Size, class _Tp>
inline
_OutputIter fill_n(_OutputIter __first, _Size __n, const _Tp& __val) {
 
  for ( ; __n > 0; --__n, ++__first)
    *__first = __val;
  return __first;
}




inline void fill(unsigned char* __first, unsigned char* __last,
                 const unsigned char& __val) {
  unsigned char __tmp = __val;
  memset(__first, __tmp, __last - __first);
}

inline void fill(signed char* __first, signed char* __last,
                 const signed char& __val) {
  signed char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}

inline void fill(char* __first, char* __last, const char& __val) {
  char __tmp = __val;
  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
}



template <class _Size>
inline unsigned char* fill_n(unsigned char* __first, _Size __n,
                             const unsigned char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline signed char* fill_n(char* __first, _Size __n,
                           const signed char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}

template <class _Size>
inline char* fill_n(char* __first, _Size __n, const char& __val) {
  fill(__first, __first + __n, __val);
  return __first + __n;
}







template <class _InputIter1, class _InputIter2>
inline
pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                        _InputIter1 __last1,
                                        _InputIter2 __first2) {
 
 
  while (__first1 != __last1 && *__first1 == *__first2) {
    ++__first1;
    ++__first2;
  }
  return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                        _InputIter1 __last1,
                                        _InputIter2 __first2,
                                        _BinaryPredicate __binary_pred) {
 
 
  while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
    ++__first1;
    ++__first2;
  }
  return pair<_InputIter1, _InputIter2>(__first1, __first2);
}

template <class _InputIter1, class _InputIter2>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!(*__first1 == *__first2))
      return false;
  return true;
}

template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline
bool equal(_InputIter1 __first1, _InputIter1 __last1,
                  _InputIter2 __first2, _BinaryPredicate __binary_pred) {
 
 
  for ( ; __first1 != __last1; ++__first1, ++__first2)
    if (!__binary_pred(*__first1, *__first2))
      return false;
  return true;
}





template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2);

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp);

inline bool
lexicographical_compare(const unsigned char* __first1,
                        const unsigned char* __last1,
                        const unsigned char* __first2,
                        const unsigned char* __last2)
{
  const size_t __len1 = __last1 - __first1;
  const size_t __len2 = __last2 - __first2;
 
 

  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? (__result < 0) : (__len1 < __len2);
}



inline bool lexicographical_compare(const char* __first1, const char* __last1,
                                    const char* __first2, const char* __last2)
{
 
 

  return lexicographical_compare((const unsigned char*) __first1,
                                 (const unsigned char*) __last1,
                                 (const unsigned char*) __first2,
                                 (const unsigned char*) __last2);
}


template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2);

inline int
__lexicographical_compare_3way(const unsigned char* __first1,
                               const unsigned char* __last1,
                               const unsigned char* __first2,
                               const unsigned char* __last2)
{
  const ptrdiff_t __len1 = __last1 - __first1;
  const ptrdiff_t __len2 = __last2 - __first2;
  const int __result = memcmp(__first1, __first2, (min) (__len1, __len2));
  return __result != 0 ? __result
                       : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));
}



inline int
__lexicographical_compare_3way(const char* __first1, const char* __last1,
                               const char* __first2, const char* __last2)
{
  return __lexicographical_compare_3way((const unsigned char*) __first1,
                                        (const unsigned char*) __last1,
                                        (const unsigned char*) __first2,
                                        (const unsigned char*) __last2);
}




template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2);




template <class _InputIter, class _Tp>
inline typename iterator_traits<_InputIter>::difference_type
count(_InputIter __first, _InputIter __last, const _Tp& __val) {
 
  typename iterator_traits<_InputIter>::difference_type __n = 0;
  for ( ; __first != __last; ++__first)
    if (*__first == __val)
      ++__n;
  return __n;
}


template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val);
template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last, _Predicate __pred);


template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2, _BinaryPred __predicate);


template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp);

template <class _ForwardIter1, class _ForwardIter2,
          class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp);


template <class _ForwardIter, class _Tp>
inline void
replace(_ForwardIter __first, _ForwardIter __last,
        const _Tp& __old_value, const _Tp& __new_value) {
 
  for ( ; __first != __last; ++__first)
    if (*__first == __old_value)
      *__first = __new_value;
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
                              const _Tp& __val, const _Compare& __comp, _Distance*);

}


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.c" 1
# 32 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.c"
namespace _STL {

template <class _InputIter1, class _InputIter2>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2) {
 
   
    for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2) {
      if (*__first1 < *__first2)
 return true;
      if (*__first2 < *__first1)
 return false;
    }
  return __first1 == __last1 && __first2 != __last2;
}

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp) {
 
   
    for ( ; __first1 != __last1 && __first2 != __last2
     ; ++__first1, ++__first2) {
      if (__comp(*__first1, *__first2))
 return true;
      if (__comp(*__first2, *__first1))
 return false;
    }
  return __first1 == __last1 && __first2 != __last2;
}



template <class _InputIter1, class _InputIter2>
int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2)
{
  while (__first1 != __last1 && __first2 != __last2) {
    if (*__first1 < *__first2)
      return -1;
    if (*__first2 < *__first1)
      return 1;
    ++__first1;
    ++__first2;
  }
  if (__first2 == __last2) {
    return !(__first1 == __last1);
  }
  else {
    return -1;
  }
}


template <class _InputIter1, class _InputIter2>
int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2)
{
 
   
    return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);
}


template <class _RandomAccessIter, class _Tp>
inline _RandomAccessIter __find(_RandomAccessIter __first, _RandomAccessIter __last,
                                           const _Tp& __val,
                                           const random_access_iterator_tag &)
{
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;

    if (*__first == __val) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (*__first == __val) return __first;
    ++__first;
  case 2:
    if (*__first == __val) return __first;
    ++__first;
  case 1:
    if (*__first == __val) return __first;
    ++__first;
  case 0:
  default:
    return __last;
  }
}

template <class _RandomAccessIter, class _Predicate>
inline _RandomAccessIter __find_if(_RandomAccessIter __first, _RandomAccessIter __last,
                                              _Predicate __pred,
                                              const random_access_iterator_tag &)
{
  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count = (__last - __first) >> 2;

  for ( ; __trip_count > 0 ; --__trip_count) {
    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;

    if (__pred(*__first)) return __first;
    ++__first;
  }

  switch(__last - __first) {
  case 3:
    if (__pred(*__first)) return __first;
    ++__first;
  case 2:
    if (__pred(*__first)) return __first;
    ++__first;
  case 1:
    if (__pred(*__first)) return __first;

  case 0:
  default:
    return __last;
  }
}

template <class _InputIter, class _Tp>
inline _InputIter __find(_InputIter __first, _InputIter __last,
    const _Tp& __val,
    const input_iterator_tag &)
{
  while (__first != __last && !(*__first == __val))
    ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
inline _InputIter __find_if(_InputIter __first, _InputIter __last,
                            _Predicate __pred,
                            const input_iterator_tag &)
{
  while (__first != __last && !__pred(*__first))
    ++__first;
  return __first;
}

template <class _InputIter, class _Predicate>
_InputIter find_if(_InputIter __first, _InputIter __last,
                   _Predicate __pred) {
 
    return __find_if(__first, __last, __pred, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _InputIter, class _Tp>
_InputIter find(_InputIter __first, _InputIter __last, const _Tp& __val)
{
 
    return __find(__first, __last, __val, typename iterator_traits< _InputIter >::iterator_category());
}

template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
                     _ForwardIter2 __first2, _ForwardIter2 __last2,
                     _BinaryPred __predicate)
{
 
   

    if (__first1 == __last1 || __first2 == __last2)
      return __first1;


  _ForwardIter2 __tmp(__first2);
  ++__tmp;
  if (__tmp == __last2) {
    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
      ++__first1;
    return __first1;
  }



  _ForwardIter2 __p1, __p;

  __p1 = __first2; ++__p1;



  while (__first1 != __last1) {
    while (__first1 != __last1) {
      if (__predicate(*__first1, *__first2))
        break;
      ++__first1;
    }
    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
      ++__first1;
    if (__first1 == __last1)
      return __last1;

    __p = __p1;
    _ForwardIter1 __current = __first1;
    if (++__current == __last1) return __last1;

    while (__predicate(*__current, *__p)) {
      if (++__p == __last2)
        return __first1;
      if (++__current == __last1)
        return __last1;
    }

    ++__first1;
  }
  return __first1;
}



template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
_InputIter __find_first_of(_InputIter __first1, _InputIter __last1,
                           _ForwardIter __first2, _ForwardIter __last2,
                           _BinaryPredicate __comp) {
  for ( ; __first1 != __last1; ++__first1)
    for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
      if (__comp(*__first1, *__iter))
        return __first1;
  return __last1;
}
# 282 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.c"
template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1 __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
                         _ForwardIter2 __first2, _ForwardIter2 __last2,
                         const forward_iterator_tag &, const forward_iterator_tag &,
                         _BinaryPredicate __comp)
{
  if (__first2 == __last2)
    return __last1;
  else {
    _ForwardIter1 __result = __last1;
    while (1) {
      _ForwardIter1 __new_result
        = search(__first1, __last1, __first2, __last2, __comp);
      if (__new_result == __last1)
        return __result;
      else {
        __result = __new_result;
        __first1 = __new_result;
        ++__first1;
      }
    }
  }
}





}
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator.h" 1
# 37 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator.h"
namespace _STL {
# 46 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iterator.h"
template <class _Iterator>
class reverse_iterator :
  public iterator<typename iterator_traits<_Iterator>::iterator_category,
                  typename iterator_traits<_Iterator>::value_type,
                  typename iterator_traits<_Iterator>::difference_type,
                  typename iterator_traits<_Iterator>::pointer,
                  typename iterator_traits<_Iterator>::reference>
{
protected:
  _Iterator current;
  typedef reverse_iterator<_Iterator> _Self;
public:
  typedef typename iterator_traits<_Iterator>::iterator_category iterator_category;
  typedef typename iterator_traits<_Iterator>::value_type value_type;
  typedef typename iterator_traits<_Iterator>::difference_type difference_type;
  typedef typename iterator_traits<_Iterator>::pointer pointer;
  typedef typename iterator_traits<_Iterator>::reference reference;
  typedef _Iterator iterator_type;
public:
  reverse_iterator() {}
  explicit reverse_iterator(iterator_type __x) : current(__x) {}
  reverse_iterator(const _Self& __x) : current(__x.current) {}
  _Self& operator = (const _Self& __x) { current = __x.base(); return *this; }

  template <class _Iter>
  reverse_iterator(const reverse_iterator<_Iter>& __x) : current(__x.base()) {}
  template <class _Iter>
  _Self& operator = (const reverse_iterator<_Iter>& __x) { current = __x.base(); return *this; }


  iterator_type base() const { return current; }
  reference operator*() const {
    _Iterator __tmp = current;
    return *--__tmp;
  }
  pointer operator->() const { return &(operator*()); }
  _Self& operator++() {
    --current;
    return *this;
  }
  _Self operator++(int) {
    _Self __tmp = *this;
    --current;
    return __tmp;
  }
  _Self& operator--() {
    ++current;
    return *this;
  }
  _Self operator--(int) {
    _Self __tmp = *this;
    ++current;
    return __tmp;
  }

  _Self operator+(difference_type __n) const {
    return _Self(current - __n);
  }
  _Self& operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  _Self operator-(difference_type __n) const {
    return _Self(current + __n);
  }
  _Self& operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  reference operator[](difference_type __n) const { return *(*this + __n); }
};

template <class _Iterator>
inline bool operator==(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return __x.base() == __y.base();
}

template <class _Iterator>
inline bool operator<(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return __y.base() < __x.base();
}



template <class _Iterator>
inline bool operator!=(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return !(__x == __y);
}

template <class _Iterator>
inline bool operator>(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return __y < __x;
}

template <class _Iterator>
inline bool operator<=(const reverse_iterator<_Iterator>& __x,
                       const reverse_iterator<_Iterator>& __y) {
  return !(__y < __x);
}

template <class _Iterator>
inline bool operator>=(const reverse_iterator<_Iterator>& __x,
                      const reverse_iterator<_Iterator>& __y) {
  return !(__x < __y);
}



template <class _Iterator>



inline typename reverse_iterator<_Iterator>::difference_type

operator-(const reverse_iterator<_Iterator>& __x,
          const reverse_iterator<_Iterator>& __y) {
  return __y.base() - __x.base();
}

template <class _Iterator, class _DifferenceType>
inline reverse_iterator<_Iterator>
operator+(_DifferenceType n,const reverse_iterator<_Iterator>& x) {
  return x.operator+(n);
}



template <class _Container>
class back_insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;

  explicit back_insert_iterator(_Container& __x) : container(&__x) {}
  back_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    container->push_back(__val);
    return *this;
  }
  back_insert_iterator<_Container>& operator*() { return *this; }
  back_insert_iterator<_Container>& operator++() { return *this; }
  back_insert_iterator<_Container> operator++(int) { return *this; }
};

template <class _Container>
inline back_insert_iterator<_Container> back_inserter(_Container& __x) {
  return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class front_insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  explicit front_insert_iterator(_Container& __x) : container(&__x) {}
  front_insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    container->push_front(__val);
    return *this;
  }
  front_insert_iterator<_Container>& operator*() { return *this; }
  front_insert_iterator<_Container>& operator++() { return *this; }
  front_insert_iterator<_Container>& operator++(int) { return *this; }
};

template <class _Container>
inline front_insert_iterator<_Container> front_inserter(_Container& __x) {
  return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class insert_iterator
  : public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  _Container* container;
  typename _Container::iterator iter;
public:
  typedef _Container container_type;
  typedef output_iterator_tag iterator_category;
  insert_iterator(_Container& __x, typename _Container::iterator __i)
    : container(&__x), iter(__i) {}
  insert_iterator<_Container>&
  operator=(const typename _Container::value_type& __val) {
    iter = container->insert(iter, __val);
    ++iter;
    return *this;
  }
  insert_iterator<_Container>& operator*() { return *this; }
  insert_iterator<_Container>& operator++() { return *this; }
  insert_iterator<_Container>& operator++(int) { return *this; }
};

template <class _Container, class _Iterator>
inline insert_iterator<_Container>
inserter(_Container& __x, _Iterator __i)
{
  typedef typename _Container::iterator __iter;
  return insert_iterator<_Container>(__x, __iter(__i));
}

}
# 313 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.c" 2
namespace _STL {


template <class _BidirectionalIter1, class _BidirectionalIter2,
  class _BinaryPredicate>
_BidirectionalIter1
__find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
           _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
           const bidirectional_iterator_tag &, const bidirectional_iterator_tag &,
           _BinaryPredicate __comp)
{
  typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
  typedef reverse_iterator<_BidirectionalIter2> _RevIter2;

  _RevIter1 __rlast1(__first1);
  _RevIter2 __rlast2(__first2);
  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
                               _RevIter2(__last2), __rlast2,
                               __comp);

  if (__rresult == __rlast1)
    return __last1;
  else {
    _BidirectionalIter1 __result = __rresult.base();
    advance(__result, -distance(__first2, __last2));
    return __result;
  }
}


template <class _ForwardIter1, class _ForwardIter2,
  class _BinaryPredicate>
_ForwardIter1
find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
         _ForwardIter2 __first2, _ForwardIter2 __last2,
         _BinaryPredicate __comp)
{
 
   
    return __find_end(__first1, __last1, __first2, __last2,

        typename iterator_traits< _ForwardIter1 >::iterator_category(),
        typename iterator_traits< _ForwardIter2 >::iterator_category(),




        __comp);
}

template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
      const _Tp& __val, const _Compare& __comp, _Distance*)
{
  _Distance __len = distance(__first, __last);
  _Distance __half;
  _ForwardIter __middle;

  while (__len > 0) {
    __half = __len >> 1;
    __middle = __first;
    advance(__middle, __half);
    if (__comp(*__middle, __val)) {
      __first = __middle;
      ++__first;
      __len = __len - __half - 1;
    }
    else
      __len = __half;
  }
  return __first;
}

}
# 576 "c:/marmalade/6.2/s3e/h/std/c++/stl/_algobase.h" 2
# 39 "c:/marmalade/6.2/s3e/h/std/c++/stl/_uninitialized.h" 2






namespace _STL {





template <class _InputIter, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     const __true_type&) {
  return __copy_aux(__first, __last, __result, _BothPtrType< _InputIter, _ForwardIter> :: _Ret());
}

template <class _InputIter, class _ForwardIter>
inline
_ForwardIter
__uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result,
                     const __false_type&)
{
  _ForwardIter __cur = __result;
  {
    for ( ; __first != __last; ++__first, ++__cur)
      _Construct(&*__cur, *__first);
    return __cur;
  }
  ;



}

template <class _InputIter, class _ForwardIter>
inline _ForwardIter
uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result) {
  return __uninitialized_copy(__first, __last, __result, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}

inline char*
uninitialized_copy(const char* __first, const char* __last, char* __result) {
  return (char*)__copy_trivial (__first, __last, __result);
}


inline wchar_t*
uninitialized_copy(const wchar_t* __first, const wchar_t* __last, wchar_t* __result) {
  return (wchar_t*)__copy_trivial (__first, __last, __result);
}





template <class _InputIter, class _Size, class _ForwardIter>
inline
pair<_InputIter, _ForwardIter>
__uninitialized_copy_n(_InputIter __first, _Size __count,
                       _ForwardIter __result,
                       const input_iterator_tag &)
{
  _ForwardIter __cur = __result;
  {
    for ( ; __count > 0 ; --__count, ++__first, ++__cur)
      _Construct(&*__cur, *__first);
    return pair<_InputIter, _ForwardIter>(__first, __cur);
  }
  ;



}
# 135 "c:/marmalade/6.2/s3e/h/std/c++/stl/_uninitialized.h"
template <class _RandomAccessIter, class _Size, class _ForwardIter>
inline pair<_RandomAccessIter, _ForwardIter>
__uninitialized_copy_n(_RandomAccessIter __first, _Size __count, _ForwardIter __result, const random_access_iterator_tag &) {
  _RandomAccessIter __last = __first + __count;
  return pair<_RandomAccessIter, _ForwardIter>( __last, __uninitialized_copy(__first, __last, __result,
                                                                             typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type()));
}


template <class _InputIter, class _Size, class _ForwardIter>
inline pair<_InputIter, _ForwardIter>
uninitialized_copy_n(_InputIter __first, _Size __count,
                     _ForwardIter __result) {
  return __uninitialized_copy_n(__first, __count, __result, typename iterator_traits< _InputIter >::iterator_category());
}




template <class _ForwardIter, class _Tp>
inline void
__uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
                     const _Tp& __x, const __true_type&) {
  _STL::fill(__first, __last, __x);
}

template <class _ForwardIter, class _Tp>
inline void
__uninitialized_fill(_ForwardIter __first, _ForwardIter __last,
                     const _Tp& __x, const __false_type&)
{
  _ForwardIter __cur = __first;
  {
    for ( ; __cur != __last; ++__cur)
      _Construct(&*__cur, __x);
  }
  ;
}

template <class _ForwardIter, class _Tp>
inline void uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __x) {
  __uninitialized_fill(__first, __last, __x, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}



template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
__uninitialized_fill_n(_ForwardIter __first, _Size __n,
                       const _Tp& __x, const __true_type&) {
  return _STL::fill_n(__first, __n, __x);
}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
__uninitialized_fill_n(_ForwardIter __first, _Size __n,
                       const _Tp& __x, const __false_type&)
{
  _ForwardIter __cur = __first;
  {
    for ( ; __n > 0; --__n, ++__cur)
      _Construct(&*__cur, __x);
    return __cur;
  }
  ;



}

template <class _ForwardIter, class _Size, class _Tp>
inline _ForwardIter
uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x) {
  return __uninitialized_fill_n(__first, __n, __x, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
}
# 219 "c:/marmalade/6.2/s3e/h/std/c++/stl/_uninitialized.h"
template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                          _InputIter2 __first2, _InputIter2 __last2,
                          _ForwardIter __result, __true_type)
{
  return __uninitialized_copy(__first2, __last2,
                              __uninitialized_copy(__first1, __last1, __result, __true_type()), __true_type());
}

template <class _InputIter1, class _InputIter2, class _ForwardIter>
inline _ForwardIter
__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                          _InputIter2 __first2, _InputIter2 __last2,
                          _ForwardIter __result, __false_type)
{
  _ForwardIter __mid = __uninitialized_copy(__first1, __last1, __result, typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
  {
    return __uninitialized_copy(__first2, __last2, __mid , typename __type_traits< typename iterator_traits< _ForwardIter >::value_type >::is_POD_type());
  }
  ;



}




template <class _ForwardIter, class _Tp, class _InputIter>
inline _ForwardIter
__uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid, const _Tp& __x,
                          _InputIter __first, _InputIter __last)
{
  typedef typename __type_traits<_Tp>::is_POD_type _I_POD;
  __uninitialized_fill(__result, __mid, __x, _I_POD());
  {
    return __uninitialized_copy(__first, __last, __mid, _I_POD());
  }
  ;



}




template <class _InputIter, class _ForwardIter, class _Tp>
inline void
__uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,
                          _ForwardIter __first2, _ForwardIter __last2,
                          const _Tp& __x)
{
  typedef typename __type_traits<_Tp>::is_POD_type _I_POD;
  _ForwardIter __mid2 = __uninitialized_copy(__first1, __last1, __first2, _I_POD());
  {
    __uninitialized_fill(__mid2, __last2, __x, _I_POD());
  }
  ;
}

}
# 41 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.h" 2


namespace _STL {

template <class _Tp>
pair<_Tp*, ptrdiff_t>
__get_temporary_buffer(ptrdiff_t __len, _Tp*);



template <class _Tp>
inline pair<_Tp*, ptrdiff_t> get_temporary_buffer(ptrdiff_t __len) {
  return __get_temporary_buffer(__len, (_Tp*) 0);
}







template <class _Tp>
inline pair<_Tp*, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __len, _Tp*) {
  return __get_temporary_buffer(__len, (_Tp*) 0);
}



template <class _Tp>
inline void return_temporary_buffer(_Tp* __p) {

  free((char*)__p);
}

template <class _ForwardIterator, class _Tp>
class _Temporary_buffer {
private:
  ptrdiff_t _M_original_len;
  ptrdiff_t _M_len;
  _Tp* _M_buffer;

  void _M_allocate_buffer() {
    _M_original_len = _M_len;
    _M_buffer = 0;

    if (_M_len > (ptrdiff_t)(0x7fffffffL / sizeof(_Tp)))
      _M_len = 0x7fffffffL / sizeof(_Tp);

    while (_M_len > 0) {
      _M_buffer = (_Tp*) malloc(_M_len * sizeof(_Tp));
      if (_M_buffer)
        break;
      _M_len /= 2;
    }
  }

  void _M_initialize_buffer(const _Tp&, const __true_type&) {}
  void _M_initialize_buffer(const _Tp& val, const __false_type&) {
    uninitialized_fill_n(_M_buffer, _M_len, val);
  }

public:
  ptrdiff_t size() const { return _M_len; }
  ptrdiff_t requested_size() const { return _M_original_len; }
  _Tp* begin() { return _M_buffer; }
  _Tp* end() { return _M_buffer + _M_len; }

  _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) {




     typedef typename __type_traits<_Tp>::has_trivial_default_constructor _Trivial;

    {
      _M_len = distance(__first, __last);
      _M_allocate_buffer();
      if (_M_len > 0)
        _M_initialize_buffer(*__first, _Trivial());
    }
    ;
  }

  ~_Temporary_buffer() {
    _STL::_Destroy(_M_buffer, _M_buffer + _M_len);
    free(_M_buffer);
  }

private:

  _Temporary_buffer(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
  void operator=(const _Temporary_buffer<_ForwardIterator, _Tp>&) {}
};





template <class _ForwardIterator,
          class _Tp

                    = typename iterator_traits<_ForwardIterator>::value_type

         >
struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>
{
  temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _Temporary_buffer<_ForwardIterator, _Tp>(__first, __last) {}
  ~temporary_buffer() {}
};



}


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.c" 1
# 33 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.c"
namespace _STL {

template <class _Tp>
pair<_Tp*, ptrdiff_t>
__get_temporary_buffer(ptrdiff_t __len, _Tp*)
{
  if (__len > ptrdiff_t(0x7fffffffL / sizeof(_Tp)))
    __len = 0x7fffffffL / sizeof(_Tp);

  while (__len > 0) {
    _Tp* __tmp = (_Tp*) malloc((size_t)__len * sizeof(_Tp));
    if (__tmp != 0)
      return pair<_Tp*, ptrdiff_t>(__tmp, __len);
    __len /= 2;
  }

  return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);
}
}
# 159 "c:/marmalade/6.2/s3e/h/std/c++/stl/_tempbuf.h" 2
# 37 "c:/marmalade/6.2/s3e/h/std/c++/memory" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_raw_storage_iter.h" 1
# 37 "c:/marmalade/6.2/s3e/h/std/c++/stl/_raw_storage_iter.h"
namespace _STL {

template <class _ForwardIterator, class _Tp>
class raw_storage_iterator



{
protected:
  _ForwardIterator _M_iter;
public:
  typedef output_iterator_tag iterator_category;

  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

  explicit raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}
  raw_storage_iterator<_ForwardIterator, _Tp>& operator*() { return *this; }
  raw_storage_iterator<_ForwardIterator, _Tp>& operator=(const _Tp& __element) {
    _Construct(&*_M_iter, __element);
    return *this;
  }
  raw_storage_iterator<_ForwardIterator, _Tp>& operator++() {
    ++_M_iter;
    return *this;
  }
  raw_storage_iterator<_ForwardIterator, _Tp> operator++(int) {
    raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
    ++_M_iter;
    return __tmp;
  }
};





}
# 41 "c:/marmalade/6.2/s3e/h/std/c++/memory" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_auto_ptr.h" 1
# 22 "c:/marmalade/6.2/s3e/h/std/c++/stl/_auto_ptr.h"
namespace _STL {

class __ptr_base {
public:
  void* _M_p;
  void __set(const void* p) { _M_p = const_cast<void*>(p); }
  void __set(void* p) { _M_p = p; }
};

template <class _Tp> class auto_ptr_ref {
public:
  __ptr_base& _M_r;
  _Tp* const _M_p;

  auto_ptr_ref(__ptr_base& __r, _Tp* __p) : _M_r(__r), _M_p(__p) { }

  _Tp* release() const { _M_r.__set((void*)0); return _M_p; }

};

template<class _Tp> class auto_ptr : public __ptr_base {
public:
  typedef _Tp element_type;
  typedef auto_ptr<_Tp> _Self;

  _Tp* release() {
    _Tp* __px = this->get();
    this->_M_p = 0;
    return __px;
  }

  void reset(_Tp* __px=0) {
    _Tp* __pt = this->get();
    if (__px != __pt)
      delete __pt;
    this->__set(__px);
  }

  _Tp* get() const { return reinterpret_cast<_Tp*>(const_cast<void*>(_M_p)); }


  _Tp* operator->() const {
   
    return get();
  }

  _Tp& operator*() const {
   
    return *get();
  }

  auto_ptr() { this->_M_p = 0; }

  explicit auto_ptr(_Tp* __px) { this->__set(__px); }



  template<class _Tp1> auto_ptr(auto_ptr<_Tp1>& __r) {
    _Tp* __conversionCheck = __r.release();
    this->__set(__conversionCheck);
  }

  template<class _Tp1> auto_ptr<_Tp>& operator=(auto_ptr<_Tp1>& __r) {
    _Tp* __conversionCheck = __r.release();
    reset(__conversionCheck);
    return *this;
  }


  auto_ptr(_Self& __r) { this->__set(__r.release()); }

  _Self& operator=(_Self& __r) {
    reset(__r.release());
    return *this;
  }

  ~auto_ptr() { delete this->get(); }

  auto_ptr(auto_ptr_ref<_Tp> __r) {
    this->__set(__r.release());
  }

  _Self& operator=(auto_ptr_ref<_Tp> __r) {
    reset(__r.release());
    return *this;
  }


  template<class _Tp1> operator auto_ptr_ref<_Tp1>() {
    return auto_ptr_ref<_Tp1>(*this, this->get());
  }
  template<class _Tp1> operator auto_ptr<_Tp1>() {
    return auto_ptr<_Tp1>(release());
  }





};
}
# 44 "c:/marmalade/6.2/s3e/h/std/c++/memory" 2
# 24 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/cctype" 1
# 51 "c:/marmalade/6.2/s3e/h/std/c++/cctype"
namespace _STL {
using ::isalnum;
using ::isalpha;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;
}
# 28 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_fwd.h" 1
# 23 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_fwd.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/iosfwd" 1
# 28 "c:/marmalade/6.2/s3e/h/std/c++/iosfwd"
         





# 1 "c:/marmalade/6.2/s3e/h/std/c++/cwchar" 1
# 49 "c:/marmalade/6.2/s3e/h/std/c++/cwchar"
# 1 "c:/marmalade/6.2/s3e/h/ext/../std/wchar.h" 1
# 17 "c:/marmalade/6.2/s3e/h/ext/../std/wchar.h"
# 1 "c:/marmalade/6.2/s3e/h/std/time.h" 1
# 19 "c:/marmalade/6.2/s3e/h/std/time.h"
typedef long time_t;





typedef long clock_t;




struct tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
};



struct timespec
{
    time_t tv_sec;
    long int tv_nsec;
};

extern "C" {






time_t time(time_t *t);

void tzset(void);

char *asctime(const struct tm *tm);
char *asctime_r(const struct tm *tm, char *buf);

char *ctime(const time_t *timep);
char *ctime_r(const time_t *timep, char *buf);

struct tm *gmtime(const time_t *timep);
struct tm *gmtime_r(const time_t *timep, struct tm *result);

struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);

time_t mktime(struct tm *tm);

size_t strftime(char *s, size_t max, const char *format, const struct tm *tm);

clock_t clock(void);

double difftime(time_t time1, time_t time0);

int nanosleep(const struct timespec *req, struct timespec *rem);



    extern char *_tzname[2];
    extern int _daylight;
    extern long int _timezone;
# 101 "c:/marmalade/6.2/s3e/h/std/time.h"
typedef int clockid_t;

int clock_getres(clockid_t clk_id, struct timespec *res);

int clock_gettime(clockid_t clk_id, struct timespec *tp);

int clock_settime(clockid_t clk_id, const struct timespec *tp);

}

# 1 "c:/marmalade/6.2/s3e/h/std/sys/time.h" 1
# 16 "c:/marmalade/6.2/s3e/h/std/sys/time.h"
# 1 "c:/marmalade/6.2/s3e/h/std/time.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/sys/time.h" 2



extern "C" {

typedef long suseconds_t;
struct timeval
{
    time_t tv_sec;
    suseconds_t tv_usec;
};

struct _timezone
{
    int tz_minuteswest;
    int tz_dsttime;
};

int gettimeofday(struct timeval *tv, struct _timezone *tz);
int settimeofday(const struct timeval *tv , const struct _timezone *tz);

int utimes(const char *filename, const struct timeval times[2]);

}
# 112 "c:/marmalade/6.2/s3e/h/std/time.h" 2
# 18 "c:/marmalade/6.2/s3e/h/ext/../std/wchar.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/wctype.h" 1
# 18 "c:/marmalade/6.2/s3e/h/std/wctype.h"
extern "C" {

typedef const int32* wctrans_t;

wctype_t wctype(const char *name);
wctrans_t wctrans(const char *name);
int iswctype(wint_t wc, wctype_t desc);
wint_t towctrans(wint_t wc, wctrans_t desc);

int towupper(int c);
int towlower(int c);
int iswalnum(int c);
int iswalpha(int c);
int iswascii(int c);
int iswblank(int c);
int iswcntrl(int c);
int iswdigit(int c);
int iswgraph(int c);
int iswlower(int c);
int iswprint(int c);
int iswpunct(int c);
int iswspace(int c);
int iswupper(int c);
int iswxdigit(int c);

}
# 19 "c:/marmalade/6.2/s3e/h/ext/../std/wchar.h" 2


extern "C" {



typedef int mbstate_t;

wchar_t fgetwc(FILE *stream);
wchar_t *fgetws(wchar_t *ws, int n, FILE *stream);
wchar_t fputwc(wchar_t wc, FILE *stream);
wchar_t putwc(wchar_t wc, FILE *stream);
wchar_t getwc(FILE *stream);
wchar_t getwchar(void);
wchar_t ungetwc(wchar_t wc, FILE *stream);

int fputws(const wchar_t *ws, FILE *stream);
int fwide(FILE *stream, int mode);

int mbsinit(const mbstate_t *ps);
wchar_t btowc(int c);
size_t mbrlen(const char *s, size_t n, mbstate_t *ps);
size_t mbsrtowcs(wchar_t *dest, const char **src, size_t len, mbstate_t *ps);
size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *ps);
wchar_t putwchar(wchar_t wc);
wchar_t *wmemset(wchar_t *wcs, wchar_t wc, size_t n);
wchar_t *wcspbrk(const wchar_t *wcs, const wchar_t *accept);
wchar_t *wcsrchr(const wchar_t *wcs, wchar_t wc);
wchar_t *wmemchr(const wchar_t *s, wchar_t c, size_t n);
int wmemcmp(const wchar_t *s1, const wchar_t *s2, size_t n);
size_t wcslen(const wchar_t *s);
size_t wcsnlen(const wchar_t *s, size_t n);
size_t wcsrtombs(char *dest, const wchar_t **src, size_t len, mbstate_t *ps);
wchar_t *wmemmove(wchar_t *dest, const wchar_t *src, size_t n);
wchar_t *wmemcpy(wchar_t *dest, const wchar_t *src, size_t n);
wchar_t *wcsstr(const wchar_t *haystack, const wchar_t *needle);
wchar_t *wcschr(const wchar_t *wcs, wchar_t wc);
size_t wcsspn(const wchar_t *wcs, const wchar_t *accept);
wchar_t *wcstok(wchar_t *wcs, const wchar_t *delim, wchar_t **ptr);
wchar_t *wcsncpy(wchar_t *dest, const wchar_t *src, size_t n);
wchar_t *wcscat(wchar_t *dest, const wchar_t *src);
wchar_t *wcscpy(wchar_t *dest, const wchar_t *src);
size_t wcsxfrm (wchar_t *s1, const wchar_t *s2, size_t n);
float wcstof(const wchar_t *nptr, wchar_t **endptr);

int wcscoll (const wchar_t *s1, const wchar_t *s2);

int wprintf(const wchar_t *format, ...);
int fwprintf(FILE *stream, const wchar_t *format, ...);
int swprintf(wchar_t *wcs, size_t maxlen, const wchar_t *format, ...);

int wscanf(const wchar_t *format, ...);
int fwscanf(FILE *stream, const wchar_t *format, ...);
int swscanf(const wchar_t *str, const wchar_t *format, ...);

size_t wcrtomb(char *s, wchar_t wc, mbstate_t *ps);
int wcscmp(const wchar_t *s1, const wchar_t *s2);
int wcsncmp(const wchar_t *s1, const wchar_t *s2, size_t n);
size_t wcsftime(wchar_t *s, size_t maxsize, const wchar_t *format, const struct tm *tp);
int wctob(wint_t c);
size_t wcscspn(const wchar_t *wcs, const wchar_t *reject);
wchar_t *wcsncat(wchar_t *dest, const wchar_t *src, size_t n);

int64 wcstoll(wchar_t *nptr, wchar_t **endptr, int base);
uint64 wcstoull(wchar_t *nptr, wchar_t **endptr, int base);
long int wcstol(const wchar_t *nptr, wchar_t **endptr, int base);
unsigned long int wcstoul(const wchar_t *nptr, wchar_t **endptr, int base);
double wcstod(const wchar_t *nptr, wchar_t **endptr);
long double wcstold(wchar_t *nptr, wchar_t **endptr);

int vwprintf(const wchar_t *format, va_list args);
int vfwprintf(FILE *stream, const wchar_t *format, va_list args);
int vswprintf(wchar_t *wcs, size_t maxlen, const wchar_t *format, va_list args);

int vfwscanf(FILE *s, const wchar_t *format, va_list arg);
int vswscanf(wchar_t *s, wchar_t *format, va_list arg);
int vwscanf(wchar_t *format, va_list arg);






}
# 50 "c:/marmalade/6.2/s3e/h/std/c++/cwchar" 2
# 98 "c:/marmalade/6.2/s3e/h/std/c++/cwchar"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_cwchar.h" 1
# 21 "c:/marmalade/6.2/s3e/h/std/c++/stl/_cwchar.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/cwchar" 1
# 22 "c:/marmalade/6.2/s3e/h/std/c++/stl/_cwchar.h" 2
# 99 "c:/marmalade/6.2/s3e/h/std/c++/cwchar" 2
# 107 "c:/marmalade/6.2/s3e/h/std/c++/cwchar"
namespace _STL {





using ::wint_t;






using ::size_t;


using ::mbstate_t;
# 147 "c:/marmalade/6.2/s3e/h/std/c++/cwchar"
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;





using ::fwide;

using ::fwprintf;
using ::fwscanf;
using ::getwchar;



using ::getwc;
using ::ungetwc;

using ::putwc;
using ::putwchar;




using ::swprintf;
using ::swscanf;
using ::vfwprintf;
using ::vwprintf;
using ::vswprintf;


using ::wcsftime;

using ::wcstok;




using ::wcscat;
using ::wcsrchr;
using ::wcscmp;
using ::wcscoll;

using ::wcscpy;
using ::wcscspn;

using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcspbrk;
using ::wcschr;

using ::wcsspn;
using ::wcsxfrm;





using ::wcstod;
using ::wcstol;





using ::wcsstr;
using ::wmemchr;




using ::wctob;
using ::wmemcmp;

using ::wmemmove;
using ::wprintf;
using ::wscanf;



using ::wmemcpy;
using ::wmemset;



}
# 35 "c:/marmalade/6.2/s3e/h/std/c++/iosfwd" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iosfwd.h" 1
# 22 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iosfwd.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/char_traits.h" 1
# 53 "c:/marmalade/6.2/s3e/h/std/c++/stl/char_traits.h"
namespace _STL {



template <class _Tp> class allocator;
# 67 "c:/marmalade/6.2/s3e/h/std/c++/stl/char_traits.h"
typedef long streamoff;


typedef ptrdiff_t streamsize;




template <class _StateT> class fpos
{
public:
  fpos(streamoff __pos) : _M_pos(__pos), _M_st(_StateT()) {}
  fpos() : _M_pos(0), _M_st(_StateT()) {}

  operator streamoff() const { return _M_pos; }

  bool operator==(const fpos<_StateT>& __y) const
    { return _M_pos == __y._M_pos; }
  bool operator!=(const fpos<_StateT>& __y) const
    { return _M_pos != __y._M_pos; }

  fpos<_StateT>& operator+=(streamoff __off) {
    _M_pos += __off;
    return *this;
  }
  fpos<_StateT>& operator-=(streamoff __off) {
    _M_pos -= __off;
    return *this;
  }

  fpos<_StateT> operator+(streamoff __off) {
    fpos<_StateT> __tmp(*this);
    __tmp += __off;
    return __tmp;
  }
  fpos<_StateT> operator-(streamoff __off) {
    fpos<_StateT> __tmp(*this);
    __tmp -= __off;
    return __tmp;
  }

public:
  _StateT state() const { return _M_st; }
  void state(_StateT __st) { _M_st = __st; }
private:
  streamoff _M_pos;
  _StateT _M_st;
};

typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;




template <class _CharT, class _IntT> class __char_traits_base {
public:
  typedef _CharT char_type;
  typedef _IntT int_type;

  typedef streamoff off_type;
  typedef streampos pos_type;



  typedef mbstate_t state_type;



  static void assign(char_type& __c1, const char_type& __c2) { __c1 = __c2; }
  static bool eq(const _CharT& __c1, const _CharT& __c2)
    { return __c1 == __c2; }
  static bool lt(const _CharT& __c1, const _CharT& __c2)
    { return __c1 < __c2; }

  static int compare(const _CharT* __s1, const _CharT* __s2, size_t __n) {
    for (size_t __i = 0; __i < __n; ++__i)
      if (!eq(__s1[__i], __s2[__i]))
        return __s1[__i] < __s2[__i] ? -1 : 1;
    return 0;
  }

  static size_t length(const _CharT* __s) {
    const _CharT _NullChar = _CharT();
    size_t __i;
    for (__i = 0; !eq(__s[__i], _NullChar); ++__i)
      {}
    return __i;
  }

  static const _CharT* find(const _CharT* __s, size_t __n, const _CharT& __c) {
    for ( ; __n > 0 ; ++__s, --__n)
      if (eq(*__s, __c))
        return __s;
    return 0;
  }


  static _CharT* move(_CharT* __s1, const _CharT* __s2, size_t _Sz) {
    return (_Sz == 0 ? __s1 : (_CharT*)memmove(__s1, __s2, _Sz * sizeof(_CharT)));
  }

  static _CharT* copy(_CharT* __s1, const _CharT* __s2, size_t __n) {
    return (__n == 0 ? __s1 :
     (_CharT*)memcpy(__s1, __s2, __n * sizeof(_CharT)));
    }

  static _CharT* assign(_CharT* __s, size_t __n, _CharT __c) {
    for (size_t __i = 0; __i < __n; ++__i)
      __s[__i] = __c;
    return __s;
  }

  static int_type not_eof(const int_type& __c) {
    return !eq_int_type(__c, eof()) ? __c : static_cast<int_type>(0);
  }

  static char_type to_char_type(const int_type& __c) {
    return (char_type)__c;
  }

  static int_type to_int_type(const char_type& __c) {
    return (int_type)__c;
  }

  static bool eq_int_type(const int_type& __c1, const int_type& __c2) {
    return __c1 == __c2;
  }

  static int_type eof() {
    return (int_type)-1;

  }
};






template <class _CharT> class char_traits
  : public __char_traits_base<_CharT, _CharT>
{};



template<> class char_traits<char>
  : public __char_traits_base<char, int>
{
public:
  typedef char char_type;
  typedef int int_type;

  typedef streamoff off_type;

  typedef streampos pos_type;
  typedef mbstate_t state_type;



  static char to_char_type(const int& __c) {
    return (char)(unsigned char)__c;
  }

  static int to_int_type(const char& __c) {
    return (unsigned char)__c;
  }

  static int compare(const char* __s1, const char* __s2, size_t __n)
    { return memcmp(__s1, __s2, __n); }

  static size_t length(const char* __s) { return strlen(__s); }

  static void assign(char& __c1, const char& __c2) { __c1 = __c2; }

  static char* assign(char* __s, size_t __n, char __c)
    { memset(__s, __c, __n); return __s; }
};



template<> class char_traits<wchar_t>
  : public __char_traits_base<wchar_t, wint_t>
{};


}
# 23 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iosfwd.h" 2


namespace _STL {

class ios_base;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_streambuf;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_istream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ostream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_stringbuf;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_istringstream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_ostringstream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT> >
class basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_filebuf;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ifstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_ofstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT> >
class istreambuf_iterator;

template <class _CharT, class _Traits = char_traits<_CharT> >
class ostreambuf_iterator;

typedef basic_ios<char, char_traits<char> > ios;


typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;



class locale;
# 95 "c:/marmalade/6.2/s3e/h/std/c++/stl/_iosfwd.h"
template <class _Facet> inline const _Facet& use_facet(const locale&);


template <class _CharT> class ctype;
template <class _CharT> class ctype_byname;
template <class _CharT> class collate;
template <class _CharT> class collate_byname;

template<> class ctype<char>;
template<> class ctype_byname<char>;
template<> class collate<char>;
template<> class collate_byname<char>;


template<> class ctype<wchar_t>;
template<> class ctype_byname<wchar_t>;
template<> class collate<wchar_t>;
template<> class collate_byname<wchar_t>;







typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_streambuf<char,char_traits<char> > streambuf;

typedef basic_stringbuf<char, char_traits<char>, allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>, allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>, allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>, allocator<char> > stringstream;

typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;



typedef basic_streambuf<wchar_t, char_traits<wchar_t> > wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;

typedef basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstringstream;

typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;


}
# 38 "c:/marmalade/6.2/s3e/h/std/c++/iosfwd" 2
# 24 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_fwd.h" 2


namespace _STL {


template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Alloc = allocator<_CharT> >
class basic_string;







typedef basic_string<char, char_traits<char>, allocator<char> > string;


typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;



 const char*
__get_c_string(const string& __str);






}
# 32 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function.h" 1
# 34 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_base.h" 1
# 37 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_base.h"
namespace _STL {

template <class _Arg, class _Result>
struct unary_function {
  typedef _Arg argument_type;
  typedef _Result result_type;
};

template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
};

template <class _Tp>
struct equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }
};

template <class _Tp>
struct not_equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }
};

template <class _Tp>
struct greater : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }
};

template <class _Tp>
struct less : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }
};

template <class _Tp>
struct greater_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }
};

template <class _Tp>
struct less_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }
};

template <class _Tp>
less<_Tp> __less(_Tp* ) { return less<_Tp>(); }

template <class _Tp>
equal_to<_Tp> __equal_to(_Tp* ) { return equal_to<_Tp>(); }

template <class _Tp>
struct plus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }
};

template <class _Tp>
struct minus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }
};

template <class _Tp>
plus<_Tp> __plus(_Tp* ) { return plus<_Tp>(); }

template <class _Tp>
minus<_Tp> __minus(_Tp* ) { return minus<_Tp>(); }

template <class _Tp>
struct multiplies : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }
};

template <class _Tp>
struct divides : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }
};

template <class _Tp>
struct modulus : public binary_function<_Tp,_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }
};

template <class _Tp>
struct negate : public unary_function<_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x) const { return -__x; }
};

template <class _Tp>
struct logical_and : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }
};

template <class _Tp>
struct logical_or : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }
};

template <class _Tp>
struct logical_not : public unary_function<_Tp,bool>
{
  bool operator()(const _Tp& __x) const { return !__x; }
};

template <class _Pair>
struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
  const typename _Pair::first_type& operator()(const _Pair& __x) const {
    return __x.first;
  }
};

template <class _Pair>
struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type>
{
  const typename _Pair::second_type& operator()(const _Pair& __x) const {
    return __x.second;
  }
};


template <class _Arg1, class _Arg2>
struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {
  _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }
};

template <class _Arg1, class _Arg2>
struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {
  _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }
};
# 188 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_base.h"
template <class _Tp>
struct _Identity : public unary_function<_Tp,_Tp> {
  const _Tp& operator()(const _Tp& __x) const { return __x; }
};

template <class _Result, class _Argument>
struct _Constant_unary_fun {
  typedef _Argument argument_type;
  typedef _Result result_type;
  result_type _M_val;

  _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()(const _Argument&) const { return _M_val; }
};

template <class _Result, class _Arg1, class _Arg2>
struct _Constant_binary_fun {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
  _Result _M_val;

  _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}
  const result_type& operator()(const _Arg1&, const _Arg2&) const {
    return _M_val;
  }
};


template <class _Tp> inline _Tp __identity_element(plus<_Tp>) { return _Tp(0); }
template <class _Tp> inline _Tp __identity_element(multiplies<_Tp>) { return _Tp(1); }

}
# 35 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function.h" 2


namespace _STL {



template <class _Tp> inline _Tp identity_element(plus<_Tp>) { return _Tp(0); }
template <class _Tp> inline _Tp identity_element(multiplies<_Tp>) { return _Tp(1); }
# 84 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function.h"
template <class _Predicate>
class unary_negate :
    public unary_function<typename _Predicate::argument_type, bool> {
protected:
  _Predicate _M_pred;
public:
  explicit unary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(const typename _Predicate::argument_type& __x) const {
    return !_M_pred(__x);
  }
};

template <class _Predicate>
inline unary_negate<_Predicate>
not1(const _Predicate& __pred)
{
  return unary_negate<_Predicate>(__pred);
}

template <class _Predicate>
class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type,
                             bool> {
protected:
  _Predicate _M_pred;
public:
  explicit binary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(const typename _Predicate::first_argument_type& __x,
                  const typename _Predicate::second_argument_type& __y) const
  {
    return !_M_pred(__x, __y);
  }
};

template <class _Predicate>
inline binary_negate<_Predicate>
not2(const _Predicate& __pred)
{
  return binary_negate<_Predicate>(__pred);
}

template <class _Operation>
class binder1st :
    public unary_function<typename _Operation::second_argument_type,
                          typename _Operation::result_type > {
protected:
  _Operation _M_op;
  typename _Operation::first_argument_type _M_value;
public:
  binder1st(const _Operation& __x,
            const typename _Operation::first_argument_type& __y)
      : _M_op(__x), _M_value(__y) {}

  typename _Operation::result_type
  operator()(const typename _Operation::second_argument_type& __x) const {
    return _M_op(_M_value, __x);
  }

  typename _Operation::result_type
  operator()(typename _Operation::second_argument_type& __x) const {
    return _M_op(_M_value, __x);
  }
};

template <class _Operation, class _Tp>
inline binder1st<_Operation>
bind1st(const _Operation& __fn, const _Tp& __x)
{
  typedef typename _Operation::first_argument_type _Arg1_type;
  return binder1st<_Operation>(__fn, _Arg1_type(__x));
}

template <class _Operation>
class binder2nd
  : public unary_function<typename _Operation::first_argument_type,
                          typename _Operation::result_type> {
protected:
  _Operation _M_op;
  typename _Operation::second_argument_type value;
public:
  binder2nd(const _Operation& __x,
            const typename _Operation::second_argument_type& __y)
      : _M_op(__x), value(__y) {}

  typename _Operation::result_type
  operator()(const typename _Operation::first_argument_type& __x) const {
    return _M_op(__x, value);
  }

  typename _Operation::result_type
  operator()(typename _Operation::first_argument_type& __x) const {
    return _M_op(__x, value);
  }
};

template <class _Operation, class _Tp>
inline binder2nd<_Operation>
bind2nd(const _Operation& __fn, const _Tp& __x)
{
  typedef typename _Operation::second_argument_type _Arg2_type;
  return binder2nd<_Operation>(__fn, _Arg2_type(__x));
}




template <class _Operation1, class _Operation2>
class unary_compose :
  public unary_function<typename _Operation2::argument_type,
                        typename _Operation1::result_type> {
protected:
  _Operation1 _M_fn1;
  _Operation2 _M_fn2;
public:
  unary_compose(const _Operation1& __x, const _Operation2& __y)
    : _M_fn1(__x), _M_fn2(__y) {}

  typename _Operation1::result_type
  operator()(const typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x));
  }

  typename _Operation1::result_type
  operator()(typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x));
  }
};

template <class _Operation1, class _Operation2>
inline unary_compose<_Operation1,_Operation2>
compose1(const _Operation1& __fn1, const _Operation2& __fn2)
{
  return unary_compose<_Operation1,_Operation2>(__fn1, __fn2);
}

template <class _Operation1, class _Operation2, class _Operation3>
class binary_compose :
    public unary_function<typename _Operation2::argument_type,
                          typename _Operation1::result_type> {
protected:
  _Operation1 _M_fn1;
  _Operation2 _M_fn2;
  _Operation3 _M_fn3;
public:
  binary_compose(const _Operation1& __x, const _Operation2& __y,
                 const _Operation3& __z)
    : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) { }

  typename _Operation1::result_type
  operator()(const typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x), _M_fn3(__x));
  }

  typename _Operation1::result_type
  operator()(typename _Operation2::argument_type& __x) const {
    return _M_fn1(_M_fn2(__x), _M_fn3(__x));
  }
};

template <class _Operation1, class _Operation2, class _Operation3>
inline binary_compose<_Operation1, _Operation2, _Operation3>
compose2(const _Operation1& __fn1, const _Operation2& __fn2,
         const _Operation3& __fn3)
{
  return binary_compose<_Operation1,_Operation2,_Operation3>
    (__fn1, __fn2, __fn3);
}






template <class _Tp> struct identity : public _Identity<_Tp> {};

template <class _Pair> struct select1st : public _Select1st<_Pair> {};
template <class _Pair> struct select2nd : public _Select2nd<_Pair> {};

template <class _Arg1, class _Arg2>
struct project1st : public _Project1st<_Arg1, _Arg2> {};

template <class _Arg1, class _Arg2>
struct project2nd : public _Project2nd<_Arg1, _Arg2> {};






template <class _Result>
struct _Constant_void_fun {
  typedef _Result result_type;
  result_type _M_val;

  _Constant_void_fun(const result_type& __v) : _M_val(__v) {}
  const result_type& operator()() const { return _M_val; }
};


template <class _Result>
struct constant_void_fun : public _Constant_void_fun<_Result> {
  constant_void_fun(const _Result& __v) : _Constant_void_fun<_Result>(__v) {}
};

template <class _Result, class _Argument = _Result >
struct constant_unary_fun : public _Constant_unary_fun<_Result, _Argument>
{
  constant_unary_fun(const _Result& __v)
    : _Constant_unary_fun<_Result, _Argument>(__v) {}
};

template <class _Result, class _Arg1 = _Result, class _Arg2 = _Arg1 >
struct constant_binary_fun
  : public _Constant_binary_fun<_Result, _Arg1, _Arg2>
{
  constant_binary_fun(const _Result& __v)
    : _Constant_binary_fun<_Result, _Arg1, _Arg2>(__v) {}
};

template <class _Result>
inline constant_void_fun<_Result> constant0(const _Result& __val)
{
  return constant_void_fun<_Result>(__val);
}

template <class _Result>
inline constant_unary_fun<_Result,_Result> constant1(const _Result& __val)
{
  return constant_unary_fun<_Result,_Result>(__val);
}

template <class _Result>
inline constant_binary_fun<_Result,_Result,_Result>
constant2(const _Result& __val)
{
  return constant_binary_fun<_Result,_Result,_Result>(__val);
}



class subtractive_rng : public unary_function<unsigned long, unsigned long> {
private:
  unsigned long _M_table[55];
  unsigned long _M_index1;
  unsigned long _M_index2;
public:
  unsigned long operator()(unsigned long __limit) {
    _M_index1 = (_M_index1 + 1) % 55;
    _M_index2 = (_M_index2 + 1) % 55;
    _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];
    return _M_table[_M_index1] % __limit;
  }

  void _M_initialize(unsigned long __seed)
  {
    unsigned long __k = 1;
    _M_table[54] = __seed;
    unsigned long __i;
    for (__i = 0; __i < 54; __i++) {
        unsigned long __ii = (21 * (__i + 1) % 55) - 1;
        _M_table[__ii] = __k;
        __k = __seed - __k;
        __seed = _M_table[__ii];
    }
    for (int __loop = 0; __loop < 4; __loop++) {
        for (__i = 0; __i < 55; __i++)
            _M_table[__i] = _M_table[__i] - _M_table[(1 + __i + 30) % 55];
    }
    _M_index1 = 0;
    _M_index2 = 31;
  }

  subtractive_rng(unsigned int __seed) { _M_initialize(__seed); }
  subtractive_rng() { _M_initialize(161803398ul); }
};



}

# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_adaptors.h" 1
# 58 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_adaptors.h"
namespace _STL {
# 411 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_adaptors.h"
template <class _Ret, class _Tp>
class mem_fun_t : public unary_function<_Tp*,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void);
public:
  explicit mem_fun_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p) const { return (__p->*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp>
class const_mem_fun_t : public unary_function<const _Tp*,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void) const;
public:
  explicit const_mem_fun_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p) const { return (__p->*_M_f)(); }
private:
  __fun_type _M_f;
};


template <class _Ret, class _Tp>
class mem_fun_ref_t : public unary_function<_Tp,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void);
public:
  explicit mem_fun_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r) const { return (__r.*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp>
class const_mem_fun_ref_t : public unary_function<_Tp,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(void) const;
public:
  explicit const_mem_fun_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r) const { return (__r.*_M_f)(); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class mem_fun1_t : public binary_function<_Tp*,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg);
public:
  explicit mem_fun1_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p, _Arg __x) const { return (__p->*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_t : public binary_function<const _Tp*,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg) const;
public:
  explicit const_mem_fun1_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p, _Arg __x) const
    { return (__p->*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg);
public:
  explicit mem_fun1_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
  typedef _Ret (_Tp::*__fun_type)(_Arg) const;
public:
  explicit const_mem_fun1_ref_t(__fun_type __pf) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  __fun_type _M_f;
};

template <class _Arg, class _Result>
class pointer_to_unary_function : public unary_function<_Arg, _Result> {
protected:
  _Result (*_M_ptr)(_Arg);
public:
  pointer_to_unary_function() {}
  explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}
  _Result operator()(_Arg __x) const { return _M_ptr(__x); }
};

template <class _Arg1, class _Arg2, class _Result>
class pointer_to_binary_function :
  public binary_function<_Arg1,_Arg2,_Result> {
protected:
    _Result (*_M_ptr)(_Arg1, _Arg2);
public:
    pointer_to_binary_function() {}
    explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}
    _Result operator()(_Arg1 __x, _Arg2 __y) const {
      return _M_ptr(__x, __y);
    }
};
# 737 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function_adaptors.h"
template <class _Result, class _Tp>
inline mem_fun_t<_Result,_Tp>
mem_fun(_Result (_Tp::*__f)()) { return mem_fun_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline const_mem_fun_t<_Result,_Tp>
mem_fun(_Result (_Tp::*__f)() const) { return const_mem_fun_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline mem_fun_ref_t<_Result,_Tp>
mem_fun_ref(_Result (_Tp::*__f)()) { return mem_fun_ref_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp>
inline const_mem_fun_ref_t<_Result,_Tp>
mem_fun_ref(_Result (_Tp::*__f)() const) { return const_mem_fun_ref_t<_Result,_Tp>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_t<_Result,_Tp,_Arg>
mem_fun(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_t<_Result,_Tp,_Arg>
mem_fun(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun_ref(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun_ref(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }




template <class _Result, class _Tp, class _Arg>
inline mem_fun1_t<_Result,_Tp,_Arg>
mem_fun1(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_t<_Result,_Tp,_Arg>
mem_fun1(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun1_ref(_Result (_Tp::*__f)(_Arg)) { return mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }

template <class _Result, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Result,_Tp,_Arg>
mem_fun1_ref(_Result (_Tp::*__f)(_Arg) const) { return const_mem_fun1_ref_t<_Result,_Tp,_Arg>(__f); }





template <class _Arg, class _Result>
inline pointer_to_unary_function<_Arg, _Result>
ptr_fun(_Result (*__f)(_Arg))
{ return pointer_to_unary_function<_Arg, _Result>(__f); }

template <class _Arg1, class _Arg2, class _Result>
inline pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__f)(_Arg1, _Arg2))
{ return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f); }

}
# 366 "c:/marmalade/6.2/s3e/h/std/c++/stl/_function.h" 2
# 36 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctraits_fns.h" 1
# 28 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctraits_fns.h"
namespace _STL {

template <class _Traits>
struct _Eq_traits
  : public binary_function<typename _Traits::char_type,
                           typename _Traits::char_type,
                           bool>
{
  bool operator()(const typename _Traits::char_type& __x,
                  const typename _Traits::char_type& __y) const
    { return _Traits::eq(__x, __y); }
};

template <class _Traits>
struct _Eq_char_bound
  : public unary_function<typename _Traits::char_type, bool>
{
  typename _Traits::char_type __val;
  _Eq_char_bound(typename _Traits::char_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
    { return _Traits::eq(__x, __val); }
};

template <class _Traits>
struct _Neq_char_bound
  : public unary_function<typename _Traits::char_type, bool>
{
  typename _Traits::char_type __val;
  _Neq_char_bound(typename _Traits::char_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
    { return !_Traits::eq(__x, __val); }
};

template <class _Traits>
struct _Eq_int_bound
  : public unary_function<typename _Traits::char_type, bool>
{
  typename _Traits::int_type __val;

  _Eq_int_bound(typename _Traits::int_type __c) : __val(__c) {}
  bool operator()(const typename _Traits::char_type& __x) const
    { return _Traits::eq_int_type(_Traits::to_int_type(__x), __val); }
};
# 85 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctraits_fns.h"
}
# 39 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2
# 79 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
namespace _STL {







template <class _Traits> struct _Not_within_traits
  : public unary_function<typename _Traits::char_type, bool> {
  typedef typename _Traits::char_type _CharT;
  const _CharT* _M_first;
  const _CharT* _M_last;

  _Not_within_traits(const typename _Traits::char_type* __f,
       const typename _Traits::char_type* __l)
    : _M_first(__f), _M_last(__l) {}

  bool operator()(const typename _Traits::char_type& __x) const {
    return find_if(_M_first, _M_last,
                   _Eq_char_bound<_Traits>(__x)) == _M_last;
  }
};
# 114 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
template <class _Tp, class _Alloc> class _String_base {
public:
 
  typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;
  _Tp* _M_start;
  _Tp* _M_finish;
  _STLP_alloc_proxy<_Tp*, _Tp, allocator_type> _M_end_of_storage;

  void _M_allocate_block(size_t);
  void _M_deallocate_block()
    { _M_end_of_storage.deallocate(_M_start, _M_end_of_storage._M_data - _M_start); }

  size_t max_size() const { return (size_t(-1) / sizeof(_Tp)) - 1; }

  _String_base(const allocator_type& __a)
    : _M_start(0), _M_finish(0), _M_end_of_storage(__a, (_Tp*)0) {}

  _String_base(const allocator_type& __a, size_t __n)
    : _M_start(0), _M_finish(0), _M_end_of_storage(__a, (_Tp*)0)
    { _M_allocate_block(__n); }

  ~_String_base() { _M_deallocate_block(); }

  void _M_throw_length_error() const;
  void _M_throw_out_of_range() const;
};
# 164 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
struct _String_reserve_t {};

template <class _CharT, class _Traits, class _Alloc> class basic_string : protected _String_base<_CharT,_Alloc> {
private:
  typedef _String_base<_CharT,_Alloc> _Base;
  typedef basic_string<_CharT, _Traits, _Alloc> _Self;


  typedef typename _Is_integer<_CharT>::_Integral _Char_Is_Integral;
public:
  typedef _CharT value_type;
  typedef _Traits traits_type;

  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef random_access_iterator_tag _Iterator_category;

  typedef const value_type* const_iterator;
  typedef value_type* iterator;

  typedef _STL::reverse_iterator<const_iterator> const_reverse_iterator; typedef _STL::reverse_iterator<iterator> reverse_iterator;







  static const size_t npos = ~(size_t)0;


  typedef _String_reserve_t _Reserve_t;
# 212 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
public:
  typedef typename _String_base<_CharT,_Alloc>::allocator_type allocator_type;

  allocator_type get_allocator() const {
    return (const allocator_type&)this->_M_end_of_storage;
  }

  basic_string();

  explicit basic_string(const allocator_type& __a)
    : _String_base<_CharT,_Alloc>(__a, 8) {
    _M_terminate_string();
  }

  basic_string(_Reserve_t, size_t __n,
               const allocator_type& __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a, __n + 1) {
    _M_terminate_string();
  }

  basic_string(const basic_string<_CharT, _Traits, _Alloc>&);

  basic_string(const _Self& __s, size_type __pos, size_type __n = npos,
               const allocator_type& __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a) {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    else
      _M_range_initialize(__s._M_start + __pos,
                          __s._M_start + __pos + (min) (__n, __s.size() - __pos));
  }

  basic_string(const _CharT* __s, size_type __n,
               const allocator_type& __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a)
    {
     
      _M_range_initialize(__s, __s + __n);
    }

  basic_string(const _CharT* __s,
               const allocator_type& __a = allocator_type());

  basic_string(size_type __n, _CharT __c,
               const allocator_type& __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a, __n + 1)
  {
    this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __c);
    _M_terminate_string();
  }
# 274 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
  template <class _InputIterator> basic_string(_InputIterator __f, _InputIterator __l,
               const allocator_type & __a = allocator_type())
    : _String_base<_CharT,_Alloc>(__a)
  {
    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
    _M_initialize_dispatch(__f, __l, _Integral());
  }
# 305 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
  ~basic_string() { _STL::_Destroy(this->_M_start, this->_M_finish + 1); }

  _Self& operator=(const _Self& __s) {
    if (&__s != this)
      assign(__s._M_start, __s._M_finish);
    return *this;
  }

  _Self& operator=(const _CharT* __s) {
   
    return assign(__s, __s + traits_type::length(__s));
  }

  _Self& operator=(_CharT __c)
    { return assign(static_cast<size_type>(1), __c); }

  static _CharT _M_null() {
    return _CharT();
  }

private:


  void _M_construct_null_aux(_CharT* __p, const __false_type&) {
    _Construct(__p);
  }
  void _M_construct_null_aux(_CharT* __p, const __true_type&) {
    *__p = 0;
  }

  void _M_construct_null(_CharT* __p) {
    _M_construct_null_aux(__p, _Char_Is_Integral());
  }

private:



  void _M_terminate_string_aux(const __false_type&) {
    {
      _M_construct_null(this->_M_finish);
    }
    ;
  }

  void _M_terminate_string_aux(const __true_type&) {
    *(this->_M_finish)=0;
  }

  void _M_terminate_string() {
    _M_terminate_string_aux(_Char_Is_Integral());
  }






  template <class _InputIter>
  bool _M_inside(_InputIter __i) const {
    const _CharT* __s = static_cast<const _CharT*>(&(*__i));
    return (__s >= this->_M_start) && (__s < this->_M_finish);
  }




  template <class _InputIter> void _M_range_initialize(_InputIter __f, _InputIter __l,
                           const input_iterator_tag &) {
    this->_M_allocate_block(8);
    _M_construct_null(this->_M_finish);
    {
      append(__f, __l);
    }
    ;
  }

  template <class _ForwardIter> void _M_range_initialize(_ForwardIter __f, _ForwardIter __l,
                           const forward_iterator_tag &) {
    difference_type __n = distance(__f, __l);
    this->_M_allocate_block(__n + 1);
    this->_M_finish = uninitialized_copy(__f, __l, this->_M_start);
    _M_terminate_string();
  }

  template <class _InputIter> void _M_range_initialize(_InputIter __f, _InputIter __l) {
    _M_range_initialize(__f, __l, typename iterator_traits< _InputIter >::iterator_category());
  }

  template <class _Integer> void _M_initialize_dispatch(_Integer __n, _Integer __x, const __true_type&) {
    this->_M_allocate_block(__n + 1);
    this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __x);
    _M_terminate_string();
  }

  template <class _InputIter> void _M_initialize_dispatch(_InputIter __f, _InputIter __l, const __false_type&) {
     _M_range_initialize(__f, __l);
  }
# 415 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
public:
  iterator begin() { return this->_M_start; }
  iterator end() { return this->_M_finish; }
  const_iterator begin() const { return this->_M_start; }
  const_iterator end() const { return this->_M_finish; }

  reverse_iterator rbegin()
    { return reverse_iterator(this->_M_finish); }
  reverse_iterator rend()
    { return reverse_iterator(this->_M_start); }
  const_reverse_iterator rbegin() const
    { return const_reverse_iterator(this->_M_finish); }
  const_reverse_iterator rend() const
    { return const_reverse_iterator(this->_M_start); }

public:
  size_type size() const { return this->_M_finish - this->_M_start; }
  size_type length() const { return size(); }

  size_t max_size() const { return _Base::max_size(); }


  void resize(size_type __n, _CharT __c) {
    if (__n <= size())
      erase(begin() + __n, end());
    else
      append(__n - size(), __c);
  }
  void resize(size_type __n) { resize(__n, _M_null()); }

  void reserve(size_type = 0);

  size_type capacity() const { return (this->_M_end_of_storage._M_data - this->_M_start) - 1; }

  void clear() {
    if (!empty()) {
      _Traits::assign(*(this->_M_start), _M_null());
      _STL::_Destroy(this->_M_start+1, this->_M_finish+1);
      this->_M_finish = this->_M_start;
    }
  }

  bool empty() const { return this->_M_start == this->_M_finish; }

public:

  const_reference operator[](size_type __n) const
    { return *(this->_M_start + __n); }
  reference operator[](size_type __n)
    { return *(this->_M_start + __n); }

  const_reference at(size_type __n) const {
    if (__n >= size())
      this->_M_throw_out_of_range();
    return *(this->_M_start + __n);
  }

  reference at(size_type __n) {
    if (__n >= size())
      this->_M_throw_out_of_range();
    return *(this->_M_start + __n);
  }

public:

  _Self& operator+=(const _Self& __s) { return append(__s); }
  _Self& operator+=(const _CharT* __s) { return append(__s); }
  _Self& operator+=(_CharT __c) { push_back(__c); return *this; }

  _Self& append(const _Self& __s)
    { return append(__s._M_start, __s._M_finish); }

  _Self& append(const _Self& __s,
                       size_type __pos, size_type __n)
  {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    return append(__s._M_start + __pos,
                  __s._M_start + __pos + (min) (__n, __s.size() - __pos));
  }

  _Self& append(const _CharT* __s, size_type __n)
    { return append(__s, __s+__n); }
  _Self& append(const _CharT* __s)
    { return append(__s, __s + traits_type::length(__s)); }
  _Self& append(size_type __n, _CharT __c);





  template <class _InputIter> _Self& append(_InputIter __first, _InputIter __last) {
    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
    return _M_append_dispatch(__first, __last, _Integral());
  }







  void push_back(_CharT __c) {
    if (this->_M_finish + 1 == this->_M_end_of_storage._M_data)
      reserve(size() + (max)(size(), static_cast<size_type>(1)));
    _M_construct_null(this->_M_finish + 1);
    _Traits::assign(*(this->_M_finish), __c);
    ++this->_M_finish;
  }

  void pop_back() {
    _Traits::assign(*(this->_M_finish - 1), _M_null());
    _STL::_Destroy(this->_M_finish);
    --this->_M_finish;
  }

private:



  template <class _InputIter> _Self& append(_InputIter __first, _InputIter __last, const input_iterator_tag &)
  {
   for ( ; __first != __last ; ++__first)
     push_back(*__first);
   return *this;
 }

  template <class _ForwardIter> _Self& append(_ForwardIter __first, _ForwardIter __last,
                       const forward_iterator_tag &) {
    if (__first != __last) {
     const size_type __old_size = size();
     difference_type __n = distance(__first, __last);
     if (static_cast<size_type>(__n) > max_size() || __old_size > max_size() - static_cast<size_type>(__n))
       this->_M_throw_length_error();
     if (__old_size + __n > capacity()) {
       const size_type __len = __old_size +
                             (max)(__old_size, static_cast<size_type>(__n)) + 1;
       pointer __new_start = this->_M_end_of_storage.allocate(__len);
       pointer __new_finish = __new_start;
       {
         __new_finish = uninitialized_copy(this->_M_start, this->_M_finish, __new_start);
         __new_finish = uninitialized_copy(__first, __last, __new_finish);
         _M_construct_null(__new_finish);
       }
       ;

       _STL::_Destroy(this->_M_start, this->_M_finish + 1);
       this->_M_deallocate_block();
       this->_M_start = __new_start;
       this->_M_finish = __new_finish;
       this->_M_end_of_storage._M_data = __new_start + __len;
     }
     else {
       _ForwardIter __f1 = __first;
       ++__f1;
       uninitialized_copy(__f1, __last, this->_M_finish + 1);
       {
         _M_construct_null(this->_M_finish + __n);
       }
       ;
       _Traits::assign(*end(), *__first);
       this->_M_finish += __n;
     }
   }
   return *this;
 }

  template <class _Integer> _Self& _M_append_dispatch(_Integer __n, _Integer __x, const __true_type&) {
    return append((size_type) __n, (_CharT) __x);
  }

  template <class _InputIter> _Self& _M_append_dispatch(_InputIter __f, _InputIter __l,
                                   const __false_type&) {
    return append(__f, __l, typename iterator_traits< _InputIter >::iterator_category());
  }



public:

  _Self& assign(const _Self& __s)
    { return assign(__s._M_start, __s._M_finish); }

  _Self& assign(const _Self& __s,
                       size_type __pos, size_type __n) {
    if (__pos > __s.size())
      this->_M_throw_out_of_range();
    return assign(__s._M_start + __pos,
                  __s._M_start + __pos + (min) (__n, __s.size() - __pos));
  }

  _Self& assign(const _CharT* __s, size_type __n)
    { return assign(__s, __s + __n); }

  _Self& assign(const _CharT* __s)
    { return assign(__s, __s + _Traits::length(__s)); }

  _Self& assign(size_type __n, _CharT __c);



private:

  template <class _Integer>
  _Self& _M_assign_dispatch(_Integer __n, _Integer __x, const __true_type&) {
    return assign((size_type) __n, (_CharT) __x);
  }

  template <class _InputIter>
  _Self& _M_assign_dispatch(_InputIter __f, _InputIter __l,
       const __false_type&) {
    pointer __cur = this->_M_start;
    while (__f != __l && __cur != this->_M_finish) {
      _Traits::assign(*__cur, *__f);
      ++__f;
      ++__cur;
    }
    if (__f == __l)
      erase(__cur, end());
    else
      append(__f, __l);
    return *this;
  }

public:


  template <class _InputIter> _Self& assign(_InputIter __first, _InputIter __last) {
    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
    return _M_assign_dispatch(__first, __last, _Integral());
  }



  _Self& assign(const _CharT* __f, const _CharT* __l)
  {
    ptrdiff_t __n = __l - __f;
    if (static_cast<size_type>(__n) <= size()) {
      _Traits::copy(this->_M_start, __f, __n);
      erase(begin() + __n, end());
    }
    else {
      _Traits::copy(this->_M_start, __f, size());
      append(__f + size(), __l);
    }
    return *this;
  }

public:

  _Self& insert(size_type __pos, const _Self& __s) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (size() > max_size() - __s.size())
      this->_M_throw_length_error();
    insert(begin() + __pos, __s._M_start, __s._M_finish);
    return *this;
  }

  _Self& insert(size_type __pos, const _Self& __s,
                       size_type __beg, size_type __n) {
    if (__pos > size() || __beg > __s.size())
      this->_M_throw_out_of_range();
    size_type __len = (min) (__n, __s.size() - __beg);
    if (size() > max_size() - __len)
      this->_M_throw_length_error();
    insert(begin() + __pos,
           __s._M_start + __beg, __s._M_start + __beg + __len);
    return *this;
  }

  _Self& insert(size_type __pos, const _CharT* __s, size_type __n) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (size() > max_size() - __n)
      this->_M_throw_length_error();
    insert(begin() + __pos, __s, __s + __n);
    return *this;
  }

  _Self& insert(size_type __pos, const _CharT* __s) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    size_type __len = _Traits::length(__s);
    if (size() > max_size() - __len)
      this->_M_throw_length_error();
    insert(this->_M_start + __pos, __s, __s + __len);
    return *this;
  }

  _Self& insert(size_type __pos, size_type __n, _CharT __c) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    if (size() > max_size() - __n)
      this->_M_throw_length_error();
    insert(begin() + __pos, __n, __c);
    return *this;
  }

  iterator insert(iterator __p, _CharT __c) {
   
    if (__p == end()) {
      push_back(__c);
      return this->_M_finish - 1;
    }
    else
      return _M_insert_aux(__p, __c);
  }

  void insert(iterator __p, size_t __n, _CharT __c);





  template <class _InputIter> void insert(iterator __p, _InputIter __first, _InputIter __last) {
    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
    _M_insert_dispatch(__p, __first, __last, _Integral());
  }







private:



  template <class _InputIter> void insert(iterator __p, _InputIter __first, _InputIter __last,
       const input_iterator_tag &)
  {
   for ( ; __first != __last; ++__first) {
     __p = insert(__p, *__first);
     ++__p;
   }
 }

  template <class _ForwardIter>
  void insert(iterator __position, _ForwardIter __first, _ForwardIter __last,
       const forward_iterator_tag &) {
    if (__first != __last) {
      difference_type __n = distance(__first, __last);
      if (this->_M_end_of_storage._M_data - this->_M_finish >= __n + 1) {
 const difference_type __elems_after = this->_M_finish - __position;
 pointer __old_finish = this->_M_finish;
 if (__elems_after >= __n) {
   uninitialized_copy((this->_M_finish - __n) + 1, this->_M_finish + 1,
        this->_M_finish + 1);
   this->_M_finish += __n;
   _Traits::move(__position + __n,
   __position, (__elems_after - __n) + 1);
   _M_move(__first, __last, __position);
       }
 else {
   _ForwardIter __mid = __first;
   advance(__mid, __elems_after + 1);
   uninitialized_copy(__mid, __last, this->_M_finish + 1);
   this->_M_finish += __n - __elems_after;
         {
           uninitialized_copy(__position, __old_finish + 1, this->_M_finish);
           this->_M_finish += __elems_after;
         }
         ;

         _M_move(__first, __mid, __position);
 }
      }
      else {
 const size_type __old_size = size();
 const size_type __len
   = __old_size + (max)(__old_size, static_cast<size_type>(__n)) + 1;
       pointer __new_start = this->_M_end_of_storage.allocate(__len);
       pointer __new_finish = __new_start;
       {
         __new_finish = uninitialized_copy(this->_M_start, __position, __new_start);
         __new_finish = uninitialized_copy(__first, __last, __new_finish);
         __new_finish
           = uninitialized_copy(__position, this->_M_finish, __new_finish);
         _M_construct_null(__new_finish);
       }
       ;

       _STL::_Destroy(this->_M_start, this->_M_finish + 1);
       this->_M_deallocate_block();
       this->_M_start = __new_start;
       this->_M_finish = __new_finish;
       this->_M_end_of_storage._M_data = __new_start + __len;
     }
    }
  }

  template <class _Integer> void _M_insert_dispatch(iterator __p, _Integer __n, _Integer __x,
                          const __true_type&) {
    insert(__p, (size_type) __n, (_CharT) __x);
  }

  template <class _InputIter> void _M_insert_dispatch(iterator __p, _InputIter __first, _InputIter __last,
                          const __false_type&) {
    insert(__p, __first, __last, typename iterator_traits< _InputIter >::iterator_category());
  }

  template <class _InputIterator> void
  _M_copy(_InputIterator __first, _InputIterator __last, pointer __result) {
    for ( ; __first != __last; ++__first, ++__result)
      _Traits::assign(*__result, *__first);
  }

  template <class _InputIterator>
  void _M_move(_InputIterator __first, _InputIterator __last, pointer __result) {

    for ( ; __first != __last; ++__first, ++__result)
      _Traits::assign(*__result, *__first);
  }



  pointer _M_insert_aux(pointer, _CharT);

  void
  _M_copy(const _CharT* __first, const _CharT* __last, _CharT* __result) {
    _Traits::copy(__result, __first, __last - __first);
  }
  void _M_move(const _CharT* __first, const _CharT* __last, _CharT* __result) {
    _Traits::move(__result, __first, __last - __first);
  }

public:

  _Self& erase(size_type __pos = 0, size_type __n = npos) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    erase(begin() + __pos, begin() + __pos + (min) (__n, size() - __pos));
    return *this;
  }

  iterator erase(iterator __position) {

    _Traits::move(__position, __position + 1, this->_M_finish - __position);
    _STL::_Destroy(this->_M_finish);
    --this->_M_finish;
    return __position;
  }

  iterator erase(iterator __first, iterator __last) {
    if (__first != __last) {

      traits_type::move(__first, __last, (this->_M_finish - __last) + 1);
      pointer __new_finish = this->_M_finish - (__last - __first);
      _STL::_Destroy(__new_finish + 1, this->_M_finish + 1);
      this->_M_finish = __new_finish;
    }
    return __first;
  }

public:

  _Self& replace(size_type __pos, size_type __n,
                        const _Self& __s) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n, size() - __pos);
    if (size() - __len >= max_size() - __s.size())
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len,
                   __s._M_start, __s._M_finish);
  }

  _Self& replace(size_type __pos1, size_type __n1,
                        const _Self& __s,
                        size_type __pos2, size_type __n2) {
    if (__pos1 > size() || __pos2 > __s.size())
      this->_M_throw_out_of_range();
    const size_type __len1 = (min) (__n1, size() - __pos1);
    const size_type __len2 = (min) (__n2, __s.size() - __pos2);
    if (size() - __len1 >= max_size() - __len2)
      this->_M_throw_length_error();
    return replace(begin() + __pos1, begin() + __pos1 + __len1,
                   __s._M_start + __pos2, __s._M_start + __pos2 + __len2);
  }

  _Self& replace(size_type __pos, size_type __n1,
                        const _CharT* __s, size_type __n2) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n1, size() - __pos);
    if (__n2 > max_size() || size() - __len >= max_size() - __n2)
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len,
                   __s, __s + __n2);
  }

  _Self& replace(size_type __pos, size_type __n1,
                        const _CharT* __s) {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n1, size() - __pos);
    const size_type __n2 = _Traits::length(__s);
    if (__n2 > max_size() || size() - __len >= max_size() - __n2)
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len,
                   __s, __s + _Traits::length(__s));
  }

  _Self& replace(size_type __pos, size_type __n1,
                        size_type __n2, _CharT __c) {
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n1, size() - __pos);
    if (__n2 > max_size() || size() - __len >= max_size() - __n2)
      this->_M_throw_length_error();
    return replace(begin() + __pos, begin() + __pos + __len, __n2, __c);
  }

  _Self& replace(iterator __first, iterator __last,
                        const _Self& __s)
    { return replace(__first, __last, __s._M_start, __s._M_finish); }

  _Self& replace(iterator __first, iterator __last,
                        const _CharT* __s, size_type __n)
    { return replace(__first, __last, __s, __s + __n); }

  _Self& replace(iterator __first, iterator __last,
                        const _CharT* __s) {
   
    return replace(__first, __last, __s, __s + _Traits::length(__s));
  }

  _Self& replace(iterator __first, iterator __last,
                        size_type __n, _CharT __c);




  template <class _InputIter> _Self& replace(iterator __first, iterator __last,
                        _InputIter __f, _InputIter __l) {
    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
    return _M_replace_dispatch(__first, __last, __f, __l, _Integral());
  }





private:



  template <class _Integer> _Self& _M_replace_dispatch(iterator __first, iterator __last,
                                    _Integer __n, _Integer __x,
                                    const __true_type&) {
    return replace(__first, __last, (size_type) __n, (_CharT) __x);
  }

  template <class _InputIter> _Self& _M_replace_dispatch(iterator __first, iterator __last,
                                    _InputIter __f, _InputIter __l,
                                    const __false_type&) {
    return replace(__first, __last, __f, __l, typename iterator_traits< _InputIter >::iterator_category());
  }

  template <class _InputIter> _Self& replace(iterator __first, iterator __last,
                        _InputIter __f, _InputIter __l, const input_iterator_tag &) {
   for ( ; __first != __last && __f != __l; ++__first, ++__f)
     _Traits::assign(*__first, *__f);

   if (__f == __l)
     erase(__first, __last);
   else
     insert(__last, __f, __l);
   return *this;
 }

  template <class _InputIter>
  _Self& replace(iterator __first, iterator __last,
                 _InputIter __f, _InputIter __l, const random_access_iterator_tag &) {

    if (_M_inside(__f)) {
      difference_type __n = __l - __f;
      const difference_type __len = __last - __first;
      if (__len >= __n) {
        _M_move(__f, __l, __first);
        erase(__first + __n, __last);
      }
      else {
        _InputIter __m = __f + __len;
        if ((__l <= __first) || (__f >= __last)) {

          _M_copy(__f, __m, __first);
          insert(__last, __m, __l);
        }
        else {

      const difference_type __off_dest = __first - this->begin();
      const difference_type __off_src = __f - this->begin();
      insert(__last, __m, __l);
      _Traits::move(begin() + __off_dest, begin() + __off_src, __n);
        }
      }
      return *this;
    }
   else {
    return replace(__first, __last, __f, __l, forward_iterator_tag());
   }
  }


  template <class _ForwardIter> _Self& replace(iterator __first, iterator __last,
                        _ForwardIter __f, _ForwardIter __l,
                        const forward_iterator_tag &) {
   difference_type __n = distance(__f, __l);
   const difference_type __len = __last - __first;
   if (__len >= __n) {
     _M_copy(__f, __l, __first);
     erase(__first + __n, __last);
   }
   else {
     _ForwardIter __m = __f;
     advance(__m, __len);
     _M_copy(__f, __m, __first);
     insert(__last, __m, __l);
   }
   return *this;
 }



public:

  size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const {
   
    if (__pos > size())
      this->_M_throw_out_of_range();
    const size_type __len = (min) (__n, size() - __pos);
    _Traits::copy(__s, this->_M_start + __pos, __len);
    return __len;
  }

  void swap(_Self& __s) {
    _STL::swap(this->_M_start, __s._M_start);
    _STL::swap(this->_M_finish, __s._M_finish);
    _STL::swap(this->_M_end_of_storage, __s._M_end_of_storage);
  }

public:

  const _CharT* c_str() const { return this->_M_start; }
  const _CharT* data() const { return this->_M_start; }

public:

  size_type find(const _Self& __s, size_type __pos = 0) const
    { return find(__s._M_start, __pos, __s.size()); }

  size_type find(const _CharT* __s, size_type __pos = 0) const
    { return find(__s, __pos, _Traits::length(__s)); }

  size_type find(const _CharT* __s, size_type __pos, size_type __n) const;


  size_type find(_CharT __c) const
    { return find(__c, 0) ; }
  size_type find(_CharT __c, size_type __pos ) const;

public:

  size_type rfind(const _Self& __s, size_type __pos = npos) const
    { return rfind(__s._M_start, __pos, __s.size()); }

  size_type rfind(const _CharT* __s, size_type __pos = npos) const
    { return rfind(__s, __pos, _Traits::length(__s)); }

  size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const;
  size_type rfind(_CharT __c, size_type __pos = npos) const;

public:

  size_type find_first_of(const _Self& __s, size_type __pos = 0) const
    { return find_first_of(__s._M_start, __pos, __s.size()); }

  size_type find_first_of(const _CharT* __s, size_type __pos = 0) const
    { return find_first_of(__s, __pos, _Traits::length(__s)); }

  size_type find_first_of(const _CharT* __s, size_type __pos,
                          size_type __n) const;

  size_type find_first_of(_CharT __c, size_type __pos = 0) const
    { return find(__c, __pos); }

public:

  size_type find_last_of(const _Self& __s,
                         size_type __pos = npos) const
    { return find_last_of(__s._M_start, __pos, __s.size()); }

  size_type find_last_of(const _CharT* __s, size_type __pos = npos) const
    { return find_last_of(__s, __pos, _Traits::length(__s)); }

  size_type find_last_of(const _CharT* __s, size_type __pos,
                         size_type __n) const;

  size_type find_last_of(_CharT __c, size_type __pos = npos) const {
    return rfind(__c, __pos);
  }

public:

  size_type find_first_not_of(const _Self& __s,
                              size_type __pos = 0) const
    { return find_first_not_of(__s._M_start, __pos, __s.size()); }

  size_type find_first_not_of(const _CharT* __s, size_type __pos = 0) const
    { return find_first_not_of(__s, __pos, _Traits::length(__s)); }

  size_type find_first_not_of(const _CharT* __s, size_type __pos,
                              size_type __n) const;

  size_type find_first_not_of(_CharT __c, size_type __pos = 0) const;

public:

  size_type find_last_not_of(const _Self& __s,
                             size_type __pos = npos) const
    { return find_last_not_of(__s._M_start, __pos, __s.size()); }

  size_type find_last_not_of(const _CharT* __s, size_type __pos = npos) const
    { return find_last_not_of(__s, __pos, _Traits::length(__s)); }

  size_type find_last_not_of(const _CharT* __s, size_type __pos,
                             size_type __n) const;

  size_type find_last_not_of(_CharT __c, size_type __pos = npos) const;

public:

  _Self substr(size_type __pos = 0, size_type __n = npos) const {
    if (__pos > size())
      this->_M_throw_out_of_range();
    return _Self(this->_M_start + __pos,
                        this->_M_start + __pos + (min) (__n, size() - __pos));
  }

public:

  int compare(const _Self& __s) const
    { return _M_compare(this->_M_start, this->_M_finish, __s._M_start, __s._M_finish); }

  int compare(size_type __pos1, size_type __n1,
              const _Self& __s) const {
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_start + __pos1,
                      this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
                      __s._M_start, __s._M_finish);
  }

  int compare(size_type __pos1, size_type __n1,
              const _Self& __s,
              size_type __pos2, size_type __n2) const {
    if (__pos1 > size() || __pos2 > __s.size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_start + __pos1,
                      this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
                      __s._M_start + __pos2,
                      __s._M_start + __pos2 + (min) (__n2, __s.size() - __pos2));
  }

  int compare(const _CharT* __s) const {
   
      return _M_compare(this->_M_start, this->_M_finish, __s, __s + _Traits::length(__s));
  }

  int compare(size_type __pos1, size_type __n1, const _CharT* __s) const {
   
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_start + __pos1,
                      this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
                      __s, __s + _Traits::length(__s));
  }

  int compare(size_type __pos1, size_type __n1, const _CharT* __s,
              size_type __n2) const {
   
    if (__pos1 > size())
      this->_M_throw_out_of_range();
    return _M_compare(this->_M_start + __pos1,
                      this->_M_start + __pos1 + (min) (__n1, size() - __pos1),
                      __s, __s + __n2);
  }

public:

  static int _M_compare(const _CharT* __f1, const _CharT* __l1,
                        const _CharT* __f2, const _CharT* __l2) {
    const ptrdiff_t __n1 = __l1 - __f1;
    const ptrdiff_t __n2 = __l2 - __f2;
    const int cmp = _Traits::compare(__f1, __f2, (min) (__n1, __n2));
    return cmp != 0 ? cmp : (__n1 < __n2 ? -1 : (__n1 > __n2 ? 1 : 0));
  }
};
# 1237 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y)
{
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;


  _Str __result = _Str(_Reserve_t(),__s.size() + __y.size());



  __result.append(__s);
  __result.append(__y);
  return __result;
}





template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;
  const size_t __n = _Traits::length(__s);

  _Str __result = _Str(_Reserve_t(), __n + __y.size());



  __result.append(__s, __s + __n);
  __result.append(__y);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(_CharT __c,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;

  _Str __result = _Str(_Reserve_t(), 1 + __y.size());



  __result.push_back(__c);
  __result.append(__y);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
 
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;
  const size_t __n = _Traits::length(__s);

  _Str __result = _Str(_Reserve_t(), __x.size() + __n, __x.get_allocator());



  __result.append(__x);
  __result.append(__s, __s + __n);
  return __result;
}

template <class _CharT, class _Traits, class _Alloc> inline basic_string<_CharT,_Traits,_Alloc>
operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT __c) {
  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
  typedef typename _Str::_Reserve_t _Reserve_t;

  _Str __result = _Str(_Reserve_t(), __x.size() + 1, __x.get_allocator());



  __result.append(__x);
  __result.push_back(__c);
  return __result;
}





template <class _CharT, class _Traits, class _Alloc> inline bool
operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return __x.size() == __y.size() && _Traits::compare(__x.data(), __y.data(), __x.size()) == 0;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator==(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  size_t __n = _Traits::length(__s);
  return __n == __y.size() && _Traits::compare(__s, __y.data(), __n) == 0;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  size_t __n = _Traits::length(__s);
  return __x.size() == __n && _Traits::compare(__x.data(), __s, __n) == 0;
}



template <class _CharT, class _Traits, class _Alloc> inline bool
operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__x.begin(), __x.end(),
   __y.begin(), __y.end()) < 0;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  size_t __n = _Traits::length(__s);
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__s, __s + __n, __y.begin(), __y.end()) < 0;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
 
  size_t __n = _Traits::length(__s);
  return basic_string<_CharT,_Traits,_Alloc> ::_M_compare(__x.begin(), __x.end(), __s, __s + __n) < 0;
}



template <class _CharT, class _Traits, class _Alloc> inline bool
operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return !(__x == __y);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return __y < __x;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return !(__y < __x);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
  return !(__x < __y);
}



template <class _CharT, class _Traits, class _Alloc> inline bool
operator!=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return !(__s == __y);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  return !(__x == __s);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>(const _CharT* __s,
          const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return __y < __s;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
          const _CharT* __s) {
 
  return __s < __x;
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return !(__y < __s);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  return !(__s < __x);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>=(const _CharT* __s,
           const basic_string<_CharT,_Traits,_Alloc>& __y) {
 
  return !(__s < __y);
}

template <class _CharT, class _Traits, class _Alloc> inline bool
operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
           const _CharT* __s) {
 
  return !(__x < __s);
}






template <class _CharT, class _Traits, class _Alloc> inline void
swap(basic_string<_CharT,_Traits,_Alloc>& __x,
     basic_string<_CharT,_Traits,_Alloc>& __y) {
  __x.swap(__y);
}



template <class _CharT, class _Traits, class _Alloc> void _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,
                    _CharT* __buf,
                    size_t __n);
# 1483 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h"
}






# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c" 1
# 47 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c"
namespace _STL {
# 57 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c"
template <class _CharT, class _Traits, class _Alloc> void basic_string<_CharT,_Traits,_Alloc>::reserve(size_type __res_arg) {

  if (__res_arg >= capacity())
    {
      if (__res_arg > max_size())
 this->_M_throw_length_error();

      size_type __n = __res_arg + 1;
      pointer __new_start = this->_M_end_of_storage.allocate(__n);
      pointer __new_finish = __new_start;

      {
 __new_finish = uninitialized_copy(this->_M_start, this->_M_finish, __new_start);
 _M_construct_null(__new_finish);
      }
      ;


      _STL::_Destroy(this->_M_start, this->_M_finish + 1);
      this->_M_deallocate_block();
      this->_M_start = __new_start;
      this->_M_finish = __new_finish;
      this->_M_end_of_storage._M_data = __new_start + __n;
    }
}

template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT,_Traits,_Alloc>& basic_string<_CharT,_Traits,_Alloc>::append(size_type __n, _CharT __c) {
  if (__n > max_size() || size() > max_size() - __n)
    this->_M_throw_length_error();
  if (size() + __n > capacity())
    reserve(size() + (max)(size(), __n));
  if (__n > 0) {
    uninitialized_fill_n(this->_M_finish + 1, __n - 1, __c);
    {
      _M_construct_null(this->_M_finish + __n);
    }
    ;
    _Traits::assign(*end(), __c);
    this->_M_finish += __n;
  }
  return *this;
}
# 144 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c"
template <class _CharT, class _Traits, class _Alloc>
basic_string<_CharT,_Traits,_Alloc>&
basic_string<_CharT,_Traits,_Alloc>::assign(size_type __n, _CharT __c) {
  if (__n <= size()) {
    _Traits::assign(this->_M_start, __n, __c);
    erase(begin() + __n, end());
  }
  else {
    _Traits::assign(this->_M_start, size(), __c);
    append(__n - size(), __c);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Alloc> _CharT*
basic_string<_CharT,_Traits,_Alloc> ::_M_insert_aux(_CharT* __p,
                  _CharT __c)
{
  pointer __new_pos = __p;
  if (this->_M_finish + 1 < this->_M_end_of_storage._M_data) {
    _M_construct_null(this->_M_finish + 1);
    _Traits::move(__p + 1, __p, this->_M_finish - __p);
    _Traits::assign(*__p, __c);
    ++this->_M_finish;
  }
  else {
    const size_type __old_len = size();
    const size_type __len = __old_len +
                            (max)(__old_len, static_cast<size_type>(1)) + 1;
    pointer __new_start = this->_M_end_of_storage.allocate(__len);
    pointer __new_finish = __new_start;
    {
      __new_pos = uninitialized_copy(this->_M_start, __p, __new_start);
      _Construct(__new_pos, __c);
      __new_finish = __new_pos + 1;
      __new_finish = uninitialized_copy(__p, this->_M_finish, __new_finish);
      _M_construct_null(__new_finish);
    }
    ;

    _STL::_Destroy(this->_M_start, this->_M_finish + 1);
    this->_M_deallocate_block();
    this->_M_start = __new_start;
    this->_M_finish = __new_finish;
    this->_M_end_of_storage._M_data = __new_start + __len;
  }
  return __new_pos;
}

template <class _CharT, class _Traits, class _Alloc> void basic_string<_CharT,_Traits,_Alloc>::insert(iterator __position,
           size_t __n, _CharT __c)
{
  if (__n != 0) {
    if (size_type(this->_M_end_of_storage._M_data - this->_M_finish) >= __n + 1) {
      const size_type __elems_after = this->_M_finish - __position;
      pointer __old_finish = this->_M_finish;
      if (__elems_after >= __n) {
        uninitialized_copy((this->_M_finish - __n) + 1, this->_M_finish + 1,
                           this->_M_finish + 1);
        this->_M_finish += __n;
        _Traits::move(__position + __n,
                      __position, (__elems_after - __n) + 1);
        _Traits::assign(__position, __n, __c);
      }
      else {
        uninitialized_fill_n(this->_M_finish + 1, __n - __elems_after - 1, __c);
        this->_M_finish += __n - __elems_after;
        {
          uninitialized_copy(__position, __old_finish + 1, this->_M_finish);
          this->_M_finish += __elems_after;
        }
        ;

        _Traits::assign(__position, __elems_after + 1, __c);
      }
    }
    else {
      const size_type __old_size = size();
      const size_type __len = __old_size + (max)(__old_size, __n) + 1;
      pointer __new_start = this->_M_end_of_storage.allocate(__len);
      pointer __new_finish = __new_start;
      {
        __new_finish = uninitialized_copy(this->_M_start, __position, __new_start);
        __new_finish = uninitialized_fill_n(__new_finish, __n, __c);
        __new_finish = uninitialized_copy(__position, this->_M_finish,
                                          __new_finish);
        _M_construct_null(__new_finish);
      }
      ;

      _STL::_Destroy(this->_M_start, this->_M_finish + 1);
      this->_M_deallocate_block();
      this->_M_start = __new_start;
      this->_M_finish = __new_finish;
      this->_M_end_of_storage._M_data = __new_start + __len;
    }
  }
}
# 303 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c"
template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT,_Traits,_Alloc>& basic_string<_CharT,_Traits,_Alloc> ::replace(iterator __first, iterator __last, size_type __n, _CharT __c)
{
  size_type __len = (size_type)(__last - __first);

  if (__len >= __n) {
    _Traits::assign(__first, __n, __c);
    erase(__first + __n, __last);
  }
  else {
    _Traits::assign(__first, __len, __c);
    insert(__last, __n - __len, __c);
  }
  return *this;
}
# 340 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c"
template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find(const _CharT* __s, size_type __pos, size_type __n) const
{
  if (__pos + __n > size())
    return npos;
  else {
    const const_pointer __result =
      _STL::search((const _CharT*)this->_M_start + __pos, (const _CharT*)this->_M_finish,
   __s, __s + __n, _Eq_traits<_Traits>());
    return __result != this->_M_finish ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find(_CharT __c, size_type __pos) const
{
  if (__pos >= size())
    return npos;
  else {
    const const_pointer __result =
      _STL::find_if((const _CharT*)this->_M_start + __pos, (const _CharT*)this->_M_finish,
    _Eq_char_bound<_Traits>(__c));
    return __result != this->_M_finish ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::rfind(const _CharT* __s, size_type __pos, size_type __n) const
{
  const size_t __len = size();

  if (__n > __len)
    return npos;
  else if (__n == 0)
    return (min) (__len, __pos);
  else {
    const_pointer __last = this->_M_start + (min) (__len - __n, __pos) + __n;
    const_pointer __result = _STL::find_end((const_pointer)this->_M_start, __last,
       __s, __s + __n,
       _Eq_traits<_Traits>());
    return __result != __last ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::rfind(_CharT __c, size_type __pos) const
{
  const size_type __len = size();

  if (__len < 1)
    return npos;
  else {
    const const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
    const_reverse_iterator __rresult =
      _STL::find_if(const_reverse_iterator(__last), rend(),
              _Eq_char_bound<_Traits>(__c));
    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  if (__pos >= size())
    return npos;
  else {
    const_iterator __result = __find_first_of(begin() + __pos, end(),
                                              __s, __s + __n,
                                              _Eq_traits<_Traits>());
    return __result != end() ? __result - begin() : npos;
  }
}


template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  const size_type __len = size();

  if (__len < 1)
    return npos;
  else {
    const const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
    const const_reverse_iterator __rresult =
      __find_first_of(const_reverse_iterator(__last), rend(),
                      __s, __s + __n,
                      _Eq_traits<_Traits>());
    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
  }
}


template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  typedef typename _Traits::char_type _CharType;
  if (__pos > size())
    return npos;
  else {
    const_pointer __result = _STL::find_if((const _CharT*)this->_M_start + __pos,
          (const _CharT*)this->_M_finish,
                                _Not_within_traits<_Traits>((const _CharType*)__s,
           (const _CharType*)__s + __n));
    return __result != this->_M_finish ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_first_not_of(_CharT __c, size_type __pos) const
{
  if (__pos > size())
    return npos;
  else {
    const_pointer __result = _STL::find_if((const _CharT*)this->_M_start + __pos, (const _CharT*)this->_M_finish,
      _Neq_char_bound<_Traits>(__c));
    return __result != this->_M_finish ? __result - this->_M_start : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT,_Traits,_Alloc> ::find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
{
  typedef typename _Traits::char_type _CharType;
  const size_type __len = size();

  if (__len < 1)
    return npos;
  else {
    const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
    const_reverse_iterator __rlast = const_reverse_iterator(__last);
    const_reverse_iterator __rresult =
      _STL::find_if(__rlast, rend(),
    _Not_within_traits<_Traits>((const _CharType*)__s,
           (const _CharType*)__s + __n));
    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> typename basic_string<_CharT,_Traits,_Alloc>::size_type
basic_string<_CharT, _Traits, _Alloc> ::find_last_not_of(_CharT __c, size_type __pos) const
{
  const size_type __len = size();

  if (__len < 1)
    return npos;
  else {
    const_iterator __last = begin() + (min) (__len - 1, __pos) + 1;
    const_reverse_iterator __rlast = const_reverse_iterator(__last);
    const_reverse_iterator __rresult =
      _STL::find_if(__rlast, rend(),
    _Neq_char_bound<_Traits>(__c));
    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
  }
}

template <class _CharT, class _Traits, class _Alloc> void _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,
                    _CharT* __buf,
                    size_t __n)
{
  if (__n > 0) {
    __n = (min) (__n - 1, __s.size());
    _STL::copy(__s.begin(), __s.begin() + __n, __buf);
    __buf[__n] = _CharT();
  }
}
}





# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_fwd.c" 1
# 512 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c" 2






# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_range_errors.h" 1
# 36 "c:/marmalade/6.2/s3e/h/std/c++/stl/_range_errors.h"
namespace _STL {
void __stl_throw_range_error(const char* __msg);
void __stl_throw_out_of_range(const char* __msg);
void __stl_throw_length_error(const char* __msg);
void __stl_throw_invalid_argument(const char* __msg);
void __stl_throw_overflow_error(const char* __msg);
}
# 519 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.c" 2
namespace _STL {


template <class _Tp, class _Alloc> void _String_base<_Tp,_Alloc>::_M_throw_length_error() const {
    __stl_throw_length_error("basic_string");
}

template <class _Tp, class _Alloc> void _String_base<_Tp, _Alloc>::_M_throw_out_of_range() const {
    __stl_throw_out_of_range("basic_string");
}

template <class _Tp, class _Alloc> void _String_base<_Tp, _Alloc>::_M_allocate_block(size_t __n) {
  if ((__n <= (max_size()+1)) && (__n>0)){
    _M_start = _M_end_of_storage.allocate(__n);
    _M_finish = _M_start;
    _M_end_of_storage._M_data = _M_start + __n;
  }
    else
      _M_throw_length_error();
}

template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT, _Traits, _Alloc>::basic_string()
  : _String_base<_CharT,_Alloc>(allocator_type()) {
  this->_M_start = this->_M_end_of_storage.allocate(8);
  this->_M_finish = this->_M_start;
  this->_M_end_of_storage._M_data = this->_M_start + 8;
  _M_terminate_string();
}


template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT* __s,
          const allocator_type& __a)
  : _String_base<_CharT,_Alloc>(__a)
{
 
    _M_range_initialize(__s, __s + traits_type::length(__s));
}


template <class _CharT, class _Traits, class _Alloc> basic_string<_CharT, _Traits, _Alloc>::basic_string(const basic_string<_CharT, _Traits, _Alloc> & __s)
  : _String_base<_CharT,_Alloc>(__s.get_allocator())
{
  _M_range_initialize(__s._M_start, __s._M_finish);
}





}
# 1491 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.h" 1
# 36 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.h"
namespace _STL {



template <class _CharT, class _Traits, class _Alloc>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT,_Traits,_Alloc>& __s);

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT,_Traits,_Alloc>& __s);

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s,
        _CharT __delim);



template <class _CharT, class _Traits, class _Alloc>
inline basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s)
{
  return getline(__is, __s, __is.widen('\n'));
}


template <class _CharT, class _Traits>
bool
__stlp_string_fill(basic_ostream<_CharT, _Traits>& __os,
                  basic_streambuf<_CharT, _Traits>* __buf,
                  size_t __n);
# 114 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.h"
}




# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.c" 1
# 9 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.c"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctype.h" 1
# 26 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctype.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/c_locale.h" 1
# 109 "c:/marmalade/6.2/s3e/h/std/c++/stl/c_locale.h"
struct _Locale_ctype;
struct _Locale_numeric;
struct _Locale_time;
struct _Locale_collate;
struct _Locale_monetary;
struct _Locale_messages;
# 27 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctype.h" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_locale.h" 1
# 46 "c:/marmalade/6.2/s3e/h/std/c++/stl/_locale.h"
namespace _STL {

class _Locale_impl;
class _Locale;
class locale;
class ios_base;


template <class _CharT>
bool
__locale_do_operator_call (const locale* __that,
                           const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >& __x,
                           const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >& __y);



class locale {
public:


  class facet : private _Refcount_Base {
  protected:
    explicit facet(size_t __no_del = 0) : _Refcount_Base(1), _M_delete(__no_del == 0) {}
    virtual ~facet();
    friend class locale;
    friend class _Locale_impl;
    friend class _Locale;

  private:
    facet(const facet& __f) : _Refcount_Base(1), _M_delete(__f._M_delete == 0) {};
    void operator=(const facet&);

  private:
    const bool _M_delete;
  };




  class

  id {
    friend class locale;
    friend class _Locale_impl;
  public:
    size_t _M_index;
    static size_t _S_max;
  };

  typedef int category;



  static const category

    none = 0x000,
    collate = 0x010,
    ctype = 0x020,
    monetary = 0x040,
    numeric = 0x100,
    time = 0x200,
    messages = 0x400,
    all = collate | ctype | monetary | numeric | time | messages



  ;


  locale();
  locale(const locale&) ;
  explicit locale(const char *);
  locale(const locale&, const char*, category);


  locale(_Locale_impl*);
  locale(_Locale_impl*, bool);

public:


  template <class _Facet>
  locale(const locale& __loc, _Facet* __f) : _M_impl(0)
    {

      new(this) locale(__loc._M_impl, __f != 0);
      if (__f != 0)
        this->_M_insert(__f, _Facet::id);
    }


  locale(const locale&, const locale&, category);
  ~locale() ;
  const locale& operator=(const locale&) ;


  template <class _Facet> locale combine(const locale& __loc) {
    locale __result(__loc._M_impl, true);
    if (facet* __f = __loc._M_get_facet(_Facet::id)) {
      __result._M_insert(__f, _Facet::id);
      __f->_M_incr();
    }
    else
      _M_throw_runtime_error();
    return __result;
  }


  string name() const;

  bool operator==(const locale&) const;
  bool operator!=(const locale&) const;







  template <class _CharT, class _Traits, class _Alloc>
  bool operator()(const basic_string<_CharT, _Traits, _Alloc>& __x,
                  const basic_string<_CharT, _Traits, _Alloc>& __y) const {
    return __locale_do_operator_call(this, __x, __y);
  }



  static locale global(const locale&);
  static const locale& classic();

public:
  facet* _M_get_facet(const id&) const;

  facet* _M_use_facet(const id&) const;
  static void _M_throw_runtime_error(const char* = 0);
  static void _S_initialize();
  static void _S_uninitialize();

private:

  void _M_insert(facet* __f, id& __id);


  friend class _Locale_impl;
  friend class _Locale;
  friend class ios_base;

private:
  _Locale_impl* _M_impl;
};
# 205 "c:/marmalade/6.2/s3e/h/std/c++/stl/_locale.h"
template <class _Facet> inline const _Facet& use_facet(const locale& __loc)

{
  return *static_cast<const _Facet*>(__loc._M_use_facet(_Facet::id));
}
# 219 "c:/marmalade/6.2/s3e/h/std/c++/stl/_locale.h"
template <class _Facet> inline bool has_facet(const locale& __loc)

{
  return (__loc._M_get_facet(_Facet::id) != 0);
}






}
# 30 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ctype.h" 2





namespace _STL {

class ctype_base {
public:
  enum mask {
    space = 0x8,
    print = ((0x0100|0x1|0x2) | 0x4 | 0x40 | 0x10),
    cntrl = 0x20,
    upper = 0x1,
    lower = 0x2,
    alpha = ( (0x0100|0x1|0x2) & ~ (0x1 | 0x2 )),
    digit = 0x4,
    punct = 0x10,
    xdigit = 0x80,
    alnum = alpha | digit,
    graph = alnum | punct
  };
};



template <class charT> class ctype {};
template <class charT> class ctype_byname {};



template<>
class ctype<char> : public locale::facet, public ctype_base
{






    friend class ctype<wchar_t>;


  friend class _Locale;
public:

  typedef char char_type;

  explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);
  bool is(mask __m, char __c) const
    { return ((*(_M_ctype_table+(unsigned char)__c)) & __m) != 0; }

  const char* is(const char* __low, const char* __high, mask* __vec) const {
    for (const char* __p = __low;__p != __high; ++__p, ++__vec) {
      *__vec = _M_ctype_table[(unsigned char)*__p];
    }
    return __high;
  }

  const char* scan_is(mask __m, const char* __low, const char* __high) const;
  const char* scan_not(mask __m, const char* __low, const char* __high) const;

  char (toupper)(char __c) const { return do_toupper(__c); }
  const char* (toupper)(char* __low, const char* __high) const {
    return do_toupper(__low, __high);
  }

  char (tolower)(char __c) const { return do_tolower(__c); }
  const char* (tolower)(char* __low, const char* __high) const {
    return do_tolower(__low, __high);
  }

  char widen(char __c) const { return do_widen(__c); }
  const char* widen(const char* __low, const char* __high, char* __to) const {
    return do_widen(__low, __high, __to);
  }

  char narrow(char __c, char __dfault) const {
    return do_narrow(__c, __dfault);
  }
  const char* narrow(const char* __low, const char* __high,
                     char __dfault, char* __to) const {
    return do_narrow(__low, __high, __dfault, __to);
  }

  static locale::id id;



  static const size_t table_size = 256;


protected:
  const mask* table() const {return _M_ctype_table;}
  static const mask* classic_table() { return & _S_classic_table [1]; }

  ~ctype();

  virtual char do_toupper(char __c) const;
  virtual char do_tolower(char __c) const;
  virtual const char* do_toupper(char* __low, const char* __high) const;
  virtual const char* do_tolower(char* __low, const char* __high) const;
  virtual char do_widen(char __c) const;
  virtual const char* do_widen(const char* __low, const char* __high,
                               char* __to) const;
  virtual char do_narrow(char __c, char ) const;
  virtual const char* do_narrow(const char* __low, const char* __high,
                                char , char* __to) const;
private:
  struct _Is_mask {
    mask __m;
    _Is_mask(mask __x): __m(__x) {}
   bool operator()(char __c) {return (__m & (unsigned char) __c) != 0;}
  };

  static const mask _S_classic_table[257 ];
  const mask* _M_ctype_table;
  bool _M_delete;

  static const unsigned char _S_upper[256 ];
  static const unsigned char _S_lower[256 ];
};

template<>
class ctype_byname<char>: public ctype<char> {
public:
  explicit ctype_byname(const char*, size_t = 0);
  ~ctype_byname();

  virtual char do_toupper(char __c) const;
  virtual char do_tolower(char __c) const;

  virtual const char* do_toupper(char*, const char*) const;
  virtual const char* do_tolower(char*, const char*) const;

private:
  mask _M_byname_table[table_size + 1];
  _Locale_ctype* _M_ctype;
};



template<>
class ctype<wchar_t> : public locale::facet, public ctype_base
{
  friend class _Locale;
public:
  typedef wchar_t char_type;

  explicit ctype(size_t __refs = 0) : locale::facet(__refs) {}

  bool is(mask __m, wchar_t __c) const
    { return do_is(__m, __c); }

  const wchar_t* is(const wchar_t* __low, const wchar_t* __high,
                    mask* __vec) const
    { return do_is(__low, __high, __vec); }

  const wchar_t* scan_is(mask __m,
                         const wchar_t* __low, const wchar_t* __high) const
    { return do_scan_is(__m, __low, __high); }

  const wchar_t* scan_not (mask __m,
                           const wchar_t* __low, const wchar_t* __high) const
    { return do_scan_not(__m, __low, __high); }

  wchar_t (toupper)(wchar_t __c) const { return do_toupper(__c); }
  const wchar_t* (toupper)(wchar_t* __low, const wchar_t* __high) const
    { return do_toupper(__low, __high); }

  wchar_t (tolower)(wchar_t __c) const { return do_tolower(__c); }
  const wchar_t* (tolower)(wchar_t* __low, const wchar_t* __high) const
    { return do_tolower(__low, __high); }

  wchar_t widen(char __c) const { return do_widen(__c); }
  const char* widen(const char* __low, const char* __high,
                    wchar_t* __to) const
    { return do_widen(__low, __high, __to); }

  char narrow(wchar_t __c, char __dfault) const
    { return do_narrow(__c, __dfault); }
  const wchar_t* narrow(const wchar_t* __low, const wchar_t* __high,
                        char __dfault, char* __to) const
    { return do_narrow(__low, __high, __dfault, __to); }

  static locale::id id;

protected:
  ~ctype();

  virtual bool do_is(mask __m, wchar_t __c) const;
  virtual const wchar_t* do_is(const wchar_t*, const wchar_t*, mask*) const;
  virtual const wchar_t* do_scan_is(mask,
                                    const wchar_t*, const wchar_t*) const;
  virtual const wchar_t* do_scan_not(mask,
                                     const wchar_t*, const wchar_t*) const;
  virtual wchar_t do_toupper(wchar_t __c) const;
  virtual const wchar_t* do_toupper(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_tolower(wchar_t c) const;
  virtual const wchar_t* do_tolower(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_widen(char c) const;
  virtual const char* do_widen(const char*, const char*, wchar_t*) const;
  virtual char do_narrow(wchar_t __c, char __dfault) const;
  virtual const wchar_t* do_narrow(const wchar_t*, const wchar_t*,
                                   char, char*) const;
};

template<>
class ctype_byname<wchar_t>: public ctype<wchar_t> {
public:
  explicit ctype_byname(const char* __name, size_t __refs = 0);

protected:
  ~ctype_byname();

  virtual bool do_is(mask __m, wchar_t __c) const;
  virtual const wchar_t* do_is(const wchar_t*, const wchar_t*, mask*) const;
  virtual const wchar_t* do_scan_is(mask,
                                    const wchar_t*, const wchar_t*) const;
  virtual const wchar_t* do_scan_not(mask,
                                     const wchar_t*, const wchar_t*) const;
  virtual wchar_t do_toupper(wchar_t __c) const;
  virtual const wchar_t* do_toupper(wchar_t*, const wchar_t*) const;
  virtual wchar_t do_tolower(wchar_t c) const;
  virtual const wchar_t* do_tolower(wchar_t*, const wchar_t*) const;

private:
  _Locale_ctype* _M_ctype;
};



}
# 10 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.c" 2






namespace _STL {
# 26 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.c"
template <class _CharT, class _Traits>
bool
__stlp_string_fill(basic_ostream<_CharT, _Traits>& __os,
                  basic_streambuf<_CharT, _Traits>* __buf,
                  size_t __n)
{
  _CharT __f = __os.fill();
  size_t __i;
  bool __ok = true;

  for (__i = 0; __i < __n; ++__i)
    __ok = __ok && !_Traits::eq_int_type(__buf->sputc(__f), _Traits::eof());
  return __ok;
}

template <class _CharT, class _Traits, class _Alloc>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os,
           const basic_string<_CharT,_Traits,_Alloc>& __s)
{

 
  typedef basic_ostream<_CharT, _Traits> __ostream;
  typename __ostream::sentry __sentry(__os);
  bool __ok = false;

  if (__sentry) {
    __ok = true;
    size_t __n = __s.size();
    size_t __pad_len = 0;
    const bool __left = (__os.flags() & __ostream::left) != 0;
    const size_t __w = __os.width(0);
    basic_streambuf<_CharT, _Traits>* __buf = __os.rdbuf();

    if (__n < __w) {
      __pad_len = __w - __n;
    }

    if (!__left)
      __ok = __stlp_string_fill(__os, __buf, __pad_len);

    __ok = __ok && (__buf->sputn(__s.data(), streamsize(__n)) == streamsize(__n));

    if (__left)
      __ok = __ok && __stlp_string_fill(__os, __buf, __pad_len);
  }

  if (!__ok)
    __os.setstate(__ostream::failbit);

  return __os;
}

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is,
           basic_string<_CharT,_Traits, _Alloc>& __s)
{
 
  typedef basic_istream<_CharT, _Traits> __istream;
  typename __istream::sentry __sentry(__is);

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
    typedef ctype<_CharT> _C_type;



    const _C_type& _Ctype = *(const _C_type*)__is._M_ctype_facet();
# 107 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.c"
    __s.clear();
    size_t __n = __is.width(0);
    if (__n == 0)
      __n = static_cast<size_t>(-1);
    else
      __s.reserve(__n);


    while (__n-- > 0) {
      typename _Traits::int_type __c1 = __buf->sbumpc();
      if (_Traits::eq_int_type(__c1, _Traits::eof())) {
        __is.setstate(__istream::eofbit);
        break;
      }
      else {
        _CharT __c = _Traits::to_char_type(__c1);

        if (_Ctype.is(_C_type::space, __c)) {
          if (_Traits::eq_int_type(__buf->sputbackc(__c), _Traits::eof()))
            __is.setstate(__istream::failbit);
          break;
        }
        else
          __s.push_back(__c);
      }
    }


    if (__s.size() == 0)
      __is.setstate(__istream::failbit);
  }
  else
    __is.setstate(__istream::failbit);

  return __is;
}

template <class _CharT, class _Traits, class _Alloc>
basic_istream<_CharT, _Traits>&
getline(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT,_Traits,_Alloc>& __s,
        _CharT __delim)
{
 
  typedef basic_istream<_CharT, _Traits> __istream;
  size_t __nread = 0;
  typename basic_istream<_CharT, _Traits>::sentry __sentry(__is, true);
  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
    __s.clear();

    while (__nread < __s.max_size()) {
      int __c1 = __buf->sbumpc();
      if (_Traits::eq_int_type(__c1, _Traits::eof())) {
        __is.setstate(__istream::eofbit);
        break;
      }
      else {
        ++__nread;
        _CharT __c = _Traits::to_char_type(__c1);
        if (!_Traits::eq(__c, __delim))
          __s.push_back(__c);
        else
          break;
      }
    }
  }
  if (__nread == 0 || __nread >= __s.max_size())
    __is.setstate(__istream::failbit);

  return __is;
}
# 329 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.c"
}
# 120 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_io.h" 2
# 1494 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_hash.h" 1
# 23 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_hash.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_hash_fun.h" 1
# 38 "c:/marmalade/6.2/s3e/h/std/c++/stl/_hash_fun.h"
namespace _STL {

template <class _Key> struct hash { };

inline size_t __stl_hash_string(const char* __s)
{
 
  unsigned long __h = 0;
  for ( ; *__s; ++__s)
    __h = 5*__h + *__s;

  return size_t(__h);
}

template<> struct hash<char*>
{
  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
};

template<> struct hash<const char*>
{
  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
};

template<> struct hash<char> {
  size_t operator()(char __x) const { return __x; }
};
template<> struct hash<unsigned char> {
  size_t operator()(unsigned char __x) const { return __x; }
};

template<> struct hash<signed char> {
  size_t operator()(unsigned char __x) const { return __x; }
};

template<> struct hash<short> {
  size_t operator()(short __x) const { return __x; }
};
template<> struct hash<unsigned short> {
  size_t operator()(unsigned short __x) const { return __x; }
};
template<> struct hash<int> {
  size_t operator()(int __x) const { return __x; }
};
template<> struct hash<unsigned int> {
  size_t operator()(unsigned int __x) const { return __x; }
};
template<> struct hash<long> {
  size_t operator()(long __x) const { return __x; }
};
template<> struct hash<unsigned long> {
  size_t operator()(unsigned long __x) const { return __x; }
};


template<> struct hash<long long> {
  size_t operator()(long x) const { return x; }
};
template<> struct hash<unsigned long long> {
  size_t operator()(unsigned long x) const { return x; }
};


}
# 24 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_hash.h" 2






namespace _STL {

template <class _CharT, class _Traits, class _Alloc>
inline size_t
__stl_string_hash(const basic_string<_CharT,_Traits,_Alloc>& __s) {
  unsigned long __h = 0;
  typedef typename basic_string<_CharT,_Traits,_Alloc>::const_pointer const_ptr;
  size_t __len = __s.size();
  const _CharT* __data = __s.data();
  for ( size_t __i = 0; __i < __len; ++__i)
    __h = 5*__h + __data[__i];
  return size_t(__h);
}



template <class _CharT, class _Traits, class _Alloc>
struct hash<basic_string<_CharT,_Traits,_Alloc> > {
  size_t operator()(const basic_string<_CharT,_Traits,_Alloc>& __s) const
    { return __stl_string_hash(__s); }
};
# 68 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string_hash.h"
}
# 1495 "c:/marmalade/6.2/s3e/h/std/c++/stl/_string.h" 2
# 46 "c:/marmalade/6.2/s3e/h/std/c++/string" 2







# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 2
# 54 "c:/marmalade/6.2/s3e/h/std/c++/string" 2
# 5 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/history.h" 2

class CHistory
{
public:
 CHistory(char* filename);

 ~CHistory();

 char** histArray;
 int size;
 int location;
 TiXmlDocument histDoc;
 TiXmlElement* histElem;
 bool playerTurn;
 char* histFilename;

 bool addNpcTextToHist(int id, char text[250]);
 bool addPlayerTextToHist(int id, char text[250]);
 void clearAndCreateHist();
};
# 2 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/history.cpp" 2
# 1 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/h/tinyxml.h" 1
# 3 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/history.cpp" 2

# 1 "c:/marmalade/6.2/s3e/h/std/c++/iostream" 1
# 24 "c:/marmalade/6.2/s3e/h/std/c++/iostream"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h" 1
# 16 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/6.2/s3e/h/std/c++/stl/_prolog.h" 2
# 25 "c:/marmalade/6.2/s3e/h/std/c++/iostream" 2



         





# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.h" 1
# 27 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios.h" 1
# 23 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios_base.h" 1
# 22 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios_base.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stdexcept" 1
# 29 "c:/marmalade/6.2/s3e/h/std/c++/stdexcept"
         







# 1 "c:/marmalade/6.2/s3e/h/std/c++/exception" 1
# 75 "c:/marmalade/6.2/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/6.2/s3e/h/std/c++/exception"
}
# 38 "c:/marmalade/6.2/s3e/h/std/c++/stdexcept" 2
# 54 "c:/marmalade/6.2/s3e/h/std/c++/stdexcept"
namespace _STL {



using __std_alias::exception;




class __Named_exception : public exception {
public:
  __Named_exception(const string& __str)

    ;
  const char* what() const throw();
  ~__Named_exception() throw();
# 78 "c:/marmalade/6.2/s3e/h/std/c++/stdexcept"
private:
  enum { _S_bufsize = 256 };
  char _M_name[_S_bufsize];
};

class logic_error : public __Named_exception {
public:
  logic_error(const string& __s) : __Named_exception(__s) {}

  ~logic_error() throw();

};

class runtime_error : public __Named_exception {
public:
  runtime_error(const string& __s) : __Named_exception(__s) {}

  ~runtime_error() throw();

};

class domain_error : public logic_error {
public:
  domain_error(const string& __arg) : logic_error(__arg) {}

  ~domain_error() throw();

};

class invalid_argument : public logic_error {
public:
  invalid_argument(const string& __arg) : logic_error(__arg) {}

  ~invalid_argument() throw();

};

class length_error : public logic_error {
public:
  length_error(const string& __arg) : logic_error(__arg) {}

  ~length_error() throw();

};

class out_of_range : public logic_error {
public:
  out_of_range(const string& __arg) : logic_error(__arg) {}

  ~out_of_range() throw();

};

class range_error : public runtime_error {
public:
  range_error(const string& __arg) : runtime_error(__arg) {}

  ~range_error() throw();

};

class overflow_error : public runtime_error {
public:
  overflow_error(const string& __arg) : runtime_error(__arg) {}

  ~overflow_error() throw();

};

class underflow_error : public runtime_error {
public:
  underflow_error(const string& __arg) : runtime_error(__arg) {}

  ~underflow_error() throw();

};

}
# 23 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios_base.h" 2


# 1 "c:/marmalade/6.2/s3e/h/std/c++/utility" 1
# 32 "c:/marmalade/6.2/s3e/h/std/c++/utility"
         
# 26 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios_base.h" 2
# 34 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios_base.h"
namespace _STL {
# 45 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios_base.h"
class ios_base {
public:

  class failure : public __Named_exception {
  public:
    explicit failure(const string&);
    virtual ~failure() throw();
  };

  typedef int fmtflags;
  typedef int iostate;
  typedef int openmode;
  typedef int seekdir;


  typedef fmtflags fmt_flags;







  static const int

    left = 0x0001,
    right = 0x0002,
    internal = 0x0004,
    dec = 0x0008,
    hex = 0x0010,
    oct = 0x0020,
    fixed = 0x0040,
    scientific = 0x0080,
    boolalpha = 0x0100,
    showbase = 0x0200,
    showpoint = 0x0400,
    showpos = 0x0800,
    skipws = 0x1000,
    unitbuf = 0x2000,
    uppercase = 0x4000,
    adjustfield = left | right | internal,
    basefield = dec | hex | oct,
    floatfield = scientific | fixed,


    goodbit = 0x00,
    badbit = 0x01,
    eofbit = 0x02,
    failbit = 0x04,


    __default_mode = 0x0,
    app = 0x01,
    ate = 0x02,
    binary = 0x04,
    in = 0x08,
    out = 0x10,
    trunc = 0x20,



    beg = 0x01,
    cur = 0x02,
    end = 0x04



  ;

public:
  fmtflags flags() const { return _M_fmtflags; }
  fmtflags flags(fmtflags __flags) {
    fmtflags __tmp = _M_fmtflags;
    _M_fmtflags = __flags;
    return __tmp;
  }

  fmtflags setf(fmtflags __flag) {
    fmtflags __tmp = _M_fmtflags;
    _M_fmtflags |= __flag;
    return __tmp;
  }
  fmtflags setf(fmtflags __flag, fmtflags __mask) {
    fmtflags __tmp = _M_fmtflags;
    _M_fmtflags &= ~__mask;
    _M_fmtflags |= __flag & __mask;
    return __tmp;
  }
  void unsetf(fmtflags __mask) { _M_fmtflags &= ~__mask; }

  streamsize precision() const { return _M_precision; }
  streamsize precision(streamsize __newprecision) {
    streamsize __tmp = _M_precision;
    _M_precision = __newprecision;
    return __tmp;
  }

  streamsize width() const { return _M_width; }
  streamsize width(streamsize __newwidth) {
    streamsize __tmp = _M_width;
    _M_width = __newwidth;
    return __tmp;
  }

public:
  locale imbue(const locale&);
  locale getloc() const { return _M_locale; }

public:
  static int xalloc();
  long& iword(int __index);
  void*& pword(int __index);

public:
  virtual ~ios_base();

public:
  enum event { erase_event, imbue_event, copyfmt_event };
  typedef void (*event_callback)(event, ios_base&, int __index);
  void register_callback(event_callback __fn, int __index);

public:


  static bool sync_with_stdio(bool __sync = true);

public:



  operator void*() const { return !fail() ? (void*) const_cast<ios_base*>(this) : (void*) 0; }
  bool operator!() const { return fail(); }

  iostate rdstate() const { return _M_iostate; }

  bool good() const { return _M_iostate == 0; }
  bool eof() const { return (_M_iostate & eofbit) != 0; }
  bool fail() const { return (_M_iostate & (failbit | badbit)) != 0; }
  bool bad() const { return (_M_iostate & badbit) != 0; }

protected:





  void _M_copy_state(const ios_base& __x);

  void _M_setstate_nothrow(iostate __state) { _M_iostate |= __state; }
  void _M_clear_nothrow(iostate __state) { _M_iostate = __state; }
  iostate _M_get_exception_mask() const { return _M_exception_mask; }
  void _M_set_exception_mask(iostate __mask) { _M_exception_mask = __mask; }
  void _M_check_exception_mask() {
    if (_M_iostate & _M_exception_mask)
      _M_throw_failure();
  }

  void _M_invoke_callbacks(event);
  void _M_throw_failure();

  ios_base();

protected:
  static void _S_initialize();
  static void _S_uninitialize();
  static bool _S_was_synced;

private:

  ios_base(const ios_base&);
  void operator=(const ios_base&);

private:

  fmtflags _M_fmtflags;
  iostate _M_iostate;
  openmode _M_openmode;
  seekdir _M_seekdir;
  iostate _M_exception_mask;

  streamsize _M_precision;
  streamsize _M_width;

  locale _M_locale;

  pair<event_callback, int>* _M_callbacks;
  size_t _M_num_callbacks;
  size_t _M_callback_index;


  long* _M_iwords;
  size_t _M_num_iwords;

  void** _M_pwords;
  size_t _M_num_pwords;

  static int _S_index;

protected:

  locale::facet* _M_cached_ctype;
  locale::facet* _M_cached_numpunct;
  string _M_cached_grouping;
public:

  const locale::facet* _M_ctype_facet() const { return _M_cached_ctype; }
  const locale::facet* _M_numpunct_facet() const { return _M_cached_numpunct; }
  const string& _M_grouping() const { return _M_cached_grouping; }
public:







  class Init {
  public:
    Init();
    ~Init();
  private:
    static long _S_count;
    friend class ios_base;
  };


  class _Loc_init {
  public:
    _Loc_init();
    ~_Loc_init();
  private:
    static long _S_count;
    friend class locale;
    friend class ios_base;
  };

  friend class Init;

public:


  typedef iostate io_state;
  typedef openmode open_mode;
  typedef seekdir seek_dir;
  typedef _STL::streamoff streamoff;
  typedef _STL::streampos streampos;

};






inline ios_base& boolalpha(ios_base& __s)
  { __s.setf(ios_base::boolalpha); return __s;}

inline ios_base& noboolalpha(ios_base& __s)
  { __s.unsetf(ios_base::boolalpha); return __s;}

inline ios_base& showbase(ios_base& __s)
  { __s.setf(ios_base::showbase); return __s;}

inline ios_base& noshowbase(ios_base& __s)
  { __s.unsetf(ios_base::showbase); return __s;}

inline ios_base& showpoint(ios_base& __s)
  { __s.setf(ios_base::showpoint); return __s;}

inline ios_base& noshowpoint(ios_base& __s)
  { __s.unsetf(ios_base::showpoint); return __s;}

inline ios_base& showpos(ios_base& __s)
  { __s.setf(ios_base::showpos); return __s;}

inline ios_base& noshowpos(ios_base& __s)
  { __s.unsetf(ios_base::showpos); return __s;}

inline ios_base& skipws(ios_base& __s)
  { __s.setf(ios_base::skipws); return __s;}

inline ios_base& noskipws(ios_base& __s)
  { __s.unsetf(ios_base::skipws); return __s;}

inline ios_base& uppercase(ios_base& __s)
  { __s.setf(ios_base::uppercase); return __s;}

inline ios_base& nouppercase(ios_base& __s)
  { __s.unsetf(ios_base::uppercase); return __s;}

inline ios_base& unitbuf(ios_base& __s)
  { __s.setf(ios_base::unitbuf); return __s;}

inline ios_base& nounitbuf(ios_base& __s)
  { __s.unsetf(ios_base::unitbuf); return __s;}



inline ios_base& internal(ios_base& __s)
  { __s.setf(ios_base::internal, ios_base::adjustfield); return __s; }

inline ios_base& left(ios_base& __s)
  { __s.setf(ios_base::left, ios_base::adjustfield); return __s; }

inline ios_base& right(ios_base& __s)
  { __s.setf(ios_base::right, ios_base::adjustfield); return __s; }


inline ios_base& dec(ios_base& __s)
  { __s.setf(ios_base::dec, ios_base::basefield); return __s; }

inline ios_base& hex(ios_base& __s)
  { __s.setf(ios_base::hex, ios_base::basefield); return __s; }

inline ios_base& oct(ios_base& __s)
  { __s.setf(ios_base::oct, ios_base::basefield); return __s; }



inline ios_base& fixed(ios_base& __s)
  { __s.setf(ios_base::fixed, ios_base::floatfield); return __s; }

inline ios_base& scientific(ios_base& __s)
  { __s.setf(ios_base::scientific, ios_base::floatfield); return __s; }
# 396 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios_base.h"
}
# 24 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios.h" 2






# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_numpunct.h" 1
# 38 "c:/marmalade/6.2/s3e/h/std/c++/stl/_numpunct.h"
namespace _STL {




template <class _CharT> class numpunct {};
template <class _CharT> class numpunct_byname {};
template <class _Ch, class _InIt> class num_get;

template<>
class numpunct<char> : public locale::facet
{
  friend class _Locale;

  template <class _Ch, class _InIt> friend class num_get;

public:
  typedef char char_type;
  typedef string string_type;

  explicit numpunct(size_t __refs = 0) : locale::facet(__refs) {}

  char decimal_point() const { return do_decimal_point(); }
  char thousands_sep() const { return do_thousands_sep(); }
  string grouping() const { return do_grouping(); }
  string truename() const { return do_truename(); }
  string falsename() const { return do_falsename(); }

  static locale::id id;


protected:

  ~numpunct();

  static string _M_truename;
  static string _M_falsename;
  static string _M_grouping;

  virtual char do_decimal_point() const;
  virtual char do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual string do_truename() const;
  virtual string do_falsename() const;
};



template<>
class numpunct<wchar_t> : public locale::facet
{
  friend class _Locale;
public:
  typedef wchar_t char_type;
  typedef wstring string_type;

  explicit numpunct(size_t __refs = 0) : locale::facet(__refs) {}

  wchar_t decimal_point() const { return do_decimal_point(); }
  wchar_t thousands_sep() const { return do_thousands_sep(); }
  string grouping() const { return do_grouping(); }
  wstring truename() const { return do_truename(); }
  wstring falsename() const { return do_falsename(); }

  static locale::id id;

protected:
  static wstring _M_truename;
  static wstring _M_falsename;
  static string _M_grouping;

  ~numpunct();

  virtual wchar_t do_decimal_point() const;
  virtual wchar_t do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual wstring do_truename() const;
  virtual wstring do_falsename() const;
};



template<>
class numpunct_byname<char> : public numpunct<char> {
public:
  typedef char char_type;
  typedef string string_type;

  explicit numpunct_byname(const char* __name, size_t __refs = 0);

protected:

  ~numpunct_byname();

  virtual char do_decimal_point() const;
  virtual char do_thousands_sep() const;
  virtual string do_grouping() const;

private:
  _Locale_numeric* _M_numeric;
};


template<>
class numpunct_byname<wchar_t>: public numpunct<wchar_t> {
public:
  typedef wchar_t char_type;
  typedef wstring string_type;

  explicit numpunct_byname(const char* __name, size_t __refs = 0);

protected:

  ~numpunct_byname();

  virtual wchar_t do_decimal_point() const;
  virtual wchar_t do_thousands_sep() const;
  virtual string do_grouping() const;

private:
  _Locale_numeric* _M_numeric;
};



}
# 31 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios.h" 2


namespace _STL {
# 46 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios.h"
template <class _CharT, class _Traits>
class basic_ios : public ios_base {
  friend class ios_base;
public:
  typedef _CharT char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits traits_type;

public:
  explicit basic_ios(basic_streambuf<_CharT, _Traits>* __streambuf);
  virtual ~basic_ios() {}

public:
  basic_ostream<_CharT, _Traits>* tie() const {
    return _M_tied_ostream;
  }
  basic_ostream<_CharT, _Traits>*
  tie(basic_ostream<char_type, traits_type>* __new_tied_ostream) {
    basic_ostream<char_type, traits_type>* __tmp = _M_tied_ostream;
    _M_tied_ostream = __new_tied_ostream;
    return __tmp;
  }

  basic_streambuf<_CharT, _Traits>* rdbuf() const
    { return _M_streambuf; }

  basic_streambuf<_CharT, _Traits>*
  rdbuf(basic_streambuf<char_type, traits_type>*);


  basic_ios<_CharT, _Traits>& copyfmt(const basic_ios<_CharT, _Traits>& __x);

  char_type fill() const { return _M_fill; }
  char_type fill(char_type __fill) {
    char_type __tmp(_M_fill);
    _M_fill = __fill;
    return __tmp;
  }

public:


  void clear(iostate __state = goodbit) {
    _M_clear_nothrow(this->rdbuf() ? __state : iostate(__state|ios_base::badbit));
    _M_check_exception_mask();
  }
  void setstate(iostate __state) { this->clear(rdstate() | __state); }

  iostate exceptions() const { return this->_M_get_exception_mask(); }
  void exceptions(iostate __mask) {
    this->_M_set_exception_mask(__mask);
    this->clear(this->rdstate());
  }

public:
  locale imbue(const locale&);

  inline char narrow(_CharT, char) const ;
  inline _CharT widen(char) const;


  static bool _S_eof(int_type __c) {
    const int_type __eof = _Traits::eof();
    return _Traits::eq_int_type(__c, __eof);
  }

protected:
  basic_ios();

  void init(basic_streambuf<_CharT, _Traits>* __streambuf);

public:



  void _M_handle_exception(ios_base::iostate __flag);

private:
  char_type _M_fill;

  basic_streambuf<_CharT, _Traits>* _M_streambuf;
  basic_ostream<_CharT, _Traits>* _M_tied_ostream;

};


template <class _CharT, class _Traits>
inline char
basic_ios<_CharT, _Traits>::narrow(_CharT __c, char __default) const
{ return ((const ctype<_CharT>*)this->_M_ctype_facet())->narrow(__c, __default); }

template <class _CharT, class _Traits>
inline _CharT
basic_ios<_CharT, _Traits>::widen(char __c) const
{
  return ((const ctype<_CharT>*)this->_M_ctype_facet())->widen(__c); }
# 169 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios.h"
}


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios.c" 1
# 28 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios.c"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_streambuf.h" 1
# 29 "c:/marmalade/6.2/s3e/h/std/c++/stl/_streambuf.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_stdio_file.h" 1
# 81 "c:/marmalade/6.2/s3e/h/std/c++/stl/_stdio_file.h"
namespace _STL {






extern char* buf;
inline int _FILE_fd(const FILE *__f) { return ((int*)__f)[0]; }
inline char* _FILE_I_begin(const FILE *__f) { return buf; }
inline char* _FILE_I_next(const FILE *__f) { return buf; }
inline char* _FILE_I_end(const FILE *__f) { return buf; }
inline ptrdiff_t _FILE_I_avail(const FILE *__f) { return 0; }
inline char& _FILE_I_preincr(FILE *__f) { return buf[0]; }
inline char& _FILE_I_postincr(FILE *__f){ return buf[0]; }
inline char& _FILE_I_predecr(FILE *__f) { return buf[0]; }
inline char& _FILE_I_postdecr(FILE *__f) { return buf[0]; }
inline void _FILE_I_bump(FILE *__f, int __n) { }
inline void _FILE_I_set(FILE *__f, char* __begin, char* __next, char* __end) {}
# 753 "c:/marmalade/6.2/s3e/h/std/c++/stl/_stdio_file.h"
inline char* _FILE_O_begin(const FILE *__f) { return _FILE_I_begin(__f); }
inline char* _FILE_O_next(const FILE *__f) { return _FILE_I_next(__f); }
inline char* _FILE_O_end(const FILE *__f) { return _FILE_I_end(__f); }

inline ptrdiff_t _FILE_O_avail(const FILE *__f) { return _FILE_I_avail(__f); }

inline char& _FILE_O_preincr(FILE *__f) { return _FILE_I_preincr(__f); }
inline char& _FILE_O_postincr(FILE *__f) { return _FILE_I_postincr(__f); }
inline char& _FILE_O_predecr(FILE *__f) { return _FILE_I_predecr(__f); }
inline char& _FILE_O_postdecr(FILE *__f) { return _FILE_I_postdecr(__f); }

inline void _FILE_O_bump(FILE *__f, int __n) { _FILE_I_bump(__f, __n); }
inline void _FILE_O_set(FILE *__f, char* __begin, char* __next, char* __end)
  { _FILE_I_set(__f, __begin, __next, __end); }






}
# 30 "c:/marmalade/6.2/s3e/h/std/c++/stl/_streambuf.h" 2



namespace _STL {
# 55 "c:/marmalade/6.2/s3e/h/std/c++/stl/_streambuf.h"
template <class _CharT, class _Traits>
class basic_streambuf
{
  friend class basic_istream<_CharT, _Traits>;
  friend class basic_ostream<_CharT, _Traits>;

public:
  typedef _CharT char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits traits_type;

private:

  char_type* _M_gbegin;
  char_type* _M_gnext;
  char_type* _M_gend;

  char_type* _M_pbegin;
  char_type* _M_pnext;
  char_type* _M_pend;

  locale _M_locale;

public:
  _STLP_mutex _M_lock;

public:
  virtual ~basic_streambuf();

protected:
  basic_streambuf();

protected:
  char_type* eback() const { return _M_gbegin; }
  char_type* gptr() const { return _M_gnext; }
  char_type* egptr() const { return _M_gend; }

  void gbump(int __n) { _M_gnext += __n; }
  void setg(char_type* __gbegin, char_type* __gnext, char_type* __gend) {
    _M_gbegin = __gbegin;
    _M_gnext = __gnext;
    _M_gend = __gend;
  }

public:




  char_type* _M_eback() const { return eback(); }
  char_type* _M_gptr() const { return gptr(); }
  char_type* _M_egptr() const { return egptr(); }
  void _M_gbump(int __n) { gbump(__n); }
  void _M_setg(char_type* __gbegin, char_type* __gnext, char_type* __gend)
    { setg(__gbegin, __gnext, __gend); }

protected:

  char_type* pbase() const { return _M_pbegin; }
  char_type* pptr() const { return _M_pnext; }
  char_type* epptr() const { return _M_pend; }

  void pbump(int __n) { _M_pnext += __n; }
  void setp(char_type* __pbegin, char_type* __pend) {
    _M_pbegin = __pbegin;
    _M_pnext = __pbegin;
    _M_pend = __pend;
  }

protected:

  virtual basic_streambuf<_CharT, _Traits>* setbuf(char_type*, streamsize);



  virtual pos_type seekoff(off_type, ios_base::seekdir,
                           ios_base::openmode = ios_base::in | ios_base::out);



  virtual pos_type
  seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out);



  virtual int sync();


public:
  basic_streambuf<_CharT, _Traits>* pubsetbuf(char_type* __s, streamsize __n)
    { return this->setbuf(__s, __n); }

  pos_type pubseekoff(off_type __offset, ios_base::seekdir __way,
                      ios_base::openmode __mod = ios_base::in | ios_base::out)
    { return this->seekoff(__offset, __way, __mod); }

  pos_type pubseekpos(pos_type __sp,
                      ios_base::openmode __mod = ios_base::in | ios_base::out)
    { return this->seekpos(__sp, __mod); }

  int pubsync() { return this->sync(); }

protected:





  virtual streamsize showmanyc();



  virtual streamsize xsgetn(char_type* __s, streamsize __n);




  virtual int_type underflow();



  virtual int_type uflow();




  virtual int_type pbackfail(int_type = traits_type::eof());

protected:




  virtual streamsize xsputn(const char_type* __s, streamsize __n);



  virtual streamsize _M_xsputnc(char_type __c, streamsize __n);



  virtual int_type overflow(int_type = traits_type::eof());

public:

  int_type sputc(char_type __c) {
    return ((_M_pnext < _M_pend) ? _Traits::to_int_type(*_M_pnext++ = __c)
      : this->overflow(_Traits::to_int_type(__c)));
  }


  streamsize sputn(const char_type* __s, streamsize __n)
    { return this->xsputn(__s, __n); }


  streamsize _M_sputnc(char_type __c, streamsize __n)
    { return this->_M_xsputnc(__c, __n); }

private:
  int_type _M_snextc_aux();


public:
  streamsize in_avail() {
    return (_M_gnext < _M_gend) ? (_M_gend - _M_gnext) : this->showmanyc();
  }


  int_type snextc() {
 return ( _M_gend - _M_gnext > 1 ?
             _Traits::to_int_type(*++_M_gnext) :
             this->_M_snextc_aux());
  }


  int_type sbumpc() {
    return _M_gnext < _M_gend ? _Traits::to_int_type(*_M_gnext++)
      : this->uflow();
  }


  int_type sgetc() {
    return _M_gnext < _M_gend ? _Traits::to_int_type(*_M_gnext)
      : this->underflow();
  }

  streamsize sgetn(char_type* __s, streamsize __n)
  { return this->xsgetn(__s, __n); }

  int_type sputbackc(char_type __c) {
    return ((_M_gbegin < _M_gnext) && _Traits::eq(__c, *(_M_gnext - 1)))
      ? _Traits::to_int_type(*--_M_gnext)
      : this->pbackfail(_Traits::to_int_type(__c));
  }

  int_type sungetc() {
    return (_M_gbegin < _M_gnext)
      ? _Traits::to_int_type(*--_M_gnext)
      : this->pbackfail();
  }

protected:





  virtual void imbue(const locale&);

public:
  locale pubimbue(const locale&);
  locale getloc() const { return _M_locale; }


  void stossc() { this->sbumpc(); }
# 284 "c:/marmalade/6.2/s3e/h/std/c++/stl/_streambuf.h"
};
# 523 "c:/marmalade/6.2/s3e/h/std/c++/stl/_streambuf.h"
}



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_streambuf.c" 1
# 27 "c:/marmalade/6.2/s3e/h/std/c++/stl/_streambuf.c"
namespace _STL {



template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
  : _M_gbegin(0), _M_gnext(0), _M_gend(0),
    _M_pbegin(0), _M_pnext(0), _M_pend(0),
    _M_locale()
{

}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf()
{}


template <class _CharT, class _Traits>
locale
basic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc) {
  this->imbue(__loc);
  locale __tmp = _M_locale;
  _M_locale = __loc;
  return __tmp;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsgetn(_CharT* __s, streamsize __n)
{
  streamsize __result = 0;
  const int_type __eof = _Traits::eof();

  while (__result < __n) {
    if (_M_gnext < _M_gend) {
      size_t __chunk = (min) (static_cast<size_t>(_M_gend - _M_gnext),
                           static_cast<size_t>(__n - __result));
      _Traits::copy(__s, _M_gnext, __chunk);
      __result += __chunk;
      __s += __chunk;
      _M_gnext += __chunk;
    }
    else {
      int_type __c = this->sbumpc();
      if (!_Traits::eq_int_type(__c, __eof)) {
        *__s = __c;
        ++__result;
 ++__s;
      }
      else
        break;
    }
  }

  return __result;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::xsputn(const _CharT* __s, streamsize __n)
{
  streamsize __result = 0;
  const int_type __eof = _Traits::eof();

  while (__result < __n) {
    if (_M_pnext < _M_pend) {
      size_t __chunk = (min) (static_cast<size_t>(_M_pend - _M_pnext),
                           static_cast<size_t>(__n - __result));
      _Traits::copy(_M_pnext, __s, __chunk);
      __result += __chunk;
      __s += __chunk;
      _M_pnext += __chunk;
    }

    else if (!_Traits::eq_int_type(this->overflow(_Traits::to_int_type(*__s)),
                                   __eof)) {
      ++__result;
      ++__s;
    }
    else
      break;
  }
  return __result;
}

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::_M_xsputnc(_CharT __c, streamsize __n)
{
  streamsize __result = 0;
  const int_type __eof = _Traits::eof();

  while (__result < __n) {
    if (_M_pnext < _M_pend) {
      size_t __chunk = (min) (static_cast<size_t>(_M_pend - _M_pnext),
                           static_cast<size_t>(__n - __result));
      _Traits::assign(_M_pnext, __chunk, __c);
      __result += __chunk;
      _M_pnext += __chunk;
    }

    else if (!_Traits::eq_int_type(this->overflow(_Traits::to_int_type(__c)),
                                   __eof))
      ++__result;
    else
      break;
  }
  return __result;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::_M_snextc_aux()
{
  int_type __eof = _Traits::eof();
  if (_M_gend == _M_gnext)
    return _Traits::eq_int_type(this->uflow(), __eof) ? __eof : this->sgetc();
  else {
    _M_gnext = _M_gend;
    return this->underflow();
  }
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::pbackfail(int_type) {
 return _Traits::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::overflow(int_type) {
  return _Traits::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow() {
    return ( _Traits::eq_int_type(this->underflow(),_Traits::eof()) ?
             _Traits::eof() :
             _Traits::to_int_type(*_M_gnext++));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow()
{ return _Traits::eof(); }

template <class _CharT, class _Traits>
streamsize
basic_streambuf<_CharT, _Traits>::showmanyc()
{ return 0; }

template <class _CharT, class _Traits>
void
basic_streambuf<_CharT, _Traits>::imbue(const locale&) {}

template <class _CharT, class _Traits>
int
basic_streambuf<_CharT, _Traits>::sync() { return 0; }

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)
{ return pos_type(-1); }

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
       ios_base::openmode)
{ return pos_type(-1); }

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_streambuf<_CharT, _Traits>:: setbuf(char_type*, streamsize)
{ return this; }
# 212 "c:/marmalade/6.2/s3e/h/std/c++/stl/_streambuf.c"
}
# 528 "c:/marmalade/6.2/s3e/h/std/c++/stl/_streambuf.h" 2
# 29 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios.c" 2






namespace _STL {




template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>
  ::basic_ios(basic_streambuf<_CharT, _Traits>* __streambuf)
    : ios_base(),
      _M_fill(_CharT()), _M_streambuf(0), _M_tied_ostream(0)
{
  init(__streambuf);
}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>*
basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __buf)
{
  basic_streambuf<_CharT, _Traits>* __tmp = _M_streambuf;
  _M_streambuf = __buf;
  this->clear();
  return __tmp;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios<_CharT, _Traits>& __x)
{
  _M_invoke_callbacks(erase_event);
  _M_copy_state(__x);
  _M_fill = __x._M_fill;
  _M_tied_ostream = __x._M_tied_ostream;
  _M_invoke_callbacks(copyfmt_event);
  this->_M_set_exception_mask(__x.exceptions());
  return *this;
}

template <class _CharT, class _Traits>
locale basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
{
  locale __tmp = ios_base::imbue(__loc);

  if (_M_streambuf)
    _M_streambuf->pubimbue(__loc);


  this->_M_cached_ctype = __loc._M_get_facet(ctype<char_type>::id) ;
  this->_M_cached_numpunct = __loc._M_get_facet(numpunct<char_type>::id) ;
  this->_M_cached_grouping = ((numpunct<char_type>*)_M_cached_numpunct)->grouping() ;
  return __tmp;
}





template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::basic_ios()
  : ios_base(),
    _M_fill(_CharT()), _M_streambuf(0), _M_tied_ostream(0)
{}

template <class _CharT, class _Traits>
void
basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
{
  this->rdbuf(__sb);
  this->imbue(locale());
  this->tie(0);
  this->_M_set_exception_mask(ios_base::goodbit);
  this->_M_clear_nothrow(__sb != 0 ? ios_base::goodbit : ios_base::badbit);
  ios_base::flags(ios_base::skipws | ios_base::dec);
  ios_base::width(0);
  ios_base::precision(6);
  this->fill(widen(' '));


}


template <class _CharT, class _Traits>
void basic_ios<_CharT, _Traits>::_M_handle_exception(ios_base::iostate __flag)
{
  this->_M_setstate_nothrow(__flag);
  if (this->_M_get_exception_mask() & __flag)
    {};
}

}
# 173 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ios.h" 2
# 28 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostream.h" 1
# 30 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostream.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostreambuf_iterator.h" 1
# 30 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostreambuf_iterator.h"
namespace _STL {

template <class _CharT, class _Traits>
extern basic_streambuf<_CharT, _Traits>* _M_get_ostreambuf(basic_ostream<_CharT, _Traits>& ) ;


template<class _CharT, class _Traits>
class ostreambuf_iterator
{
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename _Traits::int_type int_type;
  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
  typedef basic_ostream<_CharT, _Traits> ostream_type;

  typedef output_iterator_tag iterator_category;
  typedef void value_type;
  typedef void difference_type;
  typedef void pointer;
  typedef void reference;

public:
  ostreambuf_iterator(streambuf_type* __buf) : _M_buf(__buf), _M_ok(__buf!=0) {}

  inline ostreambuf_iterator(ostream_type& __o) ;

  ostreambuf_iterator<_CharT, _Traits>& operator=(char_type __c) {
    _M_ok = _M_ok && !traits_type::eq_int_type(_M_buf->sputc(__c),
                                               traits_type::eof());
    return *this;
  }

  ostreambuf_iterator<_CharT, _Traits>& operator*() { return *this; }
  ostreambuf_iterator<_CharT, _Traits>& operator++() { return *this; }
  ostreambuf_iterator<_CharT, _Traits>& operator++(int) { return *this; }

  bool failed() const { return !_M_ok; }

private:
  streambuf_type* _M_buf;
  bool _M_ok;
};

template <class _CharT, class _Traits>
inline ostreambuf_iterator<_CharT, _Traits>::ostreambuf_iterator(basic_ostream<_CharT, _Traits>& __o) : _M_buf(_M_get_ostreambuf(__o)), _M_ok(_M_buf != 0) {}
# 90 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostreambuf_iterator.h"
}
# 31 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostream.h" 2


namespace _STL {

template <class _CharT, class _Traits, class _Number>
basic_ostream<_CharT, _Traits>&
_M_put_num(basic_ostream<_CharT, _Traits>& __os, _Number __x);






template <class _CharT, class _Traits>
bool
_M_init(basic_ostream<_CharT, _Traits>& __str);




template <class _CharT, class _Traits>
class basic_ostream : virtual public basic_ios<_CharT, _Traits>
{
  typedef basic_ostream<_CharT, _Traits> _Self;

public:
  typedef _CharT char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits traits_type;
  typedef basic_ios<_CharT, _Traits> _Basic_ios;

public:


  explicit basic_ostream(basic_streambuf<_CharT, _Traits>* __buf) {this->init(__buf);}
  ~basic_ostream() {};





public:
  typedef basic_ios<_CharT, _Traits>& ( *__ios_fn)(basic_ios<_CharT, _Traits>&);
  typedef ios_base& ( *__ios_base_fn)(ios_base&);
  typedef _Self& ( *__ostream_fn)(_Self&);
  _Self& operator<< (__ostream_fn __f) { return __f(*this); }
  _Self & operator<< (__ios_base_fn __f) { __f(*this); return *this; }
  _Self& operator<< (__ios_fn __ff) { __ff(*this); return *this; }

private:
  bool _M_copy_buffered(basic_streambuf<_CharT, _Traits>* __from,
                        basic_streambuf<_CharT, _Traits>* __to);
  bool _M_copy_unbuffered(basic_streambuf<_CharT, _Traits>* __from,
                          basic_streambuf<_CharT, _Traits>* __to);

public:
  void _M_put_char(_CharT __c);

  void _M_put_nowiden(const _CharT* __s);
  void _M_put_widen(const char* __s);
  bool _M_put_widen_aux(const char* __s, streamsize __n);

public:
  _Self& put(char_type __c);
  _Self& write(const char_type* __s, streamsize __n);

public:

  _Self& operator<<(basic_streambuf<_CharT, _Traits>* __buf);


  _Self& operator<<(unsigned char __x) { _M_put_char(__x); return *this; }

  _Self& operator<<(short __x) { return _M_put_num(*this, static_cast<long>(__x)); }
  _Self& operator<<(unsigned short __x) { return _M_put_num(*this, static_cast<unsigned long>(__x)); }
  _Self& operator<<(int __x) { return _M_put_num(*this, static_cast<long>(__x)); }
  _Self& operator<<(unsigned int __x) { return _M_put_num(*this, static_cast<unsigned long>(__x)); }
  _Self& operator<<(long __x) { return _M_put_num(*this, __x); }
  _Self& operator<<(unsigned long __x) { return _M_put_num(*this, __x); }

  _Self& operator<< (long long __x) { return _M_put_num(*this, __x); }
  _Self& operator<< (unsigned long long __x) { return _M_put_num(*this, __x); }

  _Self& operator<<(float __x)
    { return _M_put_num(*this, static_cast<double>(__x)); }
  _Self& operator<<(double __x) { return _M_put_num(*this, __x); }

  _Self& operator<<(long double __x) { return _M_put_num(*this, __x); }

  _Self& operator<<(const void* __x) { return _M_put_num(*this, __x); }

  _Self& operator<<(bool __x) { return _M_put_num(*this, __x); }


public:
  _Self& flush() {
    if (this->rdbuf())
      if (this->rdbuf()->pubsync() == -1)
        this->setstate(ios_base::badbit);
    return *this;
  }

  pos_type tellp() {
    return this->rdbuf() && !this->fail()
      ? this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out)
      : pos_type(-1);
  }

  _Self& seekp(pos_type __pos) {
    if (this->rdbuf() && !this->fail())
      this->rdbuf()->pubseekpos(__pos, ios_base::out);
    return *this;
  }

  _Self& seekp(off_type __off, ios_base::seekdir __dir) {
    if (this->rdbuf() && !this->fail())
      this->rdbuf()->pubseekoff(__off, __dir, ios_base::out);
    return *this;
  }
# 163 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostream.h"
    class sentry {
      typedef sentry _Self;

    private:
      basic_ostream<_CharT, _Traits>& _M_str;

      bool _M_ok;
    public:
      explicit sentry(basic_ostream<_CharT, _Traits>& __str)
        : _M_str(__str), _M_ok(_M_init(__str))
      {
      }

      ~sentry() {
        if (_M_str.flags() & ios_base::unitbuf)



            _M_str.flush();
      }

      operator bool() const { return _M_ok; }
    private:
      sentry(const _Self& __s) : _M_str (__s._M_str) {};
      void operator=(const _Self&) {};
    };




};
# 205 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostream.h"
template <class _CharT, class _Traits>
inline basic_streambuf<_CharT, _Traits>*
_M_get_ostreambuf(basic_ostream<_CharT, _Traits>& __St)
{
  return __St.rdbuf();
}



template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c) {
  __os._M_put_char(__c);
  return __os;
}

template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __s) {
  __os._M_put_nowiden(__s);
  return __os;
}
# 270 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostream.h"
template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, char __c) {
  __os._M_put_char(__os.widen(__c));
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, char __c) {
  __os._M_put_char(__c);
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, signed char __c) {
  __os._M_put_char(__c);
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, unsigned char __c) {
  __os._M_put_char(__c);
  return __os;
}

template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const char* __s) {
  __os._M_put_widen(__s);
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const char* __s) {
  __os._M_put_nowiden(__s);
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const signed char* __s) {
  __os._M_put_nowiden(reinterpret_cast<const char*>(__s));
  return __os;
}

template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __s) {
  __os._M_put_nowiden(reinterpret_cast<const char*>(__s));
  return __os;
}





template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
endl(basic_ostream<_CharT, _Traits>& __os) {
  __os.put(__os.widen('\n'));
  __os.flush();
  return __os;
}

template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
ends(basic_ostream<_CharT, _Traits>& __os) {
  __os.put(_CharT());
  return __os;
}

template <class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
flush(basic_ostream<_CharT, _Traits>& __os) {
  __os.flush();
  return __os;
}

}




# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostream.c" 1
# 32 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostream.c"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_put.h" 1
# 36 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_put.h"
namespace _STL {







template <class _CharT, class _OutputIter = ostreambuf_iterator<_CharT, char_traits<_CharT> > >

class num_put: public locale::facet
{
  friend class _Locale;
public:
  typedef _CharT char_type;
  typedef _OutputIter iter_type;

  explicit num_put(size_t __refs = 0) : locale::facet(__refs) {}


  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                bool __val) const {
    return do_put(__s, __f, __fill, __val);
  }

  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
               long __val) const {
    return do_put(__s, __f, __fill, __val);
  }

  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                unsigned long __val) const {
    return do_put(__s, __f, __fill, __val);
  }


  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                long long __val) const {
    return do_put(__s, __f, __fill, __val);
  }

  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                unsigned long long __val) const {
    return do_put(__s, __f, __fill, __val);
  }


  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                double __val) const {
    return do_put(__s, __f, __fill, (double)__val);
  }


  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                long double __val) const {
    return do_put(__s, __f, __fill, __val);
  }


  iter_type put(iter_type __s, ios_base& __f, char_type __fill,
                const void * __val) const {
    return do_put(__s, __f, __fill, __val);
  }

  static locale::id id;

protected:
  ~num_put() {}

  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, bool __val) const;

  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, long __val) const;
  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, unsigned long __val) const;
  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, double __val) const;

  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, long double __val) const;



  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, long long __val) const;
  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                           unsigned long long __val) const ;

  virtual _OutputIter do_put(_OutputIter __s, ios_base& __f, _CharT __fill, const void* __val) const;
};
# 133 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_put.h"
template <class _Integer>
char*
__write_integer_backward(char* __buf, ios_base::fmtflags __flags, _Integer __x);

void __string_to_float(const string&, float&);
void __string_to_float(const string&, double&);
extern void __write_float(string&, ios_base::fmtflags, int, double);

void __string_to_float(const string&, long double&);
extern void __write_float(string&, ios_base::fmtflags, int, long double);



extern wchar_t* __convert_float_buffer(const char*, const char*, wchar_t*, const ctype<wchar_t>&, wchar_t);

extern void __adjust_float_buffer(char*, char*, char);

extern char*
__write_integer(char* buf, ios_base::fmtflags flags, long x);

extern ptrdiff_t __insert_grouping(char* first, char* last, const string&, char, char, char, int);

extern ptrdiff_t __insert_grouping(wchar_t*, wchar_t*, const string&, wchar_t, wchar_t, wchar_t, int);
# 175 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_put.h"
}


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_put.c" 1
# 30 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_put.c"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_limits.h" 1
# 34 "c:/marmalade/6.2/s3e/h/std/c++/stl/_limits.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/cfloat" 1
# 29 "c:/marmalade/6.2/s3e/h/std/c++/cfloat"
# 1 "c:/marmalade/6.2/s3e/h/ext/../std/float.h" 1
# 31 "c:/marmalade/6.2/s3e/h/ext/../std/float.h"
  extern "C" {
# 109 "c:/marmalade/6.2/s3e/h/ext/../std/float.h"
extern "C" {

unsigned _controlfp(unsigned, unsigned);
unsigned _clearfp(void);
unsigned _statusfp(void);

}
# 150 "c:/marmalade/6.2/s3e/h/ext/../std/float.h"
    }
# 30 "c:/marmalade/6.2/s3e/h/std/c++/cfloat" 2
# 35 "c:/marmalade/6.2/s3e/h/std/c++/stl/_limits.h" 2






namespace _STL {

enum float_round_style {
  round_indeterminate = -1,
  round_toward_zero = 0,
  round_to_nearest = 1,
  round_toward_infinity = 2,
  round_toward_neg_infinity = 3
};

enum float_denorm_style {
  denorm_indeterminate = -1,
  denorm_absent = 0,
  denorm_present = 1
};



template <class __number>
class _Numeric_limits_base {
public:

  static __number ( min)() { return __number(); }
  static __number ( max)() { return __number(); }




  static const int


  digits = 0,
  digits10 = 0,
  radix = 0,
  min_exponent = 0,
  min_exponent10 = 0,
  max_exponent = 0,
  max_exponent10 = 0






  ;
  static const float_denorm_style has_denorm = denorm_absent;
  static const float_round_style round_style = round_toward_zero;
  static const bool


    is_specialized = false,
    is_signed = false,
    is_integer = false,
    is_exact = false,
    has_infinity = false,
    has_quiet_NaN = false,
    has_signaling_NaN = false,
    has_denorm_loss = false,
    is_iec559 = false,
    is_bounded = false,
    is_modulo = false,
    traps = false,
    tinyness_before = false



  ;

  static __number epsilon() { return __number(); }
  static __number round_error() { return __number(); }

  static __number infinity() { return __number(); }
  static __number quiet_NaN() { return __number(); }
  static __number signaling_NaN() { return __number(); }
  static __number denorm_min() { return __number(); }


};
# 135 "c:/marmalade/6.2/s3e/h/std/c++/stl/_limits.h"
template <class _Int,
          _Int __imin,
          _Int __imax,
          int __idigits, bool __ismod>
class _Integer_limits : public _Numeric_limits_base<_Int>
{
public:

  static _Int ( min) () { return (_Int)__imin; }
  static _Int ( max) () { return (_Int)__imax; }




  static const int

  digits = (__idigits < 0) ?
  ((int)((sizeof(_Int) * (8))) - ((__imin == 0) ? 0 : 1))
  : (__idigits),
  digits10 = (digits * 301UL) / 1000,
  radix = 2

  ;
  static const bool



  is_specialized = true,
  is_signed = (__imin != 0),
  is_integer = true,
  is_exact = true,
  is_bounded = true,
  is_modulo = __ismod



  ;
};


template <class __number,
         int __Digits, int __Digits10,
         int __MinExp, int __MaxExp,
         int __MinExp10, int __MaxExp10,
         bool __IsIEC559,
         float_round_style __RoundStyle>
class _Floating_limits : public _Numeric_limits_base<__number>
{
public:




  static const int


  digits = __Digits,
  digits10 = __Digits10,

  radix = ( 2 ),
  min_exponent = __MinExp,
  max_exponent = __MaxExp,
  min_exponent10 = __MinExp10,
  max_exponent10 = __MaxExp10






  ;
  static const float_denorm_style has_denorm = denorm_indeterminate;
  static const float_round_style round_style = __RoundStyle;
  static const bool


  is_specialized = true,
  is_signed = true,


   has_infinity = true,
   has_quiet_NaN = true,
   has_signaling_NaN= true,






  has_denorm_loss = false,
  is_iec559 = __IsIEC559,
  is_bounded = true,
  traps = true,
  tinyness_before= false




  ;

};





template<class _Tp>
class numeric_limits : public _Numeric_limits_base<_Tp> {};





template<>
class numeric_limits<bool>
  : public _Integer_limits<bool, false, true, 1, false>
{};



template<>
class numeric_limits<char>
  : public _Integer_limits<char, 0, 255, -1, true>
{};


template<>
class numeric_limits<signed char>
  : public _Integer_limits<signed char, (-128), 127, -1, true>
{};


template<>
class numeric_limits<unsigned char>
  : public _Integer_limits<unsigned char, 0, 255, -1, true>
{};
# 281 "c:/marmalade/6.2/s3e/h/std/c++/stl/_limits.h"
template<>
class numeric_limits<short>
  : public _Integer_limits<short, (-0x7fff - 1), 0x7fff, -1, true>
{};

template<>
class numeric_limits<unsigned short>
  : public _Integer_limits<unsigned short, 0, 0xffff, -1, true>
{};







template<>
class numeric_limits<int>
  : public _Integer_limits<int, (-0x7fffffffL - 1), 0x7fffffffL, -1, true>
{};

template<>
class numeric_limits<unsigned int>
  : public _Integer_limits<unsigned int, 0, 0xffffffffUL, -1, true>
{};

template<>
class numeric_limits<long>
  : public _Integer_limits<long, (-0x7fffffffL - 1), 0x7fffffffL, -1, true>
{};

template<>
class numeric_limits<unsigned long>
  : public _Integer_limits<unsigned long, 0, 0xffffffffUL, -1, true>
{};
# 359 "c:/marmalade/6.2/s3e/h/std/c++/stl/_limits.h"
template<>
class numeric_limits<long long>
  : public _Numeric_limits_base<long long>
{
public:

  static long long ( min) () { return (-0x7fffffffffffffffLL -1LL); }
  static long long ( max) () { return 0x7fffffffffffffffLL; }




  static const int

  digits = ((int)((sizeof(long long) * (8))) - 1),
  digits10 = (digits * 301UL) / 1000,
  radix = 2

  ;
  static const bool



  is_specialized = true,
  is_signed = true,
  is_integer = true,
  is_exact = true,
  is_bounded = true,
  is_modulo = true



  ;
};

template<>
class numeric_limits<unsigned long long>
  : public _Numeric_limits_base<unsigned long long>
{
public:

  static unsigned long long ( min) () { return 0ULL; }
  static unsigned long long ( max) () { return 0xffffffffffffffffULL; }




  static const int

  digits = ((int)((sizeof(unsigned long long) * (8)))),
  digits10 = (digits * 301UL) / 1000,
  radix = 2

  ;
  static const bool



  is_specialized = true,
  is_signed = false,
  is_integer = true,
  is_exact = true,
  is_bounded = true,
  is_modulo = true



  ;
};







union _F_rep
{
  unsigned short rep[2];
  float val;
};
union _D_rep
{
  unsigned short rep[4];
  double val;
};


union _L_rep
{
  unsigned short rep[8];
  long double val;
};


template <class __dummy>
class _LimG
{
public:
  static const _F_rep _F_inf;
  static const _F_rep _F_qNaN;
  static const _F_rep _F_sNaN;
  static const _D_rep _D_inf;
  static const _D_rep _D_qNaN;
  static const _D_rep _D_sNaN;


  static const _L_rep _L_inf;
  static const _L_rep _L_qNaN;
  static const _L_rep _L_sNaN;

};





template<> class numeric_limits<float>
  : public _Floating_limits<float,
                            24,
                            6,
                            (-125),
                            128,
                            (-37),
                            38,
                            true,
                            round_to_nearest>
{
public:
  static float ( min) () { return 1.175494351e-38F; }
  static float denorm_min() { return 1.175494351e-38F; }
  static float ( max) () { return 3.402823466e+38F; }
  static float epsilon() { return 1.19209290e-7F; }
  static float round_error() { return 0.5f; }
  static float infinity() { return _LimG<bool>::_F_inf.val; }
  static float quiet_NaN() { return _LimG<bool>::_F_qNaN.val; }
  static float signaling_NaN() { return _LimG<bool>::_F_sNaN.val; }
};

template<> class numeric_limits<double>
  : public _Floating_limits<double,
                            53,
                            15,
                            (-1021),
                            1024,
                            (-307),
                            308,
                            true,
                            round_to_nearest>
{
public:
  static double ( min)() { return 2.22507385850720138e-308; }
  static double denorm_min() { return 2.22507385850720138e-308; }
  static double ( max)() { return 1.79769313486231571e+308; }
  static double epsilon() { return 2.2204460492503131e-16; }
  static double round_error() { return 0.5; }
  static double infinity() { return _LimG<bool>::_D_inf.val; }
  static double quiet_NaN(){ return _LimG<bool>::_D_qNaN.val; }
  static double signaling_NaN() { return _LimG<bool>::_D_sNaN.val; }
};



template<>
class numeric_limits<long double>
  : public _Floating_limits<long double,
                            53,
                            15,
                            (-1021),
                            1024,
                            (-307),
                            308,
                            false,
                            round_to_nearest>
{
public:
  static long double ( min) () { return 2.22507385850720138e-308L; }
  static long double denorm_min() { return 2.22507385850720138e-308L; }
  static long double ( max) () { return 1.79769313486231571e+308L; }
  static long double epsilon() { return 2.2204460492503131e-16L; }
  static long double round_error() { return 4; }
  static long double infinity() { return _LimG<bool>::_L_inf.val; }
  static long double quiet_NaN() { return _LimG<bool>::_L_qNaN.val; }
  static long double signaling_NaN() { return _LimG<bool>::_L_sNaN.val; }
};





}


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_limits.c" 1
# 30 "c:/marmalade/6.2/s3e/h/std/c++/stl/_limits.c"
namespace _STL {







template <class __number> const bool _Numeric_limits_base<__number>:: is_specialized;
template <class __number> const int _Numeric_limits_base<__number>:: digits;
template <class __number> const int _Numeric_limits_base<__number>:: digits10;
template <class __number> const bool _Numeric_limits_base<__number>:: is_signed;
template <class __number> const bool _Numeric_limits_base<__number>:: is_integer;
template <class __number> const bool _Numeric_limits_base<__number>:: is_exact;
template <class __number> const int _Numeric_limits_base<__number>:: radix;
template <class __number> const int _Numeric_limits_base<__number>:: min_exponent;
template <class __number> const int _Numeric_limits_base<__number>:: max_exponent;
template <class __number> const int _Numeric_limits_base<__number>:: min_exponent10;
template <class __number> const int _Numeric_limits_base<__number>:: max_exponent10;
template <class __number> const bool _Numeric_limits_base<__number>:: has_infinity;
template <class __number> const bool _Numeric_limits_base<__number>:: has_quiet_NaN;
template <class __number> const bool _Numeric_limits_base<__number>:: has_signaling_NaN;
template <class __number> const float_denorm_style _Numeric_limits_base<__number>:: has_denorm;
template <class __number> const bool _Numeric_limits_base<__number>:: has_denorm_loss;
template <class __number> const bool _Numeric_limits_base<__number>:: is_iec559;
template <class __number> const bool _Numeric_limits_base<__number>:: is_bounded;
template <class __number> const bool _Numeric_limits_base<__number>:: is_modulo;
template <class __number> const bool _Numeric_limits_base<__number>:: traps;
template <class __number> const bool _Numeric_limits_base<__number>:: tinyness_before;
template <class __number> const float_round_style _Numeric_limits_base<__number>:: round_style;







template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_specialized;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const int _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: digits;


template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const int _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: digits10;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_signed;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_integer;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_exact;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const int _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: radix;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_bounded;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_modulo;
# 91 "c:/marmalade/6.2/s3e/h/std/c++/stl/_limits.c"
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: is_specialized;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: digits;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: digits10;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: is_signed;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: radix;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: min_exponent;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: max_exponent;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: min_exponent10;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: max_exponent10;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_infinity;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_quiet_NaN;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_signaling_NaN;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const float_denorm_style _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_denorm;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_denorm_loss;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: is_iec559;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: is_bounded;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: traps;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: tinyness_before;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const float_round_style _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: round_style;
# 290 "c:/marmalade/6.2/s3e/h/std/c++/stl/_limits.c"
}
# 553 "c:/marmalade/6.2/s3e/h/std/c++/stl/_limits.h" 2
# 31 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_put.c" 2


namespace _STL {





template <class _CharT, class _OutputIter,class _Float>
_OutputIter
_M_do_put_float(_OutputIter __s, ios_base& __f, _CharT __fill,_Float __x);





template <class _CharT, class _OutputIter>
_OutputIter
__copy_float_and_fill(const _CharT* __first, const _CharT* __last,
                      _OutputIter __out,
                      ios_base::fmtflags __flags,
                      streamsize __width, _CharT __fill,
                      _CharT __xplus, _CharT __xminus) {
  if (__width <= __last - __first)
    return copy(__first, __last, __out);
  else {
    streamsize __pad = __width - (__last - __first);
    ios_base::fmtflags __dir = __flags & ios_base::adjustfield;

    if (__dir == ios_base::left) {
      __out = copy(__first, __last, __out);
      return fill_n(__out, __pad, __fill);
    }
    else if (__dir == ios_base::internal && __first != __last &&
             (*__first == __xplus || *__first == __xminus)) {
      *__out++ = *__first++;
      __out = fill_n(__out, __pad, __fill);
      return copy(__first, __last, __out);
    }
    else {
      __out = fill_n(__out, __pad, __fill);
      return copy(__first, __last, __out);
    }
  }
}



template <class _OutputIter>
_OutputIter
__put_float(char* __ibuf, char* __iend, _OutputIter __out,
            ios_base& __f, wchar_t __fill,
            wchar_t __decimal_point,
            wchar_t __sep, const string& __grouping)
{
  const ctype<wchar_t>& __ct = *(ctype<wchar_t>*)__f._M_ctype_facet() ;

  wchar_t __wbuf[128];
  wchar_t* __eend = __convert_float_buffer(__ibuf, __iend, __wbuf,
                                           __ct, __decimal_point);
  if (!__grouping.empty()) {





    string __new_grouping = __grouping;
    wchar_t* __decimal_pos = find(__wbuf, __eend, __decimal_point);
    if (__grouping.size() == 1)
      __new_grouping.push_back(__grouping[0]);



    __new_grouping[0] += static_cast<char>(__eend - __decimal_pos);
    ptrdiff_t __len = __insert_grouping(__wbuf, __eend, __new_grouping,
     __sep,
     __ct.widen('+'), __ct.widen('-'),
     0);
    __eend = __wbuf + __len;
  }

  return __copy_float_and_fill (__wbuf, __eend, __out,
                               __f.flags(), __f.width(0), __fill,
                               __ct.widen('+'), __ct.widen('-'));
}



template <class _OutputIter>
_OutputIter
__put_float(char* __ibuf, char* __iend, _OutputIter __out,
            ios_base& __f, char __fill,
            char __decimal_point,
            char __sep, const string& __grouping)
{
  __adjust_float_buffer(__ibuf, __iend, __decimal_point);
  if (!__grouping.empty()) {
    string __new_grouping = __grouping;
    const char * __decimal_pos = find(__ibuf, __iend, __decimal_point);
    if (__grouping.size() == 1)
      __new_grouping.push_back(__grouping[0]);
    __new_grouping[0] += static_cast<char>((__iend - __decimal_pos));
    ptrdiff_t __len = __insert_grouping(__ibuf, __iend, __new_grouping,
     __sep, '+', '-', 0);
    __iend = __ibuf + __len;
  }

  return __copy_float_and_fill<char> (__ibuf, __iend, __out,
                               __f.flags(), __f.width(0), (unsigned char)__fill, '+', '-');
}

template <class _CharT, class _OutputIter, class _Float>
_OutputIter
_M_do_put_float(_OutputIter __s, ios_base& __f,
                _CharT __fill, _Float __x)
{
  string __buf;
  __buf.reserve(128);
  __write_float(__buf, __f.flags(), (int)__f.precision(), __x);

  const numpunct<_CharT>& __np = *(const numpunct<_CharT>*)__f._M_numpunct_facet();

  return __put_float(const_cast<char*>(__buf.c_str()),
                     const_cast<char*>(__buf.c_str()) + __buf.size(),
                     __s, __f, __fill,
                     __np.decimal_point(),
                   __np.thousands_sep(), __f._M_grouping());
}



template <class _CharT, class _OutputIter>
_OutputIter
__copy_integer_and_fill(const _CharT* __buf, ptrdiff_t __len,
                        _OutputIter __out,
                        ios_base::fmtflags __flg, streamsize __wid, _CharT __fill,
                        _CharT __xplus, _CharT __xminus)
{
  if (__len >= __wid)
    return copy(__buf, __buf + __len, __out);
  else {
    ptrdiff_t __pad = __wid - __len;
    ios_base::fmtflags __dir = __flg & ios_base::adjustfield;

    if (__dir == ios_base::left) {
      __out = copy(__buf, __buf + __len, __out);
      return fill_n(__out, __pad, __fill);
    }
    else if (__dir == ios_base::internal && __len != 0 &&
             (__buf[0] == __xplus || __buf[0] == __xminus)) {
      *__out++ = __buf[0];
      __out = fill_n(__out, __pad, __fill);
      return copy(__buf + 1, __buf + __len, __out);
    }
    else if (__dir == ios_base::internal && __len >= 2 &&
             (__flg & ios_base::showbase) &&
             (__flg & ios_base::basefield) == ios_base::hex) {
      *__out++ = __buf[0];
      *__out++ = __buf[1];
      __out = fill_n(__out, __pad, __fill);
      return copy(__buf + 2, __buf + __len, __out);
    }
    else {
      __out = fill_n(__out, __pad, __fill);
      return copy(__buf, __buf + __len, __out);
    }
  }
}



template <class _OutputIter>
_OutputIter
__put_integer(char* __buf, char* __iend, _OutputIter __s,
              ios_base& __f,
              ios_base::fmtflags __flags, wchar_t __fill)
{
  locale __loc = __f.getloc();

  const ctype<wchar_t>& __ct = *(const ctype<wchar_t>*)__f._M_ctype_facet();

  wchar_t __xplus = __ct.widen('+');
  wchar_t __xminus = __ct.widen('-');

  wchar_t __wbuf[64];
  __ct.widen(__buf, __iend, __wbuf);
  ptrdiff_t __len = __iend - __buf;
  wchar_t* __eend = __wbuf + __len;




  const numpunct<wchar_t>& __np = *(const numpunct<wchar_t>*)__f._M_numpunct_facet();
  const string& __grouping = __f._M_grouping();

  if (!__grouping.empty()) {
    int __basechars;
    if (__flags & ios_base::showbase)
      switch (__flags & ios_base::basefield) {
 case ios_base::hex: __basechars = 2; break;
 case ios_base::oct: __basechars = 1; break;
 default: __basechars = 0;
      }
    else
      __basechars = 0;

    __len = __insert_grouping(__wbuf, __eend, __grouping, __np.thousands_sep(),
         __xplus, __xminus, __basechars);
  }

  return __copy_integer_and_fill((wchar_t*)__wbuf, __len, __s,
                                 __flags, __f.width(0), __fill, __xplus, __xminus);
}



template <class _OutputIter>
_OutputIter
__put_integer(char* __buf, char* __iend, _OutputIter __s,
              ios_base& __f, ios_base::fmtflags __flags, char __fill)
{
  ptrdiff_t __len = __iend - __buf;
  char __grpbuf[64];




  const numpunct<char>& __np = *(const numpunct<char>*)__f._M_numpunct_facet();
  const string& __grouping = __f._M_grouping();

  if (!__grouping.empty()) {
    int __basechars;
    if (__flags & ios_base::showbase)
      switch (__flags & ios_base::basefield) {
 case ios_base::hex: __basechars = 2; break;
 case ios_base::oct: __basechars = 1; break;
 default: __basechars = 0;
      }
    else
      __basechars = 0;




    copy(__buf, __iend, (char *) __grpbuf);
    __buf = __grpbuf;
    __iend = __grpbuf + __len;
    __len = __insert_grouping(__buf, __iend, __grouping, __np.thousands_sep(),
                              '+', '-', __basechars);
  }

  return __copy_integer_and_fill(__buf, __len, __s, __flags, __f.width(0), __fill, (char)'+', (char)'-');
}


typedef long long __max_int_t;
typedef unsigned long long __umax_int_t;





extern const char __hex_char_table_lo[];
extern const char __hex_char_table_hi[];

template <class _Integer>
inline char*
__write_decimal_backward(char* __ptr, _Integer __x, ios_base::fmtflags __flags, const __true_type& )
{
  const bool __negative = __x < 0 ;
  __max_int_t __temp = __x;
  __umax_int_t __utemp = __negative?-__temp:__temp;

  for (; __utemp != 0; __utemp /= 10)
    *--__ptr = (int)(__utemp % 10) + '0';

  if (__negative)
    *--__ptr = '-';
  else if (__flags & ios_base::showpos)
    *--__ptr = '+';
  return __ptr;
}

template <class _Integer>
inline char*
__write_decimal_backward(char* __ptr, _Integer __x, ios_base::fmtflags __flags, const __false_type& )
{
  for (; __x != 0; __x /= 10)
    *--__ptr = (int)(__x % 10) + '0';

  if (__flags & ios_base::showpos)
    *--__ptr = '+';
  return __ptr;
}

template <class _Integer>
char*
__write_integer_backward(char* __buf, ios_base::fmtflags __flags, _Integer __x)
{
  char* __ptr = __buf;
  __umax_int_t __temp;

  if (__x == 0) {
    *--__ptr = '0';
    if ((__flags & ios_base::showpos) && ( (__flags & (ios_base::hex | ios_base::oct)) == 0 ))
      *--__ptr = '+';
  }
  else {

    switch (__flags & ios_base::basefield) {
    case ios_base::oct:
      __temp = __x;

      if ( sizeof(__x) < 8 && sizeof(__umax_int_t) >= 8 )
        __temp &= 0xFFFFFFFF;

      for (; __temp != 0; __temp >>=3)
        *--__ptr = (((unsigned)__temp)& 0x7) + '0';


      if (__flags & ios_base::showbase)
        *--__ptr = '0';
      break;
    case ios_base::hex:
      {
        const char* __table_ptr = (__flags & ios_base::uppercase) ?
          __hex_char_table_hi : __hex_char_table_lo;
      __temp = __x;

      if ( sizeof(__x) < 8 && sizeof(__umax_int_t) >= 8 )
        __temp &= 0xFFFFFFFF;

        for (; __temp != 0; __temp >>=4)
          *--__ptr = __table_ptr[((unsigned)__temp & 0xF)];

        if (__flags & ios_base::showbase) {
          *--__ptr = __table_ptr[16];
          *--__ptr = '0';
        }
      }
      break;
    default:
      {







 typedef typename __bool2type<numeric_limits<_Integer>::is_signed>::_Ret _IsSigned;
 __ptr = __write_decimal_backward(__ptr, __x, __flags, _IsSigned());

      }
      break;
    }
  }

  return __ptr;
}







template <class _CharT, class _OutputIterator>
locale::id num_put<_CharT, _OutputIterator>::id;
# 428 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_put.c"
template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f,
                                     char_type __fill, bool __val) const {
  if (!(__f.flags() & ios_base::boolalpha))
    return this->do_put(__s, __f, __fill, static_cast<long>(__val));

  locale __loc = __f.getloc();



  const numpunct<_CharT>& __np = *(const numpunct<_CharT>*)__f._M_numpunct_facet();

  basic_string<_CharT> __str = __val ? __np.truename() : __np.falsename();




  ios_base::fmtflags __flags = __f.flags();
  if ((__flags & ios_base::adjustfield) == ios_base::internal)
    __flags = (__flags & ~ios_base::adjustfield) | ios_base::right;

  return __copy_integer_and_fill(__str.c_str(), __str.size(), __s,
                                 __flags, __f.width(0), __fill,
                                 (_CharT) 0, (_CharT) 0);
}



template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     long __val) const {

  char __buf[64];

  ios_base::fmtflags __flags = __f.flags();
  char* __ibeg = __write_integer_backward((char*)__buf+64, __flags, __val);
  return __put_integer(__ibeg, (char*)__buf+64, __s, __f, __flags, __fill);
}


template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
         unsigned long __val) const {
  char __buf[64];


  ios_base::fmtflags __flags = __f.flags();
  char* __ibeg = __write_integer_backward((char*)__buf+64, __flags, __val);
  return __put_integer(__ibeg, (char*)__buf+64, __s, __f, __flags, __fill);
}

template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     double __val) const {
  return _M_do_put_float(__s, __f, __fill, __val);
}


template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     long double __val) const {
  return _M_do_put_float(__s, __f, __fill, __val);
}



template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     long long __val) const {
  char __buf[64];


  ios_base::fmtflags __flags = __f.flags();
  char* __ibeg = __write_integer_backward((char*)__buf+64, __flags, __val);
  return __put_integer(__ibeg, (char*)__buf+64, __s, __f, __flags, __fill);
}

template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT __fill,
                                     unsigned long long __val) const {
  char __buf[64];


  ios_base::fmtflags __flags = __f.flags();
  char* __ibeg = __write_integer_backward((char*)__buf+64, __flags, __val);
  return __put_integer(__ibeg, (char*)__buf+64, __s, __f, __flags, __fill);
}





template <class _CharT, class _OutputIter>
_OutputIter
num_put<_CharT, _OutputIter>::do_put(_OutputIter __s, ios_base& __f, _CharT ,
         const void* __val) const {
  const ctype<_CharT>& __c_type = *(const ctype<_CharT>*)__f._M_ctype_facet();
  ios_base::fmtflags __save_flags = __f.flags();

  __f.setf(ios_base::hex, ios_base::basefield);
  __f.setf(ios_base::showbase);
  __f.setf(ios_base::internal, ios_base::adjustfield);
  __f.width((sizeof(void*) * 2) + 2);

  _OutputIter result = this->do_put(__s, __f, __c_type.widen('0'), reinterpret_cast<unsigned long long>(__val));



  __f.flags(__save_flags);
  return result;
}

}
# 179 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_put.h" 2
# 33 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostream.c" 2


namespace _STL {




template <class _CharT, class _Traits>
bool
_M_init(basic_ostream<_CharT, _Traits>& __str) {
  if (__str.good()) {

    if (!__str.rdbuf())
      __str.setstate(ios_base::badbit);
    if (__str.tie())
      __str.tie()->flush();
    return __str.good();
  } else
    return false;
}
# 82 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostream.c"
template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<_CharT, _Traits>* __from)
{
  sentry __sentry(*this);
  if (__sentry) {
    if (__from) {
      bool __any_inserted = __from->gptr() != __from->egptr()
        ? this->_M_copy_buffered(__from, this->rdbuf())
        : this->_M_copy_unbuffered(__from, this->rdbuf());
      if (!__any_inserted)
        this->setstate(ios_base::failbit);
    }
    else
      this->setstate(ios_base::badbit);
  }

  return *this;
}







template <class _CharT, class _Traits>
bool basic_ostream<_CharT, _Traits>
  ::_M_copy_buffered(basic_streambuf<_CharT, _Traits>* __from,
                     basic_streambuf<_CharT, _Traits>* __to)
{
  bool __any_inserted = false;

  while (__from->egptr() != __from->gptr()) {
    const ptrdiff_t __avail = __from->egptr() - __from->gptr();

    streamsize __nwritten;
    {
      __nwritten = __to->sputn(__from->gptr(), __avail);
      __from->gbump((int)__nwritten);
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
      return __any_inserted;
    }

    if (__nwritten == __avail) {
      {
        if (this->_S_eof(__from->sgetc()))
          return true;
        else
          __any_inserted = true;
      }
      if (false) {
        this->_M_handle_exception(ios_base::failbit);
        return false;
      }
    }

    else if (__nwritten != 0)
      return true;

    else
      return __any_inserted;
  }



  return __any_inserted || this->_M_copy_unbuffered(__from, __to);
}

template <class _CharT, class _Traits>
bool basic_ostream<_CharT, _Traits>
  ::_M_copy_unbuffered(basic_streambuf<_CharT, _Traits>* __from,
                       basic_streambuf<_CharT, _Traits>* __to)
{
  bool __any_inserted = false;

  while (true) {
    int_type __c;
    {
      __c = __from->sbumpc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::failbit);
      return __any_inserted;
    }

    if (this->_S_eof(__c))
      return __any_inserted;

    else {
      int_type __tmp;
      {
        __tmp = __to->sputc(__c);
      }
      if (false) {
        this->_M_handle_exception(ios_base::badbit);
        return __any_inserted;
      }

      if (this->_S_eof(__tmp)) {
        {
                        __from->sputbackc(__c);
        }
        if (false) {
          this->_M_handle_exception(ios_base::badbit);
          return __any_inserted;
        }
      }
      else
        __any_inserted = true;
    }
  }
}



template <class _CharT, class _Traits, class _Number>
basic_ostream<_CharT, _Traits>&
_M_put_num(basic_ostream<_CharT, _Traits>& __os, _Number __x)
{
  typedef typename basic_ostream<_CharT, _Traits>::sentry _Sentry;
  _Sentry __sentry(__os);
  bool __failed = true;

  if (__sentry) {
    {
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> > _NumPut;
      __failed = (use_facet<_NumPut>(__os.getloc())).put(
                                                         ostreambuf_iterator<_CharT, _Traits>(__os.rdbuf()),
                                                         __os, __os.fill(),
                                                         __x).failed();
    }
    if (false) {
      __os._M_handle_exception(ios_base::badbit);
    }
  }
  if (__failed)
    __os.setstate(ios_base::badbit);
  return __os;
}
# 238 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostream.c"
template <class _CharT, class _Traits>
void basic_ostream<_CharT, _Traits>::_M_put_char(_CharT __c)
{
  sentry __sentry(*this);
  if (__sentry) {
    bool __failed = true;
    {
      streamsize __npad = this->width() > 0 ? this->width() - 1 : 0;

      if (__npad == 0)
        __failed = this->_S_eof(this->rdbuf()->sputc(__c));
      else if ((this->flags() & ios_base::adjustfield) == ios_base::left) {
        __failed = this->_S_eof(this->rdbuf()->sputc(__c));
        __failed = __failed ||
                   this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
      }
      else {
        __failed = this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
        __failed = __failed || this->_S_eof(this->rdbuf()->sputc(__c));
      }

      this->width(0);
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (__failed)
      this->setstate(ios_base::badbit);
  }
}

template <class _CharT, class _Traits>
void basic_ostream<_CharT, _Traits>::_M_put_nowiden(const _CharT* __s)
{
  sentry __sentry(*this);
  if (__sentry) {
    bool __failed = true;
    streamsize __n = _Traits::length(__s);
    streamsize __npad = this->width() > __n ? this->width() - __n : 0;

    {
      if (__npad == 0)
        __failed = this->rdbuf()->sputn(__s, __n) != __n;
      else if ((this->flags() & ios_base::adjustfield) == ios_base::left) {
        __failed = this->rdbuf()->sputn(__s, __n) != __n;
        __failed = __failed ||
                   this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
      }
      else {
        __failed = this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
        __failed = __failed || this->rdbuf()->sputn(__s, __n) != __n;
      }

      this->width(0);
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (__failed)
      this->setstate(ios_base::failbit);
  }
}

template <class _CharT, class _Traits>
void basic_ostream<_CharT, _Traits>::_M_put_widen(const char* __s)
{
  sentry __sentry(*this);
  if (__sentry) {
    bool __failed = true;
    streamsize __n = char_traits<char>::length(__s);
    streamsize __npad = this->width() > __n ? this->width() - __n : 0;

    {
      if (__npad == 0)
        __failed = !this->_M_put_widen_aux(__s, __n);
      else if ((this->flags() & ios_base::adjustfield) == ios_base::left) {
        __failed = !this->_M_put_widen_aux(__s, __n);
        __failed = __failed ||
                   this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
      }
      else {
        __failed = this->rdbuf()->_M_sputnc(this->fill(), __npad) != __npad;
        __failed = __failed || !this->_M_put_widen_aux(__s, __n);
      }

      this->width(0);
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (__failed)
      this->setstate(ios_base::failbit);
  }
}

template <class _CharT, class _Traits>
bool basic_ostream<_CharT, _Traits>::_M_put_widen_aux(const char* __s,
                                                      streamsize __n)
{
  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

  for ( ; __n > 0 ; --__n)
    if (this->_S_eof(__buf->sputc(this->widen(*__s++))))
      return false;
  return true;
}


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::put(char_type __c)
{
  sentry __sentry(*this);
  bool __failed = true;

  if (__sentry) {
    {
      __failed = this->_S_eof(this->rdbuf()->sputc(__c));
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }
  }

  if (__failed)
    this->setstate(ios_base::badbit);

  return *this;
}


template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)
{
  sentry __sentry(*this);
  bool __failed = true;

  if (__sentry) {
    {
      __failed = this->rdbuf()->sputn(__s, __n) != __n;
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }
  }

  if (__failed)
    this->setstate(ios_base::badbit);

  return *this;
}

}
# 358 "c:/marmalade/6.2/s3e/h/std/c++/stl/_ostream.h" 2
# 32 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istreambuf_iterator.h" 1
# 34 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istreambuf_iterator.h"
namespace _STL {


template <class _CharT, class _Traits>
extern basic_streambuf<_CharT, _Traits>* _M_get_istreambuf(basic_istream<_CharT, _Traits>& ) ;





template<class _CharT, class _Traits>
class istreambuf_iterator
{
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename _Traits::int_type int_type;
  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
  typedef basic_istream<_CharT, _Traits> istream_type;

  typedef input_iterator_tag iterator_category;
  typedef _CharT value_type;
  typedef typename _Traits::off_type difference_type;
  typedef const _CharT* pointer;
  typedef const _CharT& reference;

public:
  istreambuf_iterator(streambuf_type* __p = 0) { this->_M_init(__p); }

  inline istreambuf_iterator(basic_istream<_CharT, _Traits>& __is);

  char_type operator*() const { this->_M_getc(); return _M_c; }
  istreambuf_iterator<_CharT, _Traits>& operator++() { this->_M_bumpc(); return *this; }
  istreambuf_iterator<_CharT, _Traits> operator++(int);

  bool equal(const istreambuf_iterator<_CharT, _Traits>& __i) const {
    if (this->_M_buf)
      this->_M_getc();
    if (__i._M_buf)
      __i._M_getc();
    return this->_M_eof == __i._M_eof;
  }

private:
  void _M_init(streambuf_type* __p) {
    _M_buf = __p;
    _M_eof = !__p;

    _M_have_c = false;
  }

  void _M_getc() const {
    if (_M_have_c)
      return;
    int_type __c = _M_buf->sgetc();

    _M_c = traits_type::to_char_type(__c);
    _M_eof = traits_type::eq_int_type(__c, traits_type::eof());
    _M_have_c = true;







  }

  void _M_bumpc() {
    _M_buf->sbumpc();
    _M_have_c = false;
  }

private:
  streambuf_type* _M_buf;
  mutable _CharT _M_c;
  mutable unsigned char _M_eof;
  mutable unsigned char _M_have_c;
};

template<class _CharT, class _Traits>
inline istreambuf_iterator<_CharT, _Traits>::istreambuf_iterator(basic_istream<_CharT, _Traits>& __is)
{ this->_M_init(_M_get_istreambuf(__is)); }

template<class _CharT, class _Traits>
inline bool operator==(const istreambuf_iterator<_CharT, _Traits>& __x,
                                  const istreambuf_iterator<_CharT, _Traits>& __y) {
  return __x.equal(__y);
}



template<class _CharT, class _Traits>
inline bool operator!=(const istreambuf_iterator<_CharT, _Traits>& __x,
                                  const istreambuf_iterator<_CharT, _Traits>& __y) {
  return !__x.equal(__y);
}
# 151 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istreambuf_iterator.h"
template <class _CharT, class _Traits>
istreambuf_iterator<_CharT, _Traits>
istreambuf_iterator<_CharT, _Traits>::operator++(int) {
  istreambuf_iterator<_CharT, _Traits> __tmp = *this;
  this->_M_bumpc();
  this->_M_have_c = false;
  return __tmp;
}

}
# 36 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.h" 2




namespace _STL {

template <class _CharT, class _Traits, class _Number>
ios_base::iostate
_M_get_num(basic_istream<_CharT, _Traits>& __that, _Number& __val);






struct _No_Skip_WS {};

template <class _CharT, class _Traits>
bool _M_init_skip(basic_istream<_CharT, _Traits>& __is);
template <class _CharT, class _Traits>
bool _M_init_noskip(basic_istream<_CharT, _Traits>& __is);
# 66 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.h"
template <class _CharT, class _Traits>
class basic_istream : virtual public basic_ios<_CharT, _Traits> {
public:

  typedef _CharT char_type;
  typedef typename _Traits::int_type int_type;
  typedef typename _Traits::pos_type pos_type;
  typedef typename _Traits::off_type off_type;
  typedef _Traits traits_type;
  typedef basic_ios<_CharT, _Traits> _Basic_ios;
  typedef basic_istream<_CharT, _Traits> _Self;

  typedef basic_ios<_CharT, _Traits>& ( *__ios_fn)(basic_ios<_CharT, _Traits>&);
  typedef ios_base& ( *__ios_base_fn)(ios_base&);
  typedef _Self& ( *__istream_fn)(_Self&);

public:
  explicit basic_istream(basic_streambuf<_CharT, _Traits>* __buf) :
    basic_ios<_CharT, _Traits>(), _M_gcount(0) {
    this->init(__buf);
  }
  ~basic_istream() {};

public:

public:

  _Self& operator>> (__istream_fn __f) { return __f(*this); }
  _Self& operator>> (__ios_fn __f) { __f(*this); return *this; }
  _Self& operator>> (__ios_base_fn __f) { __f(*this); return *this; }

public:
  _Self& operator>> (short& __val) {
    long __lval;
    unsigned short __uval;
   _M_get_num(*this, __lval);
    __val = static_cast<short>(__lval);
    __uval = __lval;


    if ((__val != __lval) && ((long)__uval != __lval))
      this->setstate(ios_base::failbit);
    return *this;
  }
  _Self& operator>> (int& __val) {
    long __lval;
    unsigned int __uval;
    _M_get_num(*this, __lval);
    __val = __lval;
    __uval = __lval;


    if ((__val != __lval) && ((long)__uval != __lval))
      this->setstate(ios_base::failbit);
    return *this;
  }
  _Self& operator>> (unsigned short& __val) { _M_get_num(*this, __val); return *this; }
  _Self& operator>> (unsigned int& __val) { _M_get_num(*this, __val); return *this; }
  _Self& operator>> (long& __val) { _M_get_num(*this, __val); return *this; }
  _Self& operator>> (unsigned long& __val) { _M_get_num(*this, __val); return *this; }

  _Self& operator>> (long long& __val) { _M_get_num(*this, __val); return *this; }
  _Self& operator>> (unsigned long long& __val) { _M_get_num(*this, __val); return *this; }

  _Self& operator>> (float& __val) { _M_get_num(*this, __val); return *this; }
  _Self& operator>> (double& __val) { _M_get_num(*this, __val); return *this; }

  _Self& operator>> (long double& __val) { _M_get_num(*this, __val); return *this; }


  _Self& operator>> (bool& __val) { _M_get_num(*this, __val); return *this; }

  _Self& operator>> (void*& __val) { _M_get_num(*this, __val); return *this; }

public:
  _Self& operator>>(basic_streambuf<_CharT, _Traits>*);

public:
  streamsize gcount() const { return _M_gcount; }
  int_type peek();

public:
  int_type get();
  _Self& get(char_type& __c);

public:
  _Self& get(char_type* __s, streamsize __n, char_type __delim);
  _Self& get(char_type* __s, streamsize __n)
    { return get(__s, __n, this->widen('\n')); }

public:
  _Self& get(basic_streambuf<_CharT, _Traits>& __buf,
                     char_type __delim);
  _Self& get(basic_streambuf<_CharT, _Traits>& __buf)
    { return get(__buf, this->widen('\n')); }

public:
  _Self& getline(char_type* __s, streamsize __n, char_type delim);
  _Self& getline(char_type* __s, streamsize __n)
    { return getline(__s, __n, this->widen('\n')); }

public:
  _Self& ignore();
  _Self& ignore(streamsize __n);



  _Self& ignore(streamsize __n, int_type __delim);

  _Self& read(char_type* __s, streamsize __n);
  streamsize readsome(char_type* __s, streamsize __n);

public:
  _Self& putback(char_type __c);
  _Self& unget();

public:
  int sync();

  pos_type tellg();
  _Self& seekg(pos_type __pos);
  _Self& seekg(off_type, ios_base::seekdir);

public:
  void _M_formatted_get(_CharT& __c);
  void _M_formatted_get(_CharT* __s);
  void _M_skip_whitespace(bool __set_failbit);

private:
  streamsize _M_gcount;

public:
# 209 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.h"
  class sentry {
    typedef sentry _Self;


  private:
    const bool _M_ok;


  public:
    typedef _Traits traits_type;

    explicit sentry(basic_istream<_CharT, _Traits>& __is,
                    bool __noskipws = false) :
      _M_ok((__noskipws || !(__is.flags() & ios_base::skipws)) ? _M_init_noskip(__is) : _M_init_skip(__is) )

      {}



    sentry(basic_istream<_CharT, _Traits>& __is, _No_Skip_WS) :
      _M_ok(_M_init_noskip(__is)) {}

    ~sentry() {}

    operator bool() const { return _M_ok; }

  private:
    sentry(const _Self&) : _M_ok(false) {}
    void operator=(const _Self&) {}
  };





};
# 258 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.h"
template <class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c) {
  __in._M_formatted_get(__c);
  return __in;
}

template <class _Traits>
inline basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c) {
  __in._M_formatted_get(reinterpret_cast<char&>(__c));
  return __in;
}

template <class _Traits>
inline basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __in, signed char& __c) {
  __in._M_formatted_get(reinterpret_cast<char&>(__c));
  return __in;
}

template <class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s) {
  __in._M_formatted_get(__s);
  return __in;
}

template <class _Traits>
inline basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s) {
  __in._M_formatted_get(reinterpret_cast<char*>(__s));
  return __in;
}

template <class _Traits>
inline basic_istream<char, _Traits>&
operator>>(basic_istream<char, _Traits>& __in, signed char* __s) {
  __in._M_formatted_get(reinterpret_cast<char*>(__s));
  return __in;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __is);




template <class _CharT, class _Traits>
class basic_iostream
  : public basic_istream<_CharT, _Traits>,
    public basic_ostream<_CharT, _Traits>
{
public:
  typedef basic_ios<_CharT, _Traits> _Basic_ios;

  explicit basic_iostream(basic_streambuf<_CharT, _Traits>* __buf);
  virtual ~basic_iostream();
};
# 328 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.h"
template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>* _M_get_istreambuf(basic_istream<_CharT, _Traits>& __is)
{
  return __is.rdbuf();
}

}


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.c" 1
# 32 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.c"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_get.h" 1
# 41 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_get.h"
namespace _STL {







template <class _CharT, class _InputIter = istreambuf_iterator<_CharT> >

class num_get: public locale::facet
{
  friend class _Locale;
public:
  typedef _CharT char_type;
  typedef _InputIter iter_type;

  explicit num_get(size_t __refs = 0): locale::facet(__refs) {}


  _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
                ios_base::iostate& __err, bool& __val) const {
    return do_get(__in, __end, __str, __err, __val);
  }
# 79 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_get.h"
  _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
                ios_base::iostate& __err, long& __val) const {
    return do_get(__in, __end, __str, __err, __val);
  }

  _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
                ios_base::iostate& __err, unsigned short& __val) const {
    return do_get(__in, __end, __str, __err, __val);
  }

  _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
                ios_base::iostate& __err, unsigned int& __val) const {
    return do_get(__in, __end, __str, __err, __val);
  }

  _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
                ios_base::iostate& __err, unsigned long& __val) const {
    return do_get(__in, __end, __str, __err, __val);
  }



  _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
                ios_base::iostate& __err, long long& __val) const {
    return do_get(__in, __end, __str, __err, __val);
  }

  _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
                ios_base::iostate& __err, unsigned long long& __val) const {
    return do_get(__in, __end, __str, __err, __val);
  }



  _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
                 ios_base::iostate& __err, float& __val) const {
    return do_get(__in, __end, __str, __err, __val);
  }

  _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
                ios_base::iostate& __err, double& __val) const {
    return do_get(__in, __end, __str, __err, __val);
  }



  _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
                ios_base::iostate& __err, long double& __val) const {
    return do_get(__in, __end, __str, __err, __val);
  }


  _InputIter get(_InputIter __in, _InputIter __end, ios_base& __str,
                ios_base::iostate& __err, void*& __val) const {
    return do_get(__in, __end, __str, __err, __val);
  }

  static locale::id id;

protected:
  ~num_get() {}

  typedef string string_type;
  typedef ctype<_CharT> _Ctype;
  typedef numpunct<_CharT> _Numpunct;


  virtual _InputIter do_get(_InputIter __in, _InputIter __end,
                           ios_base& __str, ios_base::iostate& __err, bool& __val) const;


  virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                           ios_base::iostate& __err, long& __val) const;
  virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                           ios_base::iostate& __err, unsigned short& __val) const;
  virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                           ios_base::iostate& __err, unsigned int& __val) const;
  virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                           ios_base::iostate& __err, unsigned long& __val) const;







  virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                          ios_base::iostate& __err, float& __val) const;
  virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                           ios_base::iostate& __err, double& __val) const;
  virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                           ios_base::iostate& __err,
                           void*& __p) const;


  virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                           ios_base::iostate& __err, long double& __val) const;




  virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                            ios_base::iostate& __err, long long& __val) const;
  virtual _InputIter do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                           ios_base::iostate& __err, unsigned long long& __val) const;


};
# 200 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_get.h"
extern bool __valid_grouping(const char*, const char*, const char*, const char*);

template <class _InputIter, class _Integer>
bool
__get_decimal_integer(_InputIter& __first, _InputIter& __last, _Integer& __val);

inline bool __get_fdigit(char& __c, const char*);
inline bool __get_fdigit_or_sep(char& __c, char __sep, const char *);

bool __get_fdigit(wchar_t&, const wchar_t*);
bool __get_fdigit_or_sep(wchar_t&, wchar_t, const wchar_t*);


inline void
_Initialize_get_float(const ctype<char>&,
                       char& Plus, char& Minus,
                       char& pow_e, char& pow_E,
                       char*)
{
  Plus = '+';
  Minus = '-';
  pow_e = 'e';
  pow_E = 'E';
}


void _Initialize_get_float(const ctype<wchar_t>&,
                                        wchar_t&, wchar_t&, wchar_t&, wchar_t&, wchar_t*);

void __string_to_float(const string&, float&);
void __string_to_float(const string&, double&);

void __string_to_float(const string&, long double&);
# 248 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_get.h"
}


# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_get.c" 1
# 35 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_get.c"
namespace _STL {

extern const unsigned char __digit_val_table[];

template < class _InputIter, class _Integer, class _CharT>
_InputIter
_M_do_get_integer(_InputIter&, _InputIter&, ios_base&, ios_base::iostate&, _Integer&, _CharT*);



inline bool __get_fdigit(char& __c, const char*)
  { return __c >= '0' && __c <= '9'; }

inline bool __get_fdigit_or_sep(char& __c, char __sep, const char *)
{
  if (__c == __sep) {
    __c = ',' ;
    return true ;
  } else
    return ( __c >= '0' && __c <= '9');
}

inline int
__get_digit_from_table(unsigned __index)
{
  return (__index > 127 ? 0xFF : __digit_val_table[__index]);
}

extern const char __narrow_atoms[];

template <class _InputIter, class _CharT>
int
_M_get_base_or_zero(_InputIter& __in, _InputIter& __end, ios_base& __str, _CharT*)
{
  _CharT __atoms[5];
  const ctype<_CharT>& __c_type = use_facet< ctype<_CharT> >(__str.getloc());


  __c_type.widen(__narrow_atoms, __narrow_atoms + 5, __atoms);

  bool __negative = false;
  _CharT __c = *__in;

  if (__c == __atoms[1] ) {
    __negative = true;
    ++__in;
  }
  else if (__c == __atoms[0] )
    ++__in;


  int __base;
  int __valid_zero = 0;

  ios_base::fmtflags __basefield = __str.flags() & ios_base::basefield;

  switch (__basefield) {
  case ios_base::oct:
    __base = 8;
    break;
  case ios_base::dec:
    __base = 10;
    break;
  case ios_base::hex:
    __base = 16;
    if (__in != __end && *__in == __atoms[2] ) {
      ++__in;
      if (__in != __end &&
          (*__in == __atoms[3] || *__in == __atoms[4] ))
        ++__in;
      else
        __valid_zero = 1;
    }
    break;
  default:
    if (__in != __end && *__in == __atoms[2] ) {
      ++__in;
      if (__in != __end &&
          (*__in == __atoms[3] || *__in == __atoms[4] )) {
        ++__in;
        __base = 16;
      }
      else
        {
          __base = 8;
          __valid_zero = 1;
        }
    }
    else
      __base = 10;
    break;
  }
  return (__base << 2) | ((int)__negative << 1) | __valid_zero;
}


template <class _InputIter, class _Integer>
bool
__get_integer(_InputIter& __first, _InputIter& __last,
       int __base, _Integer& __val,
       int __got, bool __is_negative, char __separator, const string& __grouping, const __true_type&)
{
  bool __ovflow = false;
  _Integer __result = 0;
  bool __is_group = !__grouping.empty();
  char __group_sizes[64];
  int __current_group_size = 0;
  char* __group_sizes_end = __group_sizes;

  _Integer __over_base = (numeric_limits<_Integer>::min)() / static_cast<_Integer>(__base);

   for ( ; __first != __last ; ++__first) {

     const char __c = *__first;

     if (__is_group && __c == __separator) {
       *__group_sizes_end++ = __current_group_size;
       __current_group_size = 0;
       continue;
     }

     int __n = __get_digit_from_table(__c);

     if (__n >= __base)
       break;

     ++__got;
     ++__current_group_size;

     if (__result < __over_base)
       __ovflow = true;
     else {
       _Integer __next = static_cast<_Integer>(__base * __result - __n);
       if (__result != 0)
  __ovflow = __ovflow || __next >= __result;
       __result = __next;
     }
   }

   if (__is_group && __group_sizes_end != __group_sizes) {
     *__group_sizes_end++ = __current_group_size;
   }


   if (__got > 0) {
       __val = __ovflow
  ? __is_negative ? (numeric_limits<_Integer>::min)()
  : (numeric_limits<_Integer>::max)()
  : (__is_negative ? __result : static_cast<_Integer>(-__result));
   }

  return ((__got > 0) && !__ovflow) && (__is_group == 0 || __valid_grouping(__group_sizes, __group_sizes_end,
             __grouping.data(), __grouping.data()+ __grouping.size())) ;
}

template <class _InputIter, class _Integer>
bool
__get_integer(_InputIter& __first, _InputIter& __last,
       int __base, _Integer& __val,
       int __got, bool __is_negative, char __separator, const string& __grouping, const __false_type&)
{
  bool __ovflow = false;
  _Integer __result = 0;
  bool __is_group = !__grouping.empty();
  char __group_sizes[64];
  int __current_group_size = 0;
  char* __group_sizes_end = __group_sizes;

  _Integer __over_base = (numeric_limits<_Integer>::max)() / static_cast<_Integer>(__base);

  for ( ; __first != __last ; ++__first) {

    const char __c = *__first;

    if (__is_group && __c == __separator) {
      *__group_sizes_end++ = __current_group_size;
      __current_group_size = 0;
      continue;
    }

    int __n = __get_digit_from_table(__c);

    if (__n >= __base)
      break;

    ++__got;
    ++__current_group_size;

    if (__result > __over_base)
      __ovflow = true;
    else {
      _Integer __next = static_cast<_Integer>(__base * __result + __n);
 if (__result != 0)
   __ovflow = __ovflow || __next <= __result;
 __result = __next;
      }
  }

  if (__is_group && __group_sizes_end != __group_sizes) {
      *__group_sizes_end++ = __current_group_size;
  }


  if (__got > 0) {
      __val = __ovflow
 ? (numeric_limits<_Integer>::max)()
 : (__is_negative ? static_cast<_Integer>(-__result) : __result);
  }

  return ((__got > 0) && !__ovflow) &&
    (__is_group == 0 || __valid_grouping(__group_sizes, __group_sizes_end,
      __grouping.data(), __grouping.data()+ __grouping.size())) ;
}


template <class _InputIter, class _Integer>
bool
__get_decimal_integer(_InputIter& __first, _InputIter& __last, _Integer& __val)
{
  string __grp;
  return __get_integer(__first, __last, 10, __val, 0, false, ' ', __grp, __false_type());
}

template <class _InputIter, class _Integer, class _CharT>
_InputIter
_M_do_get_integer(_InputIter& __in, _InputIter& __end, ios_base& __str,
                  ios_base::iostate& __err, _Integer& __val, _CharT* __pc)
{




  typedef typename __bool2type<numeric_limits<_Integer>::is_signed>::_Ret _IsSigned;


  const numpunct<_CharT>& __numpunct = *(const numpunct<_CharT>*)__str._M_numpunct_facet();
  const string& __grouping = __str._M_grouping();

  const int __base_or_zero = _M_get_base_or_zero(__in, __end, __str, __pc);
  int __got = __base_or_zero & 1;

  bool __result;

  if (__in == __end) {

    if (__got > 0) {
      __val = 0;
      __result = true;
    }
    else
      __result = false;
  } else {

    const bool __negative = __base_or_zero & 2;
    const int __base = __base_or_zero >> 2;







    __result = __get_integer(__in, __end, __base, __val, __got, __negative, __numpunct.thousands_sep(), __grouping, _IsSigned());

  }

  __err = static_cast<ios_base::iostate>(__result ? ios_base::goodbit : ios_base::failbit);

  if (__in == __end)
    __err |= ios_base::eofbit;
  return __in;
}


template <class _InputIter, class _CharT>
_InputIter
__copy_sign(_InputIter __first, _InputIter __last, string& __v,
            _CharT __xplus, _CharT __xminus) {
    if (__first != __last) {
    _CharT __c = *__first;
    if (__c == __xplus)
      ++__first;
    else if (__c == __xminus) {
      __v.push_back('-');
      ++__first;
    }
  }
  return __first;
}


template <class _InputIter, class _CharT>
bool
__copy_digits(_InputIter& __first, _InputIter& __last,
              string& __v, const _CharT* __digits)
{
  bool __ok = false;

  for ( ; __first != __last; ++__first) {
    _CharT __c = *__first;
    if (__get_fdigit(__c, __digits)) {
      __v.push_back((char)__c);
      __ok = true;
    }
    else
      break;
  }
  return __ok;
}

template <class _InputIter, class _CharT>
bool
__copy_grouped_digits(_InputIter& __first, _InputIter& __last,
        string& __v, const _CharT * __digits,
        _CharT __sep, const string& __grouping,
        bool& __grouping_ok)
{
  bool __ok = false;
  char __group_sizes[64];
  char*__group_sizes_end = __group_sizes;
  char __current_group_size = 0;

  for ( ; __first != __last; ++__first) {
    _CharT __c = *__first;
    bool __tmp = __get_fdigit_or_sep(__c, __sep, __digits);
    if (__tmp) {
      if (__c == ',') {
        *__group_sizes_end++ = __current_group_size;
        __current_group_size = 0;
      }
      else {
        __ok = true;
        __v.push_back((char)__c);
        ++__current_group_size;
      }
    }
    else
      break;
  }

  if (__group_sizes_end != __group_sizes)
    *__group_sizes_end++ = __current_group_size;
  __grouping_ok = __valid_grouping(__group_sizes, __group_sizes_end, __grouping.data(), __grouping.data() + __grouping.size());
  return __ok;
}


template <class _InputIter, class _CharT>
bool
_M_read_float(string& __buf, _InputIter& __in, _InputIter& __end, ios_base& __s, _CharT*)
{



  bool __digits_before_dot ;
  bool __digits_after_dot = false;
  bool __ok;

  bool __grouping_ok = true;

  const ctype<_CharT>& __ct = use_facet< ctype<_CharT> >(__s.getloc());

  const numpunct<_CharT>& __numpunct = *(const numpunct<_CharT>*)__s._M_numpunct_facet();
  const string& __grouping = __s._M_grouping();

  _CharT __dot = __numpunct.decimal_point();
  _CharT __sep = __numpunct.thousands_sep();

  _CharT __digits[10];
  _CharT __xplus;
  _CharT __xminus;

  _CharT __pow_e;
  _CharT __pow_E;

  _Initialize_get_float(__ct, __xplus, __xminus, __pow_e, __pow_E, __digits);


  __in = __copy_sign(__in, __end, __buf, __xplus, __xminus);


  if (__grouping.size() != 0)
    __digits_before_dot = __copy_grouped_digits(__in, __end, __buf, __digits,
      __sep, __grouping, __grouping_ok);
  else
    __digits_before_dot = __copy_digits(__in, __end, __buf, __digits);


  if (__in != __end && *__in == __dot) {
    __buf.push_back('.');
    ++__in;
    __digits_after_dot = __copy_digits(__in, __end, __buf, __digits);
  }


  __ok = __digits_before_dot || __digits_after_dot;


  if (__ok && __in != __end && (*__in == __pow_e || *__in == __pow_E)) {
    __buf.push_back('e');
    ++__in;
    __in = __copy_sign(__in, __end, __buf, __xplus, __xminus);
    __ok = __copy_digits(__in, __end, __buf, __digits);


  }

  return __ok;
}






template <class _CharT, class _InputIterator>
locale::id num_get<_CharT, _InputIterator>::id;
# 473 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_get.c"
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end,
                                    ios_base& __s,
                                    ios_base::iostate& __err, bool& __x) const
{
  if (__s.flags() & ios_base::boolalpha) {
    locale __loc = __s.getloc();
    const _Numpunct& __np = *(const _Numpunct*)__s._M_numpunct_facet();



    const basic_string<_CharT> __truename = __np.truename();
    const basic_string<_CharT> __falsename = __np.falsename();
    bool __true_ok = true;
    bool __false_ok = true;

    size_t __n = 0;
    for ( ; __in != __end; ++__in) {
      _CharT __c = *__in;
      __true_ok = __true_ok && (__c == __truename[__n]);
      __false_ok = __false_ok && (__c == __falsename[__n]);
      ++__n;

      if ((!__true_ok && !__false_ok) ||
          (__true_ok && __n >= __truename.size()) ||
          (__false_ok && __n >= __falsename.size())) {
 ++__in;
        break;
      }
    }
    if (__true_ok && __n < __truename.size()) __true_ok = false;
    if (__false_ok && __n < __falsename.size()) __false_ok = false;

    if (__true_ok || __false_ok) {
      __err = ios_base::goodbit;
      __x = __true_ok;
    }
    else
      __err = ios_base::failbit;

    if (__in == __end)
      __err |= ios_base::eofbit;

    return __in;
  }

  else {
    long __lx;
    _InputIter __tmp = this->do_get(__in, __end, __s, __err, __lx);
    if (!(__err & ios_base::failbit)) {
      if (__lx == 0)
        __x = false;
      else if (__lx == 1)
        __x = true;
      else
        __err |= ios_base::failbit;
    }
    return __tmp;
  }
}
# 554 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_get.c"
template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err, long& __val) const {
  return _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
}

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    unsigned short& __val) const {
  return _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
}

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    unsigned int& __val) const {
  return _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
}

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    unsigned long& __val) const {
  return _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
}


template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    float& __val) const {
  string __buf ;
  bool __ok = _M_read_float(__buf, __in, __end, __str, (_CharT*)0 );
  __string_to_float(__buf, __val);
  __err = static_cast<ios_base::iostate>(__ok ? ios_base::goodbit : ios_base::failbit);
  if (__in == __end)
    __err |= ios_base::eofbit;
  return __in;
}

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    double& __val) const {
  string __buf ;
  bool __ok = _M_read_float(__buf, __in, __end, __str, (_CharT*)0 );
  __string_to_float(__buf, __val);
  __err = static_cast<ios_base::iostate>(__ok ? ios_base::goodbit : ios_base::failbit);
  if (__in == __end)
    __err |= ios_base::eofbit;
  return __in;
}


template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
        ios_base::iostate& __err,
                                    long double& __val) const {
  string __buf ;
  bool __ok = _M_read_float(__buf, __in, __end, __str, (_CharT*)0 );
  __string_to_float(__buf, __val);
  __err = static_cast<ios_base::iostate>(__ok ? ios_base::goodbit : ios_base::failbit);
  if (__in == __end)
    __err |= ios_base::eofbit;
  return __in;
}


template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                           ios_base::iostate& __err,
                           void*& __p) const {

  unsigned long long __val;



    iter_type __tmp = _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
    if (!(__err & ios_base::failbit))
      __p = reinterpret_cast<void*>(__val);
    return __tmp;
  }




template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    long long& __val) const {
  return _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
}

template <class _CharT, class _InputIter>
_InputIter
num_get<_CharT, _InputIter>::do_get(_InputIter __in, _InputIter __end, ios_base& __str,
                                    ios_base::iostate& __err,
                                    unsigned long long& __val) const {
  return _M_do_get_integer(__in, __end, __str, __err, __val, (_CharT*)0 );
}



}
# 252 "c:/marmalade/6.2/s3e/h/std/c++/stl/_num_get.h" 2
# 33 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.c" 2
# 46 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.c"
namespace _STL {




template <class _Traits>
struct _Is_not_wspace {
  typedef typename _Traits::char_type argument_type;
  typedef bool result_type;

  const ctype<argument_type>* _M_ctype;

  _Is_not_wspace(const ctype<argument_type>* __c_type) : _M_ctype(__c_type) {}
  bool operator()(argument_type __c) const
    { return !_M_ctype->is(ctype_base::space, __c); }
};

template <class _Traits>
struct _Is_wspace_null {
  typedef typename _Traits::char_type argument_type;
  typedef bool result_type;

  const ctype<argument_type>* _M_ctype;

  _Is_wspace_null(const ctype<argument_type>* __c_type) : _M_ctype(__c_type) {}
  bool operator()(argument_type __c) const {
    return _Traits::eq(__c, argument_type()) ||
           _M_ctype->is(ctype_base::space, __c);
  }
};

template <class _Traits>
struct _Scan_for_wspace {
  typedef typename _Traits::char_type char_type;
  typedef char_type* first_argument_type;
  typedef char_type* second_argument_type;
  typedef char_type* result_type;

  const ctype<char_type>* _M_ctype;

  _Scan_for_wspace(const ctype<char_type>* __ctype) : _M_ctype(__ctype) {}
  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return _M_ctype->scan_is(ctype_base::space, __first, __last);
  }
};

template <class _Traits>
struct _Scan_wspace_null {
  typedef typename _Traits::char_type char_type;
  typedef char_type* first_argument_type;
  typedef char_type* second_argument_type;
  typedef char_type* result_type;

  const ctype<char_type>* _M_ctype;

  _Scan_wspace_null(const ctype<char_type>* __c_type) : _M_ctype(__c_type) {}
  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    __last = find_if(__first, __last,
                     _Eq_char_bound<_Traits>(char_type()));
    return _M_ctype->scan_is(ctype_base::space, __first, __last);
  }
};

template <class _Traits>
struct _Scan_for_not_wspace {
  typedef typename _Traits::char_type char_type;
  typedef char_type* first_argument_type;
  typedef char_type* second_argument_type;
  typedef char_type* result_type;

  const ctype<char_type>* _M_ctype;

  _Scan_for_not_wspace(const ctype<char_type>* __c_type) : _M_ctype(__c_type) {}
  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return _M_ctype->scan_not(ctype_base::space, __first, __last);
  }
};

template <class _Traits>
struct _Scan_for_char_val
{
  typedef typename _Traits::char_type char_type;
  typedef char_type* first_argument_type;
  typedef char_type* second_argument_type;
  typedef char_type* result_type;

  char_type _M_val;

  _Scan_for_char_val(char_type __val) : _M_val(__val) {}

  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return find_if(__first, __last, _Eq_char_bound<_Traits>(_M_val));
  }
};

template <class _Traits>
struct _Scan_for_int_val
{
  typedef typename _Traits::char_type char_type;
  typedef typename _Traits::int_type int_type;
  typedef char_type* first_argument_type;
  typedef char_type* second_argument_type;
  typedef char_type* result_type;

  int_type _M_val;

  _Scan_for_int_val(int_type __val) : _M_val(__val) {}

  const char_type*
  operator()(const char_type* __first, const char_type* __last) const {
    return find_if(__first, __last,
                   _Eq_int_bound<_Traits>(_M_val));
  }
};




template <class _CharT, class _Traits>
bool
__pushback(basic_streambuf<_CharT, _Traits>* __buf, _CharT __c)
{
  bool ret;
  {
    const typename _Traits::int_type __eof = _Traits::eof();
    ret = !_Traits::eq_int_type(__buf->sputbackc(__c), __eof);
  }
  if (false) {
    ret = false;
  }
  return ret;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
ws(basic_istream<_CharT, _Traits>& __is)
{
  typedef typename basic_istream<_CharT, _Traits>::sentry _Sentry;
  _Sentry __sentry(__is, _No_Skip_WS());
  if (__sentry)
    __is._M_skip_whitespace(false);
  return __is;
}


template <class _CharT, class _Traits>
bool
_M_init_skip(basic_istream<_CharT, _Traits>& __is) {
  if (__is.good()) {
    if (__is.tie())
      __is.tie()->flush();

    __is._M_skip_whitespace(true);
  }

  if (!__is.good()) {
    __is.setstate(ios_base::failbit);
    return false;
  } else
    return true;
}

template <class _CharT, class _Traits>
bool
_M_init_noskip(basic_istream<_CharT, _Traits>& __is){
  if (__is.good()) {
    if (__is.tie())
      __is.tie()->flush();

    if (!__is.rdbuf())
      __is.setstate(ios_base::badbit);
  }
  else
    __is.setstate(ios_base::failbit);
  return __is.good();
}





template <class _CharT, class _Traits, class _Number>
ios_base::iostate
_M_get_num(basic_istream<_CharT, _Traits>& __that, _Number& __val)
{
  typedef typename basic_istream<_CharT, _Traits>::sentry _Sentry;
  ios_base::iostate __err = 0;
  _Sentry __sentry( __that );
  if (__sentry) {
    typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> > _Num_get;
    {
      ((const _Num_get&)use_facet<_Num_get>(__that.getloc())).get(istreambuf_iterator<_CharT, _Traits>(__that.rdbuf()),
     0, __that, __err, __val);
    }
    if (false) {
      __that._M_handle_exception(ios_base::badbit);
    }
    if (__err) __that.setstate(__err);
  }
  return __err;
}




template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek()
{
  typename _Traits::int_type __tmp = _Traits::eof();

  this->_M_gcount = 0;
  sentry __sentry(*this, _No_Skip_WS());

  if (__sentry) {
    {
      __tmp = this->rdbuf()->sgetc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }
    if (this->_S_eof(__tmp))
      this->setstate(ios_base::eofbit);
  }

  return __tmp;
}


template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get()
{
  typename _Traits::int_type __tmp = _Traits::eof();
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    {
      __tmp = this->rdbuf()->sbumpc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (!this->_S_eof(__tmp))
      this->_M_gcount = 1;
  }

  if (_M_gcount == 0)
    this->setstate(ios_base::eofbit | ios_base::failbit);

  return __tmp;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(_CharT& __c)
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    typename _Traits::int_type __tmp = _Traits::eof();
    {
      __tmp = this->rdbuf()->sbumpc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
    }

    if (!this->_S_eof(__tmp)) {
      this->_M_gcount = 1;
      __c = _Traits::to_char_type(__tmp);
    }
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::eofbit | ios_base::failbit);

  return *this;
}







template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::ignore()
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    int_type __c;
    {
      __c = this->rdbuf()->sbumpc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
      return *this;
    }

    if (!this->_S_eof(__c))
      this->_M_gcount = 1;
    else
      this->setstate(ios_base::eofbit);
  }

  return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback(_CharT __c) {
  this->_M_gcount = 0;
  sentry __sentry(*this, _No_Skip_WS());

  if (__sentry) {
    typename _Traits::int_type __tmp = _Traits::eof();
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

    if (__buf) {
      {
        __tmp = __buf->sputbackc(__c);
      }
      if (false) {
        this->_M_handle_exception(ios_base::badbit);
      }
    }
    if (this->_S_eof(__tmp))
      this->setstate(ios_base::badbit);
  }
  else
    this->setstate(ios_base::failbit);

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>& basic_istream<_CharT, _Traits>::unget() {
  this->_M_gcount = 0;

  sentry __sentry(*this, _No_Skip_WS());

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

    if (__buf) {
      {
        _CharT __tmp;
        __tmp = __buf->sungetc();
        if (this->_S_eof(__tmp))
          this->setstate(ios_base::badbit);
      }
      if (false) {
        this->_M_handle_exception(ios_base::badbit);
      }
    } else
      this->setstate(ios_base::badbit);
  }
  else
    this->setstate(ios_base::failbit);

  return *this;
}



template <class _CharT, class _Traits>
int basic_istream<_CharT, _Traits>::sync() {
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (__buf) {
    if (__buf->pubsync() == -1) {
      this->setstate(ios_base::badbit);
      return -1;
    }
    else
      return 0;
  }
  else
    return -1;
}

template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg() {

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  return (__buf && !this->fail()) ? __buf->pubseekoff(0, ios_base::cur, ios_base::in)
    : pos_type(-1);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(pos_type __pos) {
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (!this->fail() && __buf)
    __buf->pubseekpos(__pos, ios_base::in);
  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)
{
  sentry __sentry(*this, _No_Skip_WS());

  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (!this->fail() && __buf)
    __buf->pubseekoff(__off, __dir, ios_base::in);
  return *this;
}



template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_formatted_get(_CharT& __c)
{


  sentry __sentry(*this);

  if (__sentry) {
    typename _Traits::int_type __tmp = _Traits::eof();

    {
      __tmp = this->rdbuf()->sbumpc();
    }
    if (false) {
      this->_M_handle_exception(ios_base::badbit);
      return;
    }

    if (!this->_S_eof(__tmp))
      __c = _Traits::to_char_type(__tmp);
    else
      this->setstate(ios_base::eofbit | ios_base::failbit);
  }
}
# 521 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.c"
template < class _CharT, class _Traits, class _Is_Delim>
streamsize
_M_read_unbuffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __buf,
                       streamsize _Num, _CharT* __s,
                       _Is_Delim __is_delim,
                       bool __extract_delim, bool __append_null,
                       bool __is_getline)
{
  streamsize __n = 0;
  ios_base::iostate __status = 0;

  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;

  {
# 564 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.c"
while (true) {

int_type __c = __buf->sbumpc();

if (__that->_S_eof(__c)) {
if (__n < _Num || __is_getline)
__status |= ios_base::eofbit;
break;
}

else if (__is_delim(__c)) {
if (__extract_delim) {

++__n;
}
break;
}

else {

*__s++ = _Traits::to_char_type(__c);
++__n;

}

if (__n == _Num) {
if (__is_getline)
__status |= ios_base::failbit;
break;
}




}



  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
    *__s = _CharT();
    return __n;
  }

  if (__append_null)
    *__s = _CharT();
  if (__status)
    __that->setstate(__status);
  return __n;
}





template < class _CharT, class _Traits, class _Is_Delim, class _Scan_Delim>
streamsize
_M_read_buffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __buf,
                     streamsize _Num, _CharT* __s,
                     _Is_Delim __is_delim, _Scan_Delim __scan_delim,
                     bool __extract_delim, bool __append_null,
                     bool __is_getline)
{
  streamsize __n = 0;
  ios_base::iostate __status = 0;
  bool __done = false;

  {
    while (__buf->_M_egptr() != __buf->_M_gptr() && !__done) {
      const _CharT* __first = __buf->_M_gptr();
      const _CharT* __last = __buf->_M_egptr();
      ptrdiff_t __request = _Num - __n;

      const _CharT* __p = __scan_delim(__first, __last);
      ptrdiff_t __chunk = (min) (ptrdiff_t(__p - __first), __request);
      _Traits::copy(__s, __first, __chunk);
      __s += __chunk;
      __n += __chunk;
      __buf->_M_gbump((int)__chunk);


      if (__p != __last && __p - __first <= __request) {
        if (__extract_delim) {
          __n += 1;
          __buf->_M_gbump(1);
        }
        __done = true;
      }


      else if(__n == _Num) {


        if (__is_getline) {
          if (__chunk == __last - __first) {
            if (__that->_S_eof(__buf->sgetc()))
              __status |= ios_base::eofbit;
          }
          else
            __status |= ios_base::failbit;
        }
        __done = true;
      }



      else {
 if (__that->_S_eof(__buf->sgetc())) {
          __status |= ios_base::eofbit;
          __done = true;
        }
      }
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
    __done = true;
  }

  if (__done) {
    if (__append_null)
        *__s = _CharT();
    if (__status != 0)
      __that->setstate(__status);
    return __n;
  }






  return __n + _M_read_unbuffered(__that, __buf, _Num - __n, __s, __is_delim,
                                  __extract_delim,__append_null,__is_getline);
}




template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::get(_CharT* __s, streamsize __n,
                                    _CharT __delim) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    if (__n > 0) {
      basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();

      if (__buf->egptr() != __buf->gptr())
        this->_M_gcount =
          _M_read_buffered(this, __buf, __n - 1, __s,
                           _Eq_char_bound<_Traits>(__delim),
                           _Scan_for_char_val<_Traits>(__delim),
                           false, true, false);
      else
        this->_M_gcount =
          _M_read_unbuffered(this, __buf, __n - 1, __s,
                             _Eq_char_bound<_Traits>(__delim),
                             false, true, false);
    }
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::failbit);

  return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::getline(_CharT* __s, streamsize __n,
                                        _CharT __delim) {
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    if (__n > 0) {
      basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
      this->_M_gcount = __buf->egptr() != __buf->gptr()
        ? _M_read_buffered(this, __buf, __n - 1, __s,
                           _Eq_char_bound<_Traits>(__delim),
                           _Scan_for_char_val<_Traits>(__delim),
                           true, true, true)
        : _M_read_unbuffered(this, __buf, __n - 1, __s,
                             _Eq_char_bound<_Traits>(__delim),
                             true, true, true);
    }
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::failbit);

  return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry && !this->eof()) {
    basic_streambuf<_CharT, _Traits>*__buf = this->rdbuf();
    if (__buf->gptr() != __buf->egptr())
      _M_gcount
        = _M_read_buffered(this, __buf, __n, __s,
                           _Constant_unary_fun<bool, int_type>(false),
                           _Project2nd<const _CharT*, const _CharT*>(),
                           false, false, false);
    else
      _M_gcount
        = _M_read_unbuffered(this, __buf, __n, __s,
                             _Constant_unary_fun<bool, int_type>(false),
                             false, false, false);
  }
  else
    this->setstate(ios_base::failbit);

  if (this->eof())
    this->setstate(ios_base::eofbit | ios_base::failbit);

  return *this;
}




template <class _CharT, class _Traits>
streamsize
basic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __nmax)
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry && !this->eof() && __nmax >= 0) {

    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    streamsize __avail = __buf->in_avail();


    if (__avail == -1)
      this->_M_setstate_nothrow(ios_base::eofbit);

    else if (__avail != 0) {

      if (__buf->gptr() != __buf->egptr())
        _M_gcount
          = _M_read_buffered(this, __buf, (min) (__avail, __nmax), __s,
                             _Constant_unary_fun<bool, int_type>(false),
                             _Project2nd<const _CharT*, const _CharT*>(),
                             false, false, false);
      else
        _M_gcount
          = _M_read_unbuffered(this, __buf, (min) (__avail, __nmax), __s,
                               _Constant_unary_fun<bool, int_type>(false),
                               false, false, false);
    }
  }
  else {

    if (this->eof())
      this->setstate(ios_base::eofbit | ios_base::failbit);
    else
      this->setstate(ios_base::failbit);
  }




  return _M_gcount;
}

template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_formatted_get(_CharT* __s)
{
  sentry __sentry(*this);

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    streamsize __nmax = this->width() > 0
      ? this->width() - 1
      : (numeric_limits<streamsize>::max)() / sizeof(_CharT) - 1;

    streamsize __n = __buf->gptr() != __buf->egptr()
      ? _M_read_buffered(this, __buf, __nmax, __s,
                         _Is_wspace_null<_Traits>((const ctype<_CharT>*)this->_M_ctype_facet()),
                         _Scan_wspace_null<_Traits>((const ctype<_CharT>*)this->_M_ctype_facet()),
    false, true, false)
      : _M_read_unbuffered(this, __buf, __nmax, __s,
                           _Is_wspace_null<_Traits>((const ctype<_CharT>*)this->_M_ctype_facet()),
      false, true, false);
    if (__n == 0)
      this->setstate(ios_base::failbit);
  }
  this->width(0);
}






template < class _CharT, class _Traits, class _Is_Delim>
void
_M_ignore_unbuffered(basic_istream<_CharT, _Traits>* __that,
       basic_streambuf<_CharT, _Traits>* __buf,
       _Is_Delim __is_delim,
       bool __extract_delim, bool __set_failbit)
{
  bool __done = false;
  ios_base::iostate __status = 0;
  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;

  {
    while (!__done) {
      int_type __c = __buf->sbumpc();

      if (__that->_S_eof(__c)) {
        __done = true;
        __status |= __set_failbit ? ios_base::eofbit | ios_base::failbit
                                  : ios_base::eofbit;
      }

      else if (__is_delim(__c)) {
        __done = true;
        if (!__extract_delim)
          if (__that->_S_eof(__buf->sputbackc(_Traits::to_char_type(__c))))
            __status |= ios_base::failbit;
      }
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
  }

  __that->setstate(__status);
}






template < class _CharT, class _Traits, class _Is_Delim, class _Scan_Delim>
void
_M_ignore_buffered(basic_istream<_CharT, _Traits>* __that,
     basic_streambuf<_CharT, _Traits>* __buf,
     _Is_Delim __is_delim, _Scan_Delim __scan_delim,
     bool __extract_delim, bool __set_failbit)
{
  bool __at_eof = false;
  bool __found_delim = false;

  {
    while (__buf->_M_egptr() != __buf->_M_gptr() && !__at_eof && !__found_delim) {
      const _CharT* __p = __scan_delim(__buf->_M_gptr(), __buf->_M_egptr());
      __buf->_M_gbump((int)(__p - __buf->_M_gptr()));

      if (__p != __buf->_M_egptr()) {
        if (__extract_delim)
          __buf->_M_gbump(1);
        __found_delim = true;
      }

      else
        __at_eof = __that->_S_eof(__buf->sgetc());
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
    return;
  }

  if (__at_eof) {
    __that->setstate(__set_failbit ? ios_base::eofbit | ios_base::failbit
                                   : ios_base::eofbit);
    return;
  }
  if (__found_delim)
    return;





  _M_ignore_unbuffered(__that, __buf, __is_delim, __extract_delim, __set_failbit);
}
# 971 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.c"
template < class _CharT, class _Traits, class _Max_Chars, class _Is_Delim>
streamsize
_M_ignore_unbuffered(basic_istream<_CharT, _Traits>* __that,
       basic_streambuf<_CharT, _Traits>* __buf,
       streamsize _Num, _Max_Chars __max_chars,
       _Is_Delim __is_delim,
       bool __extract_delim, bool __set_failbit)
{
  streamsize __n = 0;
  ios_base::iostate __status = 0;
  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;

  {
    while (__max_chars(_Num, __n) > 0) {
      int_type __c = __buf->sbumpc();

      if (__that->_S_eof(__c)) {
        __status |= __set_failbit ? ios_base::eofbit | ios_base::failbit
                                  : ios_base::eofbit;
        break;
      }

      else if (__is_delim(__c)) {
        if (__extract_delim)
          ++__n;
        else if (__that->_S_eof(__buf->sputbackc(_Traits::to_char_type(__c))))
          __status |= ios_base::failbit;

        break;
      }

      ++__n;
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
  }

  if (__status)
    __that->setstate(__status);
  return __n;
}

template < class _CharT, class _Traits, class _Max_Chars, class _Is_Delim, class _Scan_Delim>
streamsize
_M_ignore_buffered(basic_istream<_CharT, _Traits>* __that,
     basic_streambuf<_CharT, _Traits>* __buf,
     streamsize _Num,
     _Max_Chars __max_chars,
     _Is_Delim __is_delim, _Scan_Delim __scan_delim,
     bool __extract_delim, bool __set_failbit)
{
  streamsize __n = 0;
  bool __at_eof = false;
  bool __done = false;

  {
    while (__buf->_M_egptr() != __buf->_M_gptr() && !__done) {
      ptrdiff_t __avail = __buf->_M_egptr() - __buf->_M_gptr();
      streamsize __m = __max_chars(_Num, __n);

      if (__avail >= __m) {
        const _CharT* __last = __buf->_M_gptr() + __m;
        const _CharT* __p = __scan_delim(__buf->_M_gptr(), __last);
        ptrdiff_t __chunk = __p - __buf->_M_gptr();
        __n += __chunk;
        __buf->_M_gbump((int)__chunk);

        if (__extract_delim && __p != __last) {
          __n += 1;
          __buf->_M_gbump(1);
        }

        __done = true;
      }

      else {
        const _CharT* __p = __scan_delim(__buf->_M_gptr(), __buf->_M_egptr());
        ptrdiff_t __chunk = __p - __buf->_M_gptr();
        __n += __chunk;
        __buf->_M_gbump((int)__chunk);

        if (__p != __buf->_M_egptr()) {
          if (__extract_delim) {
            __n += 1;
            __buf->_M_gbump(1);
          }

          __done = true;
        }


        else if (__that->_S_eof(__buf->sgetc())) {
          __done = true;
          __at_eof = true;
        }
      }
    }
  }
  if (false) {
    __that->_M_handle_exception(ios_base::badbit);
    return __n;
  }

  if (__at_eof)
    __that->setstate(__set_failbit ? ios_base::eofbit | ios_base::failbit
                                   : ios_base::eofbit);

  if (__done)
    return __n;






  return __n + _M_ignore_unbuffered( __that, __buf, _Num, __max_chars,
                                    __is_delim, __extract_delim, __set_failbit);
}


template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n)
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    typedef _Constant_unary_fun<bool, int_type> _Const_bool;
    typedef _Constant_binary_fun<streamsize, streamsize, streamsize>
      _Const_streamsize;
    const streamsize __maxss = (numeric_limits<streamsize>::max)();

    if (__n == (numeric_limits<int>::max)()) {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount
          = _M_ignore_buffered(this, __buf,
                               __maxss, _Const_streamsize(__maxss),
                               _Const_bool(false),
                               _Project2nd<const _CharT*, const _CharT*>(),
                               false, false);
      else
        _M_gcount = _M_ignore_unbuffered(this, __buf,
                                         __maxss, _Const_streamsize(__maxss),
                                         _Const_bool(false), false, false);
    }
    else {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount
          = _M_ignore_buffered(this, __buf,
                               __n, minus<streamsize>(),
                               _Const_bool(false),
                               _Project2nd<const _CharT*, const _CharT*>(),
                               false, false);
      else
        _M_gcount = _M_ignore_unbuffered(this, __buf, __n, minus<streamsize>(),
                                         _Const_bool(false), false, false);
    }
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __delim)
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
    typedef _Constant_unary_fun<bool, int_type> _Const_bool;
    typedef _Constant_binary_fun<streamsize, streamsize, streamsize>
      _Const_streamsize;
    const streamsize __maxss = (numeric_limits<streamsize>::max)();

    if (__n == (numeric_limits<int>::max)()) {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount = _M_ignore_buffered(this, __buf,
                                       __maxss, _Const_streamsize(__maxss),
                                       _Eq_int_bound<_Traits>(__delim),
                                       _Scan_for_int_val<_Traits>(__delim),
                                       true, false);
      else
        _M_gcount = _M_ignore_unbuffered(this, __buf,
                                         __maxss, _Const_streamsize(__maxss),
                                         _Eq_int_bound<_Traits>(__delim),
                                         true, false);
    }
    else {
      if (__buf->gptr() != __buf->egptr())
        _M_gcount = _M_ignore_buffered(this, __buf,
                                       __n, minus<streamsize>(),
                                       _Eq_int_bound<_Traits>(
                                               __delim),
                                       _Scan_for_int_val<_Traits>(__delim),
                                       true, false);
      else
        _M_gcount = _M_ignore_unbuffered(this, __buf, __n, minus<streamsize>(),
                                         _Eq_int_bound<_Traits>(__delim),
                                         true, false);
    }
  }

  return *this;
}



template <class _CharT, class _Traits>
void basic_istream<_CharT, _Traits>::_M_skip_whitespace(bool __set_failbit)
{
  basic_streambuf<_CharT, _Traits>* __buf = this->rdbuf();
  if (!__buf)
    this->setstate(ios_base::badbit);
  else if (__buf->gptr() != __buf->egptr())
    _M_ignore_buffered(this, __buf,
                       _Is_not_wspace<_Traits>((const ctype<_CharT>*)this->_M_ctype_facet()),
                       _Scan_for_not_wspace<_Traits>((const ctype<_CharT>*)this->_M_ctype_facet()),
                       false, __set_failbit);
  else
    _M_ignore_unbuffered(this, __buf,
                         _Is_not_wspace<_Traits>((const ctype<_CharT>*)this->_M_ctype_facet()),
                         false, __set_failbit);
}
# 1208 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.c"
template < class _CharT, class _Traits, class _Is_Delim>
streamsize
_M_copy_unbuffered( basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __src,
      basic_streambuf<_CharT, _Traits>* __dest,
      _Is_Delim __is_delim,
      bool __extract_delim, bool __rethrow)
{
  streamsize __extracted = 0;
  ios_base::iostate __status = 0;
  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;
  int_type __c;

  {

    while (true) {


      __c = __src->sbumpc();


      if (__that->_S_eof(__c)) {
        __status |= ios_base::eofbit;
        break;
      }

      else if (__is_delim(__c)) {
        if (!__extract_delim && !__pushback(__src, _Traits::to_char_type(__c)))
          __status |= ios_base::failbit;
        break;
      }

      else {


        bool __failed = false;
        {
          if (!__that->_S_eof(__dest->sputc(__c)))
            ++__extracted;
          else
            __failed = true;
        }
        if (false) {
          __failed = true;
        }



        if (__failed && !__pushback(__src, _Traits::to_char_type(__c)))
          __status |= ios_base::failbit;


        if (__failed)
          break;
      }

    }

  }


  if (false) {

    if (__rethrow && __extracted == 0)
      __that->_M_handle_exception(ios_base::failbit);
  }
  __that->setstate(__status);
  return __extracted;
}






template < class _CharT, class _Traits, class _Is_Delim, class _Scan_Delim>
streamsize
_M_copy_buffered(basic_istream<_CharT, _Traits>* __that, basic_streambuf<_CharT, _Traits>* __src,
                     basic_streambuf<_CharT, _Traits>* __dest,
                     _Scan_Delim __scan_delim, _Is_Delim __is_delim,
                     bool __extract_delim, bool __rethrow)
{
  streamsize __extracted = 0;
  ios_base::iostate __status = 0;
  typedef typename basic_istream<_CharT, _Traits>::int_type int_type;
  int_type __c = _Traits::eof();
  _CharT* __first = __src->_M_gptr();
  ptrdiff_t __avail = __src->_M_egptr() - __first;

  bool __do_handle_exceptions;

  {
    while (true) {
      __do_handle_exceptions = false ;
      const _CharT* __last = __scan_delim(__first, __src->_M_egptr());


      streamsize __n = __dest->sputn(__first, __extract_delim && __last != __src->_M_egptr()
                                     ? (__last - __first) + 1
                                     : (__last - __first));
      __src->_M_gbump((int)__n);
      __extracted += __n;


      __do_handle_exceptions = true;

      if (__n < __avail)
        break;

      __c = __src->sgetc();



      __first = __src->_M_gptr();
      __avail = __src->_M_egptr() - __first;

      if (__avail > 0)
        {}
      else if (__that->_S_eof(__c)) {
        __status |= ios_base::eofbit;
        break;
      }
      else
        return __extracted + _M_copy_unbuffered(__that, __src, __dest, __is_delim,
                                                __extract_delim, __rethrow);
    }
  }

  if (false) {

    if (__rethrow && __do_handle_exceptions && __extracted == 0)
      __that->_M_handle_exception(ios_base::failbit);
  }

  if (__status)
    __that->setstate(__status);
  return __extracted;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>
  ::get(basic_streambuf<_CharT, _Traits>& __dest, _CharT __delim)
{
  sentry __sentry(*this, _No_Skip_WS());
  this->_M_gcount = 0;

  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __src = this->rdbuf();

    if (__src)
      this->_M_gcount = __src->egptr() != __src->gptr()
        ? _M_copy_buffered(this, __src, &__dest,
                           _Scan_for_char_val<_Traits>(__delim),
                           _Eq_char_bound<_Traits>(__delim),
                           false, false)
        : _M_copy_unbuffered(this, __src, &__dest,
                             _Eq_char_bound<_Traits>(__delim),
                             false, false);
  }

  if (this->_M_gcount == 0)
    this->setstate(ios_base::failbit);

  return *this;
}


template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>
  ::operator>>(basic_streambuf<_CharT, _Traits>* __dest)
{
  streamsize __n = 0;
  typedef typename basic_istream<_CharT, _Traits>::sentry _Sentry;
  _Sentry __sentry(*this);
  if (__sentry) {
    basic_streambuf<_CharT, _Traits>* __src = this->rdbuf();
    if (__src && __dest)
      __n = __src->egptr() != __src->gptr()
        ? _M_copy_buffered(this, __src, __dest,
                           _Project2nd<const _CharT*, const _CharT*>(),
                           _Constant_unary_fun<bool, int_type>(false),
                           false, true)
        : _M_copy_unbuffered(this, __src, __dest,
                             _Constant_unary_fun<bool, int_type>(false),
                             false, true);
  }

  if (__n == 0)
    this->setstate(ios_base::failbit);

  return *this;
}





template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>
  ::basic_iostream(basic_streambuf<_CharT, _Traits>* __buf)
    : basic_ios<_CharT, _Traits>(),
      basic_istream<_CharT, _Traits>(__buf),
      basic_ostream<_CharT, _Traits>(__buf)
{
  this->init(__buf);
}

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream()
{}

}
# 338 "c:/marmalade/6.2/s3e/h/std/c++/stl/_istream.h" 2
# 35 "c:/marmalade/6.2/s3e/h/std/c++/iostream" 2

namespace _STL {
# 54 "c:/marmalade/6.2/s3e/h/std/c++/iostream"
extern istream cin;
extern ostream cout;
extern ostream cerr;
extern ostream clog;


extern wistream wcin;
extern wostream wcout;
extern wostream wcerr;
extern wostream wclog;





static ios_base::_Loc_init _LocInit;





static ios_base::Init _IosInit;


}
# 89 "c:/marmalade/6.2/s3e/h/std/c++/iostream"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/6.2/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/6.2/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/6.2/s3e/h/std/c++/stl/_epilog.h" 2
# 90 "c:/marmalade/6.2/s3e/h/std/c++/iostream" 2
# 5 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/history.cpp" 2

using namespace _STL;

char** histArray;
int size;
int location;
TiXmlDocument histDoc;
TiXmlElement* histElem;
bool playerTurn;
char* histFilename;

CHistory::CHistory(char* filename){
 location = 0;
 histArray = new char*[400];
 playerTurn = false;
 char buf[48];
 char* extension = "history.xml";
 strcpy(buf,filename);
 strcat(buf,extension);
 histFilename = new char[48];
 strcpy(histFilename,buf);
 if(!histDoc.LoadFile(histFilename))
   clearAndCreateHist();
 if(histDoc.RootElement()==__null){
  size = 0;
 }
 else{
  histElem = histDoc.RootElement()->FirstChildElement();
  size = 2;
  while(histElem->Parent()->NextSiblingElement()!=0){
   size = size + 2;
   histElem = histElem->Parent()->NextSiblingElement()->FirstChildElement();
  }
  if(histElem->NextSiblingElement()->NextSiblingElement()==0)
   size--;
  for(int j=0;j<size;j++)
   histArray[j] = new char[250];
  histElem = histDoc.RootElement()->FirstChildElement();
  for(int i=0;i<size;i=i+2)
  {
   location = atoi(histElem->GetText());
   histElem = histElem->NextSiblingElement();
   strcpy(histArray[i],histElem->GetText());
   if(i<size-1)
   {
    histElem = histElem->NextSiblingElement();
    if(histElem->GetText()!=__null)
     strcpy(histArray[i+1],histElem->GetText());
    else{
     char* bufnew = " \0";
     strcpy(histArray[i+1],bufnew);
    }
    histElem = histElem->NextSiblingElement();
    location = atoi(histElem->GetText());
    if(i<size-2)
     histElem = histElem->Parent()->NextSiblingElement()->FirstChildElement();
   }
  }
  if(size%2==1)
   playerTurn = true;
 }
}

CHistory::~CHistory(){
 for(int i=0;i<size;i++)
  delete[] histArray[i];
 delete[] histArray;
}

bool CHistory::addNpcTextToHist(int id, char text[250]){
 if(playerTurn==false){
  TiXmlElement* idElem = new TiXmlElement("id");
  char tempId[48];
  sprintf(tempId,"%d",id);
  TiXmlText* idText = new TiXmlText(tempId);
  TiXmlElement* textElem = new TiXmlElement("npcText");
  TiXmlText* textText = new TiXmlText(text);
  TiXmlElement* entryElem = new TiXmlElement("entry");

  histDoc.LinkEndChild(entryElem);
  entryElem->LinkEndChild(idElem);
  idElem->LinkEndChild(idText);
  entryElem->LinkEndChild(textElem);
  textElem->LinkEndChild(textText);

  histDoc.SaveFile();

  if(size==0)
   histElem = histDoc.RootElement()->FirstChildElement()->NextSiblingElement();
  else
   histElem = histElem->Parent()->NextSiblingElement()->FirstChildElement()->NextSiblingElement();

  histArray[size] = new char[250];
  strcpy(histArray[size],text);
  size++;
  location = id;
  playerTurn = true;
  return true;
 }
 else
  return false;
}

bool CHistory::addPlayerTextToHist(int id, char text[250]){
 if(playerTurn==true)
 {
  TiXmlElement* pidElem = new TiXmlElement("id");
  char ptempId[48];
  sprintf(ptempId,"%d",id);
  TiXmlText* pidText = new TiXmlText(ptempId);
  TiXmlElement* ptextElem = new TiXmlElement("playerText");
  TiXmlText* ptextText = new TiXmlText(text);
  histElem->Parent()->LinkEndChild(ptextElem);
  ptextElem->LinkEndChild(ptextText);
  histElem->Parent()->LinkEndChild(pidElem);
  pidElem->LinkEndChild(pidText);

  histDoc.SaveFile();

  histElem = histElem->NextSiblingElement()->NextSiblingElement();

  histArray[size] = new char[250];
  strcpy(histArray[size],text);
  size++;
  location = id;
  playerTurn = false;
  return true;
 }
 else
  return false;
}

void CHistory::clearAndCreateHist(){
# 151 "c:/Users/Stephen/AIMessage_GoogleCode/April 3/team-game-4410/Game Source/AIMessage/src/history.cpp"
 TiXmlDeclaration *dec1 = new TiXmlDeclaration("1.0", "", "");
 histDoc.Clear();
 histDoc.LinkEndChild(dec1);
 histDoc.SaveFile(histFilename);
 for(int i=0;i<size;i++)
  delete[] histArray[i];
 size = 0;
 playerTurn = false;
 location = 0;
 histDoc.LoadFile(histFilename);
}
